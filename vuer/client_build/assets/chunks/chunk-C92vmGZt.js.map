{"version":3,"file":"chunk-C92vmGZt.js","sources":["../../../../node_modules/@vuer-ai/vuer/dist/index-tKDsVx4T.js"],"sourcesContent":["import { jsx as Vt } from \"react/jsx-runtime\";\nimport { useRef as jt, useState as Zt, useEffect as Jn } from \"react\";\nimport * as B from \"three\";\nimport { useThree as Xt } from \"@react-three/fiber\";\nlet lA;\nconst At = typeof TextDecoder < \"u\" ? new TextDecoder(\"utf-8\", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {\n  throw Error(\"TextDecoder not available\");\n} };\ntypeof TextDecoder < \"u\" && At.decode();\nlet HA = null;\nfunction Wt() {\n  return (HA === null || HA.byteLength === 0) && (HA = new Uint8Array(lA.memory.buffer)), HA;\n}\nfunction $t(e, A) {\n  return e = e >>> 0, At.decode(Wt().subarray(e, e + A));\n}\nfunction Ae(e, A, n, t, s, i, a, r, I, g, Q) {\n  return lA.raycast_splats(e, A, n, t, s, i, a, r, I, g, Q);\n}\nasync function ne(e, A) {\n  if (typeof Response == \"function\" && e instanceof Response) {\n    if (typeof WebAssembly.instantiateStreaming == \"function\")\n      try {\n        return await WebAssembly.instantiateStreaming(e, A);\n      } catch (t) {\n        if (e.headers.get(\"Content-Type\") != \"application/wasm\")\n          console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", t);\n        else\n          throw t;\n      }\n    const n = await e.arrayBuffer();\n    return await WebAssembly.instantiate(n, A);\n  } else {\n    const n = await WebAssembly.instantiate(e, A);\n    return n instanceof WebAssembly.Instance ? { instance: n, module: e } : n;\n  }\n}\nfunction te() {\n  const e = {};\n  return e.wbg = {}, e.wbg.__wbg_buffer_609cc3eee51ed158 = function(A) {\n    return A.buffer;\n  }, e.wbg.__wbg_length_3b4f022188ae8db6 = function(A) {\n    return A.length;\n  }, e.wbg.__wbg_length_6ca527665d89694d = function(A) {\n    return A.length;\n  }, e.wbg.__wbg_length_8cfd2c6409af88ad = function(A) {\n    return A.length;\n  }, e.wbg.__wbg_new_9fee97a409b32b68 = function(A) {\n    return new Uint16Array(A);\n  }, e.wbg.__wbg_new_e3b321dcfef89fc7 = function(A) {\n    return new Uint32Array(A);\n  }, e.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(A, n, t) {\n    return new Float32Array(A, n >>> 0, t >>> 0);\n  }, e.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(A, n, t) {\n    return new Uint32Array(A, n >>> 0, t >>> 0);\n  }, e.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(A) {\n    return new Float32Array(A >>> 0);\n  }, e.wbg.__wbg_set_10bad9bee0e9c58b = function(A, n, t) {\n    A.set(n, t >>> 0);\n  }, e.wbg.__wbg_set_d23661d19148b229 = function(A, n, t) {\n    A.set(n, t >>> 0);\n  }, e.wbg.__wbg_set_f4f1f0daa30696fc = function(A, n, t) {\n    A.set(n, t >>> 0);\n  }, e.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(A, n, t) {\n    return A.subarray(n >>> 0, t >>> 0);\n  }, e.wbg.__wbg_subarray_769e1e0f81bb259b = function(A, n, t) {\n    return A.subarray(n >>> 0, t >>> 0);\n  }, e.wbg.__wbindgen_init_externref_table = function() {\n    const A = lA.__wbindgen_export_0, n = A.grow(4);\n    A.set(0, void 0), A.set(n + 0, void 0), A.set(n + 1, null), A.set(n + 2, !0), A.set(n + 3, !1);\n  }, e.wbg.__wbindgen_memory = function() {\n    return lA.memory;\n  }, e.wbg.__wbindgen_throw = function(A, n) {\n    throw new Error($t(A, n));\n  }, e;\n}\nfunction ee(e, A) {\n  return lA = e.exports, nt.__wbindgen_wasm_module = A, HA = null, lA.__wbindgen_start(), lA;\n}\nasync function nt(e) {\n  if (lA !== void 0) return lA;\n  typeof e < \"u\" && (Object.getPrototypeOf(e) === Object.prototype ? { module_or_path: e } = e : console.warn(\"using deprecated parameters for the initialization function; pass a single object instead\")), typeof e > \"u\" && (e = new URL(\"data:application/wasm;base64,AGFzbQEAAAAB9wEkYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAF/AW9gAAFvYAd/f39/f39/AGACf34Bf2ADf35+AGACf34AYAt9fX19fX19fX9vfwFvYAZ/f39/f38Bf2AFf398f38AYAR/fH9/AGAFf399f38AYAR/fX9/AGAFf39+f38AYAR/fn9/AGADf35+AX9gA39vbwF/YAJ9fQF9AvIEEQN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgACgN3YmcaX193YmdfbmV3XzlmZWU5N2E0MDliMzJiNjgACgN3YmcaX193Ymdfc2V0X2Y0ZjFmMGRhYTMwNjk2ZmMACwN3YmcdX193YmdfbGVuZ3RoXzhjZmQyYzY0MDlhZjg4YWQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAHA3diZxpfX3diZ19uZXdfZTNiMzIxZGNmZWY4OWZjNwAKA3diZxpfX3diZ19zZXRfZDIzNjYxZDE5MTQ4YjIyOQALA3diZx1fX3diZ19sZW5ndGhfNmNhNTI3NjY1ZDg5Njk0ZAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AAcDd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiAAsDd2JnHV9fd2JnX2xlbmd0aF8zYjRmMDIyMTg4YWU4ZGI2AAwDd2JnH19fd2JnX3N1YmFycmF5Xzc2OWUxZTBmODFiYjI1OWIABwN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAHA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAUA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA4DwAG+AQUAAAYPAAUF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BSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBlM/AACgCACAFQRBqQZjPwAAoAgAoAhQRAgBBkM/AACgCAEEBawUgBgs2AgBB6NLAAEEAOgAAIANFDQAACwALsgEBBn8CQAJAIABBhAFJDQAgANBvJgEQRSIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnRBBBCwAQsPCwALqQEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAkEEELABDAELIAMgAkEEIAFBAnQiAhCXASIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQZiPwABBMhC5AQALQQQgAhCUAQALowEBAn8jAEEgayIDJAACQCABRQRAQQFBACACEMYBIQAMAQsgAyABNgIMIAMgADYCCCADQRBqIANBCGoQLSADKAIQIgEEQANAIAMoAhQhBCADKAIcRQRAIAEgBCACEMYBIQAMAwtBASEAIAIgASAEEJkBDQIgAkH9/wMQnAENAiADQRBqIANBCGoQLSADKAIQIgENAAsLQQAhAAsgA0EgaiQAIAALiwEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhCXAQwCCwsgASACRQ0AGkH9zsAALQAAGiACIAEQpgELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIABBKEEEELABIAFBIGokAAuaAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIAFBIGokAAuSAQEEfyMAQRBrIgIkAEEBIQQCQCABKAIUIgNBJyABKAIYIgUoAhAiAREAAA0AIAJBBGogACgCAEGBAhAiAkAgAi0ABEGAAUYEQCADIAIoAgggAREAAEUNAQwCCyADIAItAA4iACACQQRqaiACLQAPIABrIAUoAgwRAQANAQsgA0EnIAERAAAhBAsgAkEQaiQAIAQLlQEBAn8jAEEgayIDJAACQCAAKAIEIgRBA0YgBEECSXINAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GshcAANgIEIANCADcCECADIANBHGo2AgwgA0EEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiBEUNACAAKAIMIARBDGxBBBCwAQsgAEEoQQQQsAEgA0EgaiQAC4QBAQN/An8CQCAAKAIAIgFFDQADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIDAILAkAgAkUNACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBAQ8LQQEgAEEBEBMNAhogAkEBayECIAAoAgAiAQ0ACwtBAAsLegEBfyMAQSBrIgIkAAJ/IAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQmQEMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahApCyACQSBqJAALSQEDfiAAIAFC/////w+DIgJCPn4iA0IAIgIgAUIgiEI+fnwiAUIghnwiBDcDACAAIAMgBFatIAEgAlStQiCGIAFCIIiEfDcDCAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUG8rsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICADIQ3AzggBSAFQQhqrUKAgICAkAyENwMwIAUgBUEwajYCICAFQRhqIAQQhAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCwAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEEAAsgAygCBCICBEAgASACIAMoAggQsAELIABBDEEEELABCwvzAwIIfwF+IwBBEGsiAyQAIAAoAgQhBSAAKAIAIQAgASgCFEG4rMAAQQEgASgCGCgCDBEBACEEIANBBGoiAkEAOgAFIAIgBDoABCACIAE2AgAgBQRAA0AgAyAANgIMIANBDGohCCMAQUBqIgEkAEEBIQYCQCADQQRqIgQtAAQNACAELQAFIQkCQCAEKAIAIgIoAhwiB0EEcUUEQCAJQQFxRQ0BIAIoAhRB667AAEECIAIoAhgoAgwRAQBFDQEMAgsgCUEBcUUEQCACKAIUQfWuwABBASACKAIYKAIMEQEADQIgAigCHCEHCyABQQE6ABsgASACKQIUNwIMIAFBzK7AADYCNCABIAFBG2o2AhQgASACKQIINwIkIAIpAgAhCiABIAc2AjggASACKAIQNgIsIAEgAi0AIDoAPCABIAo3AhwgASABQQxqNgIwIAggAUEcakGAmcAAKAIAEQAADQEgASgCMEHwrsAAQQIgASgCNCgCDBEBACEGDAELIAggAkGAmcAAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUFAayQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIUQfauwABBASAAKAIYKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0HYscAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQZitwAA2AgggA0ICNwIUIANCgICAgPACIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhCEAQALagIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIMIANB+LHAADYCCCADQgI3AhQgA0KAgICA8AIiBCADQQRqrYQ3AyggAyAEIAOthDcDICADIANBIGo2AhAgA0EIaiACEIQBAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0GsssAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2MBAX8jAEEQayIAJAACfyACKAIABEBBwJXAACEDQQkMAQsgAEEEaiACKAIEIAIoAggQJEHAlcAAIAAoAgggACgCBCICGyEDQQkgACgCDCACGwshAiADIAIgARBcIABBEGokAAtnACMAQTBrIgAkAEH8zsAALQAABEAgAEECNgIMIABB8JXAADYCCCAAQgE3AhQgACABNgIsIAAgAEEsaq1CgICAgPAChDcDICAAIABBIGo2AhAgAEEIakGQlsAAEIQBAAsgAEEwaiQAC+caAhJ/AX4jAEEgayIPJAACfyAAKAIAIgAoAgAEQAJ/IAEhDCMAQTBrIgYkACAAKAIIIREgACgCBCEIIAAoAgAhDgJAAkACQAJAAkADQAJAIBEgECIJRgRAQQAhAgwBCyAIRQ0GIAkgEUchEiAJQQFqIRAgCEEBayEHIA4iBC0AACEBQQAhAAJAAkACQAJAA0ACQCABwEEASARAIAFBH3EhAiAAIARqIgVBAWotAABBP3EhAyABQf8BcSIOQd8BTQRAIAJBBnQgA3IhAQwCCyAFQQJqLQAAQT9xIANBBnRyIQEgDkHwAUkEQCABIAJBDHRyIQEMAgsgAkESdEGAgPAAcSAFQQNqLQAAQT9xIAFBBnRyciIBQYCAxABHDQEMDQsgAUH/AXEhAQsCQAJAIAFBMGtBCU0EQCAAIAdGDQ4gACAEaiICQQFqLAAAIgFBv39KDQEgAiAIIABrIgBBASAAQcCdwAAQnQEACyAABEAgACAEaiwAAEG/f0wNAgsgBkEUaiEHIAQhAkEAIQMCQAJAAkACQAJAAkACQCAAIgEOAgQAAQtBASEDIAItAABBK2sOAwMBAwELIAItAABBK0YEQCACQQFqIQIgAUEKSSABQQFrIgMhAQ0BDAILIAEhAyABQQhLDQELQQAhBQNAIAItAABBMGsiAUEJSwRAQQEhAwwDCyACQQFqIQIgASAFQQpsaiEFIANBAWsiAw0ACwwCC0EAIQUDQCABRQ0CIAItAABBMGsiDkEJSwRAQQEhAwwCC0ECIQMgBa1CCn4iFEIgiKcNASACQQFqIQIgAUEBayEBIA4gFKciCmoiBSAKTw0ACwsgByADOgABIAdBAToAAAwBCyAHIAU2AgQgB0EAOgAACyAGLQAUDQMgCCAGKAIYIgVrIQoCQCAFRQ0AIAggAGsiASAFSwRAIAQgBWogAGoiAiwAAEG/f0wNBiACLAAAQb9/Sg0BIAAgBGogAUEAIAVB8J3AABCdAQALIAAgCkcNBQsgACAEaiIBIQcgBCAFaiAAaiEOIAVFIBAgEUdyDQYgDCgCHEEEcUUNBiAHLQAAQegARw0GIAVBAUcEQCABQQFqLAAAQb9/TA0GCyAAIARqQQFqIQEDQEEAIQIgASAORg0IAn8gASwAACIDQQBOBEAgA0H/AXEhCCABQQFqDAELIAEtAAFBP3EhDSADQR9xIQggA0FfTQRAIAhBBnQgDXIhCCABQQJqDAELIAEtAAJBP3EgDUEGdHIhDSADQXBJBEAgDSAIQQx0ciEIIAFBA2oMAQsgCEESdEGAgPAAcSABLQADQT9xIA1BBnRyciIIQYCAxABGDQkgAUEEagshASAIQTBrQQpJIAhBIHJB4QBrQQZJcg0ACwwGCyAAQQFqIQAMAQsLIAQgCEEAIABB0J3AABCdAQALIAYgBi0AFToACEGEm8AAQSsgBkEIakG0n8AAQcSfwAAQZQALIAAgBGogASAFIAFB4J3AABCdAQALIAEgBUEBIAVBoJ3AABCdAQALAkAgCUUNACAMQYCewABBAhCZAUUNACASIQIMAQsCQCAFQQJJDQAgBy8AAEHfyABHDQAgACAEaiIBQQFqIgcsAABBv39MDQMgBUEBayEFCyAKIABrIQgDQCAHIQQCQAJAAkACQAJAAkACQAJAAkACQCAFIgNFDQACQCAELQAAQSRrDgsCAQEBAQEBAQEBAAELIANBAUYNBSAELAABQb9/Sg0EIAQgA0EBIANBgJ/AABCdAQALIAMgBGohCUEAIQAgBCEBA0AgACECIAEiACAJRg0IAn8gACwAACIFQQBOBEAgBUH/AXEhBSAAQQFqDAELIAAtAAFBP3EhByAFQR9xIQEgBUFfTQRAIAFBBnQgB3IhBSAAQQJqDAELIAAtAAJBP3EgB0EGdHIhByAFQXBJBEAgByABQQx0ciEFIABBA2oMAQsgAUESdEGAgPAAcSAALQADQT9xIAdBBnRyciEFIABBBGoLIgEgAiAAa2ohACAFQSRrDgsCAAAAAAAAAAAAAgALAAsgA0EBRg0BIAQsAAFBv39KDQEgBCADQQEgA0G0nsAAEJ0BAAsCQAJAAkAgAgRAAkAgAiADTyIARQRAIAIgBGosAABBv39MDQEgDCAEIAIQmQFFDQRBASECDA4LIAIgA0YNAgsgBCADQQAgAkGUnsAAEJ0BAAsgDCAEIAIQmQFFDQJBASECDAsLIAwgBCACEJkBRQ0AQQEhAgwKCyAARQRAIAIgBGosAABBv39KDQEMDwsgAiADRw0OCyACIARqIQcgAyACayEFDAcLIAYgA0EBayIANgIkIAZBADYCICAGIAA2AhwgBkEkNgIUIAZBJDYCKCAGQQE6ACwgBiAEQQFqIgA2AhggBkEIaiAGQRRqEC4gBigCCEEBRw0EAkAgBigCDCICQX9HBEAgAkEBaiEBIANBAUcNAQwFCyMAQSBrIgAkACAAQQA2AhggAEEBNgIMIABB2LPAADYCCCAAQgQ3AhAgAEEIakHEnsAAEIQBAAsgACwAAEG/f0oNAwwLCwJAAn8gBCwAASIAQQBOBEAgAEH/AXEMAQsgBC0AAkE/cSICIABBH3EiAUEGdHIgAEFfTQ0AGiAELQADQT9xIAJBBnRyIgIgAUEMdHIgAEFwSQ0AGiABQRJ0QYCA8ABxIAQtAARBP3EgAkEGdHJyC0EuRwRAQQEhAiAMQaCfwABBARCZAQ0IIAQsAAFBQEgNAQwDCyAMQYCewABBAhCZAQRAQQEhAgwICwJAIANBA08EQCAELAACQUBIDQELIARBAmohByADQQJrIQUMBwsgBCADQQIgA0GQn8AAEJ0BAAsgBCADQQEgA0Gkn8AAEJ0BAAtBASECIAxBoJ/AAEEBEJkBDQULIARBAWohByADQQFrIQUMAwsCQAJAAkACQCABIANJBEAgASAEaiwAAEFASA0MIAJBAmohAQwBCyABIANHDQsgAkECaiIBRQ0BCwJAIAEgA0kEQCABIARqLAAAQb9/Sg0BDAsLIAEgA0cNCgsgASAEaiEHIAMgAWshBQJAAkAgAg4DBQEAAgsgAC8AAEHToAFGBEBB/57AACEADAYLIAAvAABBwqABRgRAQf6ewAAhAAwGCyAALwAAQdKMAUYEQEH9nsAAIQAMBgsgAC8AAEHMqAFGBEBB/J7AACEADAYLIAAvAABBx6gBRgRAQfuewAAhAAwGCyAALwAAQcygAUYEQEH6nsAAIQAMBgsgAC8AAEHSoAFHDQFB+Z7AACEADAULIAAtAABBwwBGBEBB+J7AACEADAULIAAtAABB9QBGDQEMAwsgBC0AAUH1AEcNAiACQQJJDQEgBCwAAkG/f0wNAQsgACACaiETIAJBAWshCSAEQQJqIgIhAAJAA0BBASENIAAgE0YNAQJ/IAAsAAAiAUEATgRAIAFB/wFxIQEgAEEBagwBCyAALQABQT9xIQsgAUEfcSEKIAFBX00EQCAKQQZ0IAtyIQEgAEECagwBCyAALQACQT9xIAtBBnRyIQsgAUFwSQRAIAsgCkEMdHIhASAAQQNqDAELIApBEnRBgIDwAHEgAC0AA0E/cSALQQZ0cnIiAUGAgMQARg0CIABBBGoLIQAgAUEwa0EKSSABQeEAa0EGSXINAAtBACENCyAGQRRqIQoCQAJAAkACQAJAAkACQCAJIgAOAgABAgsgCkEAOgABDAQLIAItAAAiAUEraw4DAgECAQsgAi0AACEBCwJAAkACQCABQf8BcUErRgRAIABBAWshASACQQFqIQIgAEEJSwRAIAEhAAwCCyABIgANAkEAIQEMAwsgAEEISw0ADAELQQAhAQJAA0AgAEUNAyACLQAAIgtBMGsiCUEKTwRAQX8gC0EgciIJQdcAayILIAsgCUHhAGtJGyIJQRBPDQULIAGtQgSGIhRCIIinDQEgAkEBaiECIABBAWshACAJIBSnIgtqIgEgC08NAAsgCkECOgABDAQLIApBAjoAAQwDC0EAIQEDQCACLQAAIgtBMGsiCUEKTwRAQX8gC0EgciIJQdcAayILIAsgCUHhAGtJGyIJQRBPDQMLIAJBAWohAiAJIAFBBHRqIQEgAEEBayIADQALCyAKIAE2AgQgCkEAOgAADAILIApBAToAASAKQQE6AAAMAQsgCkEBOgAACyAGLQAUDQEgDUVBgIDEACAGKAIYIgAgAEGAsANzQYCAxABrQYCQvH9JGyIAQYCAxABGcg0BIAYgADYCBCAAQSBJIABB/wBrQSFJcg0BIAZBBGogDBBGRQ0DQQEhAgwECyAAIAJBASACQeiewAAQnQEACyASIQIgDCAEIAMQmQFFDQMMAgtBASECIAwgAEEBEJkBRQ0ACwsLIAZBMGokACACDAULIAEgBUEBIAVBhJ7AABCdAQALIAQgAyABIANB1J7AABCdAQALIAQgA0EBIAFBxJ7AABCdAQALIAQgAyACIANBpJ7AABCdAQALQbCdwAAQswEACwwBCyAPQQA2AhwgDyABNgIYIA9CADcCECAPIAApAgQ3AgggD0EIakEBEBILIA9BIGokAAuYAQIDfwFvIwBBIGsiAyQAIAMgACgCABDLASIENgIAIAMgAjYCBCACIARHBEAgA0EANgIIIAMgA0EEaiADQQhqEH4ACxCeASIEEJUBIgUlARAFIQYQMyICIAYmASAFQYQBTwRAIAUQWgsgAiAAKAIAIAFBAnYQrwEgAkGEAU8EQCACEFoLIARBhAFPBEAgBBBaCyADQSBqJAALUAEBfyMAQTBrIgAkACAAQQE2AgwgAEGorMAANgIIIABCATcCFCAAIABBL2qtQoCAgIDwC4Q3AyAgACAAQSBqNgIQIABBCGpB/IPAABCEAQALQwEDfwJAIAJFDQADQCAALQAAIgQgAS0AACIFRgRAIABBAWohACABQQFqIQEgAkEBayICDQEMAgsLIAQgBWshAwsgAwtBAQF/IAIgACgCACAAKAIIIgNrSwRAIAAgAyACEEQgACgCCCEDCyAAKAIEIANqIAEgAhA8GiAAIAIgA2o2AghBAAtBAQF/IAIgACgCACAAKAIIIgNrSwRAIAAgAyACEEogACgCCCEDCyAAKAIEIANqIAEgAhA8GiAAIAIgA2o2AghBAAtPAQJ/IAAoAgQhAiAAKAIAIQMCQCAAKAIIIgAtAABFDQAgA0HkrsAAQQQgAigCDBEBAEUNAEEBDwsgACABQQpGOgAAIAMgASACKAIQEQAAC0cBAX8jAEEQayICJAAgAkEIaiABEHogAiACKAIIIAIoAgwoAhgRAgAgAigCBCEBIAAgAigCADYCACAAIAE2AgQgAkEQaiQAC08BAn9B/c7AAC0AABogASgCBCECIAEoAgAhA0EIQQQQpgEiAUUEQEEEQQgQxAEACyABIAI2AgQgASADNgIAIABBtJbAADYCBCAAIAE2AgALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhBVIAAoAgghAwsgACgCBCADaiABIAIQPBogACACIANqNgIIQQALQgEBfyMAQSBrIgMkACADQQA2AhAgA0EBNgIEIANCBDcCCCADIAE2AhwgAyAANgIYIAMgA0EYajYCACADIAIQhAEACz0BAn8gACAAKAIEIgMgAms2AgQgACAAKAIAIAIgA0tyIgQ2AgBBASEDIAQEfyADBSAAKAIIIAEgAhCZAQsLPgEBfyMAQRBrIgIkACACQQhqIAEgASgCACgCBBECACACKAIMIQEgACACKAIINgIAIAAgATYCBCACQRBqJAALxAIBA38gACgCACECIAEoAhwiAEEQcUUEQCAAQSBxRQRAIAIgARCyAQ8LQQAhACMAQYABayIEJAAgAigCACECA0AgACAEakH/AGogAkEPcSIDQTByIANBN2ogA0EKSRs6AAAgAEEBayEAIAJBEEkgAkEEdiECRQ0ACyAAQYABaiICQYEBTwRAIAJBgAFBjK/AABBoAAsgAUGcr8AAQQIgACAEakGAAWpBACAAaxAhIARBgAFqJAAPC0EAIQAjAEGAAWsiBCQAIAIoAgAhAgNAIAAgBGpB/wBqIAJBD3EiA0EwciADQdcAaiADQQpJGzoAACAAQQFrIQAgAkEQSSACQQR2IQJFDQALIABBgAFqIgJBgQFPBEAgAkGAAUGMr8AAEGgACyABQZyvwABBAiAAIARqQYABakEAIABrECEgBEGAAWokAAvNAwEDfyAAKAIAIQAgASgCHCIDQRBxRQRAIANBIHFFBEAjAEEQayIDJAACQAJAAkAgAC0AACIAQeQATwRAIAMgACAAQeQAbiIAQeQAbGtB/wFxQQF0QZ6vwABqLwAAOwAODAELQQIhAiAAQQpPDQELIANBDWogAmogAEEwcjoAAAwBC0EBIQIgAyAAQQF0QZ6vwABqLwAAOwAOCyABQQFBACADQQ1qIAJqIAJBA3MQISADQRBqJAAPCyMAQYABayIEJAAgAC0AACEAA0AgAiAEakH/AGogAEEPcSIDQTByIANBN2ogA0EKSRs6AAAgAkEBayECIAAiA0EEdiEAIANBEE8NAAsgAkGAAWoiAEGBAU8EQCAAQYABQYyvwAAQaAALIAFBnK/AAEECIAIgBGpBgAFqQQAgAmsQISAEQYABaiQADwsjAEGAAWsiBCQAIAAtAAAhAANAIAIgBGpB/wBqIABBD3EiA0EwciADQdcAaiADQQpJGzoAACACQQFrIQIgACIDQQR2IQAgA0EQTw0ACyACQYABaiIAQYEBTwRAIABBgAFBjK/AABBoAAsgAUGcr8AAQQIgAiAEakGAAWpBACACaxAhIARBgAFqJAALOAACQCACQYCAxABGDQAgACACIAEoAhARAABFDQBBAQ8LIANFBEBBAA8LIAAgAyAEIAEoAgwRAQALOQEBfyMAQRBrIgMkACADIAE2AgwgAyAANgIIIANBCGpBiI/AACADQQxqQYiPwAAgAkH4jsAAEDgACzwBAX8jAEEQayICJAAgAkGUkcAANgIMIAIgADYCCCACQQhqQZiRwAAgAkEMakGYkcAAIAFBjJXAABA4AAvcBAIHfwF+IwBBEGsiBiQAIAYgADYCDCAGQQxqIQgjAEEQayICJAAgASgCFEHwm8AAQQ0gASgCGCgCDBEBACEAIAJBADoADSACIAA6AAwgAiABNgIIIwBBQGoiACQAQQEhAwJAIAJBCGoiBC0ABA0AIAQtAAUhBSAEKAIAIgEoAhwiB0EEcUUEQCABKAIUQeuuwABB6K7AACAFQQFxIgUbQQJBAyAFGyABKAIYKAIMEQEADQEgASgCFEH9m8AAQQQgASgCGCgCDBEBAA0BIAEoAhRBuK7AAEECIAEoAhgoAgwRAQANASAIIAFB7JvAACgCABEAACEDDAELIAVBAXFFBEAgASgCFEHtrsAAQQMgASgCGCgCDBEBAA0BIAEoAhwhBwsgAEEBOgAbIAAgASkCFDcCDCAAQcyuwAA2AjQgACAAQRtqNgIUIAAgASkCCDcCJCABKQIAIQkgACAHNgI4IAAgASgCEDYCLCAAIAEtACA6ADwgACAJNwIcIAAgAEEMaiIBNgIwIAFB/ZvAAEEEECoNACABQbiuwABBAhAqDQAgCCAAQRxqQeybwAAoAgARAAANACAAKAIwQfCuwABBAiAAKAI0KAIMEQEAIQMLIARBAToABSAEIAM6AAQgAEFAayQAIAItAA0iASACLQAMIgNyIQACQCADQQFxIAFBAUdyDQAgBCgCACIALQAcQQRxRQRAIAAoAhRB867AAEECIAAoAhgoAgwRAQAhAAwBCyAAKAIUQfKuwABBASAAKAIYKAIMEQEAIQALIAJBEGokACAAQQFxIAZBEGokAAsvAQF/IwBBEGsiAiQAIAJBCGogABB6IAIoAgggASACKAIMKAIQEQAAIAJBEGokAAs5AQF/QQEhAgJAIAAgARA/DQAgASgCFEH0q8AAQQIgASgCGCgCDBEBAA0AIABBBGogARA/IQILIAIL1hMCF30LfxAzIiMgCSYBAn8gCCEqIwBBMGsiIiQAICIgIzYCBCAiQoCAgIDAADcCCCAiQQA2AhBB7M7AACErQejOwAAoAgBFBEACf0H9zsAALQAAGgJAQYCAwAAQESIIRQ0AIAhBBGstAABBA3FFDQAgCEGAgMAAEFcaCyAIBEBB+M7AAEGAgBA2AgBB7M7AAEEANgIAQfTOwAAoAgAhI0H0zsAAIAg2AgBB8M7AACgCACEmQfDOwABBgIAQNgIAQejOwAAoAgBB6M7AAEEBNgIARSAmRXJFBEAgIyAmQQJ0QQQQsAELQezOwAAMAQtBBEGAgMAAEJQBAAshKwsgKygCAEUEQCArQX82AgACQCArAn8gKkUEQEEAISNBAAwBCyArQQxqKAIAISwgK0EIaigCACEIAkAgCgRAQQAhIwNAICIgIkEEaiAjQQJ0ICNBgIAEICogI2siCiAKQYCABE8bIgpqIiZBAnQQsQE2AhQgCkECdCIjICxLDQQgIkEUaiAIICMQbyAiIAI4AiAgIiABOAIcICIgADgCGCAiIAU4AiwgIiAEOAIoICIgAzgCJCAIIQojAEEQayInJAAgIwRAICJBCGohKCAiQSRqIiQqAgAhFSAkKgIEIRggJCoCCCEZICJBGGoiJCoCCCEfICQqAgQhICAkKgIAISEDQCAjQQQgI0EESSIkGyEpAkAgCi0AA7NDAAB/Q5VDzczMPV0NACAnQQRqIAogKRAmAn0CQCAkRQRAICcqAgwhDiAnKgIIIQwgJyoCBCELQwAAAAAhFkMAAAAAIRcgCigCDCIlQf8BcQRAICVBAWtB/wFxs0NFIpE9lEMAABDBkhAsIRcLICVBCHYiJEH/AXEEQCAkQQFrQf8BcbNDRSKRPZRDAAAQwZIQLCEWCyAfIA6TIQ8gICAMkyESICEgC5MhESAlQRB2IiRB/wFxDQFDAAAAAAwCC0EDIClBnIPAABBpAAsgJEEBa0H/AXGzQ0UikT2UQwAAEMGSECwLIRogGSAKKAIIIiRBGHWyQwAA/kKVIhMgGCAlQRh1skMAAP5ClSIUlCAZIBOUkyIQlCAkQRB2wLJDAAD+QpUiDSAZIA2UIBUgFJSTIg6UkyAVIBOUIBggDZSTIgxDAACAPyANIA2UkyATIBOUkyAUIBSUk0MAAAAAEJIBkSIblJIiCyALkpIhHCAYIA0gDJQgFCAQlJMgDiAblJIiCyALkpIhHSAVIBQgDpQgEyAMlJMgECAblJIiCyALkpIhHiAPIBMgEiAUlCAPIBOUkyIQlCANIA8gDZQgESAUlJMiDpSTIBEgE5QgEiANlJMiDCAblJIiCyALkpIhDyASIA0gDJQgFCAQlJMgDiAblJIiCyALkpIhDSARIBQgDpQgEyAMlJMgECAblJIiCyALkpIhDAJAIBogFyAWEJIBIBoQkgFDCtcjPJQiC11FBEAgCyAWXkUEQCALIBdeRQRAQwAAgD8gGpUiCyAPlCIPIAsgHJQiEpRDAACAPyAXlSILIAyUIhEgCyAelCIMlEMAAIA/IBaVIgsgDZQiECALIB2UIguUkpIiDiAOlCASIBKUIAwgDJQgCyALlJKSIgwgDyAPlCARIBGUIBAgEJSSkkMAAIC/kpSTIgtDAAAAAF0NBCAOjCALkZMgDJUhDAwDCyAei0O9N4Y1XQ0DIA0gHSAMjCAelSIMlJIgFpUiCyALlCAPIBwgDJSSIBqVIgsgC5SSQwAAgD9eRQ0CDAMLIB2LQ703hjVdDQIgDCAeIA2MIB2VIgyUkiAXlSILIAuUIA8gHCAMlJIgGpUiCyALlJJDAACAP14NAgwBCyAci0O9N4Y1XQ0BIAwgHiAPjCAclSIMlJIgF5UiCyALlCANIB0gDJSSIBaVIgsgC5SSQwAAgD9eDQELIAYgDF9FIAcgDGBFcg0AICgoAggiJCAoKAIARgRAICgQTwsgKCgCBCAkQQJ0aiAMOAIAICggJEEBajYCCAsgCiApQQJ0aiEKICMgKWsiIw0ACwsgJ0EQaiQAICIoAhQiCkGEAU8EQCAKEFoLICYiIyAqSQ0ACwwBC0EAISMDQCAiICJBBGogI0ECdCAjQYCABCAqICNrIgogCkGAgARPGyIKaiImQQJ0ELEBNgIUIApBAnQiIyAsSw0DICJBFGogCCAjEG8gIiACOAIgICIgATgCHCAiIAA4AhggIiAFOAIsICIgBDgCKCAiIAM4AiQgCCEKIwBBEGsiJyQAICMEQCAiQQhqISggIkEkaiIkKgIAIhggGJQgJCoCBCIZIBmUkiAkKgIIIg8gD5SSIRIgIkEYaiIkKgIIIR8gJCoCBCEgICQqAgAhIQNAICNBBCAjQQRJIiQbISkCQCAKLQADs0MAAH9DlUPNzMw9XQ0AICdBBGogCiApECYCfQJAICRFBEAgJyoCDCEOICcqAgghDCAnKgIEIQtDAAAAACERQwAAAAAhECAKKAIMIiVB/wFxBEAgJUEBa0H/AXGzQ0UikT2UQwAAEMGSEMwBIRALICVBCHYiJEH/AXEEQCAkQQFrQf8BcbNDRSKRPZRDAAAQwZIQzAEhEQsgHyAOkyENICAgDJMhFSAhIAuTIQ4gJUEQdiIkQf8BcQ0BQwAAAAAMAgtBAyApQZyDwAAQaQALICRBAWtB/wFxs0NFIpE9lEMAABDBkhDMAQshCyAYIA6UIBkgFZSSIA8gDZSSIgwgDJQgEiAOIA6UIBUgFZSSIA0gDZSSIBAgEZIgC5JDAABAQJUiCyALlJOUkyILQwAAAABdDQAgDIwgC5GTIBKVIgsgBmBFIAcgC2BFcg0AICgoAggiJCAoKAIARgRAICgQTwsgKCgCBCAkQQJ0aiALOAIAICggJEEBajYCCAsgCiApQQJ0aiEKICMgKWsiIw0ACwsgJ0EQaiQAICIoAhQiCkGEAU8EQCAKEFoLICYiIyAqSQ0ACwsgIigCECEjICsoAgBBAWoLNgIAICMQDSEJEDMiCCAJJgEgIiAINgIkICIoAgwhIyAiKAIQISQjAEEgayIlJAAgIkEkaigCACIKJQEQCiEmICUgJDYCBCAlICY2AgACQCAkICZGBEAQngEiKhCVASImJQEgIyAkEAghCRAzIiMgCSYBICpBhAFPBEAgKhBaCyAmQYQBTwRAICYQWgsgCiUBICMlAUEAEAkgI0GEAU8EQCAjEFoLICVBIGokAAwBCyAlQQA2AgggJSAlQQRqICVBCGoQfgALICIoAggiCgRAICIoAgwgCkECdEEEELABCyAiKAIEIgpBhAFPBEAgChBaCyAiQTBqJAAgCAwCCyAjICxB5IbAABBqAAsQcAALIgglASAIEFoL+gECAn8BfiMAQRBrIgIkACACQQE7AQwgAiABNgIIIAIgADYCBCMAQRBrIgEkACACQQRqIgApAgAhBCABIAA2AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEHglsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALIAAgAzYCBCAAIAI2AgAgAEHElsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALJQAgAEUEQEGYj8AAQTIQuQEACyAAIAIgAyAEIAUgASgCEBEIAAsoACABIAAoAgAtAABBAnQiAEHkp8AAaigCACAAQdCnwABqKAIAEJkBCyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQEQkACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQER4ACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQESAACygBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAFBARCwAQsLJwAgAEEcakEAIAJC2KGkg7Hi0d18URtBACABQpXX3ZjDl4qMC1EbCyEAIABFBEBBmI/AAEEyELkBAAsgACACIAMgASgCEBEDAAsfACAARQRAQZiPwABBMhC5AQALIAAgAiABKAIQEQAAC+MVAQx/EDMiBCABJgECfyAAIQYQMyIAIAImASMAQdAAayIIJAAgCCAANgIYIAggBDYCFCAIQRRqKAIAEMoBIQtBvM7AACgCAEUEQEHkzsAAQQA2AgBB2M7AAEEANgIAQczOwABBADYCAEHAzsAAQQA2AgBB4M7AACgCACEFQeDOwABBBDYCAEHczsAAKAIAIQ1B3M7AAEEANgIAQdTOwAAoAgAhA0HUzsAAQQQ2AgBB0M7AACgCACEJQdDOwABBADYCAEHIzsAAKAIAIQRByM7AAEECNgIAQcTOwAAoAgAhB0HEzsAAQQA2AgBBvM7AACgCACEAQbzOwABBATYCAAJAIABFDQAgBwRAIAQgB0EBdEECELABCyAJBEAgAyAJQQJ0QQQQsAELIA1FDQAgBSAN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IABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAUkEQCABQZyvwABBAiAAIARqQYABakEAIABrECEgASAFNgIcIAEgBzYCBCABIAY2AgAgBEGAAWokAAwBCyACQYABQYyvwAAQaAALCwwAIAAgASkCADcDAAsNACABQfCYwABBAhAeCw0AIABBhJzAACABECkLDgAgAUGvm8AAQQUQmQELDgAgAUG8p8AAQRIQmQELDQAgAEHQqcAAIAEQKQsOACABQcipwABBBRCZAQsZACAAIAFBjM/AACgCACIAQTogABsRAgAACw0AIABBzK7AACABECkLCgAgAiAAIAEQHguQBQEHfwJAAn8CQCACIgUgACABa0sEQCABIAJqIQMgACACaiECIAAgBUEQSQ0CGiACQXxxIQRBACACQQNxIgZrIQcgBgRAIANBAWshAANAIAJBAWsiAiAALQAAOgAAIABBAWshACACIARLDQALCyAEIAUgBmsiBkF8cSIFayECIAMgB2oiA0EDcQRAIAVBAEwNAiADQQN0IgBBGHEhByADQXxxIghBBGshAUEAIABrQRhxIQkgCCgCACEAA0AgBEEEayIEIAAgCXQgASgCACIAIAd2cjYCACABQQRrIQEgAiAESQ0ACwwCCyAFQQBMDQEgASAGakEEayEBA0AgBEEEayIEIAEoAgA2AgAgAUEEayEBIAIgBEkNAAsMAQsCQCAFQRBJBEAgACECDAELIABBACAAa0EDcSIDaiEEIAMEQCAAIQIgASEAA0AgAiAALQAAOgAAIABBAWohACACQQFqIgIgBEkNAAsLIAQgBSADayIFQXxxIgZqIQICQCABIANqIgNBA3EEQCAGQQBMDQEgA0EDdCIAQRhxIQcgA0F8cSIIQQRqIQFBACAAa0EYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkkNAAsMAQsgBkEATA0AIAMhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJJDQALCyAFQQNxIQUgAyAGaiEBCyAFRQ0CIAIgBWohAANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIABJDQALDAILIAZBA3EiAEUNASADIAVrIQMgAiAAawshACADQQFrIQEDQCACQQFrIgIgAS0AADoA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YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwB0AxAATwAAAGgDAAA0AAAAdAMQAE8AAABvAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAA4EEABLAAAAxAcAAB0AAAAOBBAASwAAAMwHAAAdAAAAHAAAAAwAAAAEAAAAHQAAAB4AAAAfAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikvcnVzdGMvOTBiMzVhNjIzOWMzZDhiZGFiYzUzMGE2YTA4MTZmN2ZmODlhMGFhZi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnPJBBAASwAAAMAFAAANAAAAAAAAABAAAAAEAAAAIgAAACMAAAAkAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwAAVAUQAF4AAABnBAAADgAAAAEAAAAAAAAAOiAAAMwFEAACAAAACgpDYXVzZWQgYnk6CgAAACUAAAAMAAAABAAAACYAAAAnAAAAHwAAAAoKc3RhY2sgYmFja3RyYWNlOlN0YWNrIGJhY2t0cmFjZToKABIGEAARAAAAUwBBuIzAAAvZBAEAAAAoAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQDJBBAASwAAAHsKAAAOAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc4gGEABMAAAALQoAACQAAAAAAAAAEAAAAAQAAAAiAAAAIwAAACQAAAAgICAgOiAAAAEAAAAAAAAAAAcQAAIAAAAgICAgICAgL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnMAGwcQAFwAAAD7GAAAAQAAAAAAAAAEAAAABAAAADUAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZMoHEAAqAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMA/AcQAF8AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABsCBAADgAAAPwHEABfAAAAegIAAA0AQZyRwAALlQ8EAAAABAAAADsAAAA6AAAAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAMQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADECBAAKQAAAK4EAAANAAAAc3RkL3NyYy9iYWNrdHJhY2UucnNvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtgAkQACgAAAAkAAAAAAAAAAIAAACoCRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAGwJEAAUAAAAigEAAB0AAABAAAAAEAAAAAQAAABBAAAAQgAAAAEAAAAAAAAAOiBzdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzABYKEAAZAAAA0AAAABMAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleEAKEAAgAAAAc3RkL3NyYy9zeXMvc3luYy9tdXRleC9ub190aHJlYWRzLnJzaAoQACQAAAAUAAAACQAAAHN0ZC9zcmMvc3luYy9vbmNlLnJznAoQABQAAACeAAAAMgAAADx1bmtub3duPu+/vW1lbW9yeSBhbGxvY2F0aW9uIG9mICBieXRlcyBmYWlsZWQAAMwKEAAVAAAA4QoQAA0AAABzdGQvc3JjL2FsbG9jLnJzAAsQABAAAABjAQAACQAAAAoAAAA8AAAADAAAAAQAAABDAAAAAAAAAAgAAAAEAAAARAAAAAAAAAAIAAAABAAAAEUAAABGAAAARwAAAEgAAABJAAAAEAAAAAQAAABKAAAASwAAAEwAAABNAAAAc3RkL3NyYy8uLi8uLi9iYWNrdHJhY2Uvc3JjL3N5bWJvbGl6ZS9tb2QucnN8CxAALAAAAGcBAAAwAAAAAQAAAAAAAAAUChAAAgAAACAtIAABAAAAAAAAAMgLEAADAAAAICAgICAgICAgICAgICAgICAgIGF0IAAAqAgQAAEAAABPbmNlIGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAPwLEAAqAAAAb25lLXRpbWUgaW5pdGlhbGl6YXRpb24gbWF5IG5vdCBiZSBwZXJmb3JtZWQgcmVjdXJzaXZlbHkwDBAAOAAAACgpAAAAAAAABAAAAAQAAABRAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9vcHMvZnVuY3Rpb24ucnOEDBAAUAAAAKYAAAAFAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zdHIvcGF0dGVybi5ycwDkDBAATwAAAMgFAAAUAAAA5AwQAE8AAADIBQAAIQAAAOQMEABPAAAAvAUAACEAAAAwMTIzNDU2Nzg5YWJjZGVmAAAAAAAAAAABAAAAUgAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWVFcnJvckVtcHR5SW52YWxpZERpZ2l0UG9zT3ZlcmZsb3dOZWdPdmVyZmxvd1plcm8AAAAAAAQAAAAEAAAAUwAAAFBhcnNlSW50RXJyb3JraW5kAAAAAAAAAAwAAAAEAAAAVAAAAFUAAABWAAAA5AwQAE8AAABMBAAAJAAAAOQMEABPAAAAvgEAADcAAABfWk4vcnVzdC9kZXBzL3J1c3RjLWRlbWFuZ2xlLTAuMS4yNC9zcmMvbGVnYWN5LnJzAAAAPw4QAC4AAAA9AAAACwAAAD8OEAAuAAAAOgAAAAsAAAA/DhAALgAAADYAAAALAAAAPw4QAC4AAABmAAAAHAAAAD8OEAAuAAAAbwAAACcAAAA/DhAALgAAAHAAAAAdAAAAPw4QAC4AAAByAAAAIQAAAD8OEAAuAAAAcwAAABoAAAA/DhAALgAAAHQAAAAZAAAAOjoAAD8OEAAuAAAAfgAAAB0AAAA/DhAALgAAALQAAAAmAAAAPw4QAC4AAAC1AAAAIQAAAD8OEAAuAAAAigAAAEkAAAA/DhAALgAAAIsAAAAfAAAAPw4QAC4AAACLAAAALwAAAEMAAAA/DhAALgAAAJ0AAAA1AAAALCkoPjwmKkA/DhAALgAAAIIAAAAsAAAAPw4QAC4AAACEAAAAJQAAAC4AAAA/DhAALgAAAIcAAAAlAAAAAAAAAAEAAAABAAAAVwAAAD8OEAAuAAAAcgAAAEgAAABfX1IvcnVzdC9kZXBzL3J1c3RjLWRlbWFuZ2xlLTAuMS4yNC9zcmMvdjAucnMAAADXDxAAKgAAADIAAAATAAAA1w8QACoAAAAvAAAAEwAAANcPEAAqAAAAKwAAABMAQbygwAAL6QkBAAAAWAAAAGBmbXQ6OkVycm9yYHMgc2hvdWxkIGJlIGltcG9zc2libGUgd2l0aG91dCBhIGBmbXQ6OkZvcm1hdHRlcmAAAADXDxAAKgAAAEsAAAAOAAAA1w8QACoAAABaAAAAKAAAANcPEAAqAAAAigAAAA0AAABwdW55Y29kZXstfTDXDxAAKgAAAB4BAAAxAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZdcPEAAqAAAAMQEAABYAAADXDxAAKgAAADQBAABHAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogc3RyOjpmcm9tX3V0ZjgoKSA9ICB3YXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGNoYXIsIGJ1dCAgY2hhcnMgd2VyZSBmb3VuZBgREAA5AAAAUREQAAQAAABVERAAIgAAAHcREAARAAAA1w8QACoAAABcAQAAGgAAAGJvb2xjaGFyc3RyaThpMTZpMzJpNjRpMTI4aXNpemV1OHUxNnUzMnU2NHUxMjh1c2l6ZWYzMmY2NCFfLi4uAADXDxAAKgAAAL8BAAAfAAAA1w8QACoAAAAeAgAAHgAAANcPEAAqAAAAIwIAACIAAADXDxAAKgAAACQCAAAlAAAA1w8QACoAAACHAgAAEQAAAHtpbnZhbGlkIHN5bnRheH17cmVjdXJzaW9uIGxpbWl0IHJlYWNoZWR9Pydmb3I8PiAsIFtdOjp7Y2xvc3VyZXNoaW06IyBhcyAgbXV0IGNvbnN0IDsgZHluICArIHVuc2FmZSBleHRlcm4gItcPEAAqAAAA1AMAAC0AAAAiIGZuKCAtPiAgPSBmYWxzZXRydWV7IHsgIH06IDB4ANcPEAAqAAAAygQAAC0AAAAubGx2bS4vcnVzdC9kZXBzL3J1c3RjLWRlbWFuZ2xlLTAuMS4yNC9zcmMvbGliLnJzAAAA+hIQACsAAABiAAAAGwAAAPoSEAArAAAAaQAAABMAAAABAAAAAAAAAHtzaXplIGxpbWl0IHJlYWNoZWR9AAAAAAAAAAABAAAAWQAAAGBmbXQ6OkVycm9yYCBmcm9tIGBTaXplTGltaXRlZEZtdEFkYXB0ZXJgIHdhcyBkaXNjYXJkZWQA+hIQACsAAABTAQAAHgAAAFNpemVMaW1pdEV4aGF1c3RlZAAABQAAAAwAAAALAAAACwAAAAQAAAC0DRAAuQ0QAMUNEADQDRAA2w0QAAIAAAAEAAAABAAAAAMAAAADAAAAAwAAAAQAAAACAAAABQAAAAUAAAAEAAAAAwAAAAMAAAAEAAAABAAAAAEAAAAEAAAABAAAAAMAAAADAAAAAgAAAAMAAAAEAAAAAwAAAAMAAAABAAAAwxEQALgREAC8ERAA7hEQAMAREADrERAAuBEQANcREADSERAA5hEQALgREADIERAA3BEQAM4READiERAA8hEQALgREAC4ERAAxREQANkREABwDBAA8xEQALgREADLERAA3xEQAPEREABFcnJvcgAAAFoAAAAMAAAABAAAAFsAAABcAAAAXQAAAGNhcGFjaXR5IG92ZXJmbG93AAAA6BQQABEAAABhbGxvYy9zcmMvcmF3X3ZlYy5ycwQVEAAUAAAAGAAAAAUAQbCqwAALsAoBAAAAXgAAAGEgZm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAjhUQABAAAAB+AgAADgAAAGZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kILAVEAA8AAAALi4wMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAAABQWEAASAAAAAQAAAAAAAABbY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABkFhAAIAAAAIQWEAASAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAsxYQABAAAADDFhAAFwAAANoWEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAALMWEAAQAAAA/BYQABAAAAAMFxAACQAAANoWEAAJAAAAOiAAAAEAAAAAAAAAOBcQAAIAAAAAAAAADAAAAAQAAABlAAAAZgAAAGcAAAAgICAgIHsgLCAgewosCn0gfQpdY29yZS9zcmMvZm10L251bS5ycwAAdxcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9mbXQvbW9kLnJzZmFsc2V0cnVlAABmGBAAEwAAAKMJAAAmAAAAZhgQABMAAACsCQAAGgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2YgcmFuZ2UgZm9yIHNsaWNlIG9mIGxlbmd0aCCkGBAAEgAAALYYEAAiAAAAcmFuZ2UgZW5kIGluZGV4IOgYEAAQAAAAthgQACIAAABzbGljZSBpbmRleCBzdGFydHMgYXQgIGJ1dCBlbmRzIGF0IAAIGRAAFgAAAB4ZEAANAAAAYXR0ZW1wdGVkIHRvIGluZGV4IHNsaWNlIGZyb20gYWZ0ZXIgbWF4aW11bSB1c2l6ZQAAADwZEAAxAAAAYXR0ZW1wdGVkIHRvIGluZGV4IHNsaWNlIHVwIHRvIG1heGltdW0gdXNpemV4GRAALAAAAGF0dGVtcHRlZCB0byBpbmRleCBzdHIgdXAgdG8gbWF4aW11bSB1c2l6ZQAArBkQACoAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBorXAAAszAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwMDAwMDAwMDAwMDAwMDAwQEBAQEAEHgtcAAC8UWY29yZS9zcmMvc3RyL3BhdHRlcm4ucnMA4BoQABcAAABXBQAAEgAAAOAaEAAXAAAAVwUAACgAAADgGhAAFwAAAEoGAAAVAAAA4BoQABcAAAB4BgAAFQAAAOAaEAAXAAAAeQYAABUAAAAAWy4uLl1iZWdpbiA8PSBlbmQgKCA8PSApIHdoZW4gc2xpY2luZyBgYAAAAE4bEAAOAAAAXBsQAAQAAABgGxAAEAAAAHAbEAABAAAAYnl0ZSBpbmRleCAgaXMgbm90IGEgY2hhciBib3VuZGFyeTsgaXQgaXMgaW5zaWRlICAoYnl0ZXMgKSBvZiBgAJQbEAALAAAAnxsQACYAAADFGxAACAAAAM0bEAAGAAAAcBsQAAEAAAAgaXMgb3V0IG9mIGJvdW5kcyBvZiBgAACUGxAACwAAAPwbEAAWAAAAcBsQAAEAAABjb3JlL3NyYy9zdHIvbW9kLnJzACwcEAATAAAA8QAAACwAAABjb3JlL3NyYy91bmljb2RlL3ByaW50YWJsZS5ycwAAAFAcEAAdAAAAGgAAADYAAABQHBAAHQAAAAoAAAArAAAAAAYBAQMBBAIFBwcCCAgJAgoFCwIOBBABEQISBRMcFAEVAhcCGQ0cBR0IHwEkAWoEawKvA7ECvALPAtEC1AzVCdYC1wLaAeAF4QLnBOgC7iDwBPgC+gT7AQwnOz5OT4+enp97i5OWorK6hrEGBwk2PT5W89DRBBQYNjdWV3+qrq+9NeASh4mOngQNDhESKTE0OkVGSUpOT2RlioyNj7bBw8TGy9ZctrcbHAcICgsUFzY5Oqip2NkJN5CRqAcKOz5maY+SEW9fv+7vWmL0/P9TVJqbLi8nKFWdoKGjpKeorbq8xAYLDBUdOj9FUaanzM2gBxkaIiU+P+fs7//FxgQgIyUmKDM4OkhKTFBTVVZYWlxeYGNlZmtzeH1/iqSqr7DA0K6vbm/d3pNeInsFAwQtA2YDAS8ugIIdAzEPHAQkCR4FKwVEBA4qgKoGJAQkBCgINAtOAzQMgTcJFgoIGDtFOQNjCAkwFgUhAxsFAUA4BEsFLwQKBwkHQCAnBAwJNgM6BRoHBAwHUEk3Mw0zBy4ICgYmAx0IAoDQUhADNywIKhYaJhwUFwlOBCQJRA0ZBwoGSAgnCXULQj4qBjsFCgZRBgEFEAMFC1kIAh1iHkgICoCmXiJFCwoGDRM6BgoGFBwsBBeAuTxkUwxICQpGRRtICFMNSQcKgLYiDgoGRgodA0dJNwMOCAoGOQcKgTYZBzsDHVUBDzINg5tmdQuAxIpMYw2EMBAWCo+bBYJHmrk6hsaCOQcqBFwGJgpGCigFE4GwOoDGW2VLBDkHEUAFCwIOl/gIhNYpCqLngTMPAR0GDgQIgYyJBGsFDQMJBxCPYID6BoG0TEcJdDyA9gpzCHAVRnoUDBQMVwkZgIeBRwOFQg8VhFAfBgaA1SsFPiEBcC0DGgQCgUAfEToFAYHQKoDWKwQBgeCA9ylMBAoEAoMRREw9gMI8BgEEVQUbNAKBDiwEZAxWCoCuOB0NLAQJBwIOBoCag9gEEQMNA3cEXwYMBAEPDAQ4CAoGKAgsBAI+gVQMHQMKBTgHHAYJB4D6hAYAAQMFBQYGAgcGCAcJEQocCxkMGg0QDgwPBBADEhITCRYBFwQYARkDGgcbARwCHxYgAysDLQsuATAEMQIyAacEqQKqBKsI+gL7Bf0C/gP/Ca14eYuNojBXWIuMkBzdDg9LTPv8Li8/XF1f4oSNjpGSqbG6u8XGycre5OX/AAQREikxNDc6Oz1JSl2EjpKpsbS6u8bKzs/k5QAEDQ4REikxNDo7RUZJSl5kZYSRm53Jzs8NESk6O0VJV1tcXl9kZY2RqbS6u8XJ3+Tl8A0RRUlkZYCEsry+v9XX8PGDhYukpr6/xcfP2ttImL3Nxs7PSU5PV1leX4mOj7G2t7/BxsfXERYXW1z29/7/gG1x3t8OH25vHB1ffX6ur027vBYXHh9GR05PWFpcXn5/tcXU1dzw8fVyc490dZYmLi+nr7e/x8/X35oAQJeYMI8fzs/S1M7/Tk9aWwcIDxAnL+7vbm83PT9CRZCRU2d1yMnQ0djZ5/7/ACBfIoLfBIJECBsEBhGBrA6AqwUfCIEcAxkIAQQvBDQEBwMBBwYHEQpQDxIHVQcDBBwKCQMIAwcDAgMDAwwEBQMLBgEOFQVOBxsHVwcCBhcMUARDAy0DAQQRBg8MOgQdJV8gbQRqJYDIBYKwAxoGgv0DWQcWCRgJFAwUDGoGCgYaBlkHKwVGCiwEDAQBAzELLAQaBgsDgKwGCgYvMYD0CDwDDwM+BTgIKwWC/xEYCC8RLQMhDyEPgIwEgpoWCxWIlAUvBTsHAg4YCYC+InQMgNYagRAFgOEJ8p4DNwmBXBSAuAiA3RU7AwoGOAhGCAwGdAseA1oEWQmAgxgcChYJTASAigarpAwXBDGhBIHaJgcMBQWAphCB9QcBICoGTASAjQSAvgMbAw8NY29yZS9zcmMvdW5pY29kZS91bmljb2RlX2RhdGEucnMAAAA5IhAAIAAAAE4AAAAoAAAAOSIQACAAAABaAAAAFgAAAGNvcmUvc3JjL251bS9tb2QucnMAfCIQABMAAAAbBgAAAQAAAAADAACDBCAAkQVgAF0ToAASFyAfDCBgH+8sICsqMKArb6ZgLAKo4Cwe++AtAP4gNp7/YDb9AeE2AQohNyQN4TerDmE5LxjhOTAc4UrzHuFOQDShUh5h4VPwamFUT2/hVJ28YVUAz2FWZdGhVgDaIVcA4KFYruIhWuzk4VvQ6GFcIADuXPABf10AcAAHAC0BAQECAQIBAUgLMBUQAWUHAgYCAgEEIwEeG1sLOgkJARgEAQkBAwEFKwM7CSoYASA3AQEBBAgEAQMHCgIdAToBAQECBAgBCQEKAhoBAgI5AQQCBAICAwMBHgIDAQsCOQEEBQECBAEUAhYGAQE6AQECAQQIAQcDCgIeATsBAQEMAQkBKAEDATcBAQMFAwEEBwILAh0BOgECAgEBAwMBBAcCCwIcAjkCAQECBAgBCQEKAh0BSAEEAQIDAQEIAVEBAgcMCGIBAgkLB0kCGwEBAQEBNw4BBQECBQsBJAkBZgQBBgECAgIZAgQDEAQNAQICBgEPAQADAAQcAx0CHgJAAgEHCAECCwkBLQMBAXUCIgF2AwQCCQEGA9sCAgE6AQEHAQEBAQIIBgoCATAfMQQwCgQDJgkMAiAEAgY4AQECAwEBBTgIAgKYAwENAQcEAQYBAwLGQAABwyEAA40BYCAABmkCAAQBCiACUAIAAQMBBAEZAgUBlwIaEg0BJggZCwEBLAMwAQIEAgICASQBQwYCAgICDAEIAS8BMwEBAwICBQIBASoCCAHuAQIBBAEAAQAQEBAAAgAB4gGVBQADAQIFBCgDBAGlAgAEQQUAAk8ERgsxBHsBNg8pAQICCgMxBAICBwE9AyQFAQg+AQwCNAkBAQgEAgFfAwIEBgECAZ0BAwgVAjkCAQEBAQwBCQEOBwMFQwECBgEBAgEBAwQDAQEOAlUIAgMBARcBUQECBgEBAgEBAgEC6wECBAYCAQIbAlUIAgEBAmoBAQECCGUBAQECBAEFAAkBAvUBCgQEAZAEAgIEASAKKAYCBAgBCQYCAy4NAQIABwEGAQFSFgIHAQIBAnoGAwEBAgEHAQFIAgMBAQEAAgsCNAUFAxcBAAEGDwAMAwMABTsHAAE/BFEBCwIAAgAuAhcABQMGCAgCBx4ElAMANwQyCAEOARYFAQ8ABwERAgcBAgEFZAGgBwABPQQABP4CAAdtBwBggPAAAgICAgICAgICAwMBAQEAQbfMwAALEAEAAAAAAAAAAgIAAAAAAAIAQfbMwAALAQIAQZzNwAALAQEAQbfNwAALAQEAQZvOwAALBT8AAAC/AEG4zsAACwE2AHAJcHJvZHVjZXJzAghsYW5ndWFnZQEEUnVzdAAMcHJvY2Vzc2VkLWJ5AwVydXN0Yx0xLjgzLjAgKDkwYjM1YTYyMyAyMDI0LTExLTI2KQZ3YWxydXMGMC4yMy4zDHdhc20tYmluZGdlbgcwLjIuMTAwAEkPdGFyZ2V0X2ZlYXR1cmVzBCsPbXV0YWJsZS1nbG9iYWxzKwhzaWduLWV4dCsPcmVmZXJlbmNlLXR5cGVzKwptdWx0aXZhbHVl\", import.meta.url));\n  const A = te();\n  (typeof e == \"string\" || typeof Request == \"function\" && e instanceof Request || typeof URL == \"function\" && e instanceof URL) && (e = fetch(e));\n  const { instance: n, module: t } = await ne(await e, A);\n  return ee(n, t);\n}\nconst RA = -9, se = 9, YA = (se - RA) / 254, ie = 11, ae = 11, S = 1 << ie, bA = 1 << ae, re = 1;\nfunction ge(e) {\n  return e === \"bool\" || e === \"bvec2\" || e === \"bvec3\" || e === \"bvec4\";\n}\nfunction MA(e) {\n  return e === \"int\" || e === \"ivec2\" || e === \"ivec3\" || e === \"ivec4\";\n}\nfunction FA(e) {\n  return e === \"uint\" || e === \"uvec2\" || e === \"uvec3\" || e === \"uvec4\";\n}\nfunction oe(e) {\n  return e === \"float\" || e === \"vec2\" || e === \"vec3\" || e === \"vec4\";\n}\nfunction Ie(e) {\n  return e === \"mat2\" || e === \"mat2x2\" || e === \"mat2x3\" || e === \"mat2x4\" || e === \"mat3\" || e === \"mat3x2\" || e === \"mat3x3\" || e === \"mat3x4\" || e === \"mat4\" || e === \"mat4x2\" || e === \"mat4x3\" || e === \"mat4x4\";\n}\nfunction VA(e) {\n  return oe(e) || Ie(e);\n}\nfunction vA(e) {\n  return e === \"mat2\" || e === \"mat2x2\";\n}\nfunction GA(e) {\n  return e === \"mat3\" || e === \"mat3x3\";\n}\nfunction UA(e) {\n  return e === \"mat4\" || e === \"mat4x4\";\n}\nfunction Be(e) {\n  switch (e) {\n    case \"vec2\":\n      return \"float\";\n    case \"vec3\":\n      return \"float\";\n    case \"vec4\":\n      return \"float\";\n    case \"ivec2\":\n      return \"int\";\n    case \"ivec3\":\n      return \"int\";\n    case \"ivec4\":\n      return \"int\";\n    case \"uvec2\":\n      return \"uint\";\n    case \"uvec3\":\n      return \"uint\";\n    case \"uvec4\":\n      return \"uint\";\n    default:\n      throw new Error(`Invalid vector type: ${e}`);\n  }\n}\nfunction Qe(e) {\n  switch (e) {\n    case \"vec2\":\n    case \"ivec2\":\n    case \"uvec2\":\n      return 2;\n    case \"vec3\":\n    case \"ivec3\":\n    case \"uvec3\":\n      return 3;\n    case \"vec4\":\n    case \"ivec4\":\n    case \"uvec4\":\n      return 4;\n    default:\n      throw new Error(`Invalid vector type: ${e}`);\n  }\n}\nfunction M(e) {\n  return Math.trunc(e).toString();\n}\nfunction F(e) {\n  return `${Math.max(0, Math.trunc(e)).toString()}u`;\n}\nfunction w(e) {\n  return e === Number.POSITIVE_INFINITY ? \"INFINITY\" : e === Number.NEGATIVE_INFINITY ? \"-INFINITY\" : Number.isInteger(e) ? e.toFixed(1) : e.toString();\n}\nfunction xA(e) {\n  return e instanceof NA ? e.type : e.dynoOut().type;\n}\nclass NA {\n  constructor(A) {\n    this.__isDynoValue = !0, this.type = A;\n  }\n}\nclass P extends NA {\n  constructor(A, n) {\n    super(A.outTypes[n]), this.dyno = A, this.key = n;\n  }\n}\nclass sn extends NA {\n  constructor(A, n) {\n    super(A), this.literal = n;\n  }\n  getLiteral() {\n    return this.literal;\n  }\n}\nclass ce extends sn {\n  constructor(A, n) {\n    super(A, \"\"), this.value = n;\n  }\n  getLiteral() {\n    const { type: A, value: n } = this;\n    switch (A) {\n      case \"bool\":\n        return n ? \"true\" : \"false\";\n      case \"uint\":\n        return F(n);\n      case \"int\":\n        return M(n);\n      case \"float\":\n        return w(n);\n      case \"bvec2\": {\n        const t = n;\n        return `bvec2(${t[0]}, ${t[1]})`;\n      }\n      case \"uvec2\": {\n        if (n instanceof B.Vector2)\n          return `uvec2(${F(n.x)}, ${F(n.y)})`;\n        const t = n;\n        return `uvec2(${F(t[0])}, ${F(t[1])})`;\n      }\n      case \"ivec2\": {\n        if (n instanceof B.Vector2)\n          return `ivec2(${M(n.x)}, ${M(n.y)})`;\n        const t = n;\n        return `ivec2(${M(t[0])}, ${M(t[1])})`;\n      }\n      case \"vec2\": {\n        if (n instanceof B.Vector2)\n          return `vec2(${w(n.x)}, ${w(n.y)})`;\n        const t = n;\n        return `vec2(${w(t[0])}, ${w(t[1])})`;\n      }\n      case \"bvec3\": {\n        const t = n;\n        return `bvec3(${t[0]}, ${t[1]}, ${t[2]})`;\n      }\n      case \"uvec3\": {\n        if (n instanceof B.Vector3)\n          return `uvec3(${F(n.x)}, ${F(n.y)}, ${F(n.z)})`;\n        const t = n;\n        return `uvec3(${F(t[0])}, ${F(t[1])}, ${F(t[2])})`;\n      }\n      case \"ivec3\": {\n        if (n instanceof B.Vector3)\n          return `ivec3(${M(n.x)}, ${M(n.y)}, ${M(n.z)})`;\n        const t = n;\n        return `ivec3(${M(t[0])}, ${M(t[1])}, ${M(t[2])})`;\n      }\n      case \"vec3\": {\n        if (n instanceof B.Vector3)\n          return `vec3(${w(n.x)}, ${w(n.y)}, ${w(n.z)})`;\n        const t = n;\n        return `vec3(${w(t[0])}, ${w(t[1])}, ${w(t[2])})`;\n      }\n      case \"bvec4\": {\n        const t = n;\n        return `bvec4(${t[0]}, ${t[1]}, ${t[2]}, ${t[3]})`;\n      }\n      case \"uvec4\": {\n        if (n instanceof B.Vector4)\n          return `uvec4(${F(n.x)}, ${F(n.y)}, ${F(n.z)}, ${F(n.w)})`;\n        const t = n;\n        return `uvec4(${F(t[0])}, ${F(t[1])}, ${F(t[2])}, ${F(t[3])})`;\n      }\n      case \"ivec4\": {\n        if (n instanceof B.Vector4)\n          return `ivec4(${M(n.x)}, ${M(n.y)}, ${M(n.z)}, ${M(n.w)})`;\n        const t = n;\n        return `ivec4(${M(t[0])}, ${M(t[1])}, ${M(t[2])}, ${M(t[3])})`;\n      }\n      case \"vec4\": {\n        if (n instanceof B.Vector4)\n          return `vec4(${w(n.x)}, ${w(n.y)}, ${w(n.z)}, ${w(n.w)})`;\n        if (n instanceof B.Quaternion)\n          return `vec4(${w(n.x)}, ${w(n.y)}, ${w(n.z)}, ${w(n.w)})`;\n        const t = n;\n        return `vec4(${w(t[0])}, ${w(t[1])}, ${w(t[2])}, ${w(t[3])})`;\n      }\n      case \"mat2\":\n      case \"mat2x2\": {\n        const t = n, s = t instanceof B.Matrix2 ? t.elements : n, i = new Array(4).fill(0).map((a, r) => w(s[r]));\n        return `${A}(${i.join(\", \")})`;\n      }\n      case \"mat2x3\": {\n        const t = n, s = new Array(6).fill(0).map((i, a) => w(t[a]));\n        return `${A}(${s.join(\", \")})`;\n      }\n      case \"mat2x4\": {\n        const t = n, s = new Array(8).fill(0).map((i, a) => w(t[a]));\n        return `${A}(${s.join(\", \")})`;\n      }\n      case \"mat3\":\n      case \"mat3x3\": {\n        const t = n, s = t instanceof B.Matrix3 ? t.elements : n, i = new Array(9).fill(0).map((a, r) => w(s[r]));\n        return `${A}(${i.join(\", \")})`;\n      }\n      case \"mat3x2\": {\n        const t = n, s = new Array(6).fill(0).map((i, a) => w(t[a]));\n        return `${A}(${s.join(\", \")})`;\n      }\n      case \"mat3x4\": {\n        const t = n, s = new Array(12).fill(0).map((i, a) => w(t[a]));\n        return `${A}(${s.join(\", \")})`;\n      }\n      case \"mat4\":\n      case \"mat4x4\": {\n        const t = n, s = t instanceof B.Matrix4 ? t.elements : n, i = new Array(16).fill(0).map((a, r) => w(s[r]));\n        return `${A}(${i.join(\", \")})`;\n      }\n      case \"mat4x2\": {\n        const t = n, s = new Array(8).fill(0).map((i, a) => w(t[a]));\n        return `${A}(${s.join(\", \")})`;\n      }\n      case \"mat4x3\": {\n        const t = n, s = new Array(12).fill(0).map((i, a) => w(t[a]));\n        return `${A}(${s.join(\", \")})`;\n      }\n      default:\n        throw new Error(`Type not implemented: ${String(A)}`);\n    }\n  }\n}\nfunction Dn(e, A) {\n  return new ce(e, A);\n}\nfunction WA(e) {\n  const A = String(e);\n  if (ge(e))\n    return `${A}(false)`;\n  if (VA(e))\n    return `${A}(0.0)`;\n  if (MA(e))\n    return `${A}(0)`;\n  if (FA(e))\n    return `${A}(0u)`;\n  throw new Error(`Type not implemented: ${A}`);\n}\nconst Hn = \"    \";\nclass Ce {\n  constructor({ indent: A } = {}) {\n    this.globals = /* @__PURE__ */ new Set(), this.statements = [], this.uniforms = {}, this.declares = /* @__PURE__ */ new Set(), this.updaters = [], this.sequence = 0, this.indent = Hn, this.indent = A ?? Hn;\n  }\n  nextSequence() {\n    return this.sequence++;\n  }\n}\nclass Y {\n  constructor({\n    inTypes: A,\n    outTypes: n,\n    inputs: t,\n    update: s,\n    globals: i,\n    statements: a,\n    generate: r\n  }) {\n    this.inTypes = A ?? {}, this.outTypes = n ?? {}, this.inputs = t ?? {}, this.update = s, this.globals = i, this.statements = a, this.generate = r ?? (({ inputs: I, outputs: g, compile: Q }) => {\n      var o, c;\n      return {\n        globals: (o = this.globals) == null ? void 0 : o.call(this, { inputs: I, outputs: g, compile: Q }),\n        statements: (c = this.statements) == null ? void 0 : c.call(this, { inputs: I, outputs: g, compile: Q })\n      };\n    });\n  }\n  get outputs() {\n    const A = {};\n    for (const n in this.outTypes)\n      A[n] = new P(this, n);\n    return A;\n  }\n  apply(A) {\n    return Object.assign(this.inputs, A), this.outputs;\n  }\n  compile({\n    inputs: A,\n    outputs: n,\n    compile: t\n  }) {\n    const s = [\n      `// ${this.constructor.name}(${Object.values(A).join(\", \")}) => (${Object.values(n).join(\", \")})`\n    ], i = [];\n    for (const g in n) {\n      const Q = n[g];\n      Q && !t.declares.has(Q) && (t.declares.add(Q), i.push(g));\n    }\n    const { globals: a, statements: r, uniforms: I } = this.generate({\n      inputs: A,\n      outputs: n,\n      compile: t\n    });\n    for (const g of a ?? [])\n      t.globals.add(g);\n    for (const g in I)\n      t.uniforms[g] = I[g];\n    this.update && t.updaters.push(this.update);\n    for (const g of i) {\n      const Q = n[g];\n      Q && (t.uniforms[Q] || s.push(`${tt(Q, this.outTypes[g])};`));\n    }\n    return r != null && r.length && (s.push(\"{\"), s.push(...r.map((g) => t.indent + g)), s.push(\"}\")), s;\n  }\n}\nclass Ee extends Y {\n  constructor({\n    inTypes: A,\n    outTypes: n,\n    inputs: t,\n    update: s,\n    globals: i,\n    construct: a\n  }) {\n    super({\n      inTypes: A,\n      outTypes: n,\n      inputs: t,\n      update: s,\n      globals: i,\n      generate: (r) => this.generateBlock(r)\n    }), this.construct = a;\n  }\n  generateBlock({\n    inputs: A,\n    outputs: n,\n    compile: t\n  }) {\n    var s, i;\n    const a = {}, r = {};\n    for (const u in A)\n      A[u] != null && (a[u] = new sn(this.inTypes[u], A[u]));\n    for (const u in n)\n      n[u] != null && (r[u] = new NA(this.outTypes[u]));\n    const I = { roots: [] }, g = this.construct(a, r, I);\n    for (const u of ((s = this.globals) == null ? void 0 : s.call(this, { inputs: A, outputs: n, compile: t })) ?? [])\n      t.globals.add(u);\n    const Q = [], o = /* @__PURE__ */ new Map();\n    function c(u, d, p) {\n      let h = o.get(u);\n      if (!h) {\n        h = {\n          sequence: t.nextSequence(),\n          outNames: /* @__PURE__ */ new Map(),\n          newOuts: /* @__PURE__ */ new Set()\n        }, o.set(u, h);\n        for (const m in u.inputs) {\n          let y = u.inputs[m];\n          for (; y; ) {\n            if (y instanceof NA) {\n              y instanceof P && c(y.dyno, y.key);\n              break;\n            }\n            y = y.dynoOut();\n          }\n        }\n        Q.push(u);\n      }\n      d && (p || h.newOuts.add(d), h.outNames.set(d, p ?? `${d}_${h.sequence}`));\n    }\n    for (const u of I.roots)\n      c(u);\n    for (const u in r) {\n      let d = (g == null ? void 0 : g[u]) ?? r[u];\n      for (; d; ) {\n        if (d instanceof NA) {\n          d instanceof P && c(d.dyno, d.key, n[u]);\n          break;\n        }\n        d = d.dynoOut();\n      }\n      r[u] = d;\n    }\n    const C = [];\n    for (const u of Q) {\n      const d = {}, p = {};\n      for (const y in u.inputs) {\n        let f = u.inputs[y];\n        for (; f; ) {\n          if (f instanceof NA) {\n            if (f instanceof sn)\n              d[y] = f.getLiteral();\n            else if (f instanceof P) {\n              const D = (i = o.get(f.dyno)) == null ? void 0 : i.outNames.get(f.key);\n              if (!D)\n                throw new Error(\n                  `Source not found for ${f.dyno.constructor.name}.${f.key}`\n                );\n              d[y] = D;\n            }\n            break;\n          }\n          f = f.dynoOut();\n        }\n      }\n      const h = o.get(u) ?? { outNames: /* @__PURE__ */ new Map() };\n      for (const [y, f] of h.outNames.entries())\n        p[y] = f;\n      const m = u.compile({ inputs: d, outputs: p, compile: t });\n      C.push(m);\n    }\n    const E = [];\n    for (const u in n)\n      r[u] instanceof sn && E.push(\n        `${n[u]} = ${r[u].getLiteral()};`\n      );\n    return E.length > 0 && C.push(E), { statements: C.flatMap((u, d) => d === 0 ? u : [\"\", ...u]) };\n  }\n}\nfunction SA(e, A, n, { update: t, globals: s } = {}) {\n  return new Ee({ inTypes: e, outTypes: A, construct: n, update: t, globals: s });\n}\nfunction cn({\n  inTypes: e,\n  outTypes: A,\n  inputs: n,\n  update: t,\n  globals: s,\n  statements: i,\n  generate: a\n}) {\n  return new Y({\n    inTypes: e,\n    outTypes: A,\n    inputs: n,\n    update: t,\n    globals: s,\n    statements: i,\n    generate: a\n  });\n}\nfunction tt(e, A, n) {\n  const t = typeof A == \"string\" ? A : A.type;\n  if (!t)\n    throw new Error(`Invalid DynoType: ${String(A)}`);\n  return `${t} ${e}${n != null ? `[${n}]` : \"\"}`;\n}\nfunction BA(e) {\n  var A;\n  let n = !1;\n  const t = e.split(`\n`).map((a) => {\n    const r = a.trimEnd();\n    return n ? r : r.length > 0 ? (n = !0, r) : null;\n  }).filter((a) => a != null);\n  for (; t.length > 0 && t[t.length - 1].length === 0; )\n    t.pop();\n  if (t.length === 0)\n    return [];\n  const s = (A = t[0].match(/^\\s*/)) == null ? void 0 : A[0];\n  if (!s)\n    return t;\n  const i = new RegExp(`^${s}`);\n  return t.map((a) => a.replace(i, \"\"));\n}\nfunction O(e) {\n  return BA(e).join(`\n`);\n}\nclass Rn extends Y {\n  constructor({\n    a: A,\n    outKey: n,\n    outTypeFunc: t\n  }) {\n    const s = { a: xA(A) }, i = t(xA(A)), a = { [n]: i };\n    super({ inTypes: s, outTypes: a, inputs: { a: A } }), this.outKey = n;\n  }\n  dynoOut() {\n    return new P(this, this.outKey);\n  }\n}\nclass Cn extends Y {\n  constructor({\n    a: A,\n    b: n,\n    outKey: t,\n    outTypeFunc: s\n  }) {\n    const i = { a: xA(A), b: xA(n) }, a = s(xA(A), xA(n)), r = { [t]: a };\n    super({ inTypes: i, outTypes: r, inputs: { a: A, b: n } }), this.outKey = t;\n  }\n  dynoOut() {\n    return new P(this, this.outKey);\n  }\n}\nconst N = { type: \"Gsplat\" }, En = { type: \"PackedSplats\" }, on = (e, A) => new he({ packedSplats: e, index: A }), le = (e, A, n, t) => new ue({ packedSplats: e, index: A, base: n, count: t }), an = (e) => new de({ gsplat: e }), ln = ({\n  gsplat: e,\n  flags: A,\n  index: n,\n  center: t,\n  scales: s,\n  quaternion: i,\n  rgba: a,\n  rgb: r,\n  opacity: I,\n  x: g,\n  y: Q,\n  z: o,\n  r: c,\n  g: C,\n  b: E\n}) => new pe({\n  gsplat: e,\n  flags: A,\n  index: n,\n  center: t,\n  scales: s,\n  quaternion: i,\n  rgba: a,\n  rgb: r,\n  opacity: I,\n  x: g,\n  y: Q,\n  z: o,\n  r: c,\n  g: C,\n  b: E\n}), et = (e, {\n  scale: A,\n  rotate: n,\n  translate: t,\n  recolor: s\n}) => new ye({ gsplat: e, scale: A, rotate: n, translate: t, recolor: s }), QA = O(`\n  struct Gsplat {\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n`), vn = O(`\n  struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n  };\n`), st = O(`\n  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\n      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);\n      return true;\n    } else {\n      return false;\n    }\n  }\n`);\nclass he extends Y {\n  constructor({\n    packedSplats: A,\n    index: n\n  }) {\n    super({\n      inTypes: { packedSplats: En, index: \"int\" },\n      outTypes: { gsplat: N },\n      inputs: { packedSplats: A, index: n },\n      globals: () => [QA, vn, st],\n      statements: ({ inputs: t, outputs: s }) => {\n        const { gsplat: i } = s;\n        if (!i)\n          return [];\n        const { packedSplats: a, index: r } = t;\n        let I;\n        return a && r ? I = BA(`\n            if (readPackedSplat(${a}.texture, ${a}.numSplats, ${r}, ${i})) {\n              bool zeroSize = all(equal(${i}.scales, vec3(0.0, 0.0, 0.0)));\n              ${i}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } else {\n              ${i}.flags = 0u;\n            }\n          `) : I = [`${i}.flags = 0u;`], I.push(`${i}.index = ${r ?? \"0\"};`), I;\n      }\n    });\n  }\n  dynoOut() {\n    return new P(this, \"gsplat\");\n  }\n}\nclass ue extends Y {\n  constructor({\n    packedSplats: A,\n    index: n,\n    base: t,\n    count: s\n  }) {\n    super({\n      inTypes: {\n        packedSplats: En,\n        index: \"int\",\n        base: \"int\",\n        count: \"int\"\n      },\n      outTypes: { gsplat: N },\n      inputs: { packedSplats: A, index: n, base: t, count: s },\n      globals: () => [QA, vn, st],\n      statements: ({ inputs: i, outputs: a }) => {\n        const { gsplat: r } = a;\n        if (!r)\n          return [];\n        const { packedSplats: I, index: g, base: Q, count: o } = i;\n        let c;\n        return I && g && Q && o ? c = BA(`\n            ${r}.flags = 0u;\n            if ((${g} >= ${Q}) && (${g} < (${Q} + ${o}))) {\n              if (readPackedSplat(${I}.texture, ${I}.numSplats, ${g}, ${r})) {\n                bool zeroSize = all(equal(${r}.scales, vec3(0.0, 0.0, 0.0)));\n                ${r}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          `) : c = [`${r}.flags = 0u;`], c.push(`${r}.index = ${g ?? \"0\"};`), c;\n      }\n    });\n  }\n  dynoOut() {\n    return new P(this, \"gsplat\");\n  }\n}\nclass de extends Y {\n  constructor({ gsplat: A }) {\n    super({\n      inTypes: { gsplat: N },\n      outTypes: {\n        flags: \"uint\",\n        active: \"bool\",\n        index: \"int\",\n        center: \"vec3\",\n        scales: \"vec3\",\n        quaternion: \"vec4\",\n        rgba: \"vec4\",\n        rgb: \"vec3\",\n        opacity: \"float\",\n        x: \"float\",\n        y: \"float\",\n        z: \"float\",\n        r: \"float\",\n        g: \"float\",\n        b: \"float\"\n      },\n      inputs: { gsplat: A },\n      globals: () => [QA],\n      statements: ({ inputs: n, outputs: t }) => {\n        const { gsplat: s } = n, {\n          flags: i,\n          active: a,\n          index: r,\n          center: I,\n          scales: g,\n          quaternion: Q,\n          rgba: o,\n          rgb: c,\n          opacity: C,\n          x: E,\n          y: l,\n          z: u,\n          r: d,\n          g: p,\n          b: h\n        } = t;\n        return [\n          i ? `${i} = ${s ? `${s}.flags` : \"0u\"};` : null,\n          a ? `${a} = isGsplatActive(${s ? `${s}.flags` : \"0u\"});` : null,\n          r ? `${r} = ${s ? `${s}.index` : \"0\"};` : null,\n          I ? `${I} = ${s ? `${s}.center` : \"vec3(0.0, 0.0, 0.0)\"};` : null,\n          g ? `${g} = ${s ? `${s}.scales` : \"vec3(0.0, 0.0, 0.0)\"};` : null,\n          Q ? `${Q} = ${s ? `${s}.quaternion` : \"vec4(0.0, 0.0, 0.0, 1.0)\"};` : null,\n          o ? `${o} = ${s ? `${s}.rgba` : \"vec4(0.0, 0.0, 0.0, 0.0)\"};` : null,\n          c ? `${c} = ${s ? `${s}.rgba.rgb` : \"vec3(0.0, 0.0, 0.0)\"};` : null,\n          C ? `${C} = ${s ? `${s}.rgba.a` : \"0.0\"};` : null,\n          E ? `${E} = ${s ? `${s}.center.x` : \"0.0\"};` : null,\n          l ? `${l} = ${s ? `${s}.center.y` : \"0.0\"};` : null,\n          u ? `${u} = ${s ? `${s}.center.z` : \"0.0\"};` : null,\n          d ? `${d} = ${s ? `${s}.rgba.r` : \"0.0\"};` : null,\n          p ? `${p} = ${s ? `${s}.rgba.g` : \"0.0\"};` : null,\n          h ? `${h} = ${s ? `${s}.rgba.b` : \"0.0\"};` : null\n        ].filter(Boolean);\n      }\n    });\n  }\n}\nclass pe extends Y {\n  constructor({\n    gsplat: A,\n    flags: n,\n    index: t,\n    center: s,\n    scales: i,\n    quaternion: a,\n    rgba: r,\n    rgb: I,\n    opacity: g,\n    x: Q,\n    y: o,\n    z: c,\n    r: C,\n    g: E,\n    b: l\n  }) {\n    super({\n      inTypes: {\n        gsplat: N,\n        flags: \"uint\",\n        index: \"int\",\n        center: \"vec3\",\n        scales: \"vec3\",\n        quaternion: \"vec4\",\n        rgba: \"vec4\",\n        rgb: \"vec3\",\n        opacity: \"float\",\n        x: \"float\",\n        y: \"float\",\n        z: \"float\",\n        r: \"float\",\n        g: \"float\",\n        b: \"float\"\n      },\n      outTypes: { gsplat: N },\n      inputs: {\n        gsplat: A,\n        flags: n,\n        index: t,\n        center: s,\n        scales: i,\n        quaternion: a,\n        rgba: r,\n        rgb: I,\n        opacity: g,\n        x: Q,\n        y: o,\n        z: c,\n        r: C,\n        g: E,\n        b: l\n      },\n      globals: () => [QA],\n      statements: ({ inputs: u, outputs: d }) => {\n        const { gsplat: p } = d;\n        if (!p)\n          return [];\n        const {\n          gsplat: h,\n          flags: m,\n          index: y,\n          center: f,\n          scales: D,\n          quaternion: T,\n          rgba: R,\n          rgb: U,\n          opacity: k,\n          x: v,\n          y: Z,\n          z: q,\n          r: $,\n          g: G,\n          b: J\n        } = u;\n        return [\n          `${p}.flags = ${m ?? (h ? `${h}.flags` : \"0u\")};`,\n          `${p}.index = ${y ?? (h ? `${h}.index` : \"0\")};`,\n          `${p}.center = ${f ?? (h ? `${h}.center` : \"vec3(0.0, 0.0, 0.0)\")};`,\n          `${p}.scales = ${D ?? (h ? `${h}.scales` : \"vec3(0.0, 0.0, 0.0)\")};`,\n          `${p}.quaternion = ${T ?? (h ? `${h}.quaternion` : \"vec4(0.0, 0.0, 0.0, 1.0)\")};`,\n          `${p}.rgba = ${R ?? (h ? `${h}.rgba` : \"vec4(0.0, 0.0, 0.0, 0.0)\")};`,\n          U ? `${p}.rgba.rgb = ${U};` : null,\n          k ? `${p}.rgba.a = ${k};` : null,\n          v ? `${p}.center.x = ${v};` : null,\n          Z ? `${p}.center.y = ${Z};` : null,\n          q ? `${p}.center.z = ${q};` : null,\n          $ ? `${p}.rgba.r = ${$};` : null,\n          G ? `${p}.rgba.g = ${G};` : null,\n          J ? `${p}.rgba.b = ${J};` : null\n        ].filter(Boolean);\n      }\n    });\n  }\n  dynoOut() {\n    return new P(this, \"gsplat\");\n  }\n}\nO(`\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if (scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if (scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n      normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, normal);\n  }\n`);\nclass ye extends Y {\n  constructor({\n    gsplat: A,\n    scale: n,\n    rotate: t,\n    translate: s,\n    recolor: i\n  }) {\n    super({\n      inTypes: {\n        gsplat: N,\n        scale: \"float\",\n        rotate: \"vec4\",\n        translate: \"vec3\",\n        recolor: \"vec4\"\n      },\n      outTypes: { gsplat: N },\n      inputs: { gsplat: A, scale: n, rotate: t, translate: s, recolor: i },\n      globals: () => [QA],\n      statements: ({ inputs: a, outputs: r, compile: I }) => {\n        const { gsplat: g } = r;\n        if (!g || !a.gsplat)\n          return [];\n        const { scale: Q, rotate: o, translate: c, recolor: C } = a, E = I.indent;\n        return [\n          `${g} = ${a.gsplat};`,\n          `if (isGsplatActive(${g}.flags)) {`,\n          Q ? `${E}${g}.center *= ${Q};` : null,\n          o ? `${E}${g}.center = quatVec(${o}, ${g}.center);` : null,\n          c ? `${E}${g}.center += ${c};` : null,\n          Q ? `${E}${g}.scales *= ${Q};` : null,\n          o ? `${E}${g}.quaternion = quatQuat(${o}, ${g}.quaternion);` : null,\n          C ? `${E}${g}.rgba *= ${C};` : null,\n          \"}\"\n        ].filter(Boolean);\n      }\n    });\n  }\n  dynoOut() {\n    return new P(this, \"gsplat\");\n  }\n}\nconst fe = (e) => new me({ gsplat: e });\nclass me extends Y {\n  constructor({ gsplat: A }) {\n    super({\n      inTypes: { gsplat: N },\n      inputs: { gsplat: A },\n      globals: () => [QA],\n      statements: ({ inputs: n, outputs: t }) => {\n        const { output: s } = t;\n        if (!s)\n          return [];\n        const { gsplat: i } = n;\n        return i ? BA(`\n            if (isGsplatActive(${i}.flags)) {\n              ${s} = packSplat(${i}.center, ${i}.scales, ${i}.quaternion, ${i}.rgba);\n            } else {\n              ${s} = uvec4(0u, 0u, 0u, 0u);\n            }\n          `) : [`${s} = uvec4(0u, 0u, 0u, 0u);`];\n      }\n    });\n  }\n  dynoOut() {\n    return new P(this, \"output\");\n  }\n}\nclass we extends Y {\n  constructor({ rgba8: A }) {\n    super({\n      inTypes: { rgba8: \"vec4\" },\n      inputs: { rgba8: A },\n      statements: ({ inputs: n, outputs: t }) => [\n        `target = ${n.rgba8 ?? \"vec4(0.0, 0.0, 0.0, 0.0)\"};`\n      ]\n    });\n  }\n  dynoOut() {\n    return new P(this, \"rgba8\");\n  }\n}\nclass oA extends Y {\n  constructor({\n    key: A,\n    type: n,\n    count: t,\n    value: s,\n    update: i,\n    globals: a\n  }) {\n    A = A ?? \"value\", super({\n      outTypes: { [A]: n },\n      update: () => {\n        if (i) {\n          const r = i(this.value);\n          r !== void 0 && (this.value = r);\n        }\n        this.uniform.value = this.value;\n      },\n      generate: ({ inputs: r, outputs: I }) => {\n        const g = (a == null ? void 0 : a({ inputs: r, outputs: I })) ?? [], Q = {}, o = I[A];\n        return o && (g.push(`uniform ${tt(o, n, t)};`), Q[o] = this.uniform), { globals: g, uniforms: Q };\n      }\n    }), this.type = n, this.count = t, this.value = s, this.uniform = { value: s }, this.outKey = A;\n  }\n  dynoOut() {\n    return new P(this, this.outKey);\n  }\n}\nclass qn extends oA {\n  constructor({\n    key: A,\n    value: n,\n    update: t\n  }) {\n    super({ key: A, type: \"bool\", value: n, update: t });\n  }\n}\nclass xn extends oA {\n  constructor({\n    key: A,\n    value: n,\n    update: t\n  }) {\n    super({ key: A, type: \"int\", value: n, update: t });\n  }\n}\nclass jA extends oA {\n  constructor({\n    key: A,\n    value: n,\n    update: t\n  }) {\n    super({ key: A, type: \"float\", value: n, update: t });\n  }\n}\nclass In extends oA {\n  constructor({\n    key: A,\n    value: n,\n    update: t\n  }) {\n    super({ key: A, type: \"vec3\", value: n, update: t });\n  }\n}\nclass Gn extends oA {\n  constructor({\n    key: A,\n    value: n,\n    update: t\n  }) {\n    super({ key: A, type: \"vec4\", value: n, update: t });\n  }\n}\nclass hn extends oA {\n  constructor({\n    key: A,\n    value: n,\n    update: t\n  }) {\n    super({ key: A, type: \"usampler2DArray\", value: n, update: t });\n  }\n}\nvar _ = Uint8Array, KA = Uint16Array, De = Int32Array, it = new _([\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  2,\n  2,\n  2,\n  2,\n  3,\n  3,\n  3,\n  3,\n  4,\n  4,\n  4,\n  4,\n  5,\n  5,\n  5,\n  5,\n  0,\n  /* unused */\n  0,\n  0,\n  /* impossible */\n  0\n]), at = new _([\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  2,\n  2,\n  3,\n  3,\n  4,\n  4,\n  5,\n  5,\n  6,\n  6,\n  7,\n  7,\n  8,\n  8,\n  9,\n  9,\n  10,\n  10,\n  11,\n  11,\n  12,\n  12,\n  13,\n  13,\n  /* unused */\n  0,\n  0\n]), xe = new _([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), rt = function(e, A) {\n  for (var n = new KA(31), t = 0; t < 31; ++t)\n    n[t] = A += 1 << e[t - 1];\n  for (var s = new De(n[30]), t = 1; t < 30; ++t)\n    for (var i = n[t]; i < n[t + 1]; ++i)\n      s[i] = i - n[t] << 5 | t;\n  return { b: n, r: s };\n}, gt = rt(it, 2), ot = gt.b, Se = gt.r;\not[28] = 258, Se[258] = 28;\nvar ke = rt(at, 0), be = ke.b, It = new KA(32768);\nfor (var b = 0; b < 32768; ++b) {\n  var DA = (b & 43690) >> 1 | (b & 21845) << 1;\n  DA = (DA & 52428) >> 2 | (DA & 13107) << 2, DA = (DA & 61680) >> 4 | (DA & 3855) << 4, It[b] = ((DA & 65280) >> 8 | (DA & 255) << 8) >> 1;\n}\nvar PA = function(e, A, n) {\n  for (var t = e.length, s = 0, i = new KA(A); s < t; ++s)\n    e[s] && ++i[e[s] - 1];\n  var a = new KA(A);\n  for (s = 1; s < A; ++s)\n    a[s] = a[s - 1] + i[s - 1] << 1;\n  var r;\n  {\n    r = new KA(1 << A);\n    var I = 15 - A;\n    for (s = 0; s < t; ++s)\n      if (e[s])\n        for (var g = s << 4 | e[s], Q = A - e[s], o = a[e[s] - 1]++ << Q, c = o | (1 << Q) - 1; o <= c; ++o)\n          r[It[o] >> I] = g;\n  }\n  return r;\n}, XA = new _(288);\nfor (var b = 0; b < 144; ++b)\n  XA[b] = 8;\nfor (var b = 144; b < 256; ++b)\n  XA[b] = 9;\nfor (var b = 256; b < 280; ++b)\n  XA[b] = 7;\nfor (var b = 280; b < 288; ++b)\n  XA[b] = 8;\nvar Bt = new _(32);\nfor (var b = 0; b < 32; ++b)\n  Bt[b] = 5;\nvar Me = /* @__PURE__ */ PA(XA, 9), Fe = /* @__PURE__ */ PA(Bt, 5), un = function(e) {\n  for (var A = e[0], n = 1; n < e.length; ++n)\n    e[n] > A && (A = e[n]);\n  return A;\n}, sA = function(e, A, n) {\n  var t = A / 8 | 0;\n  return (e[t] | e[t + 1] << 8) >> (A & 7) & n;\n}, dn = function(e, A) {\n  var n = A / 8 | 0;\n  return (e[n] | e[n + 1] << 8 | e[n + 2] << 16) >> (A & 7);\n}, Qt = function(e) {\n  return (e + 7) / 8 | 0;\n}, rn = function(e, A, n) {\n  return (A == null || A < 0) && (A = 0), (n == null || n > e.length) && (n = e.length), new _(e.subarray(A, n));\n}, Ne = [\n  \"unexpected EOF\",\n  \"invalid block type\",\n  \"invalid length/literal\",\n  \"invalid distance\",\n  \"stream finished\",\n  \"no stream handler\",\n  ,\n  \"no callback\",\n  \"invalid UTF-8 data\",\n  \"extra field too long\",\n  \"date not in range 1980-2099\",\n  \"filename too long\",\n  \"stream finishing\",\n  \"invalid zip data\"\n  // determined by unknown compression method\n], X = function(e, A, n) {\n  var t = new Error(A || Ne[e]);\n  if (t.code = e, Error.captureStackTrace && Error.captureStackTrace(t, X), !n)\n    throw t;\n  return t;\n}, Re = function(e, A, n, t) {\n  var s = e.length, i = 0;\n  if (!s || A.f && !A.l)\n    return n || new _(0);\n  var a = !n, r = a || A.i != 2, I = A.i;\n  a && (n = new _(s * 3));\n  var g = function(eA) {\n    var dA = n.length;\n    if (eA > dA) {\n      var pA = new _(Math.max(dA * 2, eA));\n      pA.set(n), n = pA;\n    }\n  }, Q = A.f || 0, o = A.p || 0, c = A.b || 0, C = A.l, E = A.d, l = A.m, u = A.n, d = s * 8;\n  do {\n    if (!C) {\n      Q = sA(e, o, 1);\n      var p = sA(e, o + 1, 3);\n      if (o += 3, p)\n        if (p == 1)\n          C = Me, E = Fe, l = 9, u = 5;\n        else if (p == 2) {\n          var f = sA(e, o, 31) + 257, D = sA(e, o + 10, 15) + 4, T = f + sA(e, o + 5, 31) + 1;\n          o += 14;\n          for (var R = new _(T), U = new _(19), k = 0; k < D; ++k)\n            U[xe[k]] = sA(e, o + k * 3, 7);\n          o += D * 3;\n          for (var v = un(U), Z = (1 << v) - 1, q = PA(U, v), k = 0; k < T; ) {\n            var $ = q[sA(e, o, Z)];\n            o += $ & 15;\n            var h = $ >> 4;\n            if (h < 16)\n              R[k++] = h;\n            else {\n              var G = 0, J = 0;\n              for (h == 16 ? (J = 3 + sA(e, o, 3), o += 2, G = R[k - 1]) : h == 17 ? (J = 3 + sA(e, o, 7), o += 3) : h == 18 && (J = 11 + sA(e, o, 127), o += 7); J--; )\n                R[k++] = G;\n            }\n          }\n          var AA = R.subarray(0, f), H = R.subarray(f);\n          l = un(AA), u = un(H), C = PA(AA, l), E = PA(H, u);\n        } else\n          X(1);\n      else {\n        var h = Qt(o) + 4, m = e[h - 4] | e[h - 3] << 8, y = h + m;\n        if (y > s) {\n          I && X(0);\n          break;\n        }\n        r && g(c + m), n.set(e.subarray(h, y), c), A.b = c += m, A.p = o = y * 8, A.f = Q;\n        continue;\n      }\n      if (o > d) {\n        I && X(0);\n        break;\n      }\n    }\n    r && g(c + 131072);\n    for (var uA = (1 << l) - 1, iA = (1 << u) - 1, aA = o; ; aA = o) {\n      var G = C[dn(e, o) & uA], V = G >> 4;\n      if (o += G & 15, o > d) {\n        I && X(0);\n        break;\n      }\n      if (G || X(2), V < 256)\n        n[c++] = V;\n      else if (V == 256) {\n        aA = o, C = null;\n        break;\n      } else {\n        var cA = V - 254;\n        if (V > 264) {\n          var k = V - 257, nA = it[k];\n          cA = sA(e, o, (1 << nA) - 1) + ot[k], o += nA;\n        }\n        var rA = E[dn(e, o) & iA], x = rA >> 4;\n        rA || X(3), o += rA & 15;\n        var H = be[x];\n        if (x > 3) {\n          var nA = at[x];\n          H += dn(e, o) & (1 << nA) - 1, o += nA;\n        }\n        if (o > d) {\n          I && X(0);\n          break;\n        }\n        r && g(c + 131072);\n        var gA = c + cA;\n        if (c < H) {\n          var tA = i - H, CA = Math.min(H, gA);\n          for (tA + c < 0 && X(3); c < CA; ++c)\n            n[c] = t[tA + c];\n        }\n        for (; c < gA; ++c)\n          n[c] = n[c - H];\n      }\n    }\n    A.l = C, A.p = aA, A.b = c, A.f = Q, C && (Q = 1, A.m = l, A.d = E, A.n = u);\n  } while (!Q);\n  return c != n.length && a ? rn(n, 0, c) : n.subarray(0, c);\n}, ve = /* @__PURE__ */ new _(0), Ge = function(e) {\n  (e[0] != 31 || e[1] != 139 || e[2] != 8) && X(6, \"invalid gzip data\");\n  var A = e[3], n = 10;\n  A & 4 && (n += (e[10] | e[11] << 8) + 2);\n  for (var t = (A >> 3 & 1) + (A >> 4 & 1); t > 0; t -= !e[n++])\n    ;\n  return n + (A & 2);\n}, pn = /* @__PURE__ */ function() {\n  function e(A, n) {\n    typeof A == \"function\" && (n = A, A = {}), this.ondata = n;\n    var t = A && A.dictionary && A.dictionary.subarray(-32768);\n    this.s = { i: 0, b: t ? t.length : 0 }, this.o = new _(32768), this.p = new _(0), t && this.o.set(t);\n  }\n  return e.prototype.e = function(A) {\n    if (this.ondata || X(5), this.d && X(4), !this.p.length)\n      this.p = A;\n    else if (A.length) {\n      var n = new _(this.p.length + A.length);\n      n.set(this.p), n.set(A, this.p.length), this.p = n;\n    }\n  }, e.prototype.c = function(A) {\n    this.s.i = +(this.d = A || !1);\n    var n = this.s.b, t = Re(this.p, this.s, this.o);\n    this.ondata(rn(t, n, this.s.b), this.d), this.o = rn(t, this.s.b - 32768), this.s.b = this.o.length, this.p = rn(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n  }, e.prototype.push = function(A, n) {\n    this.e(A), this.c(n);\n  }, e;\n}(), Ue = /* @__PURE__ */ function() {\n  function e(A, n) {\n    this.v = 1, this.r = 0, pn.call(this, A, n);\n  }\n  return e.prototype.push = function(A, n) {\n    if (pn.prototype.e.call(this, A), this.r += A.length, this.v) {\n      var t = this.p.subarray(this.v - 1), s = t.length > 3 ? Ge(t) : 4;\n      if (s > t.length) {\n        if (!n)\n          return;\n      } else this.v > 1 && this.onmember && this.onmember(this.r - t.length);\n      this.p = t.subarray(s), this.v = 0;\n    }\n    pn.prototype.c.call(this, n), this.s.f && !this.s.l && !n && (this.v = Qt(this.s.p) + 9, this.s = { i: 0 }, this.o = new _(0), this.push(new _(0), n));\n  }, e;\n}(), Le = typeof TextDecoder < \"u\" && /* @__PURE__ */ new TextDecoder(), _e = 0;\ntry {\n  Le.decode(ve, { stream: !0 }), _e = 1;\n} catch {\n}\nconst Un = new Float32Array(1), ct = new Uint32Array(Un.buffer);\nfunction yn(e) {\n  Un[0] = e;\n  const A = ct[0], n = A >> 31 & 1, t = A >> 23 & 255, s = A & 8388607, i = n << 15;\n  if (t === 255)\n    return s !== 0 ? i | 32767 : i | 31744;\n  const a = t - 127 + 15;\n  if (a >= 31)\n    return i | 31744;\n  if (a <= 0) {\n    if (a < -10)\n      return i;\n    const I = (s | 8388608) >> 1 - a + 13;\n    return i | I;\n  }\n  const r = s >> 13;\n  return i | a << 10 | r;\n}\nfunction fn(e) {\n  const A = e >> 15 & 1, n = e >> 10 & 31, t = e & 1023;\n  let s;\n  if (n === 0)\n    if (t === 0)\n      s = A << 31;\n    else {\n      let i = t, a = -14;\n      for (; !(i & 1024); )\n        i <<= 1, a--;\n      i &= 1023;\n      const r = a + 127, I = i << 13;\n      s = A << 31 | r << 23 | I;\n    }\n  else if (n === 31)\n    t === 0 ? s = A << 31 | 2139095040 : s = A << 31 | 2143289344;\n  else {\n    const i = n - 15 + 127, a = t << 13;\n    s = A << 31 | i << 23 | a;\n  }\n  return ct[0] = s, Un[0];\n}\nfunction $A(e) {\n  return Math.max(0, Math.min(255, Math.round(e * 255)));\n}\nfunction Ye(e) {\n  const A = [], n = /* @__PURE__ */ new Set();\n  function t(s) {\n    s && typeof s == \"object\" && !n.has(s) && (n.add(s), s instanceof ArrayBuffer ? A.push(s) : ArrayBuffer.isView(s) ? A.push(s.buffer) : Array.isArray(s) ? s.forEach(t) : Object.values(s).forEach(t));\n  }\n  return t(e), A;\n}\nclass Te {\n  constructor({\n    // Allocate a new item with the given args\n    allocate: A,\n    // Dispose of an item (optional, if GC is enough)\n    dispose: n,\n    // Check if an existing item in the list is valid for the given args,\n    // allowing you to store heterogeneous items in the list.\n    valid: t\n  }) {\n    this.items = [], this.allocate = A, this.dispose = n, this.valid = t;\n  }\n  // Allocate a new item from the free list, first checking if a existing item\n  // on the freelist is valid for the given args.\n  alloc(A) {\n    for (; ; ) {\n      const n = this.items.pop();\n      if (!n)\n        break;\n      if (this.valid(n, A))\n        return n;\n      this.dispose && this.dispose(n);\n    }\n    return this.allocate(A);\n  }\n  free(A) {\n    this.items.push(A);\n  }\n  disposeAll() {\n    let A;\n    for (A = this.items.pop(); A; )\n      this.dispose && this.dispose(A), A = this.items.pop();\n  }\n}\nfunction zn(e, A, n, t, s, i, a, r, I, g, Q, o, c, C, E, l) {\n  const u = $A(C), d = $A(E), p = $A(l), h = $A(c), m = Xe(\n    new B.Quaternion(I, g, Q, o)\n  ), y = m & 255, f = m >>> 8 & 255, D = m >>> 16 & 255, T = i === 0 ? 0 : Math.min(\n    255,\n    Math.max(\n      0,\n      Math.round((Math.log(i) - RA) / YA) + 1\n    )\n  ), R = a === 0 ? 0 : Math.min(\n    255,\n    Math.max(\n      0,\n      Math.round((Math.log(a) - RA) / YA) + 1\n    )\n  ), U = r === 0 ? 0 : Math.min(\n    255,\n    Math.max(\n      0,\n      Math.round((Math.log(r) - RA) / YA) + 1\n    )\n  ), k = yn(n), v = yn(t), Z = yn(s), q = A * 4;\n  e[q] = u | d << 8 | p << 16 | h << 24, e[q + 1] = k | v << 16, e[q + 2] = Z | y << 16 | f << 24, e[q + 3] = T | R << 8 | U << 16 | D << 24;\n}\nconst Je = new B.Vector3(), He = new B.Vector3(), qe = new B.Quaternion(), ze = new B.Color(), Ke = {\n  center: Je,\n  scales: He,\n  quaternion: qe,\n  color: ze,\n  opacity: 0\n};\nfunction Kn(e, A) {\n  const n = Ke, t = A * 4, s = e[t], i = e[t + 1], a = e[t + 2], r = e[t + 3];\n  n.color.set(\n    (s & 255) / 255,\n    (s >>> 8 & 255) / 255,\n    (s >>> 16 & 255) / 255\n  ), n.opacity = (s >>> 24 & 255) / 255, n.center.set(\n    fn(i & 65535),\n    fn(i >>> 16 & 65535),\n    fn(a & 65535)\n  );\n  const I = r & 255;\n  n.scales.x = I === 0 ? 0 : Math.exp(RA + (I - 1) * YA);\n  const g = r >>> 8 & 255;\n  n.scales.y = g === 0 ? 0 : Math.exp(RA + (g - 1) * YA);\n  const Q = r >>> 16 & 255;\n  n.scales.z = Q === 0 ? 0 : Math.exp(RA + (Q - 1) * YA);\n  const o = a >>> 16 & 65535 | r >>> 8 & 16711680;\n  return We(o, n.quaternion), n;\n}\nfunction W(e) {\n  const A = S, n = Math.max(\n    re,\n    Math.min(bA, Math.ceil(e / A))\n  ), t = Math.ceil(e / (A * n)), s = A * n * t;\n  return { width: A, height: n, depth: t, maxSplats: s };\n}\nfunction Pe(e) {\n  const A = new B.Clock(e.autoStart);\n  return A.startTime = e.startTime, A.oldTime = e.oldTime, A.elapsedTime = e.elapsedTime, A.running = e.running, A;\n}\nconst Oe = O(`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n`);\nfunction Ve(e) {\n  const A = new B.Vector3();\n  for (const n of e)\n    A.add(n);\n  return A.divideScalar(e.length);\n}\nfunction je(e) {\n  if (e.length === 0)\n    return new B.Quaternion();\n  const A = e[0].clone();\n  for (let n = 1; n < e.length; n++)\n    e[n].dot(e[0]) < 0 ? (A.x -= e[n].x, A.y -= e[n].y, A.z -= e[n].z, A.w -= e[n].w) : (A.x += e[n].x, A.y += e[n].y, A.z += e[n].z, A.w += e[n].w);\n  return A.normalize();\n}\nfunction Ze(e, A) {\n  const [n, t] = [new B.Vector3(), new B.Quaternion()], [s, i] = [new B.Vector3(), new B.Quaternion()];\n  e.decompose(n, t, new B.Vector3()), A.decompose(s, i, new B.Vector3());\n  const a = n.distanceTo(s), r = Math.abs(t.dot(i));\n  return { distance: a, coorient: r };\n}\nfunction Sn({\n  matrix1: e,\n  matrix2: A,\n  maxDistance: n,\n  minCoorient: t\n}) {\n  const { distance: s, coorient: i } = Ze(e, A);\n  return s <= n && (t == null || i >= t);\n}\nfunction Xe(e) {\n  const A = e.clone().normalize();\n  A.w < 0 && A.set(-A.x, -A.y, -A.z, -A.w);\n  const n = 2 * Math.acos(A.w), t = Math.sqrt(\n    A.x * A.x + A.y * A.y + A.z * A.z\n  ), s = t < 1e-6 ? new B.Vector3(1, 0, 0) : new B.Vector3(A.x, A.y, A.z).divideScalar(t), i = Math.abs(s.x) + Math.abs(s.y) + Math.abs(s.z);\n  let a = s.x / i, r = s.y / i;\n  if (s.z < 0) {\n    const C = a;\n    a = (1 - Math.abs(r)) * (a >= 0 ? 1 : -1), r = (1 - Math.abs(C)) * (r >= 0 ? 1 : -1);\n  }\n  const I = a * 0.5 + 0.5, g = r * 0.5 + 0.5, Q = Math.round(I * 255), o = Math.round(g * 255);\n  return Math.round(n * (255 / Math.PI)) << 16 | o << 8 | Q;\n}\nfunction We(e, A) {\n  const n = e & 255, t = e >>> 8 & 255, s = e >>> 16 & 255, i = n / 255, a = t / 255;\n  let r = (i - 0.5) * 2, I = (a - 0.5) * 2;\n  const g = 1 - (Math.abs(r) + Math.abs(I)), Q = Math.max(-g, 0);\n  r += r >= 0 ? -Q : Q, I += I >= 0 ? -Q : Q;\n  const o = new B.Vector3(r, I, g).normalize(), C = s / 255 * Math.PI * 0.5, E = Math.sin(C), l = Math.cos(C);\n  return A.set(o.x * E, o.y * E, o.z * E, l), A;\n}\nfunction $e(e, A) {\n  const n = [];\n  let t = 0, s = null;\n  const i = new Ue((I, g) => {\n    if (n.push(I), t += I.length, g || t >= A) {\n      const Q = new Uint8Array(t);\n      let o = 0;\n      for (const c of n)\n        Q.set(c, o), o += c.length;\n      s = Q.slice(0, A);\n    }\n  }), a = 1024;\n  let r = 0;\n  for (; s == null && r < e.length; ) {\n    const I = e.slice(r, r + a);\n    i.push(I, !1), r += a;\n  }\n  if (s == null && (i.push(new Uint8Array(), !0), s == null))\n    throw new Error(\"Failed to decompress partial gzip\");\n  return s;\n}\nclass Ct {\n  constructor({\n    graph: A,\n    inputs: n,\n    outputs: t,\n    template: s\n  }) {\n    this.graph = A, this.template = s, this.inputs = n ?? {}, this.outputs = t ?? {};\n    const i = new Ce({ indent: this.template.indent });\n    for (const r in this.outputs)\n      this.outputs[r] && i.declares.add(this.outputs[r]);\n    const a = A.compile({\n      inputs: this.inputs,\n      outputs: this.outputs,\n      compile: i\n    });\n    this.shader = s.generate({ globals: i.globals, statements: a }), this.uniforms = i.uniforms, this.updaters = i.updaters;\n  }\n  prepareMaterial() {\n    return As(this);\n  }\n  update() {\n    for (const A of this.updaters)\n      A();\n  }\n}\nclass Et {\n  constructor(A) {\n    const n = A.match(/^([ \\t]*)\\{\\{\\s*GLOBALS\\s*\\}\\}/m), t = A.match(/^([ \\t]*)\\{\\{\\s*STATEMENTS\\s*\\}\\}/m);\n    if (!n || !t)\n      throw new Error(\n        \"Template must contain {{ GLOBALS }} and {{ STATEMENTS }}\"\n      );\n    this.before = A.substring(0, n.index), this.between = A.substring(\n      n.index + n[0].length,\n      t.index\n    ), this.after = A.substring(\n      t.index + t[0].length\n    ), this.indent = t[1];\n  }\n  generate({\n    globals: A,\n    statements: n\n  }) {\n    return this.before + Array.from(A).join(`\n\n`) + this.between + n.map((t) => this.indent + t).join(`\n`) + this.after;\n  }\n}\nconst Pn = /* @__PURE__ */ new Map();\nfunction As(e) {\n  let A = Pn.get(e);\n  return A || (A = new B.RawShaderMaterial({\n    glslVersion: B.GLSL3,\n    vertexShader: Oe,\n    fragmentShader: e.shader,\n    uniforms: e.uniforms\n  }), Pn.set(e, A), A);\n}\nfunction lt(e, A, n = \"add\") {\n  const t = () => {\n    throw new Error(`Invalid ${n} types: ${e}, ${A}`);\n  };\n  if (e === A) return e;\n  if (e === \"int\") {\n    if (MA(A)) return A;\n    t();\n  }\n  if (A === \"int\") {\n    if (MA(e)) return e;\n    t();\n  }\n  if (e === \"uint\") {\n    if (FA(A)) return A;\n    t();\n  }\n  if (A === \"uint\") {\n    if (FA(e)) return e;\n    t();\n  }\n  if (e === \"float\") {\n    if (VA(A)) return A;\n    t();\n  }\n  if (A === \"float\") {\n    if (VA(e)) return e;\n    t();\n  }\n  throw new Error(`Invalid ${n} types: ${e}, ${A}`);\n}\nfunction ns(e, A) {\n  return lt(e, A, \"sub\");\n}\nfunction ts(e, A) {\n  const n = () => {\n    throw new Error(`Invalid mul types: ${e}, ${A}`);\n  }, t = (s) => s;\n  if (e === \"int\") {\n    if (MA(A)) return t(A);\n    n();\n  }\n  if (A === \"int\") {\n    if (MA(e)) return t(e);\n    n();\n  }\n  if (e === \"uint\") {\n    if (FA(A)) return t(A);\n    n();\n  }\n  if (A === \"uint\") {\n    if (FA(e)) return t(e);\n    n();\n  }\n  if (e === \"float\") {\n    if (VA(A)) return t(A);\n    n();\n  }\n  if (A === \"float\") {\n    if (VA(e)) return t(e);\n    n();\n  }\n  if (MA(e) || FA(e) || MA(A) || FA(A)) {\n    if (e === A) return t(e);\n    n();\n  }\n  if (e === \"vec2\") {\n    if (A === \"vec2\" || vA(A)) return t(\"vec2\");\n    if (A === \"mat3x2\") return t(\"vec3\");\n    if (A === \"mat4x2\") return t(\"vec4\");\n    n();\n  }\n  if (e === \"vec3\") {\n    if (A === \"mat2x3\") return t(\"vec2\");\n    if (A === \"vec3\" || GA(A)) return t(\"vec3\");\n    if (A === \"mat4x3\") return t(\"vec4\");\n    n();\n  }\n  if (e === \"vec4\") {\n    if (A === \"mat2x4\") return t(\"vec2\");\n    if (A === \"mat3x4\") return t(\"vec3\");\n    if (A === \"vec4\" || UA(A)) return t(\"vec4\");\n    n();\n  }\n  if (A === \"vec2\") {\n    if (vA(e)) return t(\"vec2\");\n    if (e === \"mat2x3\") return t(\"vec3\");\n    if (e === \"mat2x4\") return t(\"vec4\");\n    n();\n  }\n  if (A === \"vec3\") {\n    if (e === \"mat3x2\") return t(\"vec2\");\n    if (GA(e)) return t(\"vec3\");\n    if (e === \"mat3x4\") return t(\"vec4\");\n    n();\n  }\n  if (A === \"vec4\") {\n    if (e === \"mat4x2\") return t(\"vec2\");\n    if (e === \"mat4x3\") return t(\"vec3\");\n    if (UA(e)) return t(\"vec4\");\n    n();\n  }\n  if (vA(e)) {\n    if (vA(A)) return t(\"mat2\");\n    if (A === \"mat3x2\") return t(\"mat3x2\");\n    if (A === \"mat4x2\") return t(\"mat4x2\");\n    n();\n  }\n  if (e === \"mat2x3\") {\n    if (vA(A)) return t(\"mat2x3\");\n    if (A === \"mat3x2\") return t(\"mat3\");\n    if (A === \"mat4x2\") return t(\"mat4x3\");\n    n();\n  }\n  if (e === \"mat2x4\") {\n    if (vA(A)) return t(\"mat2x4\");\n    if (A === \"mat3x2\") return t(\"mat3x4\");\n    if (A === \"mat4x2\") return t(\"mat4\");\n    n();\n  }\n  if (e === \"mat3x2\") {\n    if (A === \"mat2x3\") return t(\"mat2\");\n    if (GA(A)) return t(\"mat3x2\");\n    if (A === \"mat4x3\") return t(\"mat4x2\");\n    n();\n  }\n  if (GA(e)) {\n    if (A === \"mat2x3\") return t(\"mat2x3\");\n    if (GA(A)) return t(\"mat3\");\n    if (A === \"mat4x3\") return t(\"mat4x3\");\n    n();\n  }\n  if (e === \"mat3x4\") {\n    if (A === \"mat2x3\") return t(\"mat2x4\");\n    if (GA(A)) return t(\"mat3x4\");\n    if (A === \"mat4x3\") return t(\"mat4\");\n    n();\n  }\n  if (e === \"mat4x2\") {\n    if (A === \"mat2x4\") return t(\"mat2\");\n    if (A === \"mat3x4\") return t(\"mat3x2\");\n    if (UA(A)) return t(\"mat4x2\");\n    n();\n  }\n  if (e === \"mat4x3\") {\n    if (A === \"mat2x4\") return t(\"mat2x3\");\n    if (A === \"mat3x4\") return t(\"mat3\");\n    if (UA(A)) return t(\"mat4x3\");\n    n();\n  }\n  if (UA(e)) {\n    if (A === \"mat2x4\") return t(\"mat2x4\");\n    if (A === \"mat3x4\") return t(\"mat3x4\");\n    if (UA(A)) return t(\"mat4\");\n    n();\n  }\n  throw new Error(`Invalid mul types: ${e}, ${A}`);\n}\nconst OA = (e, A) => new ss({ a: e, b: A }), es = (e, A) => new is({ a: e, b: A }), ht = (e, A) => new as({ a: e, b: A });\nclass ss extends Cn {\n  constructor({ a: A, b: n }) {\n    super({ a: A, b: n, outKey: \"sum\", outTypeFunc: lt }), this.statements = ({ inputs: t, outputs: s }) => [`${s.sum} = ${t.a} + ${t.b};`];\n  }\n}\nclass is extends Cn {\n  constructor({ a: A, b: n }) {\n    super({ a: A, b: n, outKey: \"difference\", outTypeFunc: ns }), this.statements = ({ inputs: t, outputs: s }) => [`${s.difference} = ${t.a} - ${t.b};`];\n  }\n}\nclass as extends Cn {\n  constructor({ a: A, b: n }) {\n    super({ a: A, b: n, outKey: \"product\", outTypeFunc: ts }), this.statements = ({ inputs: t, outputs: s }) => [`${s.product} = ${t.a} * ${t.b};`];\n  }\n}\nconst rs = (e) => new os({ value: e }), gs = (e) => new Is({ value: e });\nclass os extends Rn {\n  constructor({ value: A }) {\n    super({ a: A, outKey: \"uint\", outTypeFunc: () => \"uint\" }), this.statements = ({ inputs: n, outputs: t }) => [`${t.uint} = packHalf2x16(${n.a});`];\n  }\n}\nclass Is extends Rn {\n  constructor({ value: A }) {\n    super({ a: A, outKey: \"rgba8\", outTypeFunc: () => \"vec4\" }), this.statements = ({ inputs: n, outputs: t }) => [\n      `uvec4 uRgba = uvec4(${n.a} & 0xffu, (${n.a} >> 8u) & 0xffu, (${n.a} >> 16u) & 0xffu, (${n.a} >> 24u) & 0xffu);`,\n      `${t.rgba8} = vec4(uRgba) / 255.0;`\n    ];\n  }\n}\nconst Bs = (e) => new Cs({ a: e }), Qs = ({\n  vector: e,\n  vectorType: A,\n  x: n,\n  y: t,\n  z: s,\n  w: i,\n  r: a,\n  g: r,\n  b: I,\n  a: g\n}) => new hs({ vector: e, vectorType: A, x: n, y: t, z: s, w: i, r: a, g: r, b: I, a: g }), cs = (e, A) => new ls({ a: e, b: A });\nclass Cs extends Rn {\n  constructor({ a: A }) {\n    super({ a: A, outTypeFunc: (n) => n, outKey: \"normalize\" }), this.statements = ({ inputs: n, outputs: t }) => [\n      `${t.normalize} = normalize(${n.a});`\n    ];\n  }\n}\nfunction Es(e) {\n  if (e === \"float\") return \"vec2\";\n  if (e === \"vec2\") return \"vec3\";\n  if (e === \"vec3\") return \"vec4\";\n  throw new Error(\"Invalid type\");\n}\nclass ls extends Cn {\n  constructor({ a: A, b: n }) {\n    const t = xA(A), s = Es(t);\n    super({ a: A, b: n, outKey: \"extend\", outTypeFunc: () => s }), this.statements = ({ inputs: i, outputs: a }) => [\n      `${a.extend} = ${s}(${i.a}, ${i.b});`\n    ];\n  }\n}\nclass hs extends Y {\n  constructor({\n    vector: A,\n    vectorType: n,\n    x: t,\n    y: s,\n    z: i,\n    w: a,\n    r,\n    g: I,\n    b: g,\n    a: Q\n  }) {\n    if (!A && !n)\n      throw new Error(\"Either vector or vectorType must be provided\");\n    const o = n ?? xA(A), c = Be(o), C = Qe(o), E = {\n      vector: o,\n      x: c,\n      y: c,\n      r: c,\n      g: c\n    }, l = { vector: A, x: t, y: s, r, g: I };\n    C >= 3 && (Object.assign(E, { z: c, b: c }), Object.assign(l, { z: i, b: g })), C >= 4 && (Object.assign(E, { w: c, a: c }), Object.assign(l, { w: a, a: Q })), super({ inTypes: E, outTypes: { vector: o }, inputs: l }), this.statements = ({ inputs: u, outputs: d }) => {\n      const { vector: p } = d, {\n        vector: h,\n        x: m,\n        y,\n        z: f,\n        w: D,\n        r: T,\n        g: R,\n        b: U,\n        a: k\n      } = u, v = [\n        `${p}.x = ${m ?? T ?? (h ? `${h}.x` : WA(c))};`,\n        `${p}.y = ${y ?? R ?? (h ? `${h}.y` : WA(c))};`\n      ];\n      return C >= 3 && v.push(\n        `${p}.z = ${f ?? U ?? (h ? `${h}.z` : WA(c))};`\n      ), C >= 4 && v.push(\n        `${p}.w = ${D ?? k ?? (h ? `${h}.w` : WA(c))};`\n      ), v;\n    };\n  }\n  dynoOut() {\n    return new P(\n      this,\n      \"vector\"\n    );\n  }\n}\nconst us = (e, {\n  scale: A,\n  scales: n,\n  rotate: t,\n  translate: s\n}) => new ps({ position: e, scale: A, scales: n, rotate: t, translate: s }).outputs.position, ds = (e, {\n  scale: A,\n  scales: n,\n  rotate: t\n}) => new ys({ dir: e, scale: A, scales: n, rotate: t }).outputs.dir;\nclass ps extends Y {\n  constructor({\n    position: A,\n    scale: n,\n    scales: t,\n    rotate: s,\n    translate: i\n  }) {\n    super({\n      inTypes: {\n        position: \"vec3\",\n        scale: \"float\",\n        scales: \"vec3\",\n        rotate: \"vec4\",\n        translate: \"vec3\"\n      },\n      outTypes: { position: \"vec3\" },\n      inputs: { position: A, scale: n, scales: t, rotate: s, translate: i },\n      statements: ({ inputs: a, outputs: r }) => {\n        const { position: I } = r;\n        if (!I)\n          return [];\n        const { scale: g, scales: Q, rotate: o, translate: c } = a;\n        return [\n          `${I} = ${a.position ?? \"vec3(0.0, 0.0, 0.0)\"};`,\n          g ? `${I} *= ${g};` : null,\n          Q ? `${I} *= ${Q};` : null,\n          o ? `${I} = quatVec(${o}, ${I});` : null,\n          c ? `${I} += ${c};` : null\n        ].filter(Boolean);\n      }\n    });\n  }\n}\nclass ys extends Y {\n  constructor({\n    dir: A,\n    scale: n,\n    scales: t,\n    rotate: s\n  }) {\n    super({\n      inTypes: { dir: \"vec3\", scale: \"float\", scales: \"vec3\", rotate: \"vec4\" },\n      outTypes: { dir: \"vec3\" },\n      inputs: { dir: A, scale: n, scales: t, rotate: s },\n      statements: ({ inputs: i, outputs: a }) => {\n        const { dir: r } = a;\n        if (!r)\n          return [];\n        const { scale: I, scales: g, rotate: Q } = i;\n        return [\n          `${r} = ${i.dir ?? \"vec3(0.0, 0.0, 0.0)\"};`,\n          I ? `${r} *= ${I};` : null,\n          g ? `${r} *= ${g};` : null,\n          Q ? `${r} = quatVec(${Q}, ${r});` : null\n        ].filter(Boolean);\n      }\n    });\n  }\n}\nvar fs = `precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout vec4 target;\n\n{{ GLOBALS }}\n\nvoid computeReadback(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        computeReadback(index);\n    } else {\n        target = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}`;\nconst hA = class EA {\n  constructor({ renderer: A } = {}) {\n    this.renderer = A, this.capacity = 0, this.count = 0;\n  }\n  dispose() {\n    this.target && (this.target.dispose(), this.target = void 0);\n  }\n  // Ensure we have a buffer large enough for the readback of count indices.\n  // Pass in previous bufer of the desired type.\n  ensureBuffer(A, n) {\n    const s = Math.ceil(Math.max(1, A) / S) * S * 4;\n    if (n.byteLength >= s)\n      return n;\n    const i = new ArrayBuffer(s);\n    if (n instanceof ArrayBuffer)\n      return i;\n    const a = n.constructor;\n    return new a(i);\n  }\n  // Ensure our render target is large enough for the readback of capacity indices.\n  ensureCapacity(A) {\n    const { width: n, height: t, depth: s, maxSplats: i } = W(A);\n    (!this.target || i > this.capacity) && (this.dispose(), this.capacity = i, this.target = new B.WebGLArrayRenderTarget(n, t, s, {\n      depthBuffer: !1,\n      stencilBuffer: !1,\n      generateMipmaps: !1,\n      magFilter: B.NearestFilter,\n      minFilter: B.NearestFilter\n    }), this.target.texture.format = B.RGBAFormat, this.target.texture.type = B.UnsignedByteType, this.target.texture.internalFormat = \"RGBA8\");\n  }\n  // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,\n  // generating it if necessary and caching the result.\n  prepareProgramMaterial(A) {\n    let n = EA.readbackProgram.get(A);\n    if (!n) {\n      const s = SA(\n        { index: \"int\" },\n        { rgba8: \"vec4\" },\n        ({ index: i }) => (A.inputs.index = i, { rgba8: new we({ rgba8: A.outputs.rgba8 }) })\n      );\n      EA.programTemplate || (EA.programTemplate = new Et(fs)), n = new Ct({\n        graph: s,\n        inputs: { index: \"index\" },\n        outputs: { rgba8: \"target\" },\n        template: EA.programTemplate\n      }), Object.assign(n.uniforms, {\n        targetLayer: { value: 0 },\n        targetBase: { value: 0 },\n        targetCount: { value: 0 }\n      }), EA.readbackProgram.set(A, n);\n    }\n    const t = n.prepareMaterial();\n    return EA.mesh.material = t, { program: n, material: t };\n  }\n  saveRenderState(A) {\n    return {\n      xrPresenting: A.xr.isPresenting,\n      autoClear: A.autoClear,\n      scissorTest: A.getScissorTest(),\n      pixelRatio: A.getPixelRatio()\n    };\n  }\n  resetRenderState(A, n) {\n    A.setRenderTarget(null), A.setPixelRatio(n.pixelRatio), A.xr.isPresenting = n.xrPresenting, A.autoClear = n.autoClear, A.setScissorTest(n.scissorTest);\n  }\n  process({\n    count: A,\n    material: n\n  }) {\n    const t = this.renderer;\n    if (!t)\n      throw new Error(\"No renderer\");\n    if (!this.target)\n      throw new Error(\"No target\");\n    const s = S * bA;\n    n.uniforms.targetBase.value = 0, n.uniforms.targetCount.value = A;\n    let i = 0;\n    for (; i < A; ) {\n      const a = Math.floor(i / s), r = a * s, I = Math.min(\n        bA,\n        Math.ceil((A - r) / S)\n      );\n      n.uniforms.targetLayer.value = a, t.setPixelRatio(1), t.setRenderTarget(this.target, a), t.xr.isPresenting = !1, t.autoClear = !1, t.setScissorTest(!0), t.setScissor(0, 0, S, I), t.render(EA.scene, EA.camera), i += S * I;\n    }\n    this.count = A;\n  }\n  async read({\n    readback: A\n  }) {\n    const n = this.renderer;\n    if (!n)\n      throw new Error(\"No renderer\");\n    if (!this.target)\n      throw new Error(\"No target\");\n    const t = Math.ceil(this.count / S) * S;\n    if (A.byteLength < t * 4)\n      throw new Error(\n        `Readback buffer too small: ${A.byteLength} < ${t * 4}`\n      );\n    const s = new Uint8Array(\n      A instanceof ArrayBuffer ? A : A.buffer\n    ), i = S * bA;\n    let a = 0;\n    const r = [];\n    for (; a < this.count; ) {\n      const I = Math.floor(a / i), g = I * i, Q = Math.min(\n        bA,\n        Math.ceil((this.count - g) / S)\n      );\n      n.setPixelRatio(1), n.setRenderTarget(this.target, I);\n      const o = S * Q * 4, c = s.subarray(\n        g * 4,\n        g * 4 + o\n      ), C = n == null ? void 0 : n.readRenderTargetPixelsAsync(\n        this.target,\n        0,\n        0,\n        S,\n        Q,\n        c\n      );\n      r.push(C), a += S * Q;\n    }\n    return Promise.all(r).then(() => A);\n  }\n  // Perform render operation to run the Rgba8Readback program\n  // but don't perform the readback yet.\n  render({\n    reader: A,\n    count: n,\n    renderer: t\n  }) {\n    if (this.renderer = t || this.renderer, !this.renderer)\n      throw new Error(\"No renderer\");\n    this.ensureCapacity(n);\n    const { program: s, material: i } = this.prepareProgramMaterial(A);\n    s.update();\n    const a = this.saveRenderState(this.renderer);\n    this.process({ count: n, material: i }), this.resetRenderState(this.renderer, a);\n  }\n  // Perform a readback of the render target, returning a buffer of the\n  // given type.\n  async readback({\n    readback: A\n  }) {\n    if (!this.renderer)\n      throw new Error(\"No renderer\");\n    const n = this.saveRenderState(this.renderer), t = this.read({ readback: A });\n    return this.resetRenderState(this.renderer, n), t;\n  }\n  // Perform a render and readback operation for the given Rgba8Readback,\n  // and readback buffer (call ensureBuffer first).\n  async renderReadback({\n    reader: A,\n    count: n,\n    renderer: t,\n    readback: s\n  }) {\n    if (this.renderer = t || this.renderer, !this.renderer)\n      throw new Error(\"No renderer\");\n    this.ensureCapacity(n);\n    const { program: i, material: a } = this.prepareProgramMaterial(A);\n    i.update();\n    const r = this.saveRenderState(this.renderer);\n    this.process({ count: n, material: a });\n    const I = this.read({ readback: s });\n    return this.resetRenderState(this.renderer, r), I;\n  }\n  getTexture() {\n    var A;\n    return (A = this.target) == null ? void 0 : A.texture;\n  }\n};\nhA.programTemplate = null;\nhA.readbackProgram = /* @__PURE__ */ new Map();\nhA.geometry = new B.PlaneGeometry(2, 2);\nhA.mesh = new B.Mesh(\n  hA.geometry,\n  new B.RawShaderMaterial({ visible: !1 })\n);\nhA.scene = new B.Scene().add(hA.mesh);\nhA.camera = new B.Camera();\nlet ut = hA;\nconst Ln = class z {\n  constructor(A = {}) {\n    this.capacity = 0, this.count = 0, this.array = null, this.readback = null, this.source = null, this.needsUpdate = !0, this.dyno = new oA({\n      key: \"rgbaArray\",\n      type: dt,\n      globals: () => [pt],\n      value: {\n        texture: z.getEmpty(),\n        count: 0\n      },\n      update: (n) => {\n        var t;\n        return n.texture = ((t = this.readback) == null ? void 0 : t.getTexture()) ?? this.source ?? z.getEmpty(), n.count = this.count, n;\n      }\n    }), A.array ? (this.array = A.array, this.capacity = Math.floor(this.array.length / 4), this.capacity = Math.floor(this.capacity / S) * S, this.count = Math.min(\n      this.capacity,\n      A.count ?? Number.POSITIVE_INFINITY\n    )) : (this.capacity = A.capacity ?? 0, this.count = 0);\n  }\n  // Free up resources\n  dispose() {\n    this.readback && (this.readback.dispose(), this.readback = null), this.source && (this.source.dispose(), this.source = null);\n  }\n  // Ensure that our array is large enough to hold capacity RGBA8 values.\n  ensureCapacity(A) {\n    var n;\n    if (!this.array || A > (((n = this.array) == null ? void 0 : n.length) ?? 0) / 4) {\n      this.capacity = W(A).maxSplats;\n      const t = new Uint8Array(this.capacity * 4);\n      this.array && t.set(this.array), this.array = t;\n    }\n    return this.array;\n  }\n  // Get the THREE.DataArrayTexture from either the readback or the source.\n  getTexture() {\n    var A;\n    let n = (A = this.readback) == null ? void 0 : A.getTexture();\n    return (this.source || this.array) && (n = this.maybeUpdateSource()), n ?? z.getEmpty();\n  }\n  // Create or get a THREE.DataArrayTexture from the data array.\n  maybeUpdateSource() {\n    if (!this.array)\n      throw new Error(\"No array\");\n    if (this.needsUpdate || !this.source) {\n      if (this.needsUpdate = !1, this.source) {\n        const { width: A, height: n, depth: t } = this.source.image;\n        this.capacity !== A * n * t && (this.source.dispose(), this.source = null);\n      }\n      if (this.source)\n        this.array.buffer !== this.source.image.data.buffer && (this.source.image.data = new Uint8Array(this.array.buffer));\n      else {\n        const { width: A, height: n, depth: t } = W(this.capacity);\n        this.source = new B.DataArrayTexture(\n          this.array,\n          A,\n          n,\n          t\n        ), this.source.format = B.RGBAFormat, this.source.type = B.UnsignedByteType, this.source.internalFormat = \"RGBA8\", this.source.needsUpdate = !0;\n      }\n      this.source.needsUpdate = !0;\n    }\n    return this.source;\n  }\n  // Generate the RGBA8 values from a Rgba8Readback dyno program.\n  render({\n    reader: A,\n    count: n,\n    renderer: t\n  }) {\n    this.readback || (this.readback = new ut({ renderer: t })), this.readback.render({ reader: A, count: n, renderer: t }), this.capacity = this.readback.capacity, this.count = this.readback.count;\n  }\n  // Extract the RGBA8 values from a PackedSplats collection.\n  fromPackedSplats({\n    packedSplats: A,\n    base: n,\n    count: t,\n    renderer: s\n  }) {\n    const { dynoSplats: i, dynoBase: a, dynoCount: r, reader: I } = z.makeDynos();\n    return i.packedSplats = A, a.value = n, r.value = t, this.render({ reader: I, count: t, renderer: s }), this;\n  }\n  // Read back the RGBA8 values from the readback buffer.\n  async read() {\n    if (!this.readback)\n      throw new Error(\"No readback\");\n    return (!this.array || this.array.length < this.count * 4) && (this.array = new Uint8Array(this.capacity * 4)), (await this.readback.readback({ readback: this.array })).subarray(0, this.count * 4);\n  }\n  // Can be used where you need an uninitialized THREE.DataArrayTexture like\n  // a uniform you will update with the result of this.getTexture() later.\n  static getEmpty() {\n    if (!z.emptySource) {\n      const A = new Uint8Array(4);\n      z.emptySource = new B.DataArrayTexture(A, 1, 1, 1), z.emptySource.format = B.RGBAFormat, z.emptySource.type = B.UnsignedByteType, z.emptySource.internalFormat = \"RGBA8\", z.emptySource.needsUpdate = !0;\n    }\n    return z.emptySource;\n  }\n  // Create a dyno program that can extract RGBA8 values from a PackedSplats\n  static makeDynos() {\n    if (!z.dynos) {\n      const A = new _n(), n = new xn({ value: 0 }), t = new xn({ value: 0 }), s = SA(\n        { index: \"int\" },\n        { rgba8: \"vec4\" },\n        ({ index: i }) => {\n          if (!i)\n            throw new Error(\"index is undefined\");\n          i = OA(i, n);\n          const a = le(\n            A,\n            i,\n            n,\n            t\n          );\n          return { rgba8: an(a).outputs.rgba };\n        }\n      );\n      z.dynos = { dynoSplats: A, dynoBase: n, dynoCount: t, reader: s };\n    }\n    return z.dynos;\n  }\n};\nLn.emptySource = null;\nLn.dynos = null;\nlet ms = Ln;\nconst dt = { type: \"RgbaArray\" }, pt = O(`\n  struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  };\n`);\nfunction ws(e, A) {\n  return new Y({\n    inTypes: { rgba: dt, index: \"int\" },\n    outTypes: { rgba: \"vec4\" },\n    inputs: { rgba: e, index: A },\n    globals: () => [pt],\n    statements: ({ inputs: t, outputs: s }) => BA(`\n        if ((index >= 0) && (index < ${t.rgba}.count)) {\n          ${s.rgba} = texelFetch(${t.rgba}.texture, splatTexCoord(index), 0);\n        } else {\n          ${s.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `)\n  }).outputs.rgba;\n}\nfunction Ds(e) {\n  switch (e) {\n    case \"all\":\n      return 0;\n    case \"plane\":\n      return 1;\n    case \"sphere\":\n      return 2;\n    case \"box\":\n      return 3;\n    case \"ellipsoid\":\n      return 4;\n    case \"cylinder\":\n      return 5;\n    case \"capsule\":\n      return 6;\n    case \"infinite_cone\":\n      return 7;\n    default:\n      throw new Error(`Unknown SDF type: ${e}`);\n  }\n}\nfunction xs(e) {\n  switch (e) {\n    case \"multiply\":\n      return 0;\n    case \"set_rgb\":\n      return 1;\n    case \"add_rgba\":\n      return 2;\n    default:\n      throw new Error(`Unknown blend mode: ${e}`);\n  }\n}\nclass Ss extends B.Object3D {\n  constructor(A = {}) {\n    super();\n    const { type: n, invert: t, opacity: s, color: i, displace: a, radius: r } = A;\n    this.type = n ?? \"sphere\", this.invert = t ?? !1, this.opacity = s ?? 1, this.color = i ?? new B.Color(1, 1, 1), this.displace = a ?? new B.Vector3(0, 0, 0), this.radius = r ?? 0;\n  }\n}\nconst yt = class ft extends B.Object3D {\n  constructor(A = {}) {\n    const {\n      name: n,\n      rgbaBlendMode: t = \"multiply\",\n      sdfSmooth: s = 0,\n      softEdge: i = 0,\n      invert: a = !1,\n      sdfs: r = null\n    } = A;\n    super(), this.rgbaBlendMode = t, this.sdfSmooth = s, this.softEdge = i, this.invert = a, this.sdfs = r, this.ordering = ft.nextOrdering++, this.name = n ?? `Edit ${this.ordering}`;\n  }\n  addSdf(A) {\n    this.sdfs == null && (this.sdfs = []), this.sdfs.push(A);\n  }\n  removeSdf(A) {\n    this.sdfs != null && (this.sdfs = this.sdfs.filter((n) => n !== A));\n  }\n};\nyt.nextOrdering = 1;\nlet mt = yt;\nclass ks {\n  constructor({ maxSdfs: A, maxEdits: n }) {\n    this.maxSdfs = Math.max(16, A ?? 0), this.numSdfs = 0, this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4), this.sdfFloatData = new Float32Array(this.sdfData.buffer), this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs), this.dynoSdfArray = new oA({\n      key: \"sdfArray\",\n      type: wt,\n      globals: () => [Dt],\n      value: {\n        numSdfs: 0,\n        sdfTexture: this.sdfTexture\n      },\n      update: (t) => (t.numSdfs = this.numSdfs, t.sdfTexture = this.sdfTexture, t)\n    }), this.maxEdits = Math.max(16, n ?? 0), this.numEdits = 0, this.editData = new Uint32Array(this.maxEdits * 4), this.editFloatData = new Float32Array(this.editData.buffer), this.dynoNumEdits = new xn({ value: 0 }), this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n  }\n  newSdfTexture(A, n) {\n    const t = new B.DataTexture(\n      A,\n      8,\n      n,\n      B.RGBAIntegerFormat,\n      B.UnsignedIntType\n    );\n    return t.internalFormat = \"RGBA32UI\", t.needsUpdate = !0, t;\n  }\n  newEdits(A, n) {\n    return new oA({\n      key: \"edits\",\n      type: \"uvec4\",\n      count: n,\n      globals: () => [xt],\n      value: A\n    });\n  }\n  // Ensure our SDF texture and edits uniform array have enough capacity.\n  // Reallocate if not.\n  ensureCapacity({\n    maxSdfs: A,\n    maxEdits: n\n  }) {\n    let t = !1;\n    return A > this.sdfTexture.image.height && (this.sdfTexture.dispose(), this.maxSdfs = Math.max(this.maxSdfs * 2, A), this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4), this.sdfFloatData = new Float32Array(this.sdfData.buffer), this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs)), n > (this.dynoEdits.count ?? 0) && (this.maxEdits = Math.max(this.maxEdits * 2, n), this.editData = new Uint32Array(this.maxEdits * 4), this.editFloatData = new Float32Array(this.editData.buffer), this.dynoEdits = this.newEdits(this.editData, this.maxEdits), t = !0), t;\n  }\n  updateEditData(A, n) {\n    const t = this.editData[A] !== n;\n    return this.editData[A] = n, t;\n  }\n  updateEditFloatData(A, n) {\n    LA[0] = n;\n    const t = this.editFloatData[A] !== LA[0];\n    return t && (this.editFloatData[A] = LA[0]), t;\n  }\n  encodeEdit(A, {\n    sdfFirst: n,\n    sdfCount: t,\n    invert: s,\n    rgbaBlendMode: i,\n    softEdge: a,\n    sdfSmooth: r\n  }) {\n    const I = A * 4;\n    let g = !1;\n    return g = this.updateEditData(I + 0, i | (s ? 256 : 0)) || g, g = this.updateEditData(I + 1, n | t << 16) || g, g = this.updateEditFloatData(I + 2, a) || g, g = this.updateEditFloatData(I + 3, r) || g, g;\n  }\n  updateSdfData(A, n) {\n    const t = this.sdfData[A] !== n;\n    return this.sdfData[A] = n, t;\n  }\n  updateSdfFloatData(A, n) {\n    LA[0] = n;\n    const t = this.sdfFloatData[A] !== LA[0];\n    return t && (this.sdfFloatData[A] = LA[0]), t;\n  }\n  encodeSdf(A, {\n    sdfType: n,\n    invert: t,\n    center: s,\n    quaternion: i,\n    scale: a,\n    sizes: r\n  }, I) {\n    const g = A * 32, Q = n | (t ? 256 : 0);\n    let o = !1;\n    o = this.updateSdfFloatData(g + 0, (s == null ? void 0 : s.x) ?? 0) || o, o = this.updateSdfFloatData(g + 1, (s == null ? void 0 : s.y) ?? 0) || o, o = this.updateSdfFloatData(g + 2, (s == null ? void 0 : s.z) ?? 0) || o, o = this.updateSdfData(g + 3, Q) || o, o = this.updateSdfFloatData(g + 4, (i == null ? void 0 : i.x) ?? 0) || o, o = this.updateSdfFloatData(g + 5, (i == null ? void 0 : i.y) ?? 0) || o, o = this.updateSdfFloatData(g + 6, (i == null ? void 0 : i.z) ?? 0) || o, o = this.updateSdfFloatData(g + 7, (i == null ? void 0 : i.w) ?? 0) || o, o = this.updateSdfFloatData(g + 8, (a == null ? void 0 : a.x) ?? 0) || o, o = this.updateSdfFloatData(g + 9, (a == null ? void 0 : a.y) ?? 0) || o, o = this.updateSdfFloatData(g + 10, (a == null ? void 0 : a.z) ?? 0) || o, o = this.updateSdfData(g + 11, 0) || o, o = this.updateSdfFloatData(g + 12, (r == null ? void 0 : r.x) ?? 0) || o, o = this.updateSdfFloatData(g + 13, (r == null ? void 0 : r.y) ?? 0) || o, o = this.updateSdfFloatData(g + 14, (r == null ? void 0 : r.z) ?? 0) || o, o = this.updateSdfFloatData(g + 15, (r == null ? void 0 : r.w) ?? 0) || o;\n    const c = Math.min(4, I.length);\n    for (let C = 0; C < c; ++C) {\n      const E = g + 16 + C * 4;\n      o = this.updateSdfFloatData(E + 0, I[C].x) || o, o = this.updateSdfFloatData(E + 1, I[C].y) || o, o = this.updateSdfFloatData(E + 2, I[C].z) || o, o = this.updateSdfFloatData(E + 3, I[C].w) || o;\n    }\n    return o;\n  }\n  // Update the SDFs and edits from an array of SplatEdits and their\n  // associated SplatEditSdfs, updating it for the dyno shader program.\n  update(A) {\n    const n = A.reduce((o, { sdfs: c }) => o + c.length, 0), t = this.ensureCapacity({\n      maxEdits: A.length,\n      maxSdfs: n\n    }), s = [new B.Vector4(), new B.Vector4()], i = new B.Vector3(), a = new B.Quaternion(), r = new B.Vector3(), I = new B.Vector4();\n    let g = 0, Q = t;\n    A.length !== this.dynoNumEdits.value && (this.dynoNumEdits.value = A.length, this.numEdits = A.length, Q = !0);\n    for (const [o, { edit: c, sdfs: C }] of A.entries()) {\n      Q = this.encodeEdit(o, {\n        sdfFirst: g,\n        sdfCount: C.length,\n        invert: c.invert,\n        rgbaBlendMode: xs(c.rgbaBlendMode),\n        softEdge: c.softEdge,\n        sdfSmooth: c.sdfSmooth\n      }) || Q;\n      let E = !1;\n      for (const l of C)\n        I.set(l.scale.x, l.scale.y, l.scale.z, l.radius), l.scale.setScalar(1), l.updateMatrixWorld(), l.matrixWorld.clone().invert().decompose(i, a, r), l.scale.set(I.x, I.y, I.z), l.updateMatrixWorld(), s[0].set(l.color.r, l.color.g, l.color.b, l.opacity), s[1].set(l.displace.x, l.displace.y, l.displace.z, 1), E = this.encodeSdf(\n          g,\n          {\n            sdfType: Ds(l.type),\n            invert: l.invert,\n            center: i,\n            quaternion: a,\n            scale: r,\n            sizes: I\n          },\n          s\n        ) || E, g += 1;\n      this.numSdfs = g, E && (this.sdfTexture.needsUpdate = !0), Q || (Q = E);\n    }\n    return { updated: Q, dynoUpdated: t };\n  }\n  // Modify a Gsplat in a dyno shader program using the current edits and SDFs.\n  modify(A) {\n    return bs(\n      A,\n      this.dynoSdfArray,\n      this.dynoNumEdits,\n      this.dynoEdits\n    );\n  }\n}\nconst wt = { type: \"SdfArray\" }, Dt = O(`\n  struct SdfArray {\n    int numSdfs;\n    usampler2D sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n    }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    }\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n    vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n    for (int index = sdfFirst; index < sdfLast; ++index) {\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n          distance = sdfPos.z;\n          break;\n        }\n        case SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n          float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n        case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n          float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        }\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance = -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < distanceAccum) {\n          distanceAccum = distance;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          }\n        }\n      } else {\n        float scaledDistance = -distance / smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n          }\n          maxExp = scaledDistance;\n        }\n\n        float weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n        for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      return distanceAccum;\n    } else {\n      // Very distant SDFs may result in 0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / 0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n      distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  }\n`), xt = O(`\n  const uint EDIT_FLAG_BLEND = 0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = uintBitsToFloat(packedEdit.z);\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\n    // On Android, moving values[0] is necessary to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) {\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n        target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    }\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\n  }\n`);\nfunction bs(e, A, n, t) {\n  return new Y({\n    inTypes: {\n      gsplat: N,\n      sdfArray: wt,\n      numEdits: \"int\",\n      rgbaDisplaceEdits: \"uvec4\"\n    },\n    outTypes: { gsplat: N },\n    globals: () => [Dt, xt],\n    inputs: { gsplat: e, sdfArray: A, numEdits: n, rgbaDisplaceEdits: t },\n    statements: ({ inputs: i, outputs: a }) => {\n      const { sdfArray: r, numEdits: I, rgbaDisplaceEdits: g } = i, { gsplat: Q } = a;\n      return BA(`\n        ${Q} = ${i.gsplat};\n        if (isGsplatActive(${Q}.flags)) {\n          for (int editIndex = 0; editIndex < ${I}; ++editIndex) {\n            applyPackedRgbaDisplaceEdit(\n              ${g}[editIndex], ${r}.sdfTexture, ${r}.numSdfs,\n              ${Q}.center, ${Q}.rgba\n            );\n          }\n        }\n      `);\n    }\n  }).outputs.gsplat;\n}\nconst LA = new Float32Array(1);\nclass Ms {\n  constructor(A) {\n    this.modifier = A, this.cache = /* @__PURE__ */ new Map();\n  }\n  apply(A) {\n    let n = this.cache.get(A);\n    return n || (n = SA(\n      { index: \"int\" },\n      { gsplat: N },\n      ({ index: t }) => {\n        const { gsplat: s } = A.apply({ index: t });\n        return this.modifier.apply({ gsplat: s });\n      }\n    ), this.cache.set(A, n)), n;\n  }\n}\nclass An {\n  // Create the dyno uniforms that parameterize the transform, setting them\n  // to initial values that are different from any valid transform.\n  constructor() {\n    this.scale = new jA({ value: Number.NEGATIVE_INFINITY }), this.rotate = new Gn({\n      value: new B.Quaternion(\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY\n      )\n    }), this.translate = new In({\n      value: new B.Vector3(\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY\n      )\n    });\n  }\n  // Apply the transform to a Vec3 position in a dyno program.\n  apply(A) {\n    return us(A, {\n      scale: this.scale,\n      rotate: this.rotate,\n      translate: this.translate\n    });\n  }\n  applyDir(A) {\n    return ds(A, {\n      rotate: this.rotate\n    });\n  }\n  // Apply the transform to a Gsplat in a dyno program.\n  applyGsplat(A) {\n    return et(A, {\n      scale: this.scale,\n      rotate: this.rotate,\n      translate: this.translate\n    });\n  }\n  // Update the uniforms to match the given transform matrix.\n  updateFromMatrix(A) {\n    const n = new B.Vector3(), t = new B.Quaternion(), s = new B.Vector3();\n    A.decompose(s, t, n);\n    const i = (n.x + n.y + n.z) / 3;\n    let a = !1;\n    return i !== this.scale.value && (this.scale.value = i, a = !0), s.equals(this.translate.value) || (this.translate.value.copy(s), a = !0), t.equals(this.rotate.value) || (this.rotate.value.copy(t), a = !0), a;\n  }\n  // Update this transform to match the object's to-world transform.\n  update(A) {\n    return A.updateMatrixWorld(), this.updateFromMatrix(A.matrixWorld);\n  }\n}\nclass St extends B.Object3D {\n  constructor({\n    numSplats: A,\n    generator: n,\n    construct: t,\n    update: s\n  }) {\n    if (super(), this.numSplats = A ?? 0, this.generator = n, this.frameUpdate = s, this.version = 0, t) {\n      const i = t(this);\n      Object.assign(this, i);\n    }\n  }\n  updateVersion() {\n    this.version += 1;\n  }\n  set needsUpdate(A) {\n    A && this.updateVersion();\n  }\n}\nconst ZA = class kn extends St {\n  constructor(A = {}) {\n    const n = new An(), t = new An(), s = new An(), i = new An(), a = new Gn({\n      value: new B.Vector4(\n        Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY\n      )\n    }), r = new jA({ value: 0 }), I = new jA({ value: 0 }), g = {\n      transform: n,\n      viewToWorld: t,\n      worldToView: s,\n      viewToObject: i,\n      recolor: a,\n      time: r,\n      deltaTime: I\n    };\n    if (super({\n      update: ({ time: Q, deltaTime: o, viewToWorld: c, globalEdits: C }) => this.update({ time: Q, deltaTime: o, viewToWorld: c, globalEdits: C })\n    }), this.isInitialized = !1, this.recolor = new B.Color(1, 1, 1), this.opacity = 1, this.enableViewToObject = !1, this.enableViewToWorld = !1, this.enableWorldToView = !1, this.skinning = null, this.edits = null, this.rgbaDisplaceEdits = null, this.splatRgba = null, this.maxSh = 3, this.packedSplats = A.packedSplats ?? new TA(), this.numSplats = this.packedSplats.numSplats, this.editable = A.editable ?? !0, this.onFrame = A.onFrame, this.context = g, this.objectModifier = A.objectModifier, this.worldModifier = A.worldModifier, this.updateGenerator(), A.url || A.fileBytes || A.constructSplats || A.packedSplats && !A.packedSplats.isInitialized)\n      this.initialized = this.asyncInitialize(A).then(async () => {\n        if (this.updateGenerator(), this.isInitialized = !0, A.onLoad) {\n          const Q = A.onLoad(this);\n          Q instanceof Promise && await Q;\n        }\n        return this;\n      });\n    else if (this.isInitialized = !0, this.initialized = Promise.resolve(this), A.onLoad) {\n      const Q = A.onLoad(this);\n      Q instanceof Promise && (this.initialized = Q.then(() => this));\n    }\n  }\n  async asyncInitialize(A) {\n    const { url: n, fileBytes: t, fileType: s, fileName: i, maxSplats: a, constructSplats: r } = A;\n    if (n || t || r) {\n      const I = {\n        url: n,\n        fileBytes: t,\n        fileType: s,\n        fileName: i,\n        maxSplats: a,\n        construct: r\n      };\n      this.packedSplats.reinitialize(I);\n    }\n    this.packedSplats && (await this.packedSplats.initialized, this.numSplats = this.packedSplats.numSplats, this.updateGenerator());\n  }\n  static async staticInitialize() {\n    await nt(), kn.isStaticInitialized = !0;\n  }\n  // Creates a new Gsplat with the provided parameters (all values in \"float\" space,\n  // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,\n  // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential\n  // doubling strategy to fit the new data, so it's fairly efficient to just\n  // pushSplat(...) each Gsplat you want to create in a loop.\n  pushSplat(A, n, t, s, i) {\n    this.packedSplats.pushSplat(A, n, t, s, i);\n  }\n  // This method iterates over all Gsplats in this instance's packedSplats,\n  // invoking the provided callback with index: number in 0..=(this.numSplats-1) and\n  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n  // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).\n  // Note that the objects passed in as center etc. are the same for every callback\n  // invocation: these objects are reused for efficiency. Changing these values has\n  // no effect as they are decoded/unpacked copies of the underlying data. To update\n  // the packedSplats, call .packedSplats.setSplat(index, center, scales,\n  // quaternion, opacity, color).\n  forEachSplat(A) {\n    this.packedSplats.forEachSplat(A);\n  }\n  // Call this when you are finished with the SplatMesh and want to free\n  // any buffers it holds (via packedSplats).\n  dispose() {\n    this.packedSplats.dispose();\n  }\n  constructGenerator(A) {\n    const { transform: n, viewToObject: t, recolor: s } = A, i = SA(\n      { index: \"int\" },\n      { gsplat: N },\n      ({ index: a }) => {\n        if (!a)\n          throw new Error(\"index is undefined\");\n        let r = on(this.packedSplats.dyno, a);\n        if (this.maxSh >= 1) {\n          const { sh1Texture: g, sh2Texture: Q, sh3Texture: o } = this.ensureShTextures();\n          if (g) {\n            const c = t.translate, { center: C } = an(r).outputs, E = Bs(es(C, c));\n            let l = vs(r, g, E);\n            this.maxSh >= 2 && Q && (l = OA(l, Gs(r, Q, E))), this.maxSh >= 3 && o && (l = OA(l, Us(r, o, E)));\n            let { rgba: u } = an(r).outputs;\n            u = OA(u, cs(l, Dn(\"float\", 0))), r = ln({ gsplat: r, rgba: u });\n          }\n        }\n        if (this.splatRgba) {\n          const g = ws(this.splatRgba.dyno, a);\n          r = ln({ gsplat: r, rgba: g });\n        }\n        this.skinning && (r = this.skinning.modify(r)), this.objectModifier && (r = this.objectModifier.apply({ gsplat: r }).gsplat), r = n.applyGsplat(r);\n        const I = ht(s, an(r).outputs.rgba);\n        return r = ln({ gsplat: r, rgba: I }), this.rgbaDisplaceEdits && (r = this.rgbaDisplaceEdits.modify(r)), this.worldModifier && (r = this.worldModifier.apply({ gsplat: r }).gsplat), { gsplat: r };\n      }\n    );\n    this.generator = i;\n  }\n  // Call this whenever something changes in the Gsplat processing pipeline,\n  // for example changing maxSh or updating objectModifier or worldModifier.\n  // Compiled generators are cached for efficiency and re-use when the same\n  // pipeline structure emerges after successive changes.\n  updateGenerator() {\n    this.constructGenerator(this.context);\n  }\n  // This is called automatically by SparkRenderer and you should not have to\n  // call it. It updates parameters for the generated pipeline and calls\n  // updateGenerator() if the pipeline needs to change.\n  update({\n    time: A,\n    viewToWorld: n,\n    deltaTime: t,\n    globalEdits: s\n  }) {\n    var i;\n    this.numSplats = this.packedSplats.numSplats, this.context.time.value = A, this.context.deltaTime.value = t, kn.dynoTime.value = A;\n    const { transform: a, viewToObject: r, recolor: I } = this.context;\n    let g = a.update(this);\n    this.context.viewToWorld.updateFromMatrix(n) && this.enableViewToWorld && (g = !0);\n    const Q = n.clone().invert();\n    this.context.worldToView.updateFromMatrix(Q) && this.enableWorldToView && (g = !0);\n    const C = new B.Matrix4().compose(\n      a.translate.value,\n      a.rotate.value,\n      new B.Vector3().setScalar(a.scale.value)\n    ).invert().multiply(n);\n    r.updateFromMatrix(C) && (this.enableViewToObject || this.packedSplats.extra.sh1) && (g = !0);\n    const E = new B.Vector4(\n      this.recolor.r,\n      this.recolor.g,\n      this.recolor.b,\n      this.opacity\n    );\n    E.equals(I.value) || (I.value.copy(E), g = !0);\n    const l = this.editable ? (this.edits ?? []).concat(s) : [];\n    this.editable && !this.edits && this.traverseVisible((d) => {\n      d instanceof mt && l.push(d);\n    }), l.sort((d, p) => d.ordering - p.ordering);\n    const u = l.map((d) => {\n      if (d.sdfs != null)\n        return { edit: d, sdfs: d.sdfs };\n      const p = [];\n      return d.traverseVisible((h) => {\n        h instanceof Ss && p.push(h);\n      }), { edit: d, sdfs: p };\n    });\n    if (u.length > 0 && !this.rgbaDisplaceEdits) {\n      const d = u.length, p = u.reduce(\n        (h, m) => h + m.sdfs.length,\n        0\n      );\n      this.rgbaDisplaceEdits = new ks({\n        maxEdits: d,\n        maxSdfs: p\n      }), this.updateGenerator();\n    }\n    if (this.rgbaDisplaceEdits) {\n      const d = this.rgbaDisplaceEdits.update(u);\n      g || (g = d.updated), d.dynoUpdated && this.updateGenerator();\n    }\n    g && this.updateVersion(), (i = this.onFrame) == null || i.call(this, { mesh: this, time: A, deltaTime: t });\n  }\n  // This method conforms to the standard THREE.Raycaster API, performing object-ray\n  // intersections using this method to populate the provided intersects[] array\n  // with each intersection point.\n  raycast(A, n) {\n    if (!this.packedSplats.packedArray || !this.packedSplats.numSplats)\n      return;\n    const { near: t, far: s, ray: i } = A, a = this.matrixWorld.clone().invert(), r = new B.Matrix3().setFromMatrix4(a), I = i.origin.clone().applyMatrix4(a), g = i.direction.clone().applyMatrix3(r), Q = new B.Vector3();\n    a.decompose(new B.Vector3(), new B.Quaternion(), Q), (Q.x * Q.y * Q.z) ** (1 / 3);\n    const c = Ae(\n      I.x,\n      I.y,\n      I.z,\n      g.x,\n      g.y,\n      g.z,\n      t,\n      s,\n      this.packedSplats.numSplats,\n      this.packedSplats.packedArray,\n      !0\n    );\n    for (const C of c) {\n      const E = i.direction.clone().multiplyScalar(C).add(i.origin);\n      n.push({\n        distance: C,\n        point: E,\n        object: this\n      });\n    }\n  }\n  ensureShTextures() {\n    if (!this.packedSplats.extra.sh1)\n      return {};\n    let A = this.packedSplats.extra.sh1Texture;\n    if (!A) {\n      let s = this.packedSplats.extra.sh1;\n      const { width: i, height: a, depth: r, maxSplats: I } = W(\n        s.length / 2\n      );\n      if (s.length < I * 2) {\n        const Q = new Uint32Array(I * 2);\n        Q.set(s), this.packedSplats.extra.sh1 = Q, s = Q;\n      }\n      const g = new B.DataArrayTexture(s, i, a, r);\n      g.format = B.RGIntegerFormat, g.type = B.UnsignedIntType, g.internalFormat = \"RG32UI\", g.needsUpdate = !0, A = new hn({\n        value: g,\n        key: \"sh1\"\n      }), this.packedSplats.extra.sh1Texture = A;\n    }\n    if (!this.packedSplats.extra.sh2)\n      return { sh1Texture: A };\n    let n = this.packedSplats.extra.sh2Texture;\n    if (!n) {\n      let s = this.packedSplats.extra.sh2;\n      const { width: i, height: a, depth: r, maxSplats: I } = W(\n        s.length / 4\n      );\n      if (s.length < I * 4) {\n        const Q = new Uint32Array(I * 4);\n        Q.set(s), this.packedSplats.extra.sh2 = Q, s = Q;\n      }\n      const g = new B.DataArrayTexture(s, i, a, r);\n      g.format = B.RGBAIntegerFormat, g.type = B.UnsignedIntType, g.internalFormat = \"RGBA32UI\", g.needsUpdate = !0, n = new hn({\n        value: g,\n        key: \"sh2\"\n      }), this.packedSplats.extra.sh2Texture = n;\n    }\n    if (!this.packedSplats.extra.sh3)\n      return { sh1Texture: A, sh2Texture: n };\n    let t = this.packedSplats.extra.sh3Texture;\n    if (!t) {\n      let s = this.packedSplats.extra.sh3;\n      const { width: i, height: a, depth: r, maxSplats: I } = W(\n        s.length / 4\n      );\n      if (s.length < I * 4) {\n        const Q = new Uint32Array(I * 4);\n        Q.set(s), this.packedSplats.extra.sh3 = Q, s = Q;\n      }\n      const g = new B.DataArrayTexture(s, i, a, r);\n      g.format = B.RGBAIntegerFormat, g.type = B.UnsignedIntType, g.internalFormat = \"RGBA32UI\", g.needsUpdate = !0, t = new hn({\n        value: g,\n        key: \"sh3\"\n      }), this.packedSplats.extra.sh3Texture = t;\n    }\n    return { sh1Texture: A, sh2Texture: n, sh3Texture: t };\n  }\n};\nZA.staticInitialized = ZA.staticInitialize();\nZA.isStaticInitialized = !1;\nZA.dynoTime = new jA({ value: 0 });\nlet Bn = ZA;\nconst Fs = O(`\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n      int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> 25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * (-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + sh1_2 * (-0.4886025 * viewDir.x);\n  }\n`), Ns = O(`\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> 24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n      int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n      int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> 24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> 24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (1.0925484 * viewDir.y * viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (1.0925484 * viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\n  }\n`), Rs = O(`\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // Extract sint6 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> 26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> 26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n    vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / 31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) >> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << 18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> 26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> 26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    )) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n      int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / 31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n`);\nfunction vs(e, A, n) {\n  return cn({\n    inTypes: { gsplat: N, sh1: \"usampler2DArray\", viewDir: \"vec3\" },\n    outTypes: { rgb: \"vec3\" },\n    inputs: { gsplat: e, sh1: A, viewDir: n },\n    globals: () => [QA, Fs],\n    statements: ({ inputs: t, outputs: s }) => BA(`\n        if (isGsplatActive(${t.gsplat}.flags)) {\n          ${s.rgb} = evaluateSH1(${t.gsplat}, ${t.sh1}, ${t.viewDir});\n        } else {\n          ${s.rgb} = vec3(0.0);\n        }\n      `)\n  }).outputs.rgb;\n}\nfunction Gs(e, A, n) {\n  return cn({\n    inTypes: { gsplat: N, sh2: \"usampler2DArray\", viewDir: \"vec3\" },\n    outTypes: { rgb: \"vec3\" },\n    inputs: { gsplat: e, sh2: A, viewDir: n },\n    globals: () => [QA, Ns],\n    statements: ({ inputs: t, outputs: s }) => BA(`\n        if (isGsplatActive(${t.gsplat}.flags)) {\n          ${s.rgb} = evaluateSH2(${t.gsplat}, ${t.sh2}, ${t.viewDir});\n        } else {\n          ${s.rgb} = vec3(0.0);\n        }\n      `)\n  }).outputs.rgb;\n}\nfunction Us(e, A, n) {\n  return cn({\n    inTypes: { gsplat: N, sh3: \"usampler2DArray\", viewDir: \"vec3\" },\n    outTypes: { rgb: \"vec3\" },\n    inputs: { gsplat: e, sh3: A, viewDir: n },\n    globals: () => [QA, Rs],\n    statements: ({ inputs: t, outputs: s }) => BA(`\n        if (isGsplatActive(${t.gsplat}.flags)) {\n          ${s.rgb} = evaluateSH3(${t.gsplat}, ${t.sh3}, ${t.viewDir});\n        } else {\n          ${s.rgb} = vec3(0.0);\n        }\n      `)\n  }).outputs.rgb;\n}\nconst kt = class gn {\n  // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet\n  constructor({ fileBytes: A }) {\n    this.header = \"\", this.littleEndian = !0, this.elements = {}, this.comments = [], this.data = null, this.numSplats = 0, this.fileBytes = A instanceof ArrayBuffer ? new Uint8Array(A) : A;\n  }\n  // Identify and parse the PLY text header (assumed to be <64KB in size).\n  // this.elements will contain all the elements in the file, typically\n  // \"vertex\" contains the Gsplat data.\n  async parseHeader() {\n    const n = new ReadableStream({\n      start: (a) => {\n        a.enqueue(this.fileBytes.slice(0, 65536)), a.close();\n      }\n    }).pipeThrough(new TextDecoderStream()).getReader();\n    this.header = \"\";\n    const t = `end_header\n`;\n    for (; ; ) {\n      const { value: a, done: r } = await n.read();\n      if (r)\n        throw new Error(\"Failed to read header\");\n      this.header += a;\n      const I = this.header.indexOf(t);\n      if (I >= 0) {\n        this.header = this.header.slice(0, I + t.length);\n        break;\n      }\n    }\n    const s = new TextEncoder().encode(this.header).length;\n    this.data = new DataView(this.fileBytes.buffer, s), this.elements = {};\n    let i = null;\n    this.comments = [], this.header.trim().split(`\n`).forEach((a, r) => {\n      const I = a.trim();\n      if (r === 0) {\n        if (I !== \"ply\")\n          throw new Error(\"Invalid PLY header\");\n        return;\n      }\n      if (I.length === 0)\n        return;\n      const g = I.split(\" \");\n      switch (g[0]) {\n        case \"format\":\n          if (g[1] === \"binary_little_endian\")\n            this.littleEndian = !0;\n          else if (g[1] === \"binary_big_endian\")\n            this.littleEndian = !1;\n          else\n            throw new Error(`Unsupported PLY format: ${g[1]}`);\n          if (g[2] !== \"1.0\")\n            throw new Error(`Unsupported PLY version: ${g[2]}`);\n          break;\n        case \"end_header\":\n          break;\n        case \"comment\":\n          this.comments.push(I.slice(8));\n          break;\n        case \"element\": {\n          const Q = g[1];\n          i = {\n            name: Q,\n            count: Number.parseInt(g[2]),\n            properties: {}\n          }, this.elements[Q] = i;\n          break;\n        }\n        case \"property\":\n          if (i == null)\n            throw new Error(\"Property must be inside an element\");\n          g[1] === \"list\" ? i.properties[g[4]] = {\n            isList: !0,\n            type: g[3],\n            countType: g[2]\n          } : i.properties[g[2]] = {\n            isList: !1,\n            type: g[1]\n          };\n          break;\n      }\n    }), this.elements.vertex && (this.numSplats = this.elements.vertex.count);\n  }\n  parseData(A) {\n    let n = 0;\n    const t = this.data;\n    if (t == null)\n      throw new Error(\"No data to parse\");\n    for (const s in this.elements) {\n      const i = this.elements[s], { count: a, properties: r } = i, I = {}, g = [];\n      for (const [o, c] of Object.entries(r))\n        c.isList ? (I[o] = [], g.push(() => {\n          const C = I[o];\n          C.length = tn[c.countType](\n            t,\n            n,\n            this.littleEndian\n          ), n += _A[c.countType];\n          for (let E = 0; E < C.length; E++)\n            C[E] = tn[c.type](\n              t,\n              n,\n              this.littleEndian\n            ), n += _A[c.type];\n        })) : (I[o] = 0, g.push(() => {\n          I[o] = tn[c.type](\n            t,\n            n,\n            this.littleEndian\n          ), n += _A[c.type];\n        }));\n      const Q = A(i) ?? (() => {\n      });\n      for (let o = 0; o < a; o++) {\n        for (const c of g)\n          c();\n        Q(o, I);\n      }\n    }\n  }\n  // Parse all the Gsplat data in the PLY file in go, invoking the given\n  // callbacks for each Gsplat.\n  parseSplats(A, n) {\n    if (this.elements.vertex == null)\n      throw new Error(\"No vertex element found\");\n    let t = !1;\n    const s = [];\n    let i = 0, a = [], r = [], I = [], g, Q, o;\n    function c() {\n      const d = Ys[i];\n      a = new Array(3).fill(null).flatMap(\n        (p, h) => [0, 1, 2].map((m, y) => `f_rest_${h + y * d / 3}`)\n      ), r = new Array(5).fill(null).flatMap(\n        (p, h) => [0, 1, 2].map((m, y) => `f_rest_${3 + h + y * d / 3}`)\n      ), I = new Array(7).fill(null).flatMap(\n        (p, h) => [0, 1, 2].map((m, y) => `f_rest_${8 + h + y * d / 3}`)\n      ), g = i >= 1 ? new Float32Array(3 * 3) : void 0, Q = i >= 2 ? new Float32Array(5 * 3) : void 0, o = i >= 3 ? new Float32Array(7 * 3) : void 0;\n    }\n    function C(d, p) {\n      if (!g)\n        throw new Error(\"Missing sh1\");\n      for (const [h, m] of a.entries())\n        g[h] = p[m] * 8 / 255 - 4;\n      if (Q)\n        for (const [h, m] of r.entries())\n          Q[h] = p[m] * 8 / 255 - 4;\n      if (o)\n        for (const [h, m] of I.entries())\n          o[h] = p[m] * 8 / 255 - 4;\n      n == null || n(d, g, Q, o);\n    }\n    function E(d) {\n      const {\n        min_x: p,\n        min_y: h,\n        min_z: m,\n        max_x: y,\n        max_y: f,\n        max_z: D,\n        min_scale_x: T,\n        min_scale_y: R,\n        min_scale_z: U,\n        max_scale_x: k,\n        max_scale_y: v,\n        max_scale_z: Z,\n        min_r: q,\n        min_g: $,\n        min_b: G,\n        max_r: J,\n        max_g: AA,\n        max_b: H\n      } = d.properties;\n      if (!p || !h || !m || !y || !f || !D || !T || !R || !U || !k || !v || !Z || !q || !$ || !G || !J || !AA || !H)\n        throw new Error(\"Missing PLY chunk properties\");\n      return t = !0, (uA, iA) => {\n        const {\n          min_x: aA,\n          min_y: V,\n          min_z: cA,\n          max_x: nA,\n          max_y: rA,\n          max_z: x,\n          min_scale_x: gA,\n          min_scale_y: tA,\n          min_scale_z: CA,\n          max_scale_x: eA,\n          max_scale_y: dA,\n          max_scale_z: pA,\n          min_r: JA,\n          min_g: yA,\n          min_b: fA,\n          max_r: mA,\n          max_g: wA,\n          max_b: K\n        } = iA;\n        s.push({\n          min_x: aA,\n          min_y: V,\n          min_z: cA,\n          max_x: nA,\n          max_y: rA,\n          max_z: x,\n          min_scale_x: gA,\n          min_scale_y: tA,\n          min_scale_z: CA,\n          max_scale_x: eA,\n          max_scale_y: dA,\n          max_scale_z: pA,\n          min_r: JA,\n          min_g: yA,\n          min_b: fA,\n          max_r: mA,\n          max_g: wA,\n          max_b: K\n        });\n      };\n    }\n    function l(d) {\n      if (n && d.name === \"sh\")\n        return i = Vn(d.properties), c(), C;\n      if (d.name !== \"vertex\")\n        return null;\n      const { packed_position: p, packed_rotation: h, packed_scale: m, packed_color: y } = d.properties;\n      if (!p || !h || !m || !y)\n        throw new Error(\n          \"Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color\"\n        );\n      const f = Math.sqrt(2);\n      return (D, T) => {\n        const R = s[D >>> 8];\n        if (R == null)\n          throw new Error(\"Missing PLY chunk\");\n        const {\n          min_x: U,\n          min_y: k,\n          min_z: v,\n          max_x: Z,\n          max_y: q,\n          max_z: $,\n          min_scale_x: G,\n          min_scale_y: J,\n          min_scale_z: AA,\n          max_scale_x: H,\n          max_scale_y: uA,\n          max_scale_z: iA,\n          min_r: aA,\n          min_g: V,\n          min_b: cA,\n          max_r: nA,\n          max_g: rA,\n          max_b: x\n        } = R, { packed_position: gA, packed_rotation: tA, packed_scale: CA, packed_color: eA } = T, dA = (gA >>> 21 & 2047) / 2047 * (Z - U) + U, pA = (gA >>> 11 & 1023) / 1023 * (q - k) + k, JA = (gA & 2047) / 2047 * ($ - v) + v, yA = ((tA >>> 20 & 1023) / 1023 - 0.5) * f, fA = ((tA >>> 10 & 1023) / 1023 - 0.5) * f, mA = ((tA & 1023) / 1023 - 0.5) * f, wA = Math.sqrt(Math.max(0, 1 - yA * yA - fA * fA - mA * mA)), K = tA >>> 30, kA = K === 0 ? yA : K === 1 ? wA : fA, _t = K <= 1 ? fA : K === 2 ? wA : mA, Yt = K <= 2 ? mA : wA, Tt = K === 0 ? wA : yA, Jt = Math.exp(\n          (CA >>> 21 & 2047) / 2047 * (H - G) + G\n        ), Ht = Math.exp(\n          (CA >>> 11 & 1023) / 1023 * (uA - J) + J\n        ), qt = Math.exp(\n          (CA & 2047) / 2047 * (iA - AA) + AA\n        ), zt = (eA >>> 24 & 255) / 255 * (nA - aA) + aA, Kt = (eA >>> 16 & 255) / 255 * (rA - V) + V, Pt = (eA >>> 8 & 255) / 255 * (x - cA) + cA, Ot = (eA & 255) / 255;\n        A(\n          D,\n          dA,\n          pA,\n          JA,\n          Jt,\n          Ht,\n          qt,\n          kA,\n          _t,\n          Yt,\n          Tt,\n          Ot,\n          zt,\n          Kt,\n          Pt\n        );\n      };\n    }\n    const u = (d) => {\n      if (d.name === \"chunk\")\n        return E(d);\n      if (t)\n        return l(d);\n      if (d.name !== \"vertex\")\n        return null;\n      const {\n        x: p,\n        y: h,\n        z: m,\n        scale_0: y,\n        scale_1: f,\n        scale_2: D,\n        rot_0: T,\n        rot_1: R,\n        rot_2: U,\n        rot_3: k,\n        opacity: v,\n        f_dc_0: Z,\n        f_dc_1: q,\n        f_dc_2: $,\n        red: G,\n        green: J,\n        blue: AA,\n        alpha: H\n      } = d.properties;\n      if (!p || !h || !m)\n        throw new Error(\"Missing PLY properties: x, y, z\");\n      const uA = y && f && D, iA = T && R && U && k, aA = H != null ? en[H.type] : 1, V = G != null ? en[G.type] : 1, cA = J != null ? en[J.type] : 1, nA = AA != null ? en[AA.type] : 1;\n      return i = Vn(d.properties), c(), (rA, x) => {\n        const gA = uA ? Math.exp(x.scale_0) : gn.defaultPointScale, tA = uA ? Math.exp(x.scale_1) : gn.defaultPointScale, CA = uA ? Math.exp(x.scale_2) : gn.defaultPointScale, eA = iA ? x.rot_1 : 0, dA = iA ? x.rot_2 : 0, pA = iA ? x.rot_3 : 0, JA = iA ? x.rot_0 : 1, yA = v != null ? 1 / (1 + Math.exp(-x.opacity)) : H != null ? x.alpha / aA : 1, fA = Z != null ? x.f_dc_0 * nn + 0.5 : G != null ? x.red / V : 1, mA = q != null ? x.f_dc_1 * nn + 0.5 : J != null ? x.green / cA : 1, wA = $ != null ? x.f_dc_2 * nn + 0.5 : AA != null ? x.blue / nA : 1;\n        if (A(\n          rA,\n          x.x,\n          x.y,\n          x.z,\n          gA,\n          tA,\n          CA,\n          eA,\n          dA,\n          pA,\n          JA,\n          yA,\n          fA,\n          mA,\n          wA\n        ), n && g) {\n          if (g)\n            for (const [K, kA] of a.entries())\n              g[K] = x[kA];\n          if (Q)\n            for (const [K, kA] of r.entries())\n              Q[K] = x[kA];\n          if (o)\n            for (const [K, kA] of I.entries())\n              o[K] = x[kA];\n          n(rA, g, Q, o);\n        }\n      };\n    };\n    this.parseData(u);\n  }\n  // Inject RGBA values into original PLY file, which can be used to modify\n  // the color/opacity of the Gsplats and write out the modified PLY file.\n  injectRgba(A) {\n    let n = 0;\n    const t = this.data;\n    if (t == null)\n      throw new Error(\"No parsed data\");\n    if (A.length !== this.numSplats * 4)\n      throw new Error(\"Invalid RGBA array length\");\n    for (const s in this.elements) {\n      const i = this.elements[s], { count: a, properties: r } = i, I = [];\n      let g = 0;\n      const Q = s === \"vertex\";\n      if (Q) {\n        for (const o of [\"opacity\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"])\n          if (!r[o] || r[o].type !== \"float\")\n            throw new Error(`Can't injectRgba due to property: ${o}`);\n      }\n      for (const [o, c] of Object.entries(r))\n        if (c.isList)\n          I.push(() => {\n            const C = tn[c.countType](\n              t,\n              n,\n              this.littleEndian\n            );\n            n += _A[c.countType], n += C * _A[c.type];\n          });\n        else {\n          if (Q)\n            if (o === \"f_dc_0\" || o === \"f_dc_1\" || o === \"f_dc_2\") {\n              const C = Number.parseInt(\n                o.slice(5)\n              );\n              I.push(() => {\n                const E = (A[g + C] / 255 - 0.5) / nn;\n                On[c.type](\n                  t,\n                  n,\n                  this.littleEndian,\n                  E\n                );\n              });\n            } else o === \"opacity\" && I.push(() => {\n              const C = Math.max(\n                -100,\n                Math.min(\n                  100,\n                  -Math.log(1 / (A[g + 3] / 255) - 1)\n                )\n              );\n              On[c.type](\n                t,\n                n,\n                this.littleEndian,\n                C\n              );\n            });\n          I.push(() => {\n            n += _A[c.type];\n          });\n        }\n      for (let o = 0; o < a; o++) {\n        for (const c of I)\n          c();\n        Q && (g += 4);\n      }\n    }\n  }\n};\nkt.defaultPointScale = 1e-3;\nlet Ls = kt;\nconst nn = 0.28209479177387814, tn = {\n  char: (e, A, n) => e.getInt8(A),\n  uchar: (e, A, n) => e.getUint8(A),\n  short: (e, A, n) => e.getInt16(A, n),\n  ushort: (e, A, n) => e.getUint16(A, n),\n  int: (e, A, n) => e.getInt32(A, n),\n  uint: (e, A, n) => e.getUint32(A, n),\n  float: (e, A, n) => e.getFloat32(A, n),\n  double: (e, A, n) => e.getFloat64(A, n)\n}, On = {\n  char: (e, A, n, t) => {\n    e.setInt8(A, t);\n  },\n  uchar: (e, A, n, t) => {\n    e.setUint8(A, t);\n  },\n  short: (e, A, n, t) => {\n    e.setInt16(A, t, n);\n  },\n  ushort: (e, A, n, t) => {\n    e.setUint16(A, t, n);\n  },\n  int: (e, A, n, t) => {\n    e.setInt32(A, t, n);\n  },\n  uint: (e, A, n, t) => {\n    e.setUint32(A, t, n);\n  },\n  float: (e, A, n, t) => {\n    e.setFloat32(A, t, n);\n  },\n  double: (e, A, n, t) => {\n    e.setFloat64(A, t, n);\n  }\n}, _A = {\n  char: 1,\n  uchar: 1,\n  short: 2,\n  ushort: 2,\n  int: 4,\n  uint: 4,\n  float: 4,\n  double: 8\n}, en = {\n  char: 127,\n  uchar: 255,\n  short: 32767,\n  ushort: 65535,\n  int: 2147483647,\n  uint: 4294967295,\n  float: 1,\n  double: 1\n}, _s = {\n  0: 0,\n  9: 1,\n  24: 2,\n  45: 3\n}, Ys = {\n  0: 0,\n  1: 9,\n  2: 24,\n  3: 45\n};\nfunction Vn(e) {\n  let A = 0;\n  for (; e[`f_rest_${A}`]; )\n    A += 1;\n  const n = _s[A];\n  if (n == null)\n    throw new Error(`Unsupported number of SH coefficients: ${A}`);\n  return n;\n}\nconst bt = `(function() {\n  \"use strict\";\n  let wasm;\n  const cachedTextDecoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-8\", { ignoreBOM: true, fatal: true }) : { decode: () => {\n    throw Error(\"TextDecoder not available\");\n  } };\n  if (typeof TextDecoder !== \"undefined\") {\n    cachedTextDecoder.decode();\n  }\n  let cachedUint8ArrayMemory0 = null;\n  function getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n  }\n  function getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n  }\n  function sort_splats(num_splats, readback, ordering) {\n    const ret = wasm.sort_splats(num_splats, readback, ordering);\n    return ret >>> 0;\n  }\n  function raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid) {\n    const ret = wasm.raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid);\n    return ret;\n  }\n  async function __wbg_load(module, imports) {\n    if (typeof Response === \"function\" && module instanceof Response) {\n      if (typeof WebAssembly.instantiateStreaming === \"function\") {\n        try {\n          return await WebAssembly.instantiateStreaming(module, imports);\n        } catch (e) {\n          if (module.headers.get(\"Content-Type\") != \"application/wasm\") {\n            console.warn(\"\\`WebAssembly.instantiateStreaming\\` failed because your server does not serve Wasm with \\`application/wasm\\` MIME type. Falling back to \\`WebAssembly.instantiate\\` which is slower. Original error:\\\\n\", e);\n          } else {\n            throw e;\n          }\n        }\n      }\n      const bytes = await module.arrayBuffer();\n      return await WebAssembly.instantiate(bytes, imports);\n    } else {\n      const instance = await WebAssembly.instantiate(module, imports);\n      if (instance instanceof WebAssembly.Instance) {\n        return { instance, module };\n      } else {\n        return instance;\n      }\n    }\n  }\n  function __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n      const ret = arg0.buffer;\n      return ret;\n    };\n    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {\n      const ret = new Uint16Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\n      const ret = new Uint32Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {\n      const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {\n      const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\n      const ret = new Float32Array(arg0 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n      const table = wasm.__wbindgen_export_0;\n      const offset = table.grow(4);\n      table.set(0, void 0);\n      table.set(offset + 0, void 0);\n      table.set(offset + 1, null);\n      table.set(offset + 2, true);\n      table.set(offset + 3, false);\n    };\n    imports.wbg.__wbindgen_memory = function() {\n      const ret = wasm.memory;\n      return ret;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n      throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    return imports;\n  }\n  function __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedUint8ArrayMemory0 = null;\n    wasm.__wbindgen_start();\n    return wasm;\n  }\n  async function __wbg_init(module_or_path) {\n    if (wasm !== void 0) return wasm;\n    if (typeof module_or_path !== \"undefined\") {\n      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n        ({ module_or_path } = module_or_path);\n      } else {\n        console.warn(\"using deprecated parameters for the initialization function; pass a single object instead\");\n      }\n    }\n    if (typeof module_or_path === \"undefined\") {\n      module_or_path = new URL(\"data:application/wasm;base64,AGFzbQEAAAAB9wEkYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAF/AW9gAAFvYAd/f39/f39/AGACf34Bf2ADf35+AGACf34AYAt9fX19fX19fX9vfwFvYAZ/f39/f38Bf2AFf398f38AYAR/fH9/AGAFf399f38AYAR/fX9/AGAFf39+f38AYAR/fn9/AGADf35+AX9gA39vbwF/YAJ9fQF9AvIEEQN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgACgN3YmcaX193YmdfbmV3XzlmZWU5N2E0MDliMzJiNjgACgN3YmcaX193Ymdfc2V0X2Y0ZjFmMGRhYTMwNjk2ZmMACwN3YmcdX193YmdfbGVuZ3RoXzhjZmQyYzY0MDlhZjg4YWQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAHA3diZxpfX3diZ19uZXdfZTNiMzIxZGNmZWY4OWZjNwAKA3diZxpfX3diZ19zZXRfZDIzNjYxZDE5MTQ4YjIyOQALA3diZx1fX3diZ19sZW5ndGhfNmNhNTI3NjY1ZDg5Njk0ZAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AAcDd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiAAsDd2JnHV9fd2JnX2xlbmd0aF8zYjRmMDIyMTg4YWU4ZGI2AAwDd2JnH19fd2JnX3N1YmFycmF5Xzc2OWUxZTBmODFiYjI1OWIABwN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAHA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAUA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA4DwAG+AQUAAAYPAAUF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BSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBlM/AACgCACAFQRBqQZjPwAAoAgAoAhQRAgBBkM/AACgCAEEBawUgBgs2AgBB6NLAAEEAOgAAIANFDQAACwALsgEBBn8CQAJAIABBhAFJDQAgANBvJgEQRSIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnRBBBCwAQsPCwALqQEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAkEEELABDAELIAMgAkEEIAFBAnQiAhCXASIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQZiPwABBMhC5AQALQQQgAhCUAQALowEBAn8jAEEgayIDJAACQCABRQRAQQFBACACEMYBIQAMAQsgAyABNgIMIAMgADYCCCADQRBqIANBCGoQLSADKAIQIgEEQANAIAMoAhQhBCADKAIcRQRAIAEgBCACEMYBIQAMAwtBASEAIAIgASAEEJkBDQIgAkH9/wMQnAENAiADQRBqIANBCGoQLSADKAIQIgENAAsLQQAhAAsgA0EgaiQAIAALiwEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhCXAQwCCwsgASACRQ0AGkH9zsAALQAAGiACIAEQpgELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIABBKEEEELABIAFBIGokAAuaAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIAFBIGokAAuSAQEEfyMAQRBrIgIkAEEBIQQCQCABKAIUIgNBJyABKAIYIgUoAhAiAREAAA0AIAJBBGogACgCAEGBAhAiAkAgAi0ABEGAAUYEQCADIAIoAgggAREAAEUNAQwCCyADIAItAA4iACACQQRqaiACLQAPIABrIAUoAgwRAQANAQsgA0EnIAERAAAhBAsgAkEQaiQAIAQLlQEBAn8jAEEgayIDJAACQCAAKAIEIgRBA0YgBEECSXINAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GshcAANgIEIANCADcCECADIANBHGo2AgwgA0EEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiBEUNACAAKAIMIARBDGxBBBCwAQsgAEEoQQQQsAEgA0EgaiQAC4QBAQN/An8CQCAAKAIAIgFFDQADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIDAILAkAgAkUNACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBAQ8LQQEgAEEBEBMNAhogAkEBayECIAAoAgAiAQ0ACwtBAAsLegEBfyMAQSBrIgIkAAJ/IAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQmQEMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahApCyACQSBqJAALSQEDfiAAIAFC/////w+DIgJCPn4iA0IAIgIgAUIgiEI+fnwiAUIghnwiBDcDACAAIAMgBFatIAEgAlStQiCGIAFCIIiEfDcDCAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUG8rsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICADIQ3AzggBSAFQQhqrUKAgICAkAyENwMwIAUgBUEwajYCICAFQRhqIAQQhAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCwAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEEAAsgAygCBCICBEAgASACIAMoAggQsAELIABBDEEEELABCwvzAwIIfwF+IwBBEGsiAyQAIAAoAgQhBSAAKAIAIQAgASgCFEG4rMAAQQEgASgCGCgCDBEBACEEIANBBGoiAkEAOgAFIAIgBDoABCACIAE2AgAgBQRAA0AgAyAANgIMIANBDGohCCMAQUBqIgEkAEEBIQYCQCADQQRqIgQtAAQNACAELQAFIQkCQCAEKAIAIgIoAhwiB0EEcUUEQCAJQQFxRQ0BIAIoAhRB667AAEECIAIoAhgoAgwRAQBFDQEMAgsgCUEBcUUEQCACKAIUQfWuwABBASACKAIYKAIMEQEADQIgAigCHCEHCyABQQE6ABsgASACKQIUNwIMIAFBzK7AADYCNCABIAFBG2o2AhQgASACKQIINwIkIAIpAgAhCiABIAc2AjggASACKAIQNgIsIAEgAi0AIDoAPCABIAo3AhwgASABQQxqNgIwIAggAUEcakGAmcAAKAIAEQAADQEgASgCMEHwrsAAQQIgASgCNCgCDBEBACEGDAELIAggAkGAmcAAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUFAayQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIUQfauwABBASAAKAIYKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0HYscAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQZitwAA2AgggA0ICNwIUIANCgICAgPACIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhCEAQALagIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIM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AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEHglsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALIAAgAzYCBCAAIAI2AgAgAEHElsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALJQAgAEUEQEGYj8AAQTIQuQEACyAAIAIgAyAEIAUgASgCEBEIAAsoACABIAAoAgAtAABBAnQiAEHkp8AAaigCACAAQdCnwABqKAIAEJkBCyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQEQkACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQER4ACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQESAACygBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAFBARCwAQsLJwAgAEEcakEAIAJC2KGkg7Hi0d18URtBACABQpXX3ZjDl4qMC1EbCyEAIABFBEBBmI/AAEEyELkBAAsgACACIAMgASgCEBEDAAsfACAARQRAQZiPwABBMhC5AQALIAAgAiABKAIQEQAAC+MVAQx/EDMiBCABJgECfyAAIQYQMyIAIAImASMAQdAAayIIJAAgCCAANgIYIAggBDYCFCAIQRRqKAIAEMoBIQtBvM7AACgCAEUEQEHkzsAAQQA2AgBB2M7AAEEANgIAQczOwABBADYCAEHAzsAAQQA2AgBB4M7AACgCACEFQeDOwABBBDYCAEHczsAAKAIAIQ1B3M7AAEEANgIAQdTOwAAoAgAhA0HUzsAAQQQ2AgBB0M7AACgCACEJQdDOwABBADYCAEHIzsAAKAIAIQRByM7AAEECNgIAQcTOwAAoAgAhB0HEzsAAQQA2AgBBvM7AACgCACEAQbzOwABBATYCAAJAIABFDQAgBwRAIAQgB0EBdEECELABCyAJBEAgAyAJQQJ0QQQQsAELIA1FDQAgBSAN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IABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAUkEQCABQZyvwABBAiAAIARqQYABakEAIABrECEgASAFNgIcIAEgBzYCBCABIAY2AgAgBEGAAWokAAwBCyACQYABQYyvwAAQaAALCwwAIAAgASkCADcDAAsNACABQfCYwABBAhAeCw0AIABBhJzAACABECkLDgAgAUGvm8AAQQUQmQELDgAgAUG8p8AAQRIQmQELDQAgAEHQqcAAIAEQKQsOACABQcipwABBBRCZAQsZACAAIAFBjM/AACgCACIAQTogABsRAgAACw0AIABBzK7AACABECkLCgAgAiAAIAEQHguQBQEHfwJAAn8CQCACIgUgACABa0sEQCABIAJqIQMgACACaiECIAAgBUEQSQ0CGiACQXxxIQRBACACQQNxIgZrIQcgBgRAIANBAWshAANAIAJBAWsiAiAALQAAOgAAIABBAWshACACIARLDQALCyAEIAUgBmsiBkF8cSIFayECIAMgB2oiA0EDcQRAIAVBAEwNAiADQQN0IgBBGHEhByADQXxxIghBBGshAUEAIABrQRhxIQkgCCgCACEAA0AgBEEEayIEIAAgCXQgASgCACIAIAd2cjYCACABQQRrIQEgAiAESQ0ACwwCCyAFQQBMDQEgASAGakEEayEBA0AgBEEEayIEIAEoAgA2AgAgAUEEayEBIAIgBEkNAAsMAQsCQCAFQRBJBEAgACECDAELIABBACAAa0EDcSIDaiEEIAMEQCAAIQIgASEAA0AgAiAALQAAOgAAIABBAWohACACQQFqIgIgBEkNAAsLIAQgBSADayIFQXxxIgZqIQICQCABIANqIgNBA3EEQCAGQQBMDQEgA0EDdCIAQRhxIQcgA0F8cSIIQQRqIQFBACAAa0EYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkkNAAsMAQsgBkEATA0AIAMhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJJDQALCyAFQQNxIQUgAyAGaiEBCyAFRQ0CIAIgBWohAANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIABJDQALDAILIAZBA3EiAEUNASADIAVrIQMgAiAAawshACADQQFrIQEDQCACQQFrIgIgAS0AADoA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YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwB0AxAATwAAAGgDAAA0AAAAdAMQAE8AAABvAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAA4EEABLAAAAxAcAAB0AAAAOBBAASwAAAMwHAAAdAAAAHAAAAAwAAAAEAAAAHQAAAB4AAAAfAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikvcnVzdGMvOTBiMzVhNjIzOWMzZDhiZGFiYzUzMGE2YTA4MTZmN2ZmODlhMGFhZi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnPJBBAASwAAAMAFAAANAAAAAAAAABAAAAAEAAAAIgAAACMAAAAkAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwAAVAUQAF4AAABnBAAADgAAAAEAAAAAAAAAOiAAAMwFEAACAAAACgpDYXVzZWQgYnk6CgAAACUAAAAMAAAABAAAACYAAAAnAAAAHwAAAAoKc3RhY2sgYmFja3RyYWNlOlN0YWNrIGJhY2t0cmFjZToKABIGEAARAAAAUwBBuIzAAAvZBAEAAAAoAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQDJBBAASwAAAHsKAAAOAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc4gGEABMAAAALQoAACQAAAAAAAAAEAAAAAQAAAAiAAAAIwAAACQAAAAgICAgOiAAAAEAAAAAAAAAAAcQAAIAAAAgICAgICAgL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnMAGwcQAFwAAAD7GAAAAQAAAAAAAAAEAAAABAAAADUAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZMoHEAAqAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMA/AcQAF8AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABsCBAADgAAAPwHEABfAAAAegIAAA0AQZyRwAALlQ8EAAAABAAAADsAAAA6AAAAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAMQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADECBAAKQAAAK4EAAANAAAAc3RkL3NyYy9iYWNrdHJhY2UucnNvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtgAkQACgAAAAkAAAAAAAAAAIAAACoCRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAGwJEAAUAAAAigEAAB0AAABAAAAAEAAAAAQAAABBAAAAQgAAAAEAAAAAAAAAOiBzdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzABYKEAAZAAAA0AAAABMAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleEAKEAAgAAAAc3RkL3NyYy9zeXMvc3luYy9tdXRleC9ub190aHJlYWRzLnJzaAoQACQAAAAUAAAACQAAAHN0ZC9zcmMvc3luYy9v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Zm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAjhUQABAAAAB+AgAADgAAAGZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kILAVEAA8AAAALi4wMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAAABQWEAASAAAAAQAAAAAAAABbY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABkFhAAIAAAAIQWEAASAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAsxYQABAAAADDFhAAFwAAANoWEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAALMWEAAQAAAA/BYQABAAAAAMFxAACQAAANoWEAAJAAAAOiAAAAEAAAAAAAAAOBcQAAIAAAAAAAAADAAAAAQAAABlAAAAZgAAAGcAAAAgICAgIHsgLCAgewosCn0gfQpdY29yZS9zcmMvZm10L251bS5ycwAAdxcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9mbXQvbW9kLnJzZmFsc2V0cnVlAABmGBAAEwAAAKMJAAAmAAAAZhgQABMAAACsCQAAGgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2YgcmFuZ2UgZm9yIHNsaWNlIG9mIGxlbmd0aCCkGBAAEgAAALYYEAAiAAAAcmFuZ2UgZW5kIGluZGV4IOgYEAAQAAAAthgQACIAAABzbGljZSBpbmRleCBzdGFydHMgYXQgIGJ1dCBlbmRzIGF0IAAIGRAAFgAAAB4ZEAANAAAAYXR0ZW1wdGVkIHRvIGluZGV4IHNsaWNlIGZyb20gYWZ0ZXIgbWF4aW11bSB1c2l6ZQAAADwZEAAxAAAAYXR0ZW1wdGVkIHRvIGluZGV4IHNsaWNlIHVwIHRvIG1heGltdW0gdXNpemV4GRAALAAAAGF0dGVtcHRlZCB0byBpbmRleCBzdHIgdXAgdG8gbWF4aW11bSB1c2l6ZQAArBkQACoAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQBBorXAAAszAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwMDAwMDAwMDAwMDAwMDAwQEBAQEAEHgtcAAC8UWY29yZS9zcmMvc3RyL3BhdHRlcm4ucnMA4BoQABcAAABXBQAAEgAAAOAaEAAXAAAAVwUAACgAAADgGhAAFwAAAEoGAAAVAAAA4BoQABcAAAB4BgAAFQAAAOAaEAAXAAAAeQYAABUAAAAAWy4uLl1iZWdpbiA8PSBlbmQgKCA8PSApIHdoZW4gc2xpY2luZyBgYAAAAE4bEAAOAAAAXBsQAAQAAABgGxAAEAAAAHAbEAABAAAAYnl0ZSBpbmRleCAgaXMgbm90IGEgY2hhciBib3VuZGFyeTsgaXQgaXMgaW5zaWRlICAoYnl0ZXMgKSBvZiBgAJQbEAALAAAAnxsQACYAAADFGxAACAAAAM0bEAAGAAAAcBsQAAEAAAAgaXMgb3V0IG9mIGJvdW5kcyBvZiBgAACUGxAACwAAAPwbEAAWAAAAcBsQAAEAAABjb3JlL3NyYy9zdHIvbW9kLnJzACwcEAATAAAA8QAAACwAAABjb3JlL3NyYy91bmljb2RlL3ByaW50YWJsZS5ycwAAAFAcEAAdAAAAGgAAADYAAABQHBAAHQAAAAoAAAArAAAAAAYBAQMBBAIFBwcCCAgJAgoFCwIOBBABEQISBRMcFAEVAhcCGQ0cBR0IHwEkAWoEawKvA7ECvALPAtEC1AzVCdYC1wLaAeAF4QLnBOgC7iDwBPgC+gT7AQwnOz5OT4+enp97i5OWorK6hrEGBwk2PT5W89DRBBQYNjdWV3+qrq+9NeASh4mOngQNDhESKTE0OkVGSUpOT2RlioyNj7bBw8TGy9ZctrcbHAcICgsUFzY5Oqip2NkJN5CRqAcKOz5maY+SEW9fv+7vWmL0/P9TVJqbLi8nKFWdoKGjpKeorbq8xAYLDBUdOj9FUaanzM2gBxkaIiU+P+fs7//FxgQgIyUmKDM4OkhKTFBTVVZYWlxeYGNlZmtzeH1/iqSqr7DA0K6vbm/d3pNeInsFAwQtA2YDAS8ugIIdAzEPHAQkCR4FKwVEBA4qgKoGJAQkBCgINAtOAzQMgTcJFgoIGDtFOQNjCAkwFgUhAxsFAUA4BEsFLwQKBwkHQCAnBAwJNgM6BRoHBAwHUEk3Mw0zBy4ICgYmAx0IAoDQUhADNywIKhYaJhwUFwlOBCQJRA0ZBwoGSAgnCXULQj4qBjsFCgZRBgEFEAMFC1kIAh1iHkgICoCmXiJFCwoGDRM6BgoGFBwsBBeAuTxkUwxICQpGRRtICFMNSQcKgLYiDgoGRgodA0dJNwMOCAoGOQcKgTYZBzsDHVUBDzINg5tmdQuAxIpMYw2EMBAWCo+bBYJHmrk6hsaCOQcqBFwGJgpGCigFE4GwOoDGW2VLBDkHEUAFCwIOl/gIhNYpCqLngTMPAR0GDgQIgYyJBGsFDQMJBxCPYID6BoG0TEcJdDyA9gpzCHAVRnoUDBQMVwkZgIeBRwOFQg8VhFAfBgaA1SsFPiEBcC0DGgQCgUAfEToFAYHQKoDWKwQBgeCA9ylMBAoEAoMRREw9gMI8BgEEVQUbNAKBDiwEZAxWCoCuOB0NLAQJBwIOBoCag9gEEQMNA3cEXwYMBAEPDAQ4CAoGKAgsBAI+gVQMHQMKBTgHHAYJB4D6hAYAAQMFBQYGAgcGCAcJEQocCxkMGg0QDgwPBBADEhITCRYBFwQYARkDGgcbARwCHxYgAysDLQsuATAEMQIyAacEqQKqBKsI+gL7Bf0C/gP/Ca14eYuNojBXWIuMkBzdDg9LTPv8Li8/XF1f4oSNjpGSqbG6u8XGycre5OX/AAQREikxNDc6Oz1JSl2EjpKpsbS6u8bKzs/k5QAEDQ4REikxNDo7RUZJSl5kZYSRm53Jzs8NESk6O0VJV1tcXl9kZY2RqbS6u8XJ3+Tl8A0RRUlkZYCEsry+v9XX8PGDhYukpr6/xcfP2ttImL3Nxs7PSU5PV1leX4mOj7G2t7/BxsfXERYXW1z29/7/gG1x3t8OH25vHB1ffX6ur027vBYXHh9GR05PWFpcXn5/tcXU1dzw8fVyc490dZYmLi+nr7e/x8/X35oAQJeYMI8fzs/S1M7/Tk9aWwcIDxAnL+7vbm83PT9CRZCRU2d1yMnQ0djZ5/7/ACBfIoLfBIJECBsEBhGBrA6AqwUfCIEcAxkIAQQvBDQEBwMBBwYHEQpQDxIHVQcDBBwKCQMIAwcDAgMDAwwEBQMLBgEOFQVOBxsHVwcCBhcMUARDAy0DAQQRBg8MOgQdJV8gbQRqJYDIBYKwAxoGgv0DWQcWCRgJFAwUDGoGCgYaBlkHKwVGCiwEDAQBAzELLAQaBgsDgKwGCgYvMYD0CDwDDwM+BTgIKwWC/xEYCC8RLQMhDyEPgIwEgpoWCxWIlAUvBTsHAg4YCYC+InQMgNYagRAFgOEJ8p4DNwmBXBSAuAiA3RU7AwoGOAhGCAwGdAseA1oEWQmAgxgcChYJTASAigarpAwXBDGhBIHaJgcMBQWAphCB9QcBICoGTASAjQSAvgMbAw8NY29yZS9zcmMvdW5pY29kZS91bmljb2RlX2RhdGEucnMAAAA5IhAAIAAAAE4AAAAoAAAAOSIQACAAAABaAAAAFgAAAGNvcmUvc3JjL251bS9tb2QucnMAfCIQABMAAAAbBgAAAQAAAAADAACDBCAAkQVgAF0ToAASFyAfDCBgH+8sICsqMKArb6ZgLAKo4Cwe++AtAP4gNp7/YDb9AeE2AQohNyQN4TerDmE5LxjhOTAc4UrzHuFOQDShUh5h4VPwamFUT2/hVJ28YVUAz2FWZdGhVgDaIVcA4KFYruIhWuzk4VvQ6GFcIADuXPABf10AcAAHAC0BAQECAQIBAUgLMBUQAWUHAgYCAgEEIwEeG1sLOgkJARgEAQkBAwEFKwM7CSoYASA3AQEBBAgEAQMHCgIdAToBAQECBAgBCQEKAhoBAgI5AQQCBAICAwMBHgIDAQsCOQEEBQECBAEUAhYGAQE6AQECAQQIAQcDCgIeATsBAQEMAQkBKAEDATcBAQMFAwEEBwILAh0BOgECAgEBAwMBBAcCCwIcAjkCAQECBAgBCQEKAh0BSAEEAQIDAQEIAVEBAgcMCGIBAgkLB0kCGwEBAQEBNw4BBQECBQsBJAkBZgQBBgECAgIZAgQDEAQNAQICBgEPAQADAAQcAx0CHgJAAgEHCAECCwkBLQMBAXUCIgF2AwQCCQEGA9sCAgE6AQEHAQEBAQIIBgoCATAfMQQwCgQDJgkMAiAEAgY4AQECAwEBBTgIAgKYAwENAQcEAQYBAwLGQAABwyEAA40BYCAABmkCAAQBCiACUAIAAQMBBAEZAgUBlwIaEg0BJggZCwEBLAMwAQIEAgICASQBQwYCAgICDAEIAS8BMwEBAwICBQIBASoCCAHuAQIBBAEAAQAQEBAAAgAB4gGVBQADAQIFBCgDBAGlAgAEQQUAAk8ERgsxBHsBNg8pAQICCgMxBAICBwE9AyQFAQg+AQwCNAkBAQgEAgFfAwIEBgECAZ0BAwgVAjkCAQEBAQwBCQEOBwMFQwECBgEBAgEBAwQDAQEOAlUIAgMBARcBUQECBgEBAgEBAgEC6wECBAYCAQIbAlUIAgEBAmoBAQECCGUBAQECBAEFAAkBAvUBCgQEAZAEAgIEASAKKAYCBAgBCQYCAy4NAQIABwEGAQFSFgIHAQIBAnoGAwEBAgEHAQFIAgMBAQEAAgsCNAUFAxcBAAEGDwAMAwMABTsHAAE/BFEBCwIAAgAuAhcABQMGCAgCBx4ElAMANwQyCAEOARYFAQ8ABwERAgcBAgEFZAGgBwABPQQABP4CAAdtBwBggPAAAgICAgICAgICAwMBAQEAQbfMwAALEAEAAAAAAAAAAgIAAAAAAAIAQfbMwAALAQIAQZzNwAALAQEAQbfNwAALAQEAQZvOwAALBT8AAAC/AEG4zsAACwE2AHAJcHJvZHVjZXJzAghsYW5ndWFnZQEEUnVzdAAMcHJvY2Vzc2VkLWJ5AwVydXN0Yx0xLjgzLjAgKDkwYjM1YTYyMyAyMDI0LTExLTI2KQZ3YWxydXMGMC4yMy4zDHdhc20tYmluZGdlbgcwLjIuMTAwAEkPdGFyZ2V0X2ZlYXR1cmVzBCsPbXV0YWJsZS1nbG9iYWxzKwhzaWduLWV4dCsPcmVmZXJlbmNlLXR5cGVzKwptdWx0aXZhbHVl\", self.location.href);\n    }\n    const imports = __wbg_get_imports();\n    if (typeof module_or_path === \"string\" || typeof Request === \"function\" && module_or_path instanceof Request || typeof URL === \"function\" && module_or_path instanceof URL) {\n      module_or_path = fetch(module_or_path);\n    }\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n    return __wbg_finalize_init(instance, module);\n  }\n  var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n  var fleb = new u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */\n    0,\n    0,\n    /* impossible */\n    0\n  ]);\n  var fdeb = new u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */\n    0,\n    0\n  ]);\n  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n  var freb = function(eb, start) {\n    var b = new u16(31);\n    for (var i2 = 0; i2 < 31; ++i2) {\n      b[i2] = start += 1 << eb[i2 - 1];\n    }\n    var r = new i32(b[30]);\n    for (var i2 = 1; i2 < 30; ++i2) {\n      for (var j = b[i2]; j < b[i2 + 1]; ++j) {\n        r[j] = j - b[i2] << 5 | i2;\n      }\n    }\n    return { b, r };\n  };\n  var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n  fl[28] = 258, revfl[258] = 28;\n  var _b = freb(fdeb, 0), fd = _b.b;\n  var rev = new u16(32768);\n  for (var i = 0; i < 32768; ++i) {\n    var x = (i & 43690) >> 1 | (i & 21845) << 1;\n    x = (x & 52428) >> 2 | (x & 13107) << 2;\n    x = (x & 61680) >> 4 | (x & 3855) << 4;\n    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\n  }\n  var hMap = function(cd, mb, r) {\n    var s = cd.length;\n    var i2 = 0;\n    var l = new u16(mb);\n    for (; i2 < s; ++i2) {\n      if (cd[i2])\n        ++l[cd[i2] - 1];\n    }\n    var le = new u16(mb);\n    for (i2 = 1; i2 < mb; ++i2) {\n      le[i2] = le[i2 - 1] + l[i2 - 1] << 1;\n    }\n    var co;\n    if (r) {\n      co = new u16(1 << mb);\n      var rvb = 15 - mb;\n      for (i2 = 0; i2 < s; ++i2) {\n        if (cd[i2]) {\n          var sv = i2 << 4 | cd[i2];\n          var r_1 = mb - cd[i2];\n          var v = le[cd[i2] - 1]++ << r_1;\n          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\n            co[rev[v] >> rvb] = sv;\n          }\n        }\n      }\n    } else {\n      co = new u16(s);\n      for (i2 = 0; i2 < s; ++i2) {\n        if (cd[i2]) {\n          co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];\n        }\n      }\n    }\n    return co;\n  };\n  var flt = new u8(288);\n  for (var i = 0; i < 144; ++i)\n    flt[i] = 8;\n  for (var i = 144; i < 256; ++i)\n    flt[i] = 9;\n  for (var i = 256; i < 280; ++i)\n    flt[i] = 7;\n  for (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n  var fdt = new u8(32);\n  for (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);\n  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\n  var max = function(a) {\n    var m = a[0];\n    for (var i2 = 1; i2 < a.length; ++i2) {\n      if (a[i2] > m)\n        m = a[i2];\n    }\n    return m;\n  };\n  var bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n  };\n  var bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n  };\n  var shft = function(p) {\n    return (p + 7) / 8 | 0;\n  };\n  var slc = function(v, s, e) {\n    if (s == null || s < 0)\n      s = 0;\n    if (e == null || e > v.length)\n      e = v.length;\n    return new u8(v.subarray(s, e));\n  };\n  var ec = [\n    \"unexpected EOF\",\n    \"invalid block type\",\n    \"invalid length/literal\",\n    \"invalid distance\",\n    \"stream finished\",\n    \"no stream handler\",\n    ,\n    \"no callback\",\n    \"invalid UTF-8 data\",\n    \"extra field too long\",\n    \"date not in range 1980-2099\",\n    \"filename too long\",\n    \"stream finishing\",\n    \"invalid zip data\"\n    // determined by unknown compression method\n  ];\n  var err = function(ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(e, err);\n    if (!nt)\n      throw e;\n    return e;\n  };\n  var inflt = function(dat, st, buf, dict) {\n    var sl = dat.length, dl = 0;\n    if (!sl || st.f && !st.l)\n      return buf || new u8(0);\n    var noBuf = !buf;\n    var resize = noBuf || st.i != 2;\n    var noSt = st.i;\n    if (noBuf)\n      buf = new u8(sl * 3);\n    var cbuf = function(l2) {\n      var bl = buf.length;\n      if (l2 > bl) {\n        var nbuf = new u8(Math.max(bl * 2, l2));\n        nbuf.set(buf);\n        buf = nbuf;\n      }\n    };\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    var tbts = sl * 8;\n    do {\n      if (!lm) {\n        final = bits(dat, pos, 1);\n        var type = bits(dat, pos + 1, 3);\n        pos += 3;\n        if (!type) {\n          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n          if (t > sl) {\n            if (noSt)\n              err(0);\n            break;\n          }\n          if (resize)\n            cbuf(bt + l);\n          buf.set(dat.subarray(s, t), bt);\n          st.b = bt += l, st.p = pos = t * 8, st.f = final;\n          continue;\n        } else if (type == 1)\n          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n        else if (type == 2) {\n          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n          var tl = hLit + bits(dat, pos + 5, 31) + 1;\n          pos += 14;\n          var ldt = new u8(tl);\n          var clt = new u8(19);\n          for (var i2 = 0; i2 < hcLen; ++i2) {\n            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);\n          }\n          pos += hcLen * 3;\n          var clb = max(clt), clbmsk = (1 << clb) - 1;\n          var clm = hMap(clt, clb, 1);\n          for (var i2 = 0; i2 < tl; ) {\n            var r = clm[bits(dat, pos, clbmsk)];\n            pos += r & 15;\n            var s = r >> 4;\n            if (s < 16) {\n              ldt[i2++] = s;\n            } else {\n              var c = 0, n = 0;\n              if (s == 16)\n                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];\n              else if (s == 17)\n                n = 3 + bits(dat, pos, 7), pos += 3;\n              else if (s == 18)\n                n = 11 + bits(dat, pos, 127), pos += 7;\n              while (n--)\n                ldt[i2++] = c;\n            }\n          }\n          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n          lbt = max(lt);\n          dbt = max(dt);\n          lm = hMap(lt, lbt, 1);\n          dm = hMap(dt, dbt, 1);\n        } else\n          err(1);\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n      }\n      if (resize)\n        cbuf(bt + 131072);\n      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n      var lpos = pos;\n      for (; ; lpos = pos) {\n        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n        pos += c & 15;\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (!c)\n          err(2);\n        if (sym < 256)\n          buf[bt++] = sym;\n        else if (sym == 256) {\n          lpos = pos, lm = null;\n          break;\n        } else {\n          var add2 = sym - 254;\n          if (sym > 264) {\n            var i2 = sym - 257, b = fleb[i2];\n            add2 = bits(dat, pos, (1 << b) - 1) + fl[i2];\n            pos += b;\n          }\n          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n          if (!d)\n            err(3);\n          pos += d & 15;\n          var dt = fd[dsym];\n          if (dsym > 3) {\n            var b = fdeb[dsym];\n            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n          }\n          if (pos > tbts) {\n            if (noSt)\n              err(0);\n            break;\n          }\n          if (resize)\n            cbuf(bt + 131072);\n          var end = bt + add2;\n          if (bt < dt) {\n            var shift = dl - dt, dend = Math.min(dt, end);\n            if (shift + bt < 0)\n              err(3);\n            for (; bt < dend; ++bt)\n              buf[bt] = dict[shift + bt];\n          }\n          for (; bt < end; ++bt)\n            buf[bt] = buf[bt - dt];\n        }\n      }\n      st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n      if (lm)\n        final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n  };\n  var et = /* @__PURE__ */ new u8(0);\n  var gzs = function(d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n      err(6, \"invalid gzip data\");\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n      st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n      ;\n    return st + (flg & 2);\n  };\n  var Inflate = /* @__PURE__ */ function() {\n    function Inflate2(opts, cb) {\n      if (typeof opts == \"function\")\n        cb = opts, opts = {};\n      this.ondata = cb;\n      var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n      this.s = { i: 0, b: dict ? dict.length : 0 };\n      this.o = new u8(32768);\n      this.p = new u8(0);\n      if (dict)\n        this.o.set(dict);\n    }\n    Inflate2.prototype.e = function(c) {\n      if (!this.ondata)\n        err(5);\n      if (this.d)\n        err(4);\n      if (!this.p.length)\n        this.p = c;\n      else if (c.length) {\n        var n = new u8(this.p.length + c.length);\n        n.set(this.p), n.set(c, this.p.length), this.p = n;\n      }\n    };\n    Inflate2.prototype.c = function(final) {\n      this.s.i = +(this.d = final || false);\n      var bts = this.s.b;\n      var dt = inflt(this.p, this.s, this.o);\n      this.ondata(slc(dt, bts, this.s.b), this.d);\n      this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n      this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n    };\n    Inflate2.prototype.push = function(chunk, final) {\n      this.e(chunk), this.c(final);\n    };\n    return Inflate2;\n  }();\n  var Gunzip = /* @__PURE__ */ function() {\n    function Gunzip2(opts, cb) {\n      this.v = 1;\n      this.r = 0;\n      Inflate.call(this, opts, cb);\n    }\n    Gunzip2.prototype.push = function(chunk, final) {\n      Inflate.prototype.e.call(this, chunk);\n      this.r += chunk.length;\n      if (this.v) {\n        var p = this.p.subarray(this.v - 1);\n        var s = p.length > 3 ? gzs(p) : 4;\n        if (s > p.length) {\n          if (!final)\n            return;\n        } else if (this.v > 1 && this.onmember) {\n          this.onmember(this.r - p.length);\n        }\n        this.p = p.subarray(s), this.v = 0;\n      }\n      Inflate.prototype.c.call(this, final);\n      if (this.s.f && !this.s.l && !final) {\n        this.v = shft(this.s.p) + 9;\n        this.s = { i: 0 };\n        this.o = new u8(0);\n        this.push(new u8(0), final);\n      }\n    };\n    return Gunzip2;\n  }();\n  var td = typeof TextDecoder != \"undefined\" && /* @__PURE__ */ new TextDecoder();\n  var tds = 0;\n  try {\n    td.decode(et, { stream: true });\n    tds = 1;\n  } catch (e) {\n  }\n  /**\n   * @license\n   * Copyright 2010-2024 Three.js Authors\n   * SPDX-License-Identifier: MIT\n   */\n  const REVISION = \"172\";\n  const FrontSide = 0;\n  const BackSide = 1;\n  const NormalBlending = 1;\n  const AddEquation = 100;\n  const SrcAlphaFactor = 204;\n  const OneMinusSrcAlphaFactor = 205;\n  const LessEqualDepth = 3;\n  const MultiplyOperation = 0;\n  const UVMapping = 300;\n  const RepeatWrapping = 1e3;\n  const ClampToEdgeWrapping = 1001;\n  const MirroredRepeatWrapping = 1002;\n  const NearestFilter = 1003;\n  const LinearFilter = 1006;\n  const LinearMipmapLinearFilter = 1008;\n  const UnsignedByteType = 1009;\n  const UnsignedIntType = 1014;\n  const FloatType = 1015;\n  const RGBAFormat = 1023;\n  const RGIntegerFormat = 1031;\n  const RGBAIntegerFormat = 1033;\n  const NoColorSpace = \"\";\n  const SRGBColorSpace = \"srgb\";\n  const LinearSRGBColorSpace = \"srgb-linear\";\n  const LinearTransfer = \"linear\";\n  const SRGBTransfer = \"srgb\";\n  const KeepStencilOp = 7680;\n  const AlwaysStencilFunc = 519;\n  const StaticDrawUsage = 35044;\n  const GLSL3 = \"300 es\";\n  const WebGLCoordinateSystem = 2e3;\n  const WebGPUCoordinateSystem = 2001;\n  class EventDispatcher {\n    addEventListener(type, listener) {\n      if (this._listeners === void 0) this._listeners = {};\n      const listeners = this._listeners;\n      if (listeners[type] === void 0) {\n        listeners[type] = [];\n      }\n      if (listeners[type].indexOf(listener) === -1) {\n        listeners[type].push(listener);\n      }\n    }\n    hasEventListener(type, listener) {\n      if (this._listeners === void 0) return false;\n      const listeners = this._listeners;\n      return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;\n    }\n    removeEventListener(type, listener) {\n      if (this._listeners === void 0) return;\n      const listeners = this._listeners;\n      const listenerArray = listeners[type];\n      if (listenerArray !== void 0) {\n        const index = listenerArray.indexOf(listener);\n        if (index !== -1) {\n          listenerArray.splice(index, 1);\n        }\n      }\n    }\n    dispatchEvent(event) {\n      if (this._listeners === void 0) return;\n      const listeners = this._listeners;\n      const listenerArray = listeners[event.type];\n      if (listenerArray !== void 0) {\n        event.target = this;\n        const array = listenerArray.slice(0);\n        for (let i2 = 0, l = array.length; i2 < l; i2++) {\n          array[i2].call(this, event);\n        }\n        event.target = null;\n      }\n    }\n  }\n  const _lut = [\"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"0a\", \"0b\", \"0c\", \"0d\", \"0e\", \"0f\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"1a\", \"1b\", \"1c\", \"1d\", \"1e\", \"1f\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"2a\", \"2b\", \"2c\", \"2d\", \"2e\", \"2f\", \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"3a\", \"3b\", \"3c\", \"3d\", \"3e\", \"3f\", \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\", \"4a\", \"4b\", \"4c\", \"4d\", \"4e\", \"4f\", \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\", \"5a\", \"5b\", \"5c\", \"5d\", \"5e\", \"5f\", \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\", \"6a\", \"6b\", \"6c\", \"6d\", \"6e\", \"6f\", \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\", \"7a\", \"7b\", \"7c\", \"7d\", \"7e\", \"7f\", \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\", \"8a\", \"8b\", \"8c\", \"8d\", \"8e\", \"8f\", \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\", \"9a\", \"9b\", \"9c\", \"9d\", \"9e\", \"9f\", \"a0\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"a6\", \"a7\", \"a8\", \"a9\", \"aa\", \"ab\", \"ac\", \"ad\", \"ae\", \"af\", \"b0\", \"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\", \"b8\", \"b9\", \"ba\", \"bb\", \"bc\", \"bd\", \"be\", \"bf\", \"c0\", \"c1\", \"c2\", \"c3\", \"c4\", \"c5\", \"c6\", \"c7\", \"c8\", \"c9\", \"ca\", \"cb\", \"cc\", \"cd\", \"ce\", \"cf\", \"d0\", \"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\", \"da\", \"db\", \"dc\", \"dd\", \"de\", \"df\", \"e0\", \"e1\", \"e2\", \"e3\", \"e4\", \"e5\", \"e6\", \"e7\", \"e8\", \"e9\", \"ea\", \"eb\", \"ec\", \"ed\", \"ee\", \"ef\", \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \"f8\", \"f9\", \"fa\", \"fb\", \"fc\", \"fd\", \"fe\", \"ff\"];\n  function generateUUID() {\n    const d0 = Math.random() * 4294967295 | 0;\n    const d1 = Math.random() * 4294967295 | 0;\n    const d2 = Math.random() * 4294967295 | 0;\n    const d3 = Math.random() * 4294967295 | 0;\n    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + \"-\" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + \"-\" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + \"-\" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + \"-\" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];\n    return uuid.toLowerCase();\n  }\n  function clamp(value, min, max2) {\n    return Math.max(min, Math.min(max2, value));\n  }\n  function euclideanModulo(n, m) {\n    return (n % m + m) % m;\n  }\n  function lerp(x2, y, t) {\n    return (1 - t) * x2 + t * y;\n  }\n  function denormalize(value, array) {\n    switch (array.constructor) {\n      case Float32Array:\n        return value;\n      case Uint32Array:\n        return value / 4294967295;\n      case Uint16Array:\n        return value / 65535;\n      case Uint8Array:\n        return value / 255;\n      case Int32Array:\n        return Math.max(value / 2147483647, -1);\n      case Int16Array:\n        return Math.max(value / 32767, -1);\n      case Int8Array:\n        return Math.max(value / 127, -1);\n      default:\n        throw new Error(\"Invalid component type.\");\n    }\n  }\n  function normalize$1(value, array) {\n    switch (array.constructor) {\n      case Float32Array:\n        return value;\n      case Uint32Array:\n        return Math.round(value * 4294967295);\n      case Uint16Array:\n        return Math.round(value * 65535);\n      case Uint8Array:\n        return Math.round(value * 255);\n      case Int32Array:\n        return Math.round(value * 2147483647);\n      case Int16Array:\n        return Math.round(value * 32767);\n      case Int8Array:\n        return Math.round(value * 127);\n      default:\n        throw new Error(\"Invalid component type.\");\n    }\n  }\n  class Vector2 {\n    constructor(x2 = 0, y = 0) {\n      Vector2.prototype.isVector2 = true;\n      this.x = x2;\n      this.y = y;\n    }\n    get width() {\n      return this.x;\n    }\n    set width(value) {\n      this.x = value;\n    }\n    get height() {\n      return this.y;\n    }\n    set height(value) {\n      this.y = value;\n    }\n    set(x2, y) {\n      this.x = x2;\n      this.y = y;\n      return this;\n    }\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      return this;\n    }\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        default:\n          throw new Error(\"index is out of range: \" + index);\n      }\n      return this;\n    }\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        default:\n          throw new Error(\"index is out of range: \" + index);\n      }\n    }\n    clone() {\n      return new this.constructor(this.x, this.y);\n    }\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      return this;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      return this;\n    }\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      return this;\n    }\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      return this;\n    }\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      return this;\n    }\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      return this;\n    }\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      return this;\n    }\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      return this;\n    }\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      return this;\n    }\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      return this;\n    }\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      return this;\n    }\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    applyMatrix3(m) {\n      const x2 = this.x, y = this.y;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[3] * y + e[6];\n      this.y = e[1] * x2 + e[4] * y + e[7];\n      return this;\n    }\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      return this;\n    }\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      return this;\n    }\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      return this;\n    }\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      return this;\n    }\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    }\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      return this;\n    }\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    }\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      return this;\n    }\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      return this;\n    }\n    dot(v) {\n      return this.x * v.x + this.y * v.y;\n    }\n    cross(v) {\n      return this.x * v.y - this.y * v.x;\n    }\n    lengthSq() {\n      return this.x * this.x + this.y * this.y;\n    }\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y);\n    }\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    angle() {\n      const angle = Math.atan2(-this.y, -this.x) + Math.PI;\n      return angle;\n    }\n    angleTo(v) {\n      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n      if (denominator === 0) return Math.PI / 2;\n      const theta = this.dot(v) / denominator;\n      return Math.acos(clamp(theta, -1, 1));\n    }\n    distanceTo(v) {\n      return Math.sqrt(this.distanceToSquared(v));\n    }\n    distanceToSquared(v) {\n      const dx = this.x - v.x, dy = this.y - v.y;\n      return dx * dx + dy * dy;\n    }\n    manhattanDistanceTo(v) {\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n    }\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      return this;\n    }\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      return this;\n    }\n    equals(v) {\n      return v.x === this.x && v.y === this.y;\n    }\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      return this;\n    }\n    rotateAround(center, angle) {\n      const c = Math.cos(angle), s = Math.sin(angle);\n      const x2 = this.x - center.x;\n      const y = this.y - center.y;\n      this.x = x2 * c - y * s + center.x;\n      this.y = x2 * s + y * c + center.y;\n      return this;\n    }\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n    }\n  }\n  class Matrix3 {\n    constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      Matrix3.prototype.isMatrix3 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\n      }\n    }\n    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      const te = this.elements;\n      te[0] = n11;\n      te[1] = n21;\n      te[2] = n31;\n      te[3] = n12;\n      te[4] = n22;\n      te[5] = n32;\n      te[6] = n13;\n      te[7] = n23;\n      te[8] = n33;\n      return this;\n    }\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    copy(m) {\n      const te = this.elements;\n      const me = m.elements;\n      te[0] = me[0];\n      te[1] = me[1];\n      te[2] = me[2];\n      te[3] = me[3];\n      te[4] = me[4];\n      te[5] = me[5];\n      te[6] = me[6];\n      te[7] = me[7];\n      te[8] = me[8];\n      return this;\n    }\n    extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.setFromMatrix3Column(this, 0);\n      yAxis.setFromMatrix3Column(this, 1);\n      zAxis.setFromMatrix3Column(this, 2);\n      return this;\n    }\n    setFromMatrix4(m) {\n      const me = m.elements;\n      this.set(\n        me[0],\n        me[4],\n        me[8],\n        me[1],\n        me[5],\n        me[9],\n        me[2],\n        me[6],\n        me[10]\n      );\n      return this;\n    }\n    multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n    premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n    multiplyMatrices(a, b) {\n      const ae = a.elements;\n      const be = b.elements;\n      const te = this.elements;\n      const a11 = ae[0], a12 = ae[3], a13 = ae[6];\n      const a21 = ae[1], a22 = ae[4], a23 = ae[7];\n      const a31 = ae[2], a32 = ae[5], a33 = ae[8];\n      const b11 = be[0], b12 = be[3], b13 = be[6];\n      const b21 = be[1], b22 = be[4], b23 = be[7];\n      const b31 = be[2], b32 = be[5], b33 = be[8];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n      te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n      te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n      te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n      te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n      te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n      te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n      return this;\n    }\n    multiplyScalar(s) {\n      const te = this.elements;\n      te[0] *= s;\n      te[3] *= s;\n      te[6] *= s;\n      te[1] *= s;\n      te[4] *= s;\n      te[7] *= s;\n      te[2] *= s;\n      te[5] *= s;\n      te[8] *= s;\n      return this;\n    }\n    determinant() {\n      const te = this.elements;\n      const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];\n      return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;\n    }\n    invert() {\n      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n      const detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n31 * n23 - n33 * n21) * detInv;\n      te[2] = (n32 * n21 - n31 * n22) * detInv;\n      te[3] = t12 * detInv;\n      te[4] = (n33 * n11 - n31 * n13) * detInv;\n      te[5] = (n31 * n12 - n32 * n11) * detInv;\n      te[6] = t13 * detInv;\n      te[7] = (n21 * n13 - n23 * n11) * detInv;\n      te[8] = (n22 * n11 - n21 * n12) * detInv;\n      return this;\n    }\n    transpose() {\n      let tmp;\n      const m = this.elements;\n      tmp = m[1];\n      m[1] = m[3];\n      m[3] = tmp;\n      tmp = m[2];\n      m[2] = m[6];\n      m[6] = tmp;\n      tmp = m[5];\n      m[5] = m[7];\n      m[7] = tmp;\n      return this;\n    }\n    getNormalMatrix(matrix4) {\n      return this.setFromMatrix4(matrix4).invert().transpose();\n    }\n    transposeIntoArray(r) {\n      const m = this.elements;\n      r[0] = m[0];\n      r[1] = m[3];\n      r[2] = m[6];\n      r[3] = m[1];\n      r[4] = m[4];\n      r[5] = m[7];\n      r[6] = m[2];\n      r[7] = m[5];\n      r[8] = m[8];\n      return this;\n    }\n    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n      const c = Math.cos(rotation);\n      const s = Math.sin(rotation);\n      this.set(\n        sx * c,\n        sx * s,\n        -sx * (c * cx + s * cy) + cx + tx,\n        -sy * s,\n        sy * c,\n        -sy * (-s * cx + c * cy) + cy + ty,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    //\n    scale(sx, sy) {\n      this.premultiply(_m3.makeScale(sx, sy));\n      return this;\n    }\n    rotate(theta) {\n      this.premultiply(_m3.makeRotation(-theta));\n      return this;\n    }\n    translate(tx, ty) {\n      this.premultiply(_m3.makeTranslation(tx, ty));\n      return this;\n    }\n    // for 2D Transforms\n    makeTranslation(x2, y) {\n      if (x2.isVector2) {\n        this.set(\n          1,\n          0,\n          x2.x,\n          0,\n          1,\n          x2.y,\n          0,\n          0,\n          1\n        );\n      } else {\n        this.set(\n          1,\n          0,\n          x2,\n          0,\n          1,\n          y,\n          0,\n          0,\n          1\n        );\n      }\n      return this;\n    }\n    makeRotation(theta) {\n      const c = Math.cos(theta);\n      const s = Math.sin(theta);\n      this.set(\n        c,\n        -s,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeScale(x2, y) {\n      this.set(\n        x2,\n        0,\n        0,\n        0,\n        y,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    //\n    equals(matrix) {\n      const te = this.elements;\n      const me = matrix.elements;\n      for (let i2 = 0; i2 < 9; i2++) {\n        if (te[i2] !== me[i2]) return false;\n      }\n      return true;\n    }\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 9; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      const te = this.elements;\n      array[offset] = te[0];\n      array[offset + 1] = te[1];\n      array[offset + 2] = te[2];\n      array[offset + 3] = te[3];\n      array[offset + 4] = te[4];\n      array[offset + 5] = te[5];\n      array[offset + 6] = te[6];\n      array[offset + 7] = te[7];\n      array[offset + 8] = te[8];\n      return array;\n    }\n    clone() {\n      return new this.constructor().fromArray(this.elements);\n    }\n  }\n  const _m3 = /* @__PURE__ */ new Matrix3();\n  function arrayNeedsUint32(array) {\n    for (let i2 = array.length - 1; i2 >= 0; --i2) {\n      if (array[i2] >= 65535) return true;\n    }\n    return false;\n  }\n  function createElementNS(name) {\n    return document.createElementNS(\"http://www.w3.org/1999/xhtml\", name);\n  }\n  const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(\n    0.4123908,\n    0.3575843,\n    0.1804808,\n    0.212639,\n    0.7151687,\n    0.0721923,\n    0.0193308,\n    0.1191948,\n    0.9505322\n  );\n  const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(\n    3.2409699,\n    -1.5373832,\n    -0.4986108,\n    -0.9692436,\n    1.8759675,\n    0.0415551,\n    0.0556301,\n    -0.203977,\n    1.0569715\n  );\n  function createColorManagement() {\n    const ColorManagement2 = {\n      enabled: true,\n      workingColorSpace: LinearSRGBColorSpace,\n      /**\n       * Implementations of supported color spaces.\n       *\n       * Required:\n       *\t- primaries: chromaticity coordinates [ rx ry gx gy bx by ]\n       *\t- whitePoint: reference white [ x y ]\n       *\t- transfer: transfer function (pre-defined)\n       *\t- toXYZ: Matrix3 RGB to XYZ transform\n       *\t- fromXYZ: Matrix3 XYZ to RGB transform\n       *\t- luminanceCoefficients: RGB luminance coefficients\n       *\n       * Optional:\n       *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }\n       *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }\n       *\n       * Reference:\n       * - https://www.russellcottrell.com/photo/matrixCalculator.htm\n       */\n      spaces: {},\n      convert: function(color, sourceColorSpace, targetColorSpace) {\n        if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {\n          return color;\n        }\n        if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {\n          color.r = SRGBToLinear(color.r);\n          color.g = SRGBToLinear(color.g);\n          color.b = SRGBToLinear(color.b);\n        }\n        if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {\n          color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);\n          color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);\n        }\n        if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {\n          color.r = LinearToSRGB(color.r);\n          color.g = LinearToSRGB(color.g);\n          color.b = LinearToSRGB(color.b);\n        }\n        return color;\n      },\n      fromWorkingColorSpace: function(color, targetColorSpace) {\n        return this.convert(color, this.workingColorSpace, targetColorSpace);\n      },\n      toWorkingColorSpace: function(color, sourceColorSpace) {\n        return this.convert(color, sourceColorSpace, this.workingColorSpace);\n      },\n      getPrimaries: function(colorSpace) {\n        return this.spaces[colorSpace].primaries;\n      },\n      getTransfer: function(colorSpace) {\n        if (colorSpace === NoColorSpace) return LinearTransfer;\n        return this.spaces[colorSpace].transfer;\n      },\n      getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {\n        return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);\n      },\n      define: function(colorSpaces) {\n        Object.assign(this.spaces, colorSpaces);\n      },\n      // Internal APIs\n      _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {\n        return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);\n      },\n      _getDrawingBufferColorSpace: function(colorSpace) {\n        return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;\n      },\n      _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {\n        return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;\n      }\n    };\n    const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];\n    const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];\n    const D65 = [0.3127, 0.329];\n    ColorManagement2.define({\n      [LinearSRGBColorSpace]: {\n        primaries: REC709_PRIMARIES,\n        whitePoint: D65,\n        transfer: LinearTransfer,\n        toXYZ: LINEAR_REC709_TO_XYZ,\n        fromXYZ: XYZ_TO_LINEAR_REC709,\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n        workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n      },\n      [SRGBColorSpace]: {\n        primaries: REC709_PRIMARIES,\n        whitePoint: D65,\n        transfer: SRGBTransfer,\n        toXYZ: LINEAR_REC709_TO_XYZ,\n        fromXYZ: XYZ_TO_LINEAR_REC709,\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n      }\n    });\n    return ColorManagement2;\n  }\n  const ColorManagement = /* @__PURE__ */ createColorManagement();\n  function SRGBToLinear(c) {\n    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n  }\n  function LinearToSRGB(c) {\n    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n  }\n  let _canvas;\n  class ImageUtils {\n    static getDataURL(image) {\n      if (/^data:/i.test(image.src)) {\n        return image.src;\n      }\n      if (typeof HTMLCanvasElement === \"undefined\") {\n        return image.src;\n      }\n      let canvas;\n      if (image instanceof HTMLCanvasElement) {\n        canvas = image;\n      } else {\n        if (_canvas === void 0) _canvas = createElementNS(\"canvas\");\n        _canvas.width = image.width;\n        _canvas.height = image.height;\n        const context = _canvas.getContext(\"2d\");\n        if (image instanceof ImageData) {\n          context.putImageData(image, 0, 0);\n        } else {\n          context.drawImage(image, 0, 0, image.width, image.height);\n        }\n        canvas = _canvas;\n      }\n      if (canvas.width > 2048 || canvas.height > 2048) {\n        console.warn(\"THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons\", image);\n        return canvas.toDataURL(\"image/jpeg\", 0.6);\n      } else {\n        return canvas.toDataURL(\"image/png\");\n      }\n    }\n    static sRGBToLinear(image) {\n      if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap) {\n        const canvas = createElementNS(\"canvas\");\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const context = canvas.getContext(\"2d\");\n        context.drawImage(image, 0, 0, image.width, image.height);\n        const imageData = context.getImageData(0, 0, image.width, image.height);\n        const data = imageData.data;\n        for (let i2 = 0; i2 < data.length; i2++) {\n          data[i2] = SRGBToLinear(data[i2] / 255) * 255;\n        }\n        context.putImageData(imageData, 0, 0);\n        return canvas;\n      } else if (image.data) {\n        const data = image.data.slice(0);\n        for (let i2 = 0; i2 < data.length; i2++) {\n          if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {\n            data[i2] = Math.floor(SRGBToLinear(data[i2] / 255) * 255);\n          } else {\n            data[i2] = SRGBToLinear(data[i2]);\n          }\n        }\n        return {\n          data,\n          width: image.width,\n          height: image.height\n        };\n      } else {\n        console.warn(\"THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.\");\n        return image;\n      }\n    }\n  }\n  let _sourceId = 0;\n  class Source {\n    constructor(data = null) {\n      this.isSource = true;\n      Object.defineProperty(this, \"id\", { value: _sourceId++ });\n      this.uuid = generateUUID();\n      this.data = data;\n      this.dataReady = true;\n      this.version = 0;\n    }\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === \"string\";\n      if (!isRootObject && meta.images[this.uuid] !== void 0) {\n        return meta.images[this.uuid];\n      }\n      const output = {\n        uuid: this.uuid,\n        url: \"\"\n      };\n      const data = this.data;\n      if (data !== null) {\n        let url;\n        if (Array.isArray(data)) {\n          url = [];\n          for (let i2 = 0, l = data.length; i2 < l; i2++) {\n            if (data[i2].isDataTexture) {\n              url.push(serializeImage(data[i2].image));\n            } else {\n              url.push(serializeImage(data[i2]));\n            }\n          }\n        } else {\n          url = serializeImage(data);\n        }\n        output.url = url;\n      }\n      if (!isRootObject) {\n        meta.images[this.uuid] = output;\n      }\n      return output;\n    }\n  }\n  function serializeImage(image) {\n    if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap) {\n      return ImageUtils.getDataURL(image);\n    } else {\n      if (image.data) {\n        return {\n          data: Array.from(image.data),\n          width: image.width,\n          height: image.height,\n          type: image.data.constructor.name\n        };\n      } else {\n        console.warn(\"THREE.Texture: Unable to serialize Texture.\");\n        return {};\n      }\n    }\n  }\n  let _textureId = 0;\n  class Texture extends EventDispatcher {\n    constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {\n      super();\n      this.isTexture = true;\n      Object.defineProperty(this, \"id\", { value: _textureId++ });\n      this.uuid = generateUUID();\n      this.name = \"\";\n      this.source = new Source(image);\n      this.mipmaps = [];\n      this.mapping = mapping;\n      this.channel = 0;\n      this.wrapS = wrapS;\n      this.wrapT = wrapT;\n      this.magFilter = magFilter;\n      this.minFilter = minFilter;\n      this.anisotropy = anisotropy;\n      this.format = format;\n      this.internalFormat = null;\n      this.type = type;\n      this.offset = new Vector2(0, 0);\n      this.repeat = new Vector2(1, 1);\n      this.center = new Vector2(0, 0);\n      this.rotation = 0;\n      this.matrixAutoUpdate = true;\n      this.matrix = new Matrix3();\n      this.generateMipmaps = true;\n      this.premultiplyAlpha = false;\n      this.flipY = true;\n      this.unpackAlignment = 4;\n      this.colorSpace = colorSpace;\n      this.userData = {};\n      this.version = 0;\n      this.onUpdate = null;\n      this.renderTarget = null;\n      this.isRenderTargetTexture = false;\n      this.pmremVersion = 0;\n    }\n    get image() {\n      return this.source.data;\n    }\n    set image(value = null) {\n      this.source.data = value;\n    }\n    updateMatrix() {\n      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.name = source.name;\n      this.source = source.source;\n      this.mipmaps = source.mipmaps.slice(0);\n      this.mapping = source.mapping;\n      this.channel = source.channel;\n      this.wrapS = source.wrapS;\n      this.wrapT = source.wrapT;\n      this.magFilter = source.magFilter;\n      this.minFilter = source.minFilter;\n      this.anisotropy = source.anisotropy;\n      this.format = source.format;\n      this.internalFormat = source.internalFormat;\n      this.type = source.type;\n      this.offset.copy(source.offset);\n      this.repeat.copy(source.repeat);\n      this.center.copy(source.center);\n      this.rotation = source.rotation;\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      this.matrix.copy(source.matrix);\n      this.generateMipmaps = source.generateMipmaps;\n      this.premultiplyAlpha = source.premultiplyAlpha;\n      this.flipY = source.flipY;\n      this.unpackAlignment = source.unpackAlignment;\n      this.colorSpace = source.colorSpace;\n      this.renderTarget = source.renderTarget;\n      this.isRenderTargetTexture = source.isRenderTargetTexture;\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      this.needsUpdate = true;\n      return this;\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === \"string\";\n      if (!isRootObject && meta.textures[this.uuid] !== void 0) {\n        return meta.textures[this.uuid];\n      }\n      const output = {\n        metadata: {\n          version: 4.6,\n          type: \"Texture\",\n          generator: \"Texture.toJSON\"\n        },\n        uuid: this.uuid,\n        name: this.name,\n        image: this.source.toJSON(meta).uuid,\n        mapping: this.mapping,\n        channel: this.channel,\n        repeat: [this.repeat.x, this.repeat.y],\n        offset: [this.offset.x, this.offset.y],\n        center: [this.center.x, this.center.y],\n        rotation: this.rotation,\n        wrap: [this.wrapS, this.wrapT],\n        format: this.format,\n        internalFormat: this.internalFormat,\n        type: this.type,\n        colorSpace: this.colorSpace,\n        minFilter: this.minFilter,\n        magFilter: this.magFilter,\n        anisotropy: this.anisotropy,\n        flipY: this.flipY,\n        generateMipmaps: this.generateMipmaps,\n        premultiplyAlpha: this.premultiplyAlpha,\n        unpackAlignment: this.unpackAlignment\n      };\n      if (Object.keys(this.userData).length > 0) output.userData = this.userData;\n      if (!isRootObject) {\n        meta.textures[this.uuid] = output;\n      }\n      return output;\n    }\n    dispose() {\n      this.dispatchEvent({ type: \"dispose\" });\n    }\n    transformUv(uv) {\n      if (this.mapping !== UVMapping) return uv;\n      uv.applyMatrix3(this.matrix);\n      if (uv.x < 0 || uv.x > 1) {\n        switch (this.wrapS) {\n          case RepeatWrapping:\n            uv.x = uv.x - Math.floor(uv.x);\n            break;\n          case ClampToEdgeWrapping:\n            uv.x = uv.x < 0 ? 0 : 1;\n            break;\n          case MirroredRepeatWrapping:\n            if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n              uv.x = Math.ceil(uv.x) - uv.x;\n            } else {\n              uv.x = uv.x - Math.floor(uv.x);\n            }\n            break;\n        }\n      }\n      if (uv.y < 0 || uv.y > 1) {\n        switch (this.wrapT) {\n          case RepeatWrapping:\n            uv.y = uv.y - Math.floor(uv.y);\n            break;\n          case ClampToEdgeWrapping:\n            uv.y = uv.y < 0 ? 0 : 1;\n            break;\n          case MirroredRepeatWrapping:\n            if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n              uv.y = Math.ceil(uv.y) - uv.y;\n            } else {\n              uv.y = uv.y - Math.floor(uv.y);\n            }\n            break;\n        }\n      }\n      if (this.flipY) {\n        uv.y = 1 - uv.y;\n      }\n      return uv;\n    }\n    set needsUpdate(value) {\n      if (value === true) {\n        this.version++;\n        this.source.needsUpdate = true;\n      }\n    }\n    set needsPMREMUpdate(value) {\n      if (value === true) {\n        this.pmremVersion++;\n      }\n    }\n  }\n  Texture.DEFAULT_IMAGE = null;\n  Texture.DEFAULT_MAPPING = UVMapping;\n  Texture.DEFAULT_ANISOTROPY = 1;\n  class Vector4 {\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\n      Vector4.prototype.isVector4 = true;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n    }\n    get width() {\n      return this.z;\n    }\n    set width(value) {\n      this.z = value;\n    }\n    get height() {\n      return this.w;\n    }\n    set height(value) {\n      this.w = value;\n    }\n    set(x2, y, z, w) {\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n      return this;\n    }\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      this.w = scalar;\n      return this;\n    }\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    setZ(z) {\n      this.z = z;\n      return this;\n    }\n    setW(w) {\n      this.w = w;\n      return this;\n    }\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        case 2:\n          this.z = value;\n          break;\n        case 3:\n          this.w = value;\n          break;\n        default:\n          throw new Error(\"index is out of range: \" + index);\n      }\n      return this;\n    }\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        case 2:\n          return this.z;\n        case 3:\n          return this.w;\n        default:\n          throw new Error(\"index is out of range: \" + index);\n      }\n    }\n    clone() {\n      return new this.constructor(this.x, this.y, this.z, this.w);\n    }\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      this.w = v.w !== void 0 ? v.w : 1;\n      return this;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      this.w += v.w;\n      return this;\n    }\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      this.w += s;\n      return this;\n    }\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      this.w = a.w + b.w;\n      return this;\n    }\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      this.w += v.w * s;\n      return this;\n    }\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      this.w -= v.w;\n      return this;\n    }\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      this.w -= s;\n      return this;\n    }\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      this.w = a.w - b.w;\n      return this;\n    }\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      this.w *= v.w;\n      return this;\n    }\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      this.w *= scalar;\n      return this;\n    }\n    applyMatrix4(m) {\n      const x2 = this.x, y = this.y, z = this.z, w = this.w;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[4] * y + e[8] * z + e[12] * w;\n      this.y = e[1] * x2 + e[5] * y + e[9] * z + e[13] * w;\n      this.z = e[2] * x2 + e[6] * y + e[10] * z + e[14] * w;\n      this.w = e[3] * x2 + e[7] * y + e[11] * z + e[15] * w;\n      return this;\n    }\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n      this.w /= v.w;\n      return this;\n    }\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    setAxisAngleFromQuaternion(q) {\n      this.w = 2 * Math.acos(q.w);\n      const s = Math.sqrt(1 - q.w * q.w);\n      if (s < 1e-4) {\n        this.x = 1;\n        this.y = 0;\n        this.z = 0;\n      } else {\n        this.x = q.x / s;\n        this.y = q.y / s;\n        this.z = q.z / s;\n      }\n      return this;\n    }\n    setAxisAngleFromRotationMatrix(m) {\n      let angle, x2, y, z;\n      const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];\n      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n          this.set(1, 0, 0, 0);\n          return this;\n        }\n        angle = Math.PI;\n        const xx = (m11 + 1) / 2;\n        const yy = (m22 + 1) / 2;\n        const zz = (m33 + 1) / 2;\n        const xy = (m12 + m21) / 4;\n        const xz = (m13 + m31) / 4;\n        const yz = (m23 + m32) / 4;\n        if (xx > yy && xx > zz) {\n          if (xx < epsilon) {\n            x2 = 0;\n            y = 0.707106781;\n            z = 0.707106781;\n          } else {\n            x2 = Math.sqrt(xx);\n            y = xy / x2;\n            z = xz / x2;\n          }\n        } else if (yy > zz) {\n          if (yy < epsilon) {\n            x2 = 0.707106781;\n            y = 0;\n            z = 0.707106781;\n          } else {\n            y = Math.sqrt(yy);\n            x2 = xy / y;\n            z = yz / y;\n          }\n        } else {\n          if (zz < epsilon) {\n            x2 = 0.707106781;\n            y = 0.707106781;\n            z = 0;\n          } else {\n            z = Math.sqrt(zz);\n            x2 = xz / z;\n            y = yz / z;\n          }\n        }\n        this.set(x2, y, z, angle);\n        return this;\n      }\n      let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));\n      if (Math.abs(s) < 1e-3) s = 1;\n      this.x = (m32 - m23) / s;\n      this.y = (m13 - m31) / s;\n      this.z = (m21 - m12) / s;\n      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n      return this;\n    }\n    setFromMatrixPosition(m) {\n      const e = m.elements;\n      this.x = e[12];\n      this.y = e[13];\n      this.z = e[14];\n      this.w = e[15];\n      return this;\n    }\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      this.w = Math.min(this.w, v.w);\n      return this;\n    }\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      this.w = Math.max(this.w, v.w);\n      return this;\n    }\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      this.z = clamp(this.z, min.z, max2.z);\n      this.w = clamp(this.w, min.w, max2.w);\n      return this;\n    }\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      this.z = clamp(this.z, minVal, maxVal);\n      this.w = clamp(this.w, minVal, maxVal);\n      return this;\n    }\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      this.z = Math.floor(this.z);\n      this.w = Math.floor(this.w);\n      return this;\n    }\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      this.z = Math.ceil(this.z);\n      this.w = Math.ceil(this.w);\n      return this;\n    }\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      this.z = Math.round(this.z);\n      this.w = Math.round(this.w);\n      return this;\n    }\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      this.z = Math.trunc(this.z);\n      this.w = Math.trunc(this.w);\n      return this;\n    }\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      this.w = -this.w;\n      return this;\n    }\n    dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n    }\n    lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    }\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    }\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n    }\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      this.z += (v.z - this.z) * alpha;\n      this.w += (v.w - this.w) * alpha;\n      return this;\n    }\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      this.z = v1.z + (v2.z - v1.z) * alpha;\n      this.w = v1.w + (v2.w - v1.w) * alpha;\n      return this;\n    }\n    equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n    }\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      this.w = array[offset + 3];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      array[offset + 3] = this.w;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      this.z = attribute.getZ(index);\n      this.w = attribute.getW(index);\n      return this;\n    }\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      this.z = Math.random();\n      this.w = Math.random();\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n      yield this.z;\n      yield this.w;\n    }\n  }\n  class RenderTarget extends EventDispatcher {\n    constructor(width = 1, height = 1, options = {}) {\n      super();\n      this.isRenderTarget = true;\n      this.width = width;\n      this.height = height;\n      this.depth = 1;\n      this.scissor = new Vector4(0, 0, width, height);\n      this.scissorTest = false;\n      this.viewport = new Vector4(0, 0, width, height);\n      const image = { width, height, depth: 1 };\n      options = Object.assign({\n        generateMipmaps: false,\n        internalFormat: null,\n        minFilter: LinearFilter,\n        depthBuffer: true,\n        stencilBuffer: false,\n        resolveDepthBuffer: true,\n        resolveStencilBuffer: true,\n        depthTexture: null,\n        samples: 0,\n        count: 1\n      }, options);\n      const texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);\n      texture.flipY = false;\n      texture.generateMipmaps = options.generateMipmaps;\n      texture.internalFormat = options.internalFormat;\n      this.textures = [];\n      const count = options.count;\n      for (let i2 = 0; i2 < count; i2++) {\n        this.textures[i2] = texture.clone();\n        this.textures[i2].isRenderTargetTexture = true;\n        this.textures[i2].renderTarget = this;\n      }\n      this.depthBuffer = options.depthBuffer;\n      this.stencilBuffer = options.stencilBuffer;\n      this.resolveDepthBuffer = options.resolveDepthBuffer;\n      this.resolveStencilBuffer = options.resolveStencilBuffer;\n      this._depthTexture = null;\n      this.depthTexture = options.depthTexture;\n      this.samples = options.samples;\n    }\n    get texture() {\n      return this.textures[0];\n    }\n    set texture(value) {\n      this.textures[0] = value;\n    }\n    set depthTexture(current) {\n      if (this._depthTexture !== null) this._depthTexture.renderTarget = null;\n      if (current !== null) current.renderTarget = this;\n      this._depthTexture = current;\n    }\n    get depthTexture() {\n      return this._depthTexture;\n    }\n    setSize(width, height, depth = 1) {\n      if (this.width !== width || this.height !== height || this.depth !== depth) {\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        for (let i2 = 0, il = this.textures.length; i2 < il; i2++) {\n          this.textures[i2].image.width = width;\n          this.textures[i2].image.height = height;\n          this.textures[i2].image.depth = depth;\n        }\n        this.dispose();\n      }\n      this.viewport.set(0, 0, width, height);\n      this.scissor.set(0, 0, width, height);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.width = source.width;\n      this.height = source.height;\n      this.depth = source.depth;\n      this.scissor.copy(source.scissor);\n      this.scissorTest = source.scissorTest;\n      this.viewport.copy(source.viewport);\n      this.textures.length = 0;\n      for (let i2 = 0, il = source.textures.length; i2 < il; i2++) {\n        this.textures[i2] = source.textures[i2].clone();\n        this.textures[i2].isRenderTargetTexture = true;\n        this.textures[i2].renderTarget = this;\n      }\n      const image = Object.assign({}, source.texture.image);\n      this.texture.source = new Source(image);\n      this.depthBuffer = source.depthBuffer;\n      this.stencilBuffer = source.stencilBuffer;\n      this.resolveDepthBuffer = source.resolveDepthBuffer;\n      this.resolveStencilBuffer = source.resolveStencilBuffer;\n      if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();\n      this.samples = source.samples;\n      return this;\n    }\n    dispose() {\n      this.dispatchEvent({ type: \"dispose\" });\n    }\n  }\n  class WebGLRenderTarget extends RenderTarget {\n    constructor(width = 1, height = 1, options = {}) {\n      super(width, height, options);\n      this.isWebGLRenderTarget = true;\n    }\n  }\n  class DataArrayTexture extends Texture {\n    constructor(data = null, width = 1, height = 1, depth = 1) {\n      super(null);\n      this.isDataArrayTexture = true;\n      this.image = { data, width, height, depth };\n      this.magFilter = NearestFilter;\n      this.minFilter = NearestFilter;\n      this.wrapR = ClampToEdgeWrapping;\n      this.generateMipmaps = false;\n      this.flipY = false;\n      this.unpackAlignment = 1;\n      this.layerUpdates = /* @__PURE__ */ new Set();\n    }\n    addLayerUpdate(layerIndex) {\n      this.layerUpdates.add(layerIndex);\n    }\n    clearLayerUpdates() {\n      this.layerUpdates.clear();\n    }\n  }\n  class WebGLArrayRenderTarget extends WebGLRenderTarget {\n    constructor(width = 1, height = 1, depth = 1, options = {}) {\n      super(width, height, options);\n      this.isWebGLArrayRenderTarget = true;\n      this.depth = depth;\n      this.texture = new DataArrayTexture(null, width, height, depth);\n      this.texture.isRenderTargetTexture = true;\n    }\n  }\n  class Quaternion {\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\n      this.isQuaternion = true;\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n    }\n    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];\n      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];\n      if (t === 0) {\n        dst[dstOffset + 0] = x0;\n        dst[dstOffset + 1] = y0;\n        dst[dstOffset + 2] = z0;\n        dst[dstOffset + 3] = w0;\n        return;\n      }\n      if (t === 1) {\n        dst[dstOffset + 0] = x1;\n        dst[dstOffset + 1] = y1;\n        dst[dstOffset + 2] = z1;\n        dst[dstOffset + 3] = w1;\n        return;\n      }\n      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n        let s = 1 - t;\n        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;\n        if (sqrSin > Number.EPSILON) {\n          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);\n          s = Math.sin(s * len) / sin;\n          t = Math.sin(t * len) / sin;\n        }\n        const tDir = t * dir;\n        x0 = x0 * s + x1 * tDir;\n        y0 = y0 * s + y1 * tDir;\n        z0 = z0 * s + z1 * tDir;\n        w0 = w0 * s + w1 * tDir;\n        if (s === 1 - t) {\n          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n          x0 *= f;\n          y0 *= f;\n          z0 *= f;\n          w0 *= f;\n        }\n      }\n      dst[dstOffset] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n    }\n    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n      const x0 = src0[srcOffset0];\n      const y0 = src0[srcOffset0 + 1];\n      const z0 = src0[srcOffset0 + 2];\n      const w0 = src0[srcOffset0 + 3];\n      const x1 = src1[srcOffset1];\n      const y1 = src1[srcOffset1 + 1];\n      const z1 = src1[srcOffset1 + 2];\n      const w1 = src1[srcOffset1 + 3];\n      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n      return dst;\n    }\n    get x() {\n      return this._x;\n    }\n    set x(value) {\n      this._x = value;\n      this._onChangeCallback();\n    }\n    get y() {\n      return this._y;\n    }\n    set y(value) {\n      this._y = value;\n      this._onChangeCallback();\n    }\n    get z() {\n      return this._z;\n    }\n    set z(value) {\n      this._z = value;\n      this._onChangeCallback();\n    }\n    get w() {\n      return this._w;\n    }\n    set w(value) {\n      this._w = value;\n      this._onChangeCallback();\n    }\n    set(x2, y, z, w) {\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n      this._onChangeCallback();\n      return this;\n    }\n    clone() {\n      return new this.constructor(this._x, this._y, this._z, this._w);\n    }\n    copy(quaternion) {\n      this._x = quaternion.x;\n      this._y = quaternion.y;\n      this._z = quaternion.z;\n      this._w = quaternion.w;\n      this._onChangeCallback();\n      return this;\n    }\n    setFromEuler(euler, update = true) {\n      const x2 = euler._x, y = euler._y, z = euler._z, order = euler._order;\n      const cos = Math.cos;\n      const sin = Math.sin;\n      const c1 = cos(x2 / 2);\n      const c2 = cos(y / 2);\n      const c3 = cos(z / 2);\n      const s1 = sin(x2 / 2);\n      const s2 = sin(y / 2);\n      const s3 = sin(z / 2);\n      switch (order) {\n        case \"XYZ\":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case \"YXZ\":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        case \"ZXY\":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case \"ZYX\":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        case \"YZX\":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case \"XZY\":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        default:\n          console.warn(\"THREE.Quaternion: .setFromEuler() encountered an unknown order: \" + order);\n      }\n      if (update === true) this._onChangeCallback();\n      return this;\n    }\n    setFromAxisAngle(axis, angle) {\n      const halfAngle = angle / 2, s = Math.sin(halfAngle);\n      this._x = axis.x * s;\n      this._y = axis.y * s;\n      this._z = axis.z * s;\n      this._w = Math.cos(halfAngle);\n      this._onChangeCallback();\n      return this;\n    }\n    setFromRotationMatrix(m) {\n      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;\n      if (trace > 0) {\n        const s = 0.5 / Math.sqrt(trace + 1);\n        this._w = 0.25 / s;\n        this._x = (m32 - m23) * s;\n        this._y = (m13 - m31) * s;\n        this._z = (m21 - m12) * s;\n      } else if (m11 > m22 && m11 > m33) {\n        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);\n        this._w = (m32 - m23) / s;\n        this._x = 0.25 * s;\n        this._y = (m12 + m21) / s;\n        this._z = (m13 + m31) / s;\n      } else if (m22 > m33) {\n        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);\n        this._w = (m13 - m31) / s;\n        this._x = (m12 + m21) / s;\n        this._y = 0.25 * s;\n        this._z = (m23 + m32) / s;\n      } else {\n        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);\n        this._w = (m21 - m12) / s;\n        this._x = (m13 + m31) / s;\n        this._y = (m23 + m32) / s;\n        this._z = 0.25 * s;\n      }\n      this._onChangeCallback();\n      return this;\n    }\n    setFromUnitVectors(vFrom, vTo) {\n      let r = vFrom.dot(vTo) + 1;\n      if (r < Number.EPSILON) {\n        r = 0;\n        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n          this._x = -vFrom.y;\n          this._y = vFrom.x;\n          this._z = 0;\n          this._w = r;\n        } else {\n          this._x = 0;\n          this._y = -vFrom.z;\n          this._z = vFrom.y;\n          this._w = r;\n        }\n      } else {\n        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n        this._w = r;\n      }\n      return this.normalize();\n    }\n    angleTo(q) {\n      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\n    }\n    rotateTowards(q, step) {\n      const angle = this.angleTo(q);\n      if (angle === 0) return this;\n      const t = Math.min(1, step / angle);\n      this.slerp(q, t);\n      return this;\n    }\n    identity() {\n      return this.set(0, 0, 0, 1);\n    }\n    invert() {\n      return this.conjugate();\n    }\n    conjugate() {\n      this._x *= -1;\n      this._y *= -1;\n      this._z *= -1;\n      this._onChangeCallback();\n      return this;\n    }\n    dot(v) {\n      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n    }\n    lengthSq() {\n      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n    }\n    length() {\n      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n    }\n    normalize() {\n      let l = this.length();\n      if (l === 0) {\n        this._x = 0;\n        this._y = 0;\n        this._z = 0;\n        this._w = 1;\n      } else {\n        l = 1 / l;\n        this._x = this._x * l;\n        this._y = this._y * l;\n        this._z = this._z * l;\n        this._w = this._w * l;\n      }\n      this._onChangeCallback();\n      return this;\n    }\n    multiply(q) {\n      return this.multiplyQuaternions(this, q);\n    }\n    premultiply(q) {\n      return this.multiplyQuaternions(q, this);\n    }\n    multiplyQuaternions(a, b) {\n      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n      const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n      this._onChangeCallback();\n      return this;\n    }\n    slerp(qb, t) {\n      if (t === 0) return this;\n      if (t === 1) return this.copy(qb);\n      const x2 = this._x, y = this._y, z = this._z, w = this._w;\n      let cosHalfTheta = w * qb._w + x2 * qb._x + y * qb._y + z * qb._z;\n      if (cosHalfTheta < 0) {\n        this._w = -qb._w;\n        this._x = -qb._x;\n        this._y = -qb._y;\n        this._z = -qb._z;\n        cosHalfTheta = -cosHalfTheta;\n      } else {\n        this.copy(qb);\n      }\n      if (cosHalfTheta >= 1) {\n        this._w = w;\n        this._x = x2;\n        this._y = y;\n        this._z = z;\n        return this;\n      }\n      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;\n      if (sqrSinHalfTheta <= Number.EPSILON) {\n        const s = 1 - t;\n        this._w = s * w + t * this._w;\n        this._x = s * x2 + t * this._x;\n        this._y = s * y + t * this._y;\n        this._z = s * z + t * this._z;\n        this.normalize();\n        return this;\n      }\n      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n      this._w = w * ratioA + this._w * ratioB;\n      this._x = x2 * ratioA + this._x * ratioB;\n      this._y = y * ratioA + this._y * ratioB;\n      this._z = z * ratioA + this._z * ratioB;\n      this._onChangeCallback();\n      return this;\n    }\n    slerpQuaternions(qa, qb, t) {\n      return this.copy(qa).slerp(qb, t);\n    }\n    random() {\n      const theta1 = 2 * Math.PI * Math.random();\n      const theta2 = 2 * Math.PI * Math.random();\n      const x0 = Math.random();\n      const r1 = Math.sqrt(1 - x0);\n      const r2 = Math.sqrt(x0);\n      return this.set(\n        r1 * Math.sin(theta1),\n        r1 * Math.cos(theta1),\n        r2 * Math.sin(theta2),\n        r2 * Math.cos(theta2)\n      );\n    }\n    equals(quaternion) {\n      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n    }\n    fromArray(array, offset = 0) {\n      this._x = array[offset];\n      this._y = array[offset + 1];\n      this._z = array[offset + 2];\n      this._w = array[offset + 3];\n      this._onChangeCallback();\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._w;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this._x = attribute.getX(index);\n      this._y = attribute.getY(index);\n      this._z = attribute.getZ(index);\n      this._w = attribute.getW(index);\n      this._onChangeCallback();\n      return this;\n    }\n    toJSON() {\n      return this.toArray();\n    }\n    _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n    _onChangeCallback() {\n    }\n    *[Symbol.iterator]() {\n      yield this._x;\n      yield this._y;\n      yield this._z;\n      yield this._w;\n    }\n  }\n  class Vector3 {\n    constructor(x2 = 0, y = 0, z = 0) {\n      Vector3.prototype.isVector3 = true;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n    }\n    set(x2, y, z) {\n      if (z === void 0) z = this.z;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      return this;\n    }\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      return this;\n    }\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    setZ(z) {\n      this.z = z;\n      return this;\n    }\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        case 2:\n          this.z = value;\n          break;\n        default:\n          throw new Error(\"index is out of range: \" + index);\n      }\n      return this;\n    }\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        case 2:\n          return this.z;\n        default:\n          throw new Error(\"index is out of range: \" + index);\n      }\n    }\n    clone() {\n      return new this.constructor(this.x, this.y, this.z);\n    }\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      return this;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      return this;\n    }\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      return this;\n    }\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      return this;\n    }\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      return this;\n    }\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      return this;\n    }\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      return this;\n    }\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      return this;\n    }\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      return this;\n    }\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      return this;\n    }\n    multiplyVectors(a, b) {\n      this.x = a.x * b.x;\n      this.y = a.y * b.y;\n      this.z = a.z * b.z;\n      return this;\n    }\n    applyEuler(euler) {\n      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n    }\n    applyAxisAngle(axis, angle) {\n      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n    }\n    applyMatrix3(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[3] * y + e[6] * z;\n      this.y = e[1] * x2 + e[4] * y + e[7] * z;\n      this.z = e[2] * x2 + e[5] * y + e[8] * z;\n      return this;\n    }\n    applyNormalMatrix(m) {\n      return this.applyMatrix3(m).normalize();\n    }\n    applyMatrix4(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      const w = 1 / (e[3] * x2 + e[7] * y + e[11] * z + e[15]);\n      this.x = (e[0] * x2 + e[4] * y + e[8] * z + e[12]) * w;\n      this.y = (e[1] * x2 + e[5] * y + e[9] * z + e[13]) * w;\n      this.z = (e[2] * x2 + e[6] * y + e[10] * z + e[14]) * w;\n      return this;\n    }\n    applyQuaternion(q) {\n      const vx = this.x, vy = this.y, vz = this.z;\n      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n      const tx = 2 * (qy * vz - qz * vy);\n      const ty = 2 * (qz * vx - qx * vz);\n      const tz = 2 * (qx * vy - qy * vx);\n      this.x = vx + qw * tx + qy * tz - qz * ty;\n      this.y = vy + qw * ty + qz * tx - qx * tz;\n      this.z = vz + qw * tz + qx * ty - qy * tx;\n      return this;\n    }\n    project(camera) {\n      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n    }\n    unproject(camera) {\n      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n    }\n    transformDirection(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[4] * y + e[8] * z;\n      this.y = e[1] * x2 + e[5] * y + e[9] * z;\n      this.z = e[2] * x2 + e[6] * y + e[10] * z;\n      return this.normalize();\n    }\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n      return this;\n    }\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      return this;\n    }\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      return this;\n    }\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      this.z = clamp(this.z, min.z, max2.z);\n      return this;\n    }\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      this.z = clamp(this.z, minVal, maxVal);\n      return this;\n    }\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      this.z = Math.floor(this.z);\n      return this;\n    }\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      this.z = Math.ceil(this.z);\n      return this;\n    }\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      this.z = Math.round(this.z);\n      return this;\n    }\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      this.z = Math.trunc(this.z);\n      return this;\n    }\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      return this;\n    }\n    dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n    // TODO lengthSquared?\n    lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n    }\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      this.z += (v.z - this.z) * alpha;\n      return this;\n    }\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      this.z = v1.z + (v2.z - v1.z) * alpha;\n      return this;\n    }\n    cross(v) {\n      return this.crossVectors(this, v);\n    }\n    crossVectors(a, b) {\n      const ax = a.x, ay = a.y, az = a.z;\n      const bx = b.x, by = b.y, bz = b.z;\n      this.x = ay * bz - az * by;\n      this.y = az * bx - ax * bz;\n      this.z = ax * by - ay * bx;\n      return this;\n    }\n    projectOnVector(v) {\n      const denominator = v.lengthSq();\n      if (denominator === 0) return this.set(0, 0, 0);\n      const scalar = v.dot(this) / denominator;\n      return this.copy(v).multiplyScalar(scalar);\n    }\n    projectOnPlane(planeNormal) {\n      _vector$c.copy(this).projectOnVector(planeNormal);\n      return this.sub(_vector$c);\n    }\n    reflect(normal) {\n      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\n    }\n    angleTo(v) {\n      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n      if (denominator === 0) return Math.PI / 2;\n      const theta = this.dot(v) / denominator;\n      return Math.acos(clamp(theta, -1, 1));\n    }\n    distanceTo(v) {\n      return Math.sqrt(this.distanceToSquared(v));\n    }\n    distanceToSquared(v) {\n      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n      return dx * dx + dy * dy + dz * dz;\n    }\n    manhattanDistanceTo(v) {\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n    }\n    setFromSpherical(s) {\n      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n    }\n    setFromSphericalCoords(radius, phi, theta) {\n      const sinPhiRadius = Math.sin(phi) * radius;\n      this.x = sinPhiRadius * Math.sin(theta);\n      this.y = Math.cos(phi) * radius;\n      this.z = sinPhiRadius * Math.cos(theta);\n      return this;\n    }\n    setFromCylindrical(c) {\n      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n    }\n    setFromCylindricalCoords(radius, theta, y) {\n      this.x = radius * Math.sin(theta);\n      this.y = y;\n      this.z = radius * Math.cos(theta);\n      return this;\n    }\n    setFromMatrixPosition(m) {\n      const e = m.elements;\n      this.x = e[12];\n      this.y = e[13];\n      this.z = e[14];\n      return this;\n    }\n    setFromMatrixScale(m) {\n      const sx = this.setFromMatrixColumn(m, 0).length();\n      const sy = this.setFromMatrixColumn(m, 1).length();\n      const sz = this.setFromMatrixColumn(m, 2).length();\n      this.x = sx;\n      this.y = sy;\n      this.z = sz;\n      return this;\n    }\n    setFromMatrixColumn(m, index) {\n      return this.fromArray(m.elements, index * 4);\n    }\n    setFromMatrix3Column(m, index) {\n      return this.fromArray(m.elements, index * 3);\n    }\n    setFromEuler(e) {\n      this.x = e._x;\n      this.y = e._y;\n      this.z = e._z;\n      return this;\n    }\n    setFromColor(c) {\n      this.x = c.r;\n      this.y = c.g;\n      this.z = c.b;\n      return this;\n    }\n    equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z;\n    }\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      this.z = attribute.getZ(index);\n      return this;\n    }\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      this.z = Math.random();\n      return this;\n    }\n    randomDirection() {\n      const theta = Math.random() * Math.PI * 2;\n      const u = Math.random() * 2 - 1;\n      const c = Math.sqrt(1 - u * u);\n      this.x = c * Math.cos(theta);\n      this.y = u;\n      this.z = c * Math.sin(theta);\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n      yield this.z;\n    }\n  }\n  const _vector$c = /* @__PURE__ */ new Vector3();\n  const _quaternion$4 = /* @__PURE__ */ new Quaternion();\n  class Box3 {\n    constructor(min = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {\n      this.isBox3 = true;\n      this.min = min;\n      this.max = max2;\n    }\n    set(min, max2) {\n      this.min.copy(min);\n      this.max.copy(max2);\n      return this;\n    }\n    setFromArray(array) {\n      this.makeEmpty();\n      for (let i2 = 0, il = array.length; i2 < il; i2 += 3) {\n        this.expandByPoint(_vector$b.fromArray(array, i2));\n      }\n      return this;\n    }\n    setFromBufferAttribute(attribute) {\n      this.makeEmpty();\n      for (let i2 = 0, il = attribute.count; i2 < il; i2++) {\n        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i2));\n      }\n      return this;\n    }\n    setFromPoints(points) {\n      this.makeEmpty();\n      for (let i2 = 0, il = points.length; i2 < il; i2++) {\n        this.expandByPoint(points[i2]);\n      }\n      return this;\n    }\n    setFromCenterAndSize(center, size) {\n      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n      this.min.copy(center).sub(halfSize);\n      this.max.copy(center).add(halfSize);\n      return this;\n    }\n    setFromObject(object, precise = false) {\n      this.makeEmpty();\n      return this.expandByObject(object, precise);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(box) {\n      this.min.copy(box.min);\n      this.max.copy(box.max);\n      return this;\n    }\n    makeEmpty() {\n      this.min.x = this.min.y = this.min.z = Infinity;\n      this.max.x = this.max.y = this.max.z = -Infinity;\n      return this;\n    }\n    isEmpty() {\n      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n    }\n    getCenter(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n    }\n    getSize(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n    }\n    expandByPoint(point) {\n      this.min.min(point);\n      this.max.max(point);\n      return this;\n    }\n    expandByVector(vector) {\n      this.min.sub(vector);\n      this.max.add(vector);\n      return this;\n    }\n    expandByScalar(scalar) {\n      this.min.addScalar(-scalar);\n      this.max.addScalar(scalar);\n      return this;\n    }\n    expandByObject(object, precise = false) {\n      object.updateWorldMatrix(false, false);\n      const geometry = object.geometry;\n      if (geometry !== void 0) {\n        const positionAttribute = geometry.getAttribute(\"position\");\n        if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {\n          for (let i2 = 0, l = positionAttribute.count; i2 < l; i2++) {\n            if (object.isMesh === true) {\n              object.getVertexPosition(i2, _vector$b);\n            } else {\n              _vector$b.fromBufferAttribute(positionAttribute, i2);\n            }\n            _vector$b.applyMatrix4(object.matrixWorld);\n            this.expandByPoint(_vector$b);\n          }\n        } else {\n          if (object.boundingBox !== void 0) {\n            if (object.boundingBox === null) {\n              object.computeBoundingBox();\n            }\n            _box$4.copy(object.boundingBox);\n          } else {\n            if (geometry.boundingBox === null) {\n              geometry.computeBoundingBox();\n            }\n            _box$4.copy(geometry.boundingBox);\n          }\n          _box$4.applyMatrix4(object.matrixWorld);\n          this.union(_box$4);\n        }\n      }\n      const children = object.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        this.expandByObject(children[i2], precise);\n      }\n      return this;\n    }\n    containsPoint(point) {\n      return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;\n    }\n    containsBox(box) {\n      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n    }\n    getParameter(point, target) {\n      return target.set(\n        (point.x - this.min.x) / (this.max.x - this.min.x),\n        (point.y - this.min.y) / (this.max.y - this.min.y),\n        (point.z - this.min.z) / (this.max.z - this.min.z)\n      );\n    }\n    intersectsBox(box) {\n      return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;\n    }\n    intersectsSphere(sphere) {\n      this.clampPoint(sphere.center, _vector$b);\n      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    intersectsPlane(plane) {\n      let min, max2;\n      if (plane.normal.x > 0) {\n        min = plane.normal.x * this.min.x;\n        max2 = plane.normal.x * this.max.x;\n      } else {\n        min = plane.normal.x * this.max.x;\n        max2 = plane.normal.x * this.min.x;\n      }\n      if (plane.normal.y > 0) {\n        min += plane.normal.y * this.min.y;\n        max2 += plane.normal.y * this.max.y;\n      } else {\n        min += plane.normal.y * this.max.y;\n        max2 += plane.normal.y * this.min.y;\n      }\n      if (plane.normal.z > 0) {\n        min += plane.normal.z * this.min.z;\n        max2 += plane.normal.z * this.max.z;\n      } else {\n        min += plane.normal.z * this.max.z;\n        max2 += plane.normal.z * this.min.z;\n      }\n      return min <= -plane.constant && max2 >= -plane.constant;\n    }\n    intersectsTriangle(triangle) {\n      if (this.isEmpty()) {\n        return false;\n      }\n      this.getCenter(_center);\n      _extents.subVectors(this.max, _center);\n      _v0$2.subVectors(triangle.a, _center);\n      _v1$7.subVectors(triangle.b, _center);\n      _v2$4.subVectors(triangle.c, _center);\n      _f0.subVectors(_v1$7, _v0$2);\n      _f1.subVectors(_v2$4, _v1$7);\n      _f2.subVectors(_v0$2, _v2$4);\n      let axes = [\n        0,\n        -_f0.z,\n        _f0.y,\n        0,\n        -_f1.z,\n        _f1.y,\n        0,\n        -_f2.z,\n        _f2.y,\n        _f0.z,\n        0,\n        -_f0.x,\n        _f1.z,\n        0,\n        -_f1.x,\n        _f2.z,\n        0,\n        -_f2.x,\n        -_f0.y,\n        _f0.x,\n        0,\n        -_f1.y,\n        _f1.x,\n        0,\n        -_f2.y,\n        _f2.x,\n        0\n      ];\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n        return false;\n      }\n      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n        return false;\n      }\n      _triangleNormal.crossVectors(_f0, _f1);\n      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n      return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);\n    }\n    clampPoint(point, target) {\n      return target.copy(point).clamp(this.min, this.max);\n    }\n    distanceToPoint(point) {\n      return this.clampPoint(point, _vector$b).distanceTo(point);\n    }\n    getBoundingSphere(target) {\n      if (this.isEmpty()) {\n        target.makeEmpty();\n      } else {\n        this.getCenter(target.center);\n        target.radius = this.getSize(_vector$b).length() * 0.5;\n      }\n      return target;\n    }\n    intersect(box) {\n      this.min.max(box.min);\n      this.max.min(box.max);\n      if (this.isEmpty()) this.makeEmpty();\n      return this;\n    }\n    union(box) {\n      this.min.min(box.min);\n      this.max.max(box.max);\n      return this;\n    }\n    applyMatrix4(matrix) {\n      if (this.isEmpty()) return this;\n      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);\n      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);\n      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);\n      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);\n      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);\n      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);\n      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);\n      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);\n      this.setFromPoints(_points);\n      return this;\n    }\n    translate(offset) {\n      this.min.add(offset);\n      this.max.add(offset);\n      return this;\n    }\n    equals(box) {\n      return box.min.equals(this.min) && box.max.equals(this.max);\n    }\n  }\n  const _points = [\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3()\n  ];\n  const _vector$b = /* @__PURE__ */ new Vector3();\n  const _box$4 = /* @__PURE__ */ new Box3();\n  const _v0$2 = /* @__PURE__ */ new Vector3();\n  const _v1$7 = /* @__PURE__ */ new Vector3();\n  const _v2$4 = /* @__PURE__ */ new Vector3();\n  const _f0 = /* @__PURE__ */ new Vector3();\n  const _f1 = /* @__PURE__ */ new Vector3();\n  const _f2 = /* @__PURE__ */ new Vector3();\n  const _center = /* @__PURE__ */ new Vector3();\n  const _extents = /* @__PURE__ */ new Vector3();\n  const _triangleNormal = /* @__PURE__ */ new Vector3();\n  const _testAxis = /* @__PURE__ */ new Vector3();\n  function satForAxes(axes, v0, v1, v2, extents) {\n    for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {\n      _testAxis.fromArray(axes, i2);\n      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);\n      const p0 = v0.dot(_testAxis);\n      const p1 = v1.dot(_testAxis);\n      const p2 = v2.dot(_testAxis);\n      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const _box$3 = /* @__PURE__ */ new Box3();\n  const _v1$6 = /* @__PURE__ */ new Vector3();\n  const _v2$3 = /* @__PURE__ */ new Vector3();\n  class Sphere {\n    constructor(center = new Vector3(), radius = -1) {\n      this.isSphere = true;\n      this.center = center;\n      this.radius = radius;\n    }\n    set(center, radius) {\n      this.center.copy(center);\n      this.radius = radius;\n      return this;\n    }\n    setFromPoints(points, optionalCenter) {\n      const center = this.center;\n      if (optionalCenter !== void 0) {\n        center.copy(optionalCenter);\n      } else {\n        _box$3.setFromPoints(points).getCenter(center);\n      }\n      let maxRadiusSq = 0;\n      for (let i2 = 0, il = points.length; i2 < il; i2++) {\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));\n      }\n      this.radius = Math.sqrt(maxRadiusSq);\n      return this;\n    }\n    copy(sphere) {\n      this.center.copy(sphere.center);\n      this.radius = sphere.radius;\n      return this;\n    }\n    isEmpty() {\n      return this.radius < 0;\n    }\n    makeEmpty() {\n      this.center.set(0, 0, 0);\n      this.radius = -1;\n      return this;\n    }\n    containsPoint(point) {\n      return point.distanceToSquared(this.center) <= this.radius * this.radius;\n    }\n    distanceToPoint(point) {\n      return point.distanceTo(this.center) - this.radius;\n    }\n    intersectsSphere(sphere) {\n      const radiusSum = this.radius + sphere.radius;\n      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n    }\n    intersectsBox(box) {\n      return box.intersectsSphere(this);\n    }\n    intersectsPlane(plane) {\n      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n    }\n    clampPoint(point, target) {\n      const deltaLengthSq = this.center.distanceToSquared(point);\n      target.copy(point);\n      if (deltaLengthSq > this.radius * this.radius) {\n        target.sub(this.center).normalize();\n        target.multiplyScalar(this.radius).add(this.center);\n      }\n      return target;\n    }\n    getBoundingBox(target) {\n      if (this.isEmpty()) {\n        target.makeEmpty();\n        return target;\n      }\n      target.set(this.center, this.center);\n      target.expandByScalar(this.radius);\n      return target;\n    }\n    applyMatrix4(matrix) {\n      this.center.applyMatrix4(matrix);\n      this.radius = this.radius * matrix.getMaxScaleOnAxis();\n      return this;\n    }\n    translate(offset) {\n      this.center.add(offset);\n      return this;\n    }\n    expandByPoint(point) {\n      if (this.isEmpty()) {\n        this.center.copy(point);\n        this.radius = 0;\n        return this;\n      }\n      _v1$6.subVectors(point, this.center);\n      const lengthSq = _v1$6.lengthSq();\n      if (lengthSq > this.radius * this.radius) {\n        const length = Math.sqrt(lengthSq);\n        const delta = (length - this.radius) * 0.5;\n        this.center.addScaledVector(_v1$6, delta / length);\n        this.radius += delta;\n      }\n      return this;\n    }\n    union(sphere) {\n      if (sphere.isEmpty()) {\n        return this;\n      }\n      if (this.isEmpty()) {\n        this.copy(sphere);\n        return this;\n      }\n      if (this.center.equals(sphere.center) === true) {\n        this.radius = Math.max(this.radius, sphere.radius);\n      } else {\n        _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);\n        this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));\n        this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));\n      }\n      return this;\n    }\n    equals(sphere) {\n      return sphere.center.equals(this.center) && sphere.radius === this.radius;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  const _vector$a = /* @__PURE__ */ new Vector3();\n  const _segCenter = /* @__PURE__ */ new Vector3();\n  const _segDir = /* @__PURE__ */ new Vector3();\n  const _diff = /* @__PURE__ */ new Vector3();\n  const _edge1 = /* @__PURE__ */ new Vector3();\n  const _edge2 = /* @__PURE__ */ new Vector3();\n  const _normal$1 = /* @__PURE__ */ new Vector3();\n  class Ray {\n    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {\n      this.origin = origin;\n      this.direction = direction;\n    }\n    set(origin, direction) {\n      this.origin.copy(origin);\n      this.direction.copy(direction);\n      return this;\n    }\n    copy(ray) {\n      this.origin.copy(ray.origin);\n      this.direction.copy(ray.direction);\n      return this;\n    }\n    at(t, target) {\n      return target.copy(this.origin).addScaledVector(this.direction, t);\n    }\n    lookAt(v) {\n      this.direction.copy(v).sub(this.origin).normalize();\n      return this;\n    }\n    recast(t) {\n      this.origin.copy(this.at(t, _vector$a));\n      return this;\n    }\n    closestPointToPoint(point, target) {\n      target.subVectors(point, this.origin);\n      const directionDistance = target.dot(this.direction);\n      if (directionDistance < 0) {\n        return target.copy(this.origin);\n      }\n      return target.copy(this.origin).addScaledVector(this.direction, directionDistance);\n    }\n    distanceToPoint(point) {\n      return Math.sqrt(this.distanceSqToPoint(point));\n    }\n    distanceSqToPoint(point) {\n      const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);\n      if (directionDistance < 0) {\n        return this.origin.distanceToSquared(point);\n      }\n      _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);\n      return _vector$a.distanceToSquared(point);\n    }\n    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n      _segDir.copy(v1).sub(v0).normalize();\n      _diff.copy(this.origin).sub(_segCenter);\n      const segExtent = v0.distanceTo(v1) * 0.5;\n      const a01 = -this.direction.dot(_segDir);\n      const b0 = _diff.dot(this.direction);\n      const b1 = -_diff.dot(_segDir);\n      const c = _diff.lengthSq();\n      const det = Math.abs(1 - a01 * a01);\n      let s0, s1, sqrDist, extDet;\n      if (det > 0) {\n        s0 = a01 * b1 - b0;\n        s1 = a01 * b0 - b1;\n        extDet = segExtent * det;\n        if (s0 >= 0) {\n          if (s1 >= -extDet) {\n            if (s1 <= extDet) {\n              const invDet = 1 / det;\n              s0 *= invDet;\n              s1 *= invDet;\n              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n            } else {\n              s1 = segExtent;\n              s0 = Math.max(0, -(a01 * s1 + b0));\n              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n            }\n          } else {\n            s1 = -segExtent;\n            s0 = Math.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        } else {\n          if (s1 <= -extDet) {\n            s0 = Math.max(0, -(-a01 * segExtent + b0));\n            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          } else if (s1 <= extDet) {\n            s0 = 0;\n            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = s1 * (s1 + 2 * b1) + c;\n          } else {\n            s0 = Math.max(0, -(a01 * segExtent + b0));\n            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        }\n      } else {\n        s1 = a01 > 0 ? -segExtent : segExtent;\n        s0 = Math.max(0, -(a01 * s1 + b0));\n        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n      }\n      if (optionalPointOnRay) {\n        optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);\n      }\n      if (optionalPointOnSegment) {\n        optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);\n      }\n      return sqrDist;\n    }\n    intersectSphere(sphere, target) {\n      _vector$a.subVectors(sphere.center, this.origin);\n      const tca = _vector$a.dot(this.direction);\n      const d2 = _vector$a.dot(_vector$a) - tca * tca;\n      const radius2 = sphere.radius * sphere.radius;\n      if (d2 > radius2) return null;\n      const thc = Math.sqrt(radius2 - d2);\n      const t0 = tca - thc;\n      const t1 = tca + thc;\n      if (t1 < 0) return null;\n      if (t0 < 0) return this.at(t1, target);\n      return this.at(t0, target);\n    }\n    intersectsSphere(sphere) {\n      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    distanceToPlane(plane) {\n      const denominator = plane.normal.dot(this.direction);\n      if (denominator === 0) {\n        if (plane.distanceToPoint(this.origin) === 0) {\n          return 0;\n        }\n        return null;\n      }\n      const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\n      return t >= 0 ? t : null;\n    }\n    intersectPlane(plane, target) {\n      const t = this.distanceToPlane(plane);\n      if (t === null) {\n        return null;\n      }\n      return this.at(t, target);\n    }\n    intersectsPlane(plane) {\n      const distToPoint = plane.distanceToPoint(this.origin);\n      if (distToPoint === 0) {\n        return true;\n      }\n      const denominator = plane.normal.dot(this.direction);\n      if (denominator * distToPoint < 0) {\n        return true;\n      }\n      return false;\n    }\n    intersectBox(box, target) {\n      let tmin, tmax, tymin, tymax, tzmin, tzmax;\n      const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;\n      const origin = this.origin;\n      if (invdirx >= 0) {\n        tmin = (box.min.x - origin.x) * invdirx;\n        tmax = (box.max.x - origin.x) * invdirx;\n      } else {\n        tmin = (box.max.x - origin.x) * invdirx;\n        tmax = (box.min.x - origin.x) * invdirx;\n      }\n      if (invdiry >= 0) {\n        tymin = (box.min.y - origin.y) * invdiry;\n        tymax = (box.max.y - origin.y) * invdiry;\n      } else {\n        tymin = (box.max.y - origin.y) * invdiry;\n        tymax = (box.min.y - origin.y) * invdiry;\n      }\n      if (tmin > tymax || tymin > tmax) return null;\n      if (tymin > tmin || isNaN(tmin)) tmin = tymin;\n      if (tymax < tmax || isNaN(tmax)) tmax = tymax;\n      if (invdirz >= 0) {\n        tzmin = (box.min.z - origin.z) * invdirz;\n        tzmax = (box.max.z - origin.z) * invdirz;\n      } else {\n        tzmin = (box.max.z - origin.z) * invdirz;\n        tzmax = (box.min.z - origin.z) * invdirz;\n      }\n      if (tmin > tzmax || tzmin > tmax) return null;\n      if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n      if (tzmax < tmax || tmax !== tmax) tmax = tzmax;\n      if (tmax < 0) return null;\n      return this.at(tmin >= 0 ? tmin : tmax, target);\n    }\n    intersectsBox(box) {\n      return this.intersectBox(box, _vector$a) !== null;\n    }\n    intersectTriangle(a, b, c, backfaceCulling, target) {\n      _edge1.subVectors(b, a);\n      _edge2.subVectors(c, a);\n      _normal$1.crossVectors(_edge1, _edge2);\n      let DdN = this.direction.dot(_normal$1);\n      let sign;\n      if (DdN > 0) {\n        if (backfaceCulling) return null;\n        sign = 1;\n      } else if (DdN < 0) {\n        sign = -1;\n        DdN = -DdN;\n      } else {\n        return null;\n      }\n      _diff.subVectors(this.origin, a);\n      const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));\n      if (DdQxE2 < 0) {\n        return null;\n      }\n      const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));\n      if (DdE1xQ < 0) {\n        return null;\n      }\n      if (DdQxE2 + DdE1xQ > DdN) {\n        return null;\n      }\n      const QdN = -sign * _diff.dot(_normal$1);\n      if (QdN < 0) {\n        return null;\n      }\n      return this.at(QdN / DdN, target);\n    }\n    applyMatrix4(matrix4) {\n      this.origin.applyMatrix4(matrix4);\n      this.direction.transformDirection(matrix4);\n      return this;\n    }\n    equals(ray) {\n      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  class Matrix4 {\n    constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n      Matrix4.prototype.isMatrix4 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);\n      }\n    }\n    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n      const te = this.elements;\n      te[0] = n11;\n      te[4] = n12;\n      te[8] = n13;\n      te[12] = n14;\n      te[1] = n21;\n      te[5] = n22;\n      te[9] = n23;\n      te[13] = n24;\n      te[2] = n31;\n      te[6] = n32;\n      te[10] = n33;\n      te[14] = n34;\n      te[3] = n41;\n      te[7] = n42;\n      te[11] = n43;\n      te[15] = n44;\n      return this;\n    }\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    clone() {\n      return new Matrix4().fromArray(this.elements);\n    }\n    copy(m) {\n      const te = this.elements;\n      const me = m.elements;\n      te[0] = me[0];\n      te[1] = me[1];\n      te[2] = me[2];\n      te[3] = me[3];\n      te[4] = me[4];\n      te[5] = me[5];\n      te[6] = me[6];\n      te[7] = me[7];\n      te[8] = me[8];\n      te[9] = me[9];\n      te[10] = me[10];\n      te[11] = me[11];\n      te[12] = me[12];\n      te[13] = me[13];\n      te[14] = me[14];\n      te[15] = me[15];\n      return this;\n    }\n    copyPosition(m) {\n      const te = this.elements, me = m.elements;\n      te[12] = me[12];\n      te[13] = me[13];\n      te[14] = me[14];\n      return this;\n    }\n    setFromMatrix3(m) {\n      const me = m.elements;\n      this.set(\n        me[0],\n        me[3],\n        me[6],\n        0,\n        me[1],\n        me[4],\n        me[7],\n        0,\n        me[2],\n        me[5],\n        me[8],\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.setFromMatrixColumn(this, 0);\n      yAxis.setFromMatrixColumn(this, 1);\n      zAxis.setFromMatrixColumn(this, 2);\n      return this;\n    }\n    makeBasis(xAxis, yAxis, zAxis) {\n      this.set(\n        xAxis.x,\n        yAxis.x,\n        zAxis.x,\n        0,\n        xAxis.y,\n        yAxis.y,\n        zAxis.y,\n        0,\n        xAxis.z,\n        yAxis.z,\n        zAxis.z,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    extractRotation(m) {\n      const te = this.elements;\n      const me = m.elements;\n      const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();\n      const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();\n      const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();\n      te[0] = me[0] * scaleX;\n      te[1] = me[1] * scaleX;\n      te[2] = me[2] * scaleX;\n      te[3] = 0;\n      te[4] = me[4] * scaleY;\n      te[5] = me[5] * scaleY;\n      te[6] = me[6] * scaleY;\n      te[7] = 0;\n      te[8] = me[8] * scaleZ;\n      te[9] = me[9] * scaleZ;\n      te[10] = me[10] * scaleZ;\n      te[11] = 0;\n      te[12] = 0;\n      te[13] = 0;\n      te[14] = 0;\n      te[15] = 1;\n      return this;\n    }\n    makeRotationFromEuler(euler) {\n      const te = this.elements;\n      const x2 = euler.x, y = euler.y, z = euler.z;\n      const a = Math.cos(x2), b = Math.sin(x2);\n      const c = Math.cos(y), d = Math.sin(y);\n      const e = Math.cos(z), f = Math.sin(z);\n      if (euler.order === \"XYZ\") {\n        const ae = a * e, af = a * f, be = b * e, bf = b * f;\n        te[0] = c * e;\n        te[4] = -c * f;\n        te[8] = d;\n        te[1] = af + be * d;\n        te[5] = ae - bf * d;\n        te[9] = -b * c;\n        te[2] = bf - ae * d;\n        te[6] = be + af * d;\n        te[10] = a * c;\n      } else if (euler.order === \"YXZ\") {\n        const ce = c * e, cf = c * f, de = d * e, df = d * f;\n        te[0] = ce + df * b;\n        te[4] = de * b - cf;\n        te[8] = a * d;\n        te[1] = a * f;\n        te[5] = a * e;\n        te[9] = -b;\n        te[2] = cf * b - de;\n        te[6] = df + ce * b;\n        te[10] = a * c;\n      } else if (euler.order === \"ZXY\") {\n        const ce = c * e, cf = c * f, de = d * e, df = d * f;\n        te[0] = ce - df * b;\n        te[4] = -a * f;\n        te[8] = de + cf * b;\n        te[1] = cf + de * b;\n        te[5] = a * e;\n        te[9] = df - ce * b;\n        te[2] = -a * d;\n        te[6] = b;\n        te[10] = a * c;\n      } else if (euler.order === \"ZYX\") {\n        const ae = a * e, af = a * f, be = b * e, bf = b * f;\n        te[0] = c * e;\n        te[4] = be * d - af;\n        te[8] = ae * d + bf;\n        te[1] = c * f;\n        te[5] = bf * d + ae;\n        te[9] = af * d - be;\n        te[2] = -d;\n        te[6] = b * c;\n        te[10] = a * c;\n      } else if (euler.order === \"YZX\") {\n        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n        te[0] = c * e;\n        te[4] = bd - ac * f;\n        te[8] = bc * f + ad;\n        te[1] = f;\n        te[5] = a * e;\n        te[9] = -b * e;\n        te[2] = -d * e;\n        te[6] = ad * f + bc;\n        te[10] = ac - bd * f;\n      } else if (euler.order === \"XZY\") {\n        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n        te[0] = c * e;\n        te[4] = -f;\n        te[8] = d * e;\n        te[1] = ac * f + bd;\n        te[5] = a * e;\n        te[9] = ad * f - bc;\n        te[2] = bc * f - ad;\n        te[6] = b * e;\n        te[10] = bd * f + ac;\n      }\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = 0;\n      te[12] = 0;\n      te[13] = 0;\n      te[14] = 0;\n      te[15] = 1;\n      return this;\n    }\n    makeRotationFromQuaternion(q) {\n      return this.compose(_zero, q, _one);\n    }\n    lookAt(eye, target, up) {\n      const te = this.elements;\n      _z.subVectors(eye, target);\n      if (_z.lengthSq() === 0) {\n        _z.z = 1;\n      }\n      _z.normalize();\n      _x.crossVectors(up, _z);\n      if (_x.lengthSq() === 0) {\n        if (Math.abs(up.z) === 1) {\n          _z.x += 1e-4;\n        } else {\n          _z.z += 1e-4;\n        }\n        _z.normalize();\n        _x.crossVectors(up, _z);\n      }\n      _x.normalize();\n      _y.crossVectors(_z, _x);\n      te[0] = _x.x;\n      te[4] = _y.x;\n      te[8] = _z.x;\n      te[1] = _x.y;\n      te[5] = _y.y;\n      te[9] = _z.y;\n      te[2] = _x.z;\n      te[6] = _y.z;\n      te[10] = _z.z;\n      return this;\n    }\n    multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n    premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n    multiplyMatrices(a, b) {\n      const ae = a.elements;\n      const be = b.elements;\n      const te = this.elements;\n      const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n      const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n      const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n      const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n      const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n      const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n      const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\n      const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n      return this;\n    }\n    multiplyScalar(s) {\n      const te = this.elements;\n      te[0] *= s;\n      te[4] *= s;\n      te[8] *= s;\n      te[12] *= s;\n      te[1] *= s;\n      te[5] *= s;\n      te[9] *= s;\n      te[13] *= s;\n      te[2] *= s;\n      te[6] *= s;\n      te[10] *= s;\n      te[14] *= s;\n      te[3] *= s;\n      te[7] *= s;\n      te[11] *= s;\n      te[15] *= s;\n      return this;\n    }\n    determinant() {\n      const te = this.elements;\n      const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n      const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n      const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n      const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n    }\n    transpose() {\n      const te = this.elements;\n      let tmp;\n      tmp = te[1];\n      te[1] = te[4];\n      te[4] = tmp;\n      tmp = te[2];\n      te[2] = te[8];\n      te[8] = tmp;\n      tmp = te[6];\n      te[6] = te[9];\n      te[9] = tmp;\n      tmp = te[3];\n      te[3] = te[12];\n      te[12] = tmp;\n      tmp = te[7];\n      te[7] = te[13];\n      te[13] = tmp;\n      tmp = te[11];\n      te[11] = te[14];\n      te[14] = tmp;\n      return this;\n    }\n    setPosition(x2, y, z) {\n      const te = this.elements;\n      if (x2.isVector3) {\n        te[12] = x2.x;\n        te[13] = x2.y;\n        te[14] = x2.z;\n      } else {\n        te[12] = x2;\n        te[13] = y;\n        te[14] = z;\n      }\n      return this;\n    }\n    invert() {\n      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n      const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n      const detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n      te[4] = t12 * detInv;\n      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n      te[8] = t13 * detInv;\n      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n      te[12] = t14 * detInv;\n      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n      return this;\n    }\n    scale(v) {\n      const te = this.elements;\n      const x2 = v.x, y = v.y, z = v.z;\n      te[0] *= x2;\n      te[4] *= y;\n      te[8] *= z;\n      te[1] *= x2;\n      te[5] *= y;\n      te[9] *= z;\n      te[2] *= x2;\n      te[6] *= y;\n      te[10] *= z;\n      te[3] *= x2;\n      te[7] *= y;\n      te[11] *= z;\n      return this;\n    }\n    getMaxScaleOnAxis() {\n      const te = this.elements;\n      const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n      const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n      const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n    }\n    makeTranslation(x2, y, z) {\n      if (x2.isVector3) {\n        this.set(\n          1,\n          0,\n          0,\n          x2.x,\n          0,\n          1,\n          0,\n          x2.y,\n          0,\n          0,\n          1,\n          x2.z,\n          0,\n          0,\n          0,\n          1\n        );\n      } else {\n        this.set(\n          1,\n          0,\n          0,\n          x2,\n          0,\n          1,\n          0,\n          y,\n          0,\n          0,\n          1,\n          z,\n          0,\n          0,\n          0,\n          1\n        );\n      }\n      return this;\n    }\n    makeRotationX(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        0,\n        c,\n        -s,\n        0,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeRotationY(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        c,\n        0,\n        s,\n        0,\n        0,\n        1,\n        0,\n        0,\n        -s,\n        0,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeRotationZ(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        c,\n        -s,\n        0,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeRotationAxis(axis, angle) {\n      const c = Math.cos(angle);\n      const s = Math.sin(angle);\n      const t = 1 - c;\n      const x2 = axis.x, y = axis.y, z = axis.z;\n      const tx = t * x2, ty = t * y;\n      this.set(\n        tx * x2 + c,\n        tx * y - s * z,\n        tx * z + s * y,\n        0,\n        tx * y + s * z,\n        ty * y + c,\n        ty * z - s * x2,\n        0,\n        tx * z - s * y,\n        ty * z + s * x2,\n        t * z * z + c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeScale(x2, y, z) {\n      this.set(\n        x2,\n        0,\n        0,\n        0,\n        0,\n        y,\n        0,\n        0,\n        0,\n        0,\n        z,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeShear(xy, xz, yx, yz, zx, zy) {\n      this.set(\n        1,\n        yx,\n        zx,\n        0,\n        xy,\n        1,\n        zy,\n        0,\n        xz,\n        yz,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    compose(position, quaternion, scale) {\n      const te = this.elements;\n      const x2 = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n      const x22 = x2 + x2, y2 = y + y, z2 = z + z;\n      const xx = x2 * x22, xy = x2 * y2, xz = x2 * z2;\n      const yy = y * y2, yz = y * z2, zz = z * z2;\n      const wx = w * x22, wy = w * y2, wz = w * z2;\n      const sx = scale.x, sy = scale.y, sz = scale.z;\n      te[0] = (1 - (yy + zz)) * sx;\n      te[1] = (xy + wz) * sx;\n      te[2] = (xz - wy) * sx;\n      te[3] = 0;\n      te[4] = (xy - wz) * sy;\n      te[5] = (1 - (xx + zz)) * sy;\n      te[6] = (yz + wx) * sy;\n      te[7] = 0;\n      te[8] = (xz + wy) * sz;\n      te[9] = (yz - wx) * sz;\n      te[10] = (1 - (xx + yy)) * sz;\n      te[11] = 0;\n      te[12] = position.x;\n      te[13] = position.y;\n      te[14] = position.z;\n      te[15] = 1;\n      return this;\n    }\n    decompose(position, quaternion, scale) {\n      const te = this.elements;\n      let sx = _v1$5.set(te[0], te[1], te[2]).length();\n      const sy = _v1$5.set(te[4], te[5], te[6]).length();\n      const sz = _v1$5.set(te[8], te[9], te[10]).length();\n      const det = this.determinant();\n      if (det < 0) sx = -sx;\n      position.x = te[12];\n      position.y = te[13];\n      position.z = te[14];\n      _m1$2.copy(this);\n      const invSX = 1 / sx;\n      const invSY = 1 / sy;\n      const invSZ = 1 / sz;\n      _m1$2.elements[0] *= invSX;\n      _m1$2.elements[1] *= invSX;\n      _m1$2.elements[2] *= invSX;\n      _m1$2.elements[4] *= invSY;\n      _m1$2.elements[5] *= invSY;\n      _m1$2.elements[6] *= invSY;\n      _m1$2.elements[8] *= invSZ;\n      _m1$2.elements[9] *= invSZ;\n      _m1$2.elements[10] *= invSZ;\n      quaternion.setFromRotationMatrix(_m1$2);\n      scale.x = sx;\n      scale.y = sy;\n      scale.z = sz;\n      return this;\n    }\n    makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {\n      const te = this.elements;\n      const x2 = 2 * near / (right - left);\n      const y = 2 * near / (top - bottom);\n      const a = (right + left) / (right - left);\n      const b = (top + bottom) / (top - bottom);\n      let c, d;\n      if (coordinateSystem === WebGLCoordinateSystem) {\n        c = -(far + near) / (far - near);\n        d = -2 * far * near / (far - near);\n      } else if (coordinateSystem === WebGPUCoordinateSystem) {\n        c = -far / (far - near);\n        d = -far * near / (far - near);\n      } else {\n        throw new Error(\"THREE.Matrix4.makePerspective(): Invalid coordinate system: \" + coordinateSystem);\n      }\n      te[0] = x2;\n      te[4] = 0;\n      te[8] = a;\n      te[12] = 0;\n      te[1] = 0;\n      te[5] = y;\n      te[9] = b;\n      te[13] = 0;\n      te[2] = 0;\n      te[6] = 0;\n      te[10] = c;\n      te[14] = d;\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = -1;\n      te[15] = 0;\n      return this;\n    }\n    makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {\n      const te = this.elements;\n      const w = 1 / (right - left);\n      const h = 1 / (top - bottom);\n      const p = 1 / (far - near);\n      const x2 = (right + left) * w;\n      const y = (top + bottom) * h;\n      let z, zInv;\n      if (coordinateSystem === WebGLCoordinateSystem) {\n        z = (far + near) * p;\n        zInv = -2 * p;\n      } else if (coordinateSystem === WebGPUCoordinateSystem) {\n        z = near * p;\n        zInv = -1 * p;\n      } else {\n        throw new Error(\"THREE.Matrix4.makeOrthographic(): Invalid coordinate system: \" + coordinateSystem);\n      }\n      te[0] = 2 * w;\n      te[4] = 0;\n      te[8] = 0;\n      te[12] = -x2;\n      te[1] = 0;\n      te[5] = 2 * h;\n      te[9] = 0;\n      te[13] = -y;\n      te[2] = 0;\n      te[6] = 0;\n      te[10] = zInv;\n      te[14] = -z;\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = 0;\n      te[15] = 1;\n      return this;\n    }\n    equals(matrix) {\n      const te = this.elements;\n      const me = matrix.elements;\n      for (let i2 = 0; i2 < 16; i2++) {\n        if (te[i2] !== me[i2]) return false;\n      }\n      return true;\n    }\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 16; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      const te = this.elements;\n      array[offset] = te[0];\n      array[offset + 1] = te[1];\n      array[offset + 2] = te[2];\n      array[offset + 3] = te[3];\n      array[offset + 4] = te[4];\n      array[offset + 5] = te[5];\n      array[offset + 6] = te[6];\n      array[offset + 7] = te[7];\n      array[offset + 8] = te[8];\n      array[offset + 9] = te[9];\n      array[offset + 10] = te[10];\n      array[offset + 11] = te[11];\n      array[offset + 12] = te[12];\n      array[offset + 13] = te[13];\n      array[offset + 14] = te[14];\n      array[offset + 15] = te[15];\n      return array;\n    }\n  }\n  const _v1$5 = /* @__PURE__ */ new Vector3();\n  const _m1$2 = /* @__PURE__ */ new Matrix4();\n  const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);\n  const _one = /* @__PURE__ */ new Vector3(1, 1, 1);\n  const _x = /* @__PURE__ */ new Vector3();\n  const _y = /* @__PURE__ */ new Vector3();\n  const _z = /* @__PURE__ */ new Vector3();\n  const _matrix$2 = /* @__PURE__ */ new Matrix4();\n  const _quaternion$3 = /* @__PURE__ */ new Quaternion();\n  class Euler {\n    constructor(x2 = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {\n      this.isEuler = true;\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._order = order;\n    }\n    get x() {\n      return this._x;\n    }\n    set x(value) {\n      this._x = value;\n      this._onChangeCallback();\n    }\n    get y() {\n      return this._y;\n    }\n    set y(value) {\n      this._y = value;\n      this._onChangeCallback();\n    }\n    get z() {\n      return this._z;\n    }\n    set z(value) {\n      this._z = value;\n      this._onChangeCallback();\n    }\n    get order() {\n      return this._order;\n    }\n    set order(value) {\n      this._order = value;\n      this._onChangeCallback();\n    }\n    set(x2, y, z, order = this._order) {\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._order = order;\n      this._onChangeCallback();\n      return this;\n    }\n    clone() {\n      return new this.constructor(this._x, this._y, this._z, this._order);\n    }\n    copy(euler) {\n      this._x = euler._x;\n      this._y = euler._y;\n      this._z = euler._z;\n      this._order = euler._order;\n      this._onChangeCallback();\n      return this;\n    }\n    setFromRotationMatrix(m, order = this._order, update = true) {\n      const te = m.elements;\n      const m11 = te[0], m12 = te[4], m13 = te[8];\n      const m21 = te[1], m22 = te[5], m23 = te[9];\n      const m31 = te[2], m32 = te[6], m33 = te[10];\n      switch (order) {\n        case \"XYZ\":\n          this._y = Math.asin(clamp(m13, -1, 1));\n          if (Math.abs(m13) < 0.9999999) {\n            this._x = Math.atan2(-m23, m33);\n            this._z = Math.atan2(-m12, m11);\n          } else {\n            this._x = Math.atan2(m32, m22);\n            this._z = 0;\n          }\n          break;\n        case \"YXZ\":\n          this._x = Math.asin(-clamp(m23, -1, 1));\n          if (Math.abs(m23) < 0.9999999) {\n            this._y = Math.atan2(m13, m33);\n            this._z = Math.atan2(m21, m22);\n          } else {\n            this._y = Math.atan2(-m31, m11);\n            this._z = 0;\n          }\n          break;\n        case \"ZXY\":\n          this._x = Math.asin(clamp(m32, -1, 1));\n          if (Math.abs(m32) < 0.9999999) {\n            this._y = Math.atan2(-m31, m33);\n            this._z = Math.atan2(-m12, m22);\n          } else {\n            this._y = 0;\n            this._z = Math.atan2(m21, m11);\n          }\n          break;\n        case \"ZYX\":\n          this._y = Math.asin(-clamp(m31, -1, 1));\n          if (Math.abs(m31) < 0.9999999) {\n            this._x = Math.atan2(m32, m33);\n            this._z = Math.atan2(m21, m11);\n          } else {\n            this._x = 0;\n            this._z = Math.atan2(-m12, m22);\n          }\n          break;\n        case \"YZX\":\n          this._z = Math.asin(clamp(m21, -1, 1));\n          if (Math.abs(m21) < 0.9999999) {\n            this._x = Math.atan2(-m23, m22);\n            this._y = Math.atan2(-m31, m11);\n          } else {\n            this._x = 0;\n            this._y = Math.atan2(m13, m33);\n          }\n          break;\n        case \"XZY\":\n          this._z = Math.asin(-clamp(m12, -1, 1));\n          if (Math.abs(m12) < 0.9999999) {\n            this._x = Math.atan2(m32, m22);\n            this._y = Math.atan2(m13, m11);\n          } else {\n            this._x = Math.atan2(-m23, m33);\n            this._y = 0;\n          }\n          break;\n        default:\n          console.warn(\"THREE.Euler: .setFromRotationMatrix() encountered an unknown order: \" + order);\n      }\n      this._order = order;\n      if (update === true) this._onChangeCallback();\n      return this;\n    }\n    setFromQuaternion(q, order, update) {\n      _matrix$2.makeRotationFromQuaternion(q);\n      return this.setFromRotationMatrix(_matrix$2, order, update);\n    }\n    setFromVector3(v, order = this._order) {\n      return this.set(v.x, v.y, v.z, order);\n    }\n    reorder(newOrder) {\n      _quaternion$3.setFromEuler(this);\n      return this.setFromQuaternion(_quaternion$3, newOrder);\n    }\n    equals(euler) {\n      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n    }\n    fromArray(array) {\n      this._x = array[0];\n      this._y = array[1];\n      this._z = array[2];\n      if (array[3] !== void 0) this._order = array[3];\n      this._onChangeCallback();\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._order;\n      return array;\n    }\n    _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n    _onChangeCallback() {\n    }\n    *[Symbol.iterator]() {\n      yield this._x;\n      yield this._y;\n      yield this._z;\n      yield this._order;\n    }\n  }\n  Euler.DEFAULT_ORDER = \"XYZ\";\n  class Layers {\n    constructor() {\n      this.mask = 1 | 0;\n    }\n    set(channel) {\n      this.mask = (1 << channel | 0) >>> 0;\n    }\n    enable(channel) {\n      this.mask |= 1 << channel | 0;\n    }\n    enableAll() {\n      this.mask = 4294967295 | 0;\n    }\n    toggle(channel) {\n      this.mask ^= 1 << channel | 0;\n    }\n    disable(channel) {\n      this.mask &= ~(1 << channel | 0);\n    }\n    disableAll() {\n      this.mask = 0;\n    }\n    test(layers) {\n      return (this.mask & layers.mask) !== 0;\n    }\n    isEnabled(channel) {\n      return (this.mask & (1 << channel | 0)) !== 0;\n    }\n  }\n  let _object3DId = 0;\n  const _v1$4 = /* @__PURE__ */ new Vector3();\n  const _q1 = /* @__PURE__ */ new Quaternion();\n  const _m1$1 = /* @__PURE__ */ new Matrix4();\n  const _target = /* @__PURE__ */ new Vector3();\n  const _position$3 = /* @__PURE__ */ new Vector3();\n  const _scale$2 = /* @__PURE__ */ new Vector3();\n  const _quaternion$2 = /* @__PURE__ */ new Quaternion();\n  const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);\n  const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);\n  const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);\n  const _addedEvent = { type: \"added\" };\n  const _removedEvent = { type: \"removed\" };\n  const _childaddedEvent = { type: \"childadded\", child: null };\n  const _childremovedEvent = { type: \"childremoved\", child: null };\n  class Object3D extends EventDispatcher {\n    constructor() {\n      super();\n      this.isObject3D = true;\n      Object.defineProperty(this, \"id\", { value: _object3DId++ });\n      this.uuid = generateUUID();\n      this.name = \"\";\n      this.type = \"Object3D\";\n      this.parent = null;\n      this.children = [];\n      this.up = Object3D.DEFAULT_UP.clone();\n      const position = new Vector3();\n      const rotation = new Euler();\n      const quaternion = new Quaternion();\n      const scale = new Vector3(1, 1, 1);\n      function onRotationChange() {\n        quaternion.setFromEuler(rotation, false);\n      }\n      function onQuaternionChange() {\n        rotation.setFromQuaternion(quaternion, void 0, false);\n      }\n      rotation._onChange(onRotationChange);\n      quaternion._onChange(onQuaternionChange);\n      Object.defineProperties(this, {\n        position: {\n          configurable: true,\n          enumerable: true,\n          value: position\n        },\n        rotation: {\n          configurable: true,\n          enumerable: true,\n          value: rotation\n        },\n        quaternion: {\n          configurable: true,\n          enumerable: true,\n          value: quaternion\n        },\n        scale: {\n          configurable: true,\n          enumerable: true,\n          value: scale\n        },\n        modelViewMatrix: {\n          value: new Matrix4()\n        },\n        normalMatrix: {\n          value: new Matrix3()\n        }\n      });\n      this.matrix = new Matrix4();\n      this.matrixWorld = new Matrix4();\n      this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n      this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;\n      this.matrixWorldNeedsUpdate = false;\n      this.layers = new Layers();\n      this.visible = true;\n      this.castShadow = false;\n      this.receiveShadow = false;\n      this.frustumCulled = true;\n      this.renderOrder = 0;\n      this.animations = [];\n      this.userData = {};\n    }\n    onBeforeShadow() {\n    }\n    onAfterShadow() {\n    }\n    onBeforeRender() {\n    }\n    onAfterRender() {\n    }\n    applyMatrix4(matrix) {\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      this.matrix.premultiply(matrix);\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\n    }\n    applyQuaternion(q) {\n      this.quaternion.premultiply(q);\n      return this;\n    }\n    setRotationFromAxisAngle(axis, angle) {\n      this.quaternion.setFromAxisAngle(axis, angle);\n    }\n    setRotationFromEuler(euler) {\n      this.quaternion.setFromEuler(euler, true);\n    }\n    setRotationFromMatrix(m) {\n      this.quaternion.setFromRotationMatrix(m);\n    }\n    setRotationFromQuaternion(q) {\n      this.quaternion.copy(q);\n    }\n    rotateOnAxis(axis, angle) {\n      _q1.setFromAxisAngle(axis, angle);\n      this.quaternion.multiply(_q1);\n      return this;\n    }\n    rotateOnWorldAxis(axis, angle) {\n      _q1.setFromAxisAngle(axis, angle);\n      this.quaternion.premultiply(_q1);\n      return this;\n    }\n    rotateX(angle) {\n      return this.rotateOnAxis(_xAxis, angle);\n    }\n    rotateY(angle) {\n      return this.rotateOnAxis(_yAxis, angle);\n    }\n    rotateZ(angle) {\n      return this.rotateOnAxis(_zAxis, angle);\n    }\n    translateOnAxis(axis, distance) {\n      _v1$4.copy(axis).applyQuaternion(this.quaternion);\n      this.position.add(_v1$4.multiplyScalar(distance));\n      return this;\n    }\n    translateX(distance) {\n      return this.translateOnAxis(_xAxis, distance);\n    }\n    translateY(distance) {\n      return this.translateOnAxis(_yAxis, distance);\n    }\n    translateZ(distance) {\n      return this.translateOnAxis(_zAxis, distance);\n    }\n    localToWorld(vector) {\n      this.updateWorldMatrix(true, false);\n      return vector.applyMatrix4(this.matrixWorld);\n    }\n    worldToLocal(vector) {\n      this.updateWorldMatrix(true, false);\n      return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());\n    }\n    lookAt(x2, y, z) {\n      if (x2.isVector3) {\n        _target.copy(x2);\n      } else {\n        _target.set(x2, y, z);\n      }\n      const parent = this.parent;\n      this.updateWorldMatrix(true, false);\n      _position$3.setFromMatrixPosition(this.matrixWorld);\n      if (this.isCamera || this.isLight) {\n        _m1$1.lookAt(_position$3, _target, this.up);\n      } else {\n        _m1$1.lookAt(_target, _position$3, this.up);\n      }\n      this.quaternion.setFromRotationMatrix(_m1$1);\n      if (parent) {\n        _m1$1.extractRotation(parent.matrixWorld);\n        _q1.setFromRotationMatrix(_m1$1);\n        this.quaternion.premultiply(_q1.invert());\n      }\n    }\n    add(object) {\n      if (arguments.length > 1) {\n        for (let i2 = 0; i2 < arguments.length; i2++) {\n          this.add(arguments[i2]);\n        }\n        return this;\n      }\n      if (object === this) {\n        console.error(\"THREE.Object3D.add: object can't be added as a child of itself.\", object);\n        return this;\n      }\n      if (object && object.isObject3D) {\n        object.removeFromParent();\n        object.parent = this;\n        this.children.push(object);\n        object.dispatchEvent(_addedEvent);\n        _childaddedEvent.child = object;\n        this.dispatchEvent(_childaddedEvent);\n        _childaddedEvent.child = null;\n      } else {\n        console.error(\"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object);\n      }\n      return this;\n    }\n    remove(object) {\n      if (arguments.length > 1) {\n        for (let i2 = 0; i2 < arguments.length; i2++) {\n          this.remove(arguments[i2]);\n        }\n        return this;\n      }\n      const index = this.children.indexOf(object);\n      if (index !== -1) {\n        object.parent = null;\n        this.children.splice(index, 1);\n        object.dispatchEvent(_removedEvent);\n        _childremovedEvent.child = object;\n        this.dispatchEvent(_childremovedEvent);\n        _childremovedEvent.child = null;\n      }\n      return this;\n    }\n    removeFromParent() {\n      const parent = this.parent;\n      if (parent !== null) {\n        parent.remove(this);\n      }\n      return this;\n    }\n    clear() {\n      return this.remove(...this.children);\n    }\n    attach(object) {\n      this.updateWorldMatrix(true, false);\n      _m1$1.copy(this.matrixWorld).invert();\n      if (object.parent !== null) {\n        object.parent.updateWorldMatrix(true, false);\n        _m1$1.multiply(object.parent.matrixWorld);\n      }\n      object.applyMatrix4(_m1$1);\n      object.removeFromParent();\n      object.parent = this;\n      this.children.push(object);\n      object.updateWorldMatrix(false, true);\n      object.dispatchEvent(_addedEvent);\n      _childaddedEvent.child = object;\n      this.dispatchEvent(_childaddedEvent);\n      _childaddedEvent.child = null;\n      return this;\n    }\n    getObjectById(id) {\n      return this.getObjectByProperty(\"id\", id);\n    }\n    getObjectByName(name) {\n      return this.getObjectByProperty(\"name\", name);\n    }\n    getObjectByProperty(name, value) {\n      if (this[name] === value) return this;\n      for (let i2 = 0, l = this.children.length; i2 < l; i2++) {\n        const child = this.children[i2];\n        const object = child.getObjectByProperty(name, value);\n        if (object !== void 0) {\n          return object;\n        }\n      }\n      return void 0;\n    }\n    getObjectsByProperty(name, value, result = []) {\n      if (this[name] === value) result.push(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].getObjectsByProperty(name, value, result);\n      }\n      return result;\n    }\n    getWorldPosition(target) {\n      this.updateWorldMatrix(true, false);\n      return target.setFromMatrixPosition(this.matrixWorld);\n    }\n    getWorldQuaternion(target) {\n      this.updateWorldMatrix(true, false);\n      this.matrixWorld.decompose(_position$3, target, _scale$2);\n      return target;\n    }\n    getWorldScale(target) {\n      this.updateWorldMatrix(true, false);\n      this.matrixWorld.decompose(_position$3, _quaternion$2, target);\n      return target;\n    }\n    getWorldDirection(target) {\n      this.updateWorldMatrix(true, false);\n      const e = this.matrixWorld.elements;\n      return target.set(e[8], e[9], e[10]).normalize();\n    }\n    raycast() {\n    }\n    traverse(callback) {\n      callback(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].traverse(callback);\n      }\n    }\n    traverseVisible(callback) {\n      if (this.visible === false) return;\n      callback(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].traverseVisible(callback);\n      }\n    }\n    traverseAncestors(callback) {\n      const parent = this.parent;\n      if (parent !== null) {\n        callback(parent);\n        parent.traverseAncestors(callback);\n      }\n    }\n    updateMatrix() {\n      this.matrix.compose(this.position, this.quaternion, this.scale);\n      this.matrixWorldNeedsUpdate = true;\n    }\n    updateMatrixWorld(force) {\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      if (this.matrixWorldNeedsUpdate || force) {\n        if (this.matrixWorldAutoUpdate === true) {\n          if (this.parent === null) {\n            this.matrixWorld.copy(this.matrix);\n          } else {\n            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n          }\n        }\n        this.matrixWorldNeedsUpdate = false;\n        force = true;\n      }\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        const child = children[i2];\n        child.updateMatrixWorld(force);\n      }\n    }\n    updateWorldMatrix(updateParents, updateChildren) {\n      const parent = this.parent;\n      if (updateParents === true && parent !== null) {\n        parent.updateWorldMatrix(true, false);\n      }\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      if (this.matrixWorldAutoUpdate === true) {\n        if (this.parent === null) {\n          this.matrixWorld.copy(this.matrix);\n        } else {\n          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n        }\n      }\n      if (updateChildren === true) {\n        const children = this.children;\n        for (let i2 = 0, l = children.length; i2 < l; i2++) {\n          const child = children[i2];\n          child.updateWorldMatrix(false, true);\n        }\n      }\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === \"string\";\n      const output = {};\n      if (isRootObject) {\n        meta = {\n          geometries: {},\n          materials: {},\n          textures: {},\n          images: {},\n          shapes: {},\n          skeletons: {},\n          animations: {},\n          nodes: {}\n        };\n        output.metadata = {\n          version: 4.6,\n          type: \"Object\",\n          generator: \"Object3D.toJSON\"\n        };\n      }\n      const object = {};\n      object.uuid = this.uuid;\n      object.type = this.type;\n      if (this.name !== \"\") object.name = this.name;\n      if (this.castShadow === true) object.castShadow = true;\n      if (this.receiveShadow === true) object.receiveShadow = true;\n      if (this.visible === false) object.visible = false;\n      if (this.frustumCulled === false) object.frustumCulled = false;\n      if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n      if (Object.keys(this.userData).length > 0) object.userData = this.userData;\n      object.layers = this.layers.mask;\n      object.matrix = this.matrix.toArray();\n      object.up = this.up.toArray();\n      if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;\n      if (this.isInstancedMesh) {\n        object.type = \"InstancedMesh\";\n        object.count = this.count;\n        object.instanceMatrix = this.instanceMatrix.toJSON();\n        if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();\n      }\n      if (this.isBatchedMesh) {\n        object.type = \"BatchedMesh\";\n        object.perObjectFrustumCulled = this.perObjectFrustumCulled;\n        object.sortObjects = this.sortObjects;\n        object.drawRanges = this._drawRanges;\n        object.reservedRanges = this._reservedRanges;\n        object.visibility = this._visibility;\n        object.active = this._active;\n        object.bounds = this._bounds.map((bound) => ({\n          boxInitialized: bound.boxInitialized,\n          boxMin: bound.box.min.toArray(),\n          boxMax: bound.box.max.toArray(),\n          sphereInitialized: bound.sphereInitialized,\n          sphereRadius: bound.sphere.radius,\n          sphereCenter: bound.sphere.center.toArray()\n        }));\n        object.maxInstanceCount = this._maxInstanceCount;\n        object.maxVertexCount = this._maxVertexCount;\n        object.maxIndexCount = this._maxIndexCount;\n        object.geometryInitialized = this._geometryInitialized;\n        object.geometryCount = this._geometryCount;\n        object.matricesTexture = this._matricesTexture.toJSON(meta);\n        if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);\n        if (this.boundingSphere !== null) {\n          object.boundingSphere = {\n            center: object.boundingSphere.center.toArray(),\n            radius: object.boundingSphere.radius\n          };\n        }\n        if (this.boundingBox !== null) {\n          object.boundingBox = {\n            min: object.boundingBox.min.toArray(),\n            max: object.boundingBox.max.toArray()\n          };\n        }\n      }\n      function serialize(library, element) {\n        if (library[element.uuid] === void 0) {\n          library[element.uuid] = element.toJSON(meta);\n        }\n        return element.uuid;\n      }\n      if (this.isScene) {\n        if (this.background) {\n          if (this.background.isColor) {\n            object.background = this.background.toJSON();\n          } else if (this.background.isTexture) {\n            object.background = this.background.toJSON(meta).uuid;\n          }\n        }\n        if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {\n          object.environment = this.environment.toJSON(meta).uuid;\n        }\n      } else if (this.isMesh || this.isLine || this.isPoints) {\n        object.geometry = serialize(meta.geometries, this.geometry);\n        const parameters = this.geometry.parameters;\n        if (parameters !== void 0 && parameters.shapes !== void 0) {\n          const shapes = parameters.shapes;\n          if (Array.isArray(shapes)) {\n            for (let i2 = 0, l = shapes.length; i2 < l; i2++) {\n              const shape = shapes[i2];\n              serialize(meta.shapes, shape);\n            }\n          } else {\n            serialize(meta.shapes, shapes);\n          }\n        }\n      }\n      if (this.isSkinnedMesh) {\n        object.bindMode = this.bindMode;\n        object.bindMatrix = this.bindMatrix.toArray();\n        if (this.skeleton !== void 0) {\n          serialize(meta.skeletons, this.skeleton);\n          object.skeleton = this.skeleton.uuid;\n        }\n      }\n      if (this.material !== void 0) {\n        if (Array.isArray(this.material)) {\n          const uuids = [];\n          for (let i2 = 0, l = this.material.length; i2 < l; i2++) {\n            uuids.push(serialize(meta.materials, this.material[i2]));\n          }\n          object.material = uuids;\n        } else {\n          object.material = serialize(meta.materials, this.material);\n        }\n      }\n      if (this.children.length > 0) {\n        object.children = [];\n        for (let i2 = 0; i2 < this.children.length; i2++) {\n          object.children.push(this.children[i2].toJSON(meta).object);\n        }\n      }\n      if (this.animations.length > 0) {\n        object.animations = [];\n        for (let i2 = 0; i2 < this.animations.length; i2++) {\n          const animation = this.animations[i2];\n          object.animations.push(serialize(meta.animations, animation));\n        }\n      }\n      if (isRootObject) {\n        const geometries = extractFromCache(meta.geometries);\n        const materials = extractFromCache(meta.materials);\n        const textures = extractFromCache(meta.textures);\n        const images = extractFromCache(meta.images);\n        const shapes = extractFromCache(meta.shapes);\n        const skeletons = extractFromCache(meta.skeletons);\n        const animations = extractFromCache(meta.animations);\n        const nodes = extractFromCache(meta.nodes);\n        if (geometries.length > 0) output.geometries = geometries;\n        if (materials.length > 0) output.materials = materials;\n        if (textures.length > 0) output.textures = textures;\n        if (images.length > 0) output.images = images;\n        if (shapes.length > 0) output.shapes = shapes;\n        if (skeletons.length > 0) output.skeletons = skeletons;\n        if (animations.length > 0) output.animations = animations;\n        if (nodes.length > 0) output.nodes = nodes;\n      }\n      output.object = object;\n      return output;\n      function extractFromCache(cache) {\n        const values = [];\n        for (const key in cache) {\n          const data = cache[key];\n          delete data.metadata;\n          values.push(data);\n        }\n        return values;\n      }\n    }\n    clone(recursive) {\n      return new this.constructor().copy(this, recursive);\n    }\n    copy(source, recursive = true) {\n      this.name = source.name;\n      this.up.copy(source.up);\n      this.position.copy(source.position);\n      this.rotation.order = source.rotation.order;\n      this.quaternion.copy(source.quaternion);\n      this.scale.copy(source.scale);\n      this.matrix.copy(source.matrix);\n      this.matrixWorld.copy(source.matrixWorld);\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\n      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n      this.layers.mask = source.layers.mask;\n      this.visible = source.visible;\n      this.castShadow = source.castShadow;\n      this.receiveShadow = source.receiveShadow;\n      this.frustumCulled = source.frustumCulled;\n      this.renderOrder = source.renderOrder;\n      this.animations = source.animations.slice();\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      if (recursive === true) {\n        for (let i2 = 0; i2 < source.children.length; i2++) {\n          const child = source.children[i2];\n          this.add(child.clone());\n        }\n      }\n      return this;\n    }\n  }\n  Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);\n  Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;\n  Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\n  const _v0$1 = /* @__PURE__ */ new Vector3();\n  const _v1$3 = /* @__PURE__ */ new Vector3();\n  const _v2$2 = /* @__PURE__ */ new Vector3();\n  const _v3$2 = /* @__PURE__ */ new Vector3();\n  const _vab = /* @__PURE__ */ new Vector3();\n  const _vac = /* @__PURE__ */ new Vector3();\n  const _vbc = /* @__PURE__ */ new Vector3();\n  const _vap = /* @__PURE__ */ new Vector3();\n  const _vbp = /* @__PURE__ */ new Vector3();\n  const _vcp = /* @__PURE__ */ new Vector3();\n  const _v40 = /* @__PURE__ */ new Vector4();\n  const _v41 = /* @__PURE__ */ new Vector4();\n  const _v42 = /* @__PURE__ */ new Vector4();\n  class Triangle {\n    constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n    static getNormal(a, b, c, target) {\n      target.subVectors(c, b);\n      _v0$1.subVectors(a, b);\n      target.cross(_v0$1);\n      const targetLengthSq = target.lengthSq();\n      if (targetLengthSq > 0) {\n        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n      }\n      return target.set(0, 0, 0);\n    }\n    // static/instance method to calculate barycentric coordinates\n    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n    static getBarycoord(point, a, b, c, target) {\n      _v0$1.subVectors(c, a);\n      _v1$3.subVectors(b, a);\n      _v2$2.subVectors(point, a);\n      const dot00 = _v0$1.dot(_v0$1);\n      const dot01 = _v0$1.dot(_v1$3);\n      const dot02 = _v0$1.dot(_v2$2);\n      const dot11 = _v1$3.dot(_v1$3);\n      const dot12 = _v1$3.dot(_v2$2);\n      const denom = dot00 * dot11 - dot01 * dot01;\n      if (denom === 0) {\n        target.set(0, 0, 0);\n        return null;\n      }\n      const invDenom = 1 / denom;\n      const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n      const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n      return target.set(1 - u - v, v, u);\n    }\n    static containsPoint(point, a, b, c) {\n      if (this.getBarycoord(point, a, b, c, _v3$2) === null) {\n        return false;\n      }\n      return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;\n    }\n    static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {\n      if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {\n        target.x = 0;\n        target.y = 0;\n        if (\"z\" in target) target.z = 0;\n        if (\"w\" in target) target.w = 0;\n        return null;\n      }\n      target.setScalar(0);\n      target.addScaledVector(v1, _v3$2.x);\n      target.addScaledVector(v2, _v3$2.y);\n      target.addScaledVector(v3, _v3$2.z);\n      return target;\n    }\n    static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {\n      _v40.setScalar(0);\n      _v41.setScalar(0);\n      _v42.setScalar(0);\n      _v40.fromBufferAttribute(attr, i1);\n      _v41.fromBufferAttribute(attr, i2);\n      _v42.fromBufferAttribute(attr, i3);\n      target.setScalar(0);\n      target.addScaledVector(_v40, barycoord.x);\n      target.addScaledVector(_v41, barycoord.y);\n      target.addScaledVector(_v42, barycoord.z);\n      return target;\n    }\n    static isFrontFacing(a, b, c, direction) {\n      _v0$1.subVectors(c, b);\n      _v1$3.subVectors(a, b);\n      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;\n    }\n    set(a, b, c) {\n      this.a.copy(a);\n      this.b.copy(b);\n      this.c.copy(c);\n      return this;\n    }\n    setFromPointsAndIndices(points, i0, i1, i2) {\n      this.a.copy(points[i0]);\n      this.b.copy(points[i1]);\n      this.c.copy(points[i2]);\n      return this;\n    }\n    setFromAttributeAndIndices(attribute, i0, i1, i2) {\n      this.a.fromBufferAttribute(attribute, i0);\n      this.b.fromBufferAttribute(attribute, i1);\n      this.c.fromBufferAttribute(attribute, i2);\n      return this;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(triangle) {\n      this.a.copy(triangle.a);\n      this.b.copy(triangle.b);\n      this.c.copy(triangle.c);\n      return this;\n    }\n    getArea() {\n      _v0$1.subVectors(this.c, this.b);\n      _v1$3.subVectors(this.a, this.b);\n      return _v0$1.cross(_v1$3).length() * 0.5;\n    }\n    getMidpoint(target) {\n      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n    }\n    getNormal(target) {\n      return Triangle.getNormal(this.a, this.b, this.c, target);\n    }\n    getPlane(target) {\n      return target.setFromCoplanarPoints(this.a, this.b, this.c);\n    }\n    getBarycoord(point, target) {\n      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n    }\n    getInterpolation(point, v1, v2, v3, target) {\n      return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);\n    }\n    containsPoint(point) {\n      return Triangle.containsPoint(point, this.a, this.b, this.c);\n    }\n    isFrontFacing(direction) {\n      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n    }\n    intersectsBox(box) {\n      return box.intersectsTriangle(this);\n    }\n    closestPointToPoint(p, target) {\n      const a = this.a, b = this.b, c = this.c;\n      let v, w;\n      _vab.subVectors(b, a);\n      _vac.subVectors(c, a);\n      _vap.subVectors(p, a);\n      const d1 = _vab.dot(_vap);\n      const d2 = _vac.dot(_vap);\n      if (d1 <= 0 && d2 <= 0) {\n        return target.copy(a);\n      }\n      _vbp.subVectors(p, b);\n      const d3 = _vab.dot(_vbp);\n      const d4 = _vac.dot(_vbp);\n      if (d3 >= 0 && d4 <= d3) {\n        return target.copy(b);\n      }\n      const vc = d1 * d4 - d3 * d2;\n      if (vc <= 0 && d1 >= 0 && d3 <= 0) {\n        v = d1 / (d1 - d3);\n        return target.copy(a).addScaledVector(_vab, v);\n      }\n      _vcp.subVectors(p, c);\n      const d5 = _vab.dot(_vcp);\n      const d6 = _vac.dot(_vcp);\n      if (d6 >= 0 && d5 <= d6) {\n        return target.copy(c);\n      }\n      const vb = d5 * d2 - d1 * d6;\n      if (vb <= 0 && d2 >= 0 && d6 <= 0) {\n        w = d2 / (d2 - d6);\n        return target.copy(a).addScaledVector(_vac, w);\n      }\n      const va = d3 * d6 - d5 * d4;\n      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n        _vbc.subVectors(c, b);\n        w = (d4 - d3) / (d4 - d3 + (d5 - d6));\n        return target.copy(b).addScaledVector(_vbc, w);\n      }\n      const denom = 1 / (va + vb + vc);\n      v = vb * denom;\n      w = vc * denom;\n      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n    }\n    equals(triangle) {\n      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n    }\n  }\n  const _colorKeywords = {\n    \"aliceblue\": 15792383,\n    \"antiquewhite\": 16444375,\n    \"aqua\": 65535,\n    \"aquamarine\": 8388564,\n    \"azure\": 15794175,\n    \"beige\": 16119260,\n    \"bisque\": 16770244,\n    \"black\": 0,\n    \"blanchedalmond\": 16772045,\n    \"blue\": 255,\n    \"blueviolet\": 9055202,\n    \"brown\": 10824234,\n    \"burlywood\": 14596231,\n    \"cadetblue\": 6266528,\n    \"chartreuse\": 8388352,\n    \"chocolate\": 13789470,\n    \"coral\": 16744272,\n    \"cornflowerblue\": 6591981,\n    \"cornsilk\": 16775388,\n    \"crimson\": 14423100,\n    \"cyan\": 65535,\n    \"darkblue\": 139,\n    \"darkcyan\": 35723,\n    \"darkgoldenrod\": 12092939,\n    \"darkgray\": 11119017,\n    \"darkgreen\": 25600,\n    \"darkgrey\": 11119017,\n    \"darkkhaki\": 12433259,\n    \"darkmagenta\": 9109643,\n    \"darkolivegreen\": 5597999,\n    \"darkorange\": 16747520,\n    \"darkorchid\": 10040012,\n    \"darkred\": 9109504,\n    \"darksalmon\": 15308410,\n    \"darkseagreen\": 9419919,\n    \"darkslateblue\": 4734347,\n    \"darkslategray\": 3100495,\n    \"darkslategrey\": 3100495,\n    \"darkturquoise\": 52945,\n    \"darkviolet\": 9699539,\n    \"deeppink\": 16716947,\n    \"deepskyblue\": 49151,\n    \"dimgray\": 6908265,\n    \"dimgrey\": 6908265,\n    \"dodgerblue\": 2003199,\n    \"firebrick\": 11674146,\n    \"floralwhite\": 16775920,\n    \"forestgreen\": 2263842,\n    \"fuchsia\": 16711935,\n    \"gainsboro\": 14474460,\n    \"ghostwhite\": 16316671,\n    \"gold\": 16766720,\n    \"goldenrod\": 14329120,\n    \"gray\": 8421504,\n    \"green\": 32768,\n    \"greenyellow\": 11403055,\n    \"grey\": 8421504,\n    \"honeydew\": 15794160,\n    \"hotpink\": 16738740,\n    \"indianred\": 13458524,\n    \"indigo\": 4915330,\n    \"ivory\": 16777200,\n    \"khaki\": 15787660,\n    \"lavender\": 15132410,\n    \"lavenderblush\": 16773365,\n    \"lawngreen\": 8190976,\n    \"lemonchiffon\": 16775885,\n    \"lightblue\": 11393254,\n    \"lightcoral\": 15761536,\n    \"lightcyan\": 14745599,\n    \"lightgoldenrodyellow\": 16448210,\n    \"lightgray\": 13882323,\n    \"lightgreen\": 9498256,\n    \"lightgrey\": 13882323,\n    \"lightpink\": 16758465,\n    \"lightsalmon\": 16752762,\n    \"lightseagreen\": 2142890,\n    \"lightskyblue\": 8900346,\n    \"lightslategray\": 7833753,\n    \"lightslategrey\": 7833753,\n    \"lightsteelblue\": 11584734,\n    \"lightyellow\": 16777184,\n    \"lime\": 65280,\n    \"limegreen\": 3329330,\n    \"linen\": 16445670,\n    \"magenta\": 16711935,\n    \"maroon\": 8388608,\n    \"mediumaquamarine\": 6737322,\n    \"mediumblue\": 205,\n    \"mediumorchid\": 12211667,\n    \"mediumpurple\": 9662683,\n    \"mediumseagreen\": 3978097,\n    \"mediumslateblue\": 8087790,\n    \"mediumspringgreen\": 64154,\n    \"mediumturquoise\": 4772300,\n    \"mediumvioletred\": 13047173,\n    \"midnightblue\": 1644912,\n    \"mintcream\": 16121850,\n    \"mistyrose\": 16770273,\n    \"moccasin\": 16770229,\n    \"navajowhite\": 16768685,\n    \"navy\": 128,\n    \"oldlace\": 16643558,\n    \"olive\": 8421376,\n    \"olivedrab\": 7048739,\n    \"orange\": 16753920,\n    \"orangered\": 16729344,\n    \"orchid\": 14315734,\n    \"palegoldenrod\": 15657130,\n    \"palegreen\": 10025880,\n    \"paleturquoise\": 11529966,\n    \"palevioletred\": 14381203,\n    \"papayawhip\": 16773077,\n    \"peachpuff\": 16767673,\n    \"peru\": 13468991,\n    \"pink\": 16761035,\n    \"plum\": 14524637,\n    \"powderblue\": 11591910,\n    \"purple\": 8388736,\n    \"rebeccapurple\": 6697881,\n    \"red\": 16711680,\n    \"rosybrown\": 12357519,\n    \"royalblue\": 4286945,\n    \"saddlebrown\": 9127187,\n    \"salmon\": 16416882,\n    \"sandybrown\": 16032864,\n    \"seagreen\": 3050327,\n    \"seashell\": 16774638,\n    \"sienna\": 10506797,\n    \"silver\": 12632256,\n    \"skyblue\": 8900331,\n    \"slateblue\": 6970061,\n    \"slategray\": 7372944,\n    \"slategrey\": 7372944,\n    \"snow\": 16775930,\n    \"springgreen\": 65407,\n    \"steelblue\": 4620980,\n    \"tan\": 13808780,\n    \"teal\": 32896,\n    \"thistle\": 14204888,\n    \"tomato\": 16737095,\n    \"turquoise\": 4251856,\n    \"violet\": 15631086,\n    \"wheat\": 16113331,\n    \"white\": 16777215,\n    \"whitesmoke\": 16119285,\n    \"yellow\": 16776960,\n    \"yellowgreen\": 10145074\n  };\n  const _hslA = { h: 0, s: 0, l: 0 };\n  const _hslB = { h: 0, s: 0, l: 0 };\n  function hue2rgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n    return p;\n  }\n  class Color {\n    constructor(r, g, b) {\n      this.isColor = true;\n      this.r = 1;\n      this.g = 1;\n      this.b = 1;\n      return this.set(r, g, b);\n    }\n    set(r, g, b) {\n      if (g === void 0 && b === void 0) {\n        const value = r;\n        if (value && value.isColor) {\n          this.copy(value);\n        } else if (typeof value === \"number\") {\n          this.setHex(value);\n        } else if (typeof value === \"string\") {\n          this.setStyle(value);\n        }\n      } else {\n        this.setRGB(r, g, b);\n      }\n      return this;\n    }\n    setScalar(scalar) {\n      this.r = scalar;\n      this.g = scalar;\n      this.b = scalar;\n      return this;\n    }\n    setHex(hex, colorSpace = SRGBColorSpace) {\n      hex = Math.floor(hex);\n      this.r = (hex >> 16 & 255) / 255;\n      this.g = (hex >> 8 & 255) / 255;\n      this.b = (hex & 255) / 255;\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n    setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {\n      this.r = r;\n      this.g = g;\n      this.b = b;\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n    setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {\n      h = euclideanModulo(h, 1);\n      s = clamp(s, 0, 1);\n      l = clamp(l, 0, 1);\n      if (s === 0) {\n        this.r = this.g = this.b = l;\n      } else {\n        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n        const q = 2 * l - p;\n        this.r = hue2rgb(q, p, h + 1 / 3);\n        this.g = hue2rgb(q, p, h);\n        this.b = hue2rgb(q, p, h - 1 / 3);\n      }\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n    setStyle(style, colorSpace = SRGBColorSpace) {\n      function handleAlpha(string) {\n        if (string === void 0) return;\n        if (parseFloat(string) < 1) {\n          console.warn(\"THREE.Color: Alpha component of \" + style + \" will be ignored.\");\n        }\n      }\n      let m;\n      if (m = /^(\\\\w+)\\\\(([^\\\\)]*)\\\\)/.exec(style)) {\n        let color;\n        const name = m[1];\n        const components = m[2];\n        switch (name) {\n          case \"rgb\":\n          case \"rgba\":\n            if (color = /^\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*(?:,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setRGB(\n                Math.min(255, parseInt(color[1], 10)) / 255,\n                Math.min(255, parseInt(color[2], 10)) / 255,\n                Math.min(255, parseInt(color[3], 10)) / 255,\n                colorSpace\n              );\n            }\n            if (color = /^\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*(?:,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setRGB(\n                Math.min(100, parseInt(color[1], 10)) / 100,\n                Math.min(100, parseInt(color[2], 10)) / 100,\n                Math.min(100, parseInt(color[3], 10)) / 100,\n                colorSpace\n              );\n            }\n            break;\n          case \"hsl\":\n          case \"hsla\":\n            if (color = /^\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\%\\\\s*(?:,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setHSL(\n                parseFloat(color[1]) / 360,\n                parseFloat(color[2]) / 100,\n                parseFloat(color[3]) / 100,\n                colorSpace\n              );\n            }\n            break;\n          default:\n            console.warn(\"THREE.Color: Unknown color model \" + style);\n        }\n      } else if (m = /^\\\\#([A-Fa-f\\\\d]+)$/.exec(style)) {\n        const hex = m[1];\n        const size = hex.length;\n        if (size === 3) {\n          return this.setRGB(\n            parseInt(hex.charAt(0), 16) / 15,\n            parseInt(hex.charAt(1), 16) / 15,\n            parseInt(hex.charAt(2), 16) / 15,\n            colorSpace\n          );\n        } else if (size === 6) {\n          return this.setHex(parseInt(hex, 16), colorSpace);\n        } else {\n          console.warn(\"THREE.Color: Invalid hex color \" + style);\n        }\n      } else if (style && style.length > 0) {\n        return this.setColorName(style, colorSpace);\n      }\n      return this;\n    }\n    setColorName(style, colorSpace = SRGBColorSpace) {\n      const hex = _colorKeywords[style.toLowerCase()];\n      if (hex !== void 0) {\n        this.setHex(hex, colorSpace);\n      } else {\n        console.warn(\"THREE.Color: Unknown color \" + style);\n      }\n      return this;\n    }\n    clone() {\n      return new this.constructor(this.r, this.g, this.b);\n    }\n    copy(color) {\n      this.r = color.r;\n      this.g = color.g;\n      this.b = color.b;\n      return this;\n    }\n    copySRGBToLinear(color) {\n      this.r = SRGBToLinear(color.r);\n      this.g = SRGBToLinear(color.g);\n      this.b = SRGBToLinear(color.b);\n      return this;\n    }\n    copyLinearToSRGB(color) {\n      this.r = LinearToSRGB(color.r);\n      this.g = LinearToSRGB(color.g);\n      this.b = LinearToSRGB(color.b);\n      return this;\n    }\n    convertSRGBToLinear() {\n      this.copySRGBToLinear(this);\n      return this;\n    }\n    convertLinearToSRGB() {\n      this.copyLinearToSRGB(this);\n      return this;\n    }\n    getHex(colorSpace = SRGBColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));\n    }\n    getHexString(colorSpace = SRGBColorSpace) {\n      return (\"000000\" + this.getHex(colorSpace).toString(16)).slice(-6);\n    }\n    getHSL(target, colorSpace = ColorManagement.workingColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      const r = _color.r, g = _color.g, b = _color.b;\n      const max2 = Math.max(r, g, b);\n      const min = Math.min(r, g, b);\n      let hue, saturation;\n      const lightness = (min + max2) / 2;\n      if (min === max2) {\n        hue = 0;\n        saturation = 0;\n      } else {\n        const delta = max2 - min;\n        saturation = lightness <= 0.5 ? delta / (max2 + min) : delta / (2 - max2 - min);\n        switch (max2) {\n          case r:\n            hue = (g - b) / delta + (g < b ? 6 : 0);\n            break;\n          case g:\n            hue = (b - r) / delta + 2;\n            break;\n          case b:\n            hue = (r - g) / delta + 4;\n            break;\n        }\n        hue /= 6;\n      }\n      target.h = hue;\n      target.s = saturation;\n      target.l = lightness;\n      return target;\n    }\n    getRGB(target, colorSpace = ColorManagement.workingColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      target.r = _color.r;\n      target.g = _color.g;\n      target.b = _color.b;\n      return target;\n    }\n    getStyle(colorSpace = SRGBColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      const r = _color.r, g = _color.g, b = _color.b;\n      if (colorSpace !== SRGBColorSpace) {\n        return \\`color(\\${colorSpace} \\${r.toFixed(3)} \\${g.toFixed(3)} \\${b.toFixed(3)})\\`;\n      }\n      return \\`rgb(\\${Math.round(r * 255)},\\${Math.round(g * 255)},\\${Math.round(b * 255)})\\`;\n    }\n    offsetHSL(h, s, l) {\n      this.getHSL(_hslA);\n      return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);\n    }\n    add(color) {\n      this.r += color.r;\n      this.g += color.g;\n      this.b += color.b;\n      return this;\n    }\n    addColors(color1, color2) {\n      this.r = color1.r + color2.r;\n      this.g = color1.g + color2.g;\n      this.b = color1.b + color2.b;\n      return this;\n    }\n    addScalar(s) {\n      this.r += s;\n      this.g += s;\n      this.b += s;\n      return this;\n    }\n    sub(color) {\n      this.r = Math.max(0, this.r - color.r);\n      this.g = Math.max(0, this.g - color.g);\n      this.b = Math.max(0, this.b - color.b);\n      return this;\n    }\n    multiply(color) {\n      this.r *= color.r;\n      this.g *= color.g;\n      this.b *= color.b;\n      return this;\n    }\n    multiplyScalar(s) {\n      this.r *= s;\n      this.g *= s;\n      this.b *= s;\n      return this;\n    }\n    lerp(color, alpha) {\n      this.r += (color.r - this.r) * alpha;\n      this.g += (color.g - this.g) * alpha;\n      this.b += (color.b - this.b) * alpha;\n      return this;\n    }\n    lerpColors(color1, color2, alpha) {\n      this.r = color1.r + (color2.r - color1.r) * alpha;\n      this.g = color1.g + (color2.g - color1.g) * alpha;\n      this.b = color1.b + (color2.b - color1.b) * alpha;\n      return this;\n    }\n    lerpHSL(color, alpha) {\n      this.getHSL(_hslA);\n      color.getHSL(_hslB);\n      const h = lerp(_hslA.h, _hslB.h, alpha);\n      const s = lerp(_hslA.s, _hslB.s, alpha);\n      const l = lerp(_hslA.l, _hslB.l, alpha);\n      this.setHSL(h, s, l);\n      return this;\n    }\n    setFromVector3(v) {\n      this.r = v.x;\n      this.g = v.y;\n      this.b = v.z;\n      return this;\n    }\n    applyMatrix3(m) {\n      const r = this.r, g = this.g, b = this.b;\n      const e = m.elements;\n      this.r = e[0] * r + e[3] * g + e[6] * b;\n      this.g = e[1] * r + e[4] * g + e[7] * b;\n      this.b = e[2] * r + e[5] * g + e[8] * b;\n      return this;\n    }\n    equals(c) {\n      return c.r === this.r && c.g === this.g && c.b === this.b;\n    }\n    fromArray(array, offset = 0) {\n      this.r = array[offset];\n      this.g = array[offset + 1];\n      this.b = array[offset + 2];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.r;\n      array[offset + 1] = this.g;\n      array[offset + 2] = this.b;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.r = attribute.getX(index);\n      this.g = attribute.getY(index);\n      this.b = attribute.getZ(index);\n      return this;\n    }\n    toJSON() {\n      return this.getHex();\n    }\n    *[Symbol.iterator]() {\n      yield this.r;\n      yield this.g;\n      yield this.b;\n    }\n  }\n  const _color = /* @__PURE__ */ new Color();\n  Color.NAMES = _colorKeywords;\n  let _materialId = 0;\n  class Material extends EventDispatcher {\n    constructor() {\n      super();\n      this.isMaterial = true;\n      Object.defineProperty(this, \"id\", { value: _materialId++ });\n      this.uuid = generateUUID();\n      this.name = \"\";\n      this.type = \"Material\";\n      this.blending = NormalBlending;\n      this.side = FrontSide;\n      this.vertexColors = false;\n      this.opacity = 1;\n      this.transparent = false;\n      this.alphaHash = false;\n      this.blendSrc = SrcAlphaFactor;\n      this.blendDst = OneMinusSrcAlphaFactor;\n      this.blendEquation = AddEquation;\n      this.blendSrcAlpha = null;\n      this.blendDstAlpha = null;\n      this.blendEquationAlpha = null;\n      this.blendColor = new Color(0, 0, 0);\n      this.blendAlpha = 0;\n      this.depthFunc = LessEqualDepth;\n      this.depthTest = true;\n      this.depthWrite = true;\n      this.stencilWriteMask = 255;\n      this.stencilFunc = AlwaysStencilFunc;\n      this.stencilRef = 0;\n      this.stencilFuncMask = 255;\n      this.stencilFail = KeepStencilOp;\n      this.stencilZFail = KeepStencilOp;\n      this.stencilZPass = KeepStencilOp;\n      this.stencilWrite = false;\n      this.clippingPlanes = null;\n      this.clipIntersection = false;\n      this.clipShadows = false;\n      this.shadowSide = null;\n      this.colorWrite = true;\n      this.precision = null;\n      this.polygonOffset = false;\n      this.polygonOffsetFactor = 0;\n      this.polygonOffsetUnits = 0;\n      this.dithering = false;\n      this.alphaToCoverage = false;\n      this.premultipliedAlpha = false;\n      this.forceSinglePass = false;\n      this.visible = true;\n      this.toneMapped = true;\n      this.userData = {};\n      this.version = 0;\n      this._alphaTest = 0;\n    }\n    get alphaTest() {\n      return this._alphaTest;\n    }\n    set alphaTest(value) {\n      if (this._alphaTest > 0 !== value > 0) {\n        this.version++;\n      }\n      this._alphaTest = value;\n    }\n    // onBeforeRender and onBeforeCompile only supported in WebGLRenderer\n    onBeforeRender() {\n    }\n    onBeforeCompile() {\n    }\n    customProgramCacheKey() {\n      return this.onBeforeCompile.toString();\n    }\n    setValues(values) {\n      if (values === void 0) return;\n      for (const key in values) {\n        const newValue = values[key];\n        if (newValue === void 0) {\n          console.warn(\\`THREE.Material: parameter '\\${key}' has value of undefined.\\`);\n          continue;\n        }\n        const currentValue = this[key];\n        if (currentValue === void 0) {\n          console.warn(\\`THREE.Material: '\\${key}' is not a property of THREE.\\${this.type}.\\`);\n          continue;\n        }\n        if (currentValue && currentValue.isColor) {\n          currentValue.set(newValue);\n        } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {\n          currentValue.copy(newValue);\n        } else {\n          this[key] = newValue;\n        }\n      }\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === \"string\";\n      if (isRootObject) {\n        meta = {\n          textures: {},\n          images: {}\n        };\n      }\n      const data = {\n        metadata: {\n          version: 4.6,\n          type: \"Material\",\n          generator: \"Material.toJSON\"\n        }\n      };\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== \"\") data.name = this.name;\n      if (this.color && this.color.isColor) data.color = this.color.getHex();\n      if (this.roughness !== void 0) data.roughness = this.roughness;\n      if (this.metalness !== void 0) data.metalness = this.metalness;\n      if (this.sheen !== void 0) data.sheen = this.sheen;\n      if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();\n      if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;\n      if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();\n      if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;\n      if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();\n      if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;\n      if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();\n      if (this.shininess !== void 0) data.shininess = this.shininess;\n      if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;\n      if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;\n      if (this.clearcoatMap && this.clearcoatMap.isTexture) {\n        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;\n      }\n      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n      }\n      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {\n        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;\n        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n      }\n      if (this.dispersion !== void 0) data.dispersion = this.dispersion;\n      if (this.iridescence !== void 0) data.iridescence = this.iridescence;\n      if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;\n      if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;\n      if (this.iridescenceMap && this.iridescenceMap.isTexture) {\n        data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;\n      }\n      if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {\n        data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;\n      }\n      if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;\n      if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;\n      if (this.anisotropyMap && this.anisotropyMap.isTexture) {\n        data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;\n      }\n      if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n      if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;\n      if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n      if (this.lightMap && this.lightMap.isTexture) {\n        data.lightMap = this.lightMap.toJSON(meta).uuid;\n        data.lightMapIntensity = this.lightMapIntensity;\n      }\n      if (this.aoMap && this.aoMap.isTexture) {\n        data.aoMap = this.aoMap.toJSON(meta).uuid;\n        data.aoMapIntensity = this.aoMapIntensity;\n      }\n      if (this.bumpMap && this.bumpMap.isTexture) {\n        data.bumpMap = this.bumpMap.toJSON(meta).uuid;\n        data.bumpScale = this.bumpScale;\n      }\n      if (this.normalMap && this.normalMap.isTexture) {\n        data.normalMap = this.normalMap.toJSON(meta).uuid;\n        data.normalMapType = this.normalMapType;\n        data.normalScale = this.normalScale.toArray();\n      }\n      if (this.displacementMap && this.displacementMap.isTexture) {\n        data.displacementMap = this.displacementMap.toJSON(meta).uuid;\n        data.displacementScale = this.displacementScale;\n        data.displacementBias = this.displacementBias;\n      }\n      if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\n      if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\n      if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\n      if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;\n      if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;\n      if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;\n      if (this.envMap && this.envMap.isTexture) {\n        data.envMap = this.envMap.toJSON(meta).uuid;\n        if (this.combine !== void 0) data.combine = this.combine;\n      }\n      if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();\n      if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;\n      if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;\n      if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;\n      if (this.gradientMap && this.gradientMap.isTexture) {\n        data.gradientMap = this.gradientMap.toJSON(meta).uuid;\n      }\n      if (this.transmission !== void 0) data.transmission = this.transmission;\n      if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;\n      if (this.thickness !== void 0) data.thickness = this.thickness;\n      if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;\n      if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;\n      if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();\n      if (this.size !== void 0) data.size = this.size;\n      if (this.shadowSide !== null) data.shadowSide = this.shadowSide;\n      if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;\n      if (this.blending !== NormalBlending) data.blending = this.blending;\n      if (this.side !== FrontSide) data.side = this.side;\n      if (this.vertexColors === true) data.vertexColors = true;\n      if (this.opacity < 1) data.opacity = this.opacity;\n      if (this.transparent === true) data.transparent = true;\n      if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;\n      if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;\n      if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;\n      if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;\n      if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;\n      if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;\n      if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();\n      if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;\n      if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;\n      if (this.depthTest === false) data.depthTest = this.depthTest;\n      if (this.depthWrite === false) data.depthWrite = this.depthWrite;\n      if (this.colorWrite === false) data.colorWrite = this.colorWrite;\n      if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;\n      if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;\n      if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;\n      if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;\n      if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;\n      if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;\n      if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;\n      if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;\n      if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;\n      if (this.polygonOffset === true) data.polygonOffset = true;\n      if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;\n      if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;\n      if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;\n      if (this.dashSize !== void 0) data.dashSize = this.dashSize;\n      if (this.gapSize !== void 0) data.gapSize = this.gapSize;\n      if (this.scale !== void 0) data.scale = this.scale;\n      if (this.dithering === true) data.dithering = true;\n      if (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n      if (this.alphaHash === true) data.alphaHash = true;\n      if (this.alphaToCoverage === true) data.alphaToCoverage = true;\n      if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;\n      if (this.forceSinglePass === true) data.forceSinglePass = true;\n      if (this.wireframe === true) data.wireframe = true;\n      if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;\n      if (this.wireframeLinecap !== \"round\") data.wireframeLinecap = this.wireframeLinecap;\n      if (this.wireframeLinejoin !== \"round\") data.wireframeLinejoin = this.wireframeLinejoin;\n      if (this.flatShading === true) data.flatShading = true;\n      if (this.visible === false) data.visible = false;\n      if (this.toneMapped === false) data.toneMapped = false;\n      if (this.fog === false) data.fog = false;\n      if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n      function extractFromCache(cache) {\n        const values = [];\n        for (const key in cache) {\n          const data2 = cache[key];\n          delete data2.metadata;\n          values.push(data2);\n        }\n        return values;\n      }\n      if (isRootObject) {\n        const textures = extractFromCache(meta.textures);\n        const images = extractFromCache(meta.images);\n        if (textures.length > 0) data.textures = textures;\n        if (images.length > 0) data.images = images;\n      }\n      return data;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.name = source.name;\n      this.blending = source.blending;\n      this.side = source.side;\n      this.vertexColors = source.vertexColors;\n      this.opacity = source.opacity;\n      this.transparent = source.transparent;\n      this.blendSrc = source.blendSrc;\n      this.blendDst = source.blendDst;\n      this.blendEquation = source.blendEquation;\n      this.blendSrcAlpha = source.blendSrcAlpha;\n      this.blendDstAlpha = source.blendDstAlpha;\n      this.blendEquationAlpha = source.blendEquationAlpha;\n      this.blendColor.copy(source.blendColor);\n      this.blendAlpha = source.blendAlpha;\n      this.depthFunc = source.depthFunc;\n      this.depthTest = source.depthTest;\n      this.depthWrite = source.depthWrite;\n      this.stencilWriteMask = source.stencilWriteMask;\n      this.stencilFunc = source.stencilFunc;\n      this.stencilRef = source.stencilRef;\n      this.stencilFuncMask = source.stencilFuncMask;\n      this.stencilFail = source.stencilFail;\n      this.stencilZFail = source.stencilZFail;\n      this.stencilZPass = source.stencilZPass;\n      this.stencilWrite = source.stencilWrite;\n      const srcPlanes = source.clippingPlanes;\n      let dstPlanes = null;\n      if (srcPlanes !== null) {\n        const n = srcPlanes.length;\n        dstPlanes = new Array(n);\n        for (let i2 = 0; i2 !== n; ++i2) {\n          dstPlanes[i2] = srcPlanes[i2].clone();\n        }\n      }\n      this.clippingPlanes = dstPlanes;\n      this.clipIntersection = source.clipIntersection;\n      this.clipShadows = source.clipShadows;\n      this.shadowSide = source.shadowSide;\n      this.colorWrite = source.colorWrite;\n      this.precision = source.precision;\n      this.polygonOffset = source.polygonOffset;\n      this.polygonOffsetFactor = source.polygonOffsetFactor;\n      this.polygonOffsetUnits = source.polygonOffsetUnits;\n      this.dithering = source.dithering;\n      this.alphaTest = source.alphaTest;\n      this.alphaHash = source.alphaHash;\n      this.alphaToCoverage = source.alphaToCoverage;\n      this.premultipliedAlpha = source.premultipliedAlpha;\n      this.forceSinglePass = source.forceSinglePass;\n      this.visible = source.visible;\n      this.toneMapped = source.toneMapped;\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      return this;\n    }\n    dispose() {\n      this.dispatchEvent({ type: \"dispose\" });\n    }\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    onBuild() {\n      console.warn(\"Material: onBuild() has been removed.\");\n    }\n  }\n  class MeshBasicMaterial extends Material {\n    constructor(parameters) {\n      super();\n      this.isMeshBasicMaterial = true;\n      this.type = \"MeshBasicMaterial\";\n      this.color = new Color(16777215);\n      this.map = null;\n      this.lightMap = null;\n      this.lightMapIntensity = 1;\n      this.aoMap = null;\n      this.aoMapIntensity = 1;\n      this.specularMap = null;\n      this.alphaMap = null;\n      this.envMap = null;\n      this.envMapRotation = new Euler();\n      this.combine = MultiplyOperation;\n      this.reflectivity = 1;\n      this.refractionRatio = 0.98;\n      this.wireframe = false;\n      this.wireframeLinewidth = 1;\n      this.wireframeLinecap = \"round\";\n      this.wireframeLinejoin = \"round\";\n      this.fog = true;\n      this.setValues(parameters);\n    }\n    copy(source) {\n      super.copy(source);\n      this.color.copy(source.color);\n      this.map = source.map;\n      this.lightMap = source.lightMap;\n      this.lightMapIntensity = source.lightMapIntensity;\n      this.aoMap = source.aoMap;\n      this.aoMapIntensity = source.aoMapIntensity;\n      this.specularMap = source.specularMap;\n      this.alphaMap = source.alphaMap;\n      this.envMap = source.envMap;\n      this.envMapRotation.copy(source.envMapRotation);\n      this.combine = source.combine;\n      this.reflectivity = source.reflectivity;\n      this.refractionRatio = source.refractionRatio;\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.wireframeLinecap = source.wireframeLinecap;\n      this.wireframeLinejoin = source.wireframeLinejoin;\n      this.fog = source.fog;\n      return this;\n    }\n  }\n  const _vector$9 = /* @__PURE__ */ new Vector3();\n  const _vector2$1 = /* @__PURE__ */ new Vector2();\n  class BufferAttribute {\n    constructor(array, itemSize, normalized = false) {\n      if (Array.isArray(array)) {\n        throw new TypeError(\"THREE.BufferAttribute: array should be a Typed Array.\");\n      }\n      this.isBufferAttribute = true;\n      this.name = \"\";\n      this.array = array;\n      this.itemSize = itemSize;\n      this.count = array !== void 0 ? array.length / itemSize : 0;\n      this.normalized = normalized;\n      this.usage = StaticDrawUsage;\n      this.updateRanges = [];\n      this.gpuType = FloatType;\n      this.version = 0;\n    }\n    onUploadCallback() {\n    }\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    setUsage(value) {\n      this.usage = value;\n      return this;\n    }\n    addUpdateRange(start, count) {\n      this.updateRanges.push({ start, count });\n    }\n    clearUpdateRanges() {\n      this.updateRanges.length = 0;\n    }\n    copy(source) {\n      this.name = source.name;\n      this.array = new source.array.constructor(source.array);\n      this.itemSize = source.itemSize;\n      this.count = source.count;\n      this.normalized = source.normalized;\n      this.usage = source.usage;\n      this.gpuType = source.gpuType;\n      return this;\n    }\n    copyAt(index1, attribute, index2) {\n      index1 *= this.itemSize;\n      index2 *= attribute.itemSize;\n      for (let i2 = 0, l = this.itemSize; i2 < l; i2++) {\n        this.array[index1 + i2] = attribute.array[index2 + i2];\n      }\n      return this;\n    }\n    copyArray(array) {\n      this.array.set(array);\n      return this;\n    }\n    applyMatrix3(m) {\n      if (this.itemSize === 2) {\n        for (let i2 = 0, l = this.count; i2 < l; i2++) {\n          _vector2$1.fromBufferAttribute(this, i2);\n          _vector2$1.applyMatrix3(m);\n          this.setXY(i2, _vector2$1.x, _vector2$1.y);\n        }\n      } else if (this.itemSize === 3) {\n        for (let i2 = 0, l = this.count; i2 < l; i2++) {\n          _vector$9.fromBufferAttribute(this, i2);\n          _vector$9.applyMatrix3(m);\n          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n        }\n      }\n      return this;\n    }\n    applyMatrix4(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.applyMatrix4(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    applyNormalMatrix(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.applyNormalMatrix(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    transformDirection(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.transformDirection(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    set(value, offset = 0) {\n      this.array.set(value, offset);\n      return this;\n    }\n    getComponent(index, component) {\n      let value = this.array[index * this.itemSize + component];\n      if (this.normalized) value = denormalize(value, this.array);\n      return value;\n    }\n    setComponent(index, component, value) {\n      if (this.normalized) value = normalize$1(value, this.array);\n      this.array[index * this.itemSize + component] = value;\n      return this;\n    }\n    getX(index) {\n      let x2 = this.array[index * this.itemSize];\n      if (this.normalized) x2 = denormalize(x2, this.array);\n      return x2;\n    }\n    setX(index, x2) {\n      if (this.normalized) x2 = normalize$1(x2, this.array);\n      this.array[index * this.itemSize] = x2;\n      return this;\n    }\n    getY(index) {\n      let y = this.array[index * this.itemSize + 1];\n      if (this.normalized) y = denormalize(y, this.array);\n      return y;\n    }\n    setY(index, y) {\n      if (this.normalized) y = normalize$1(y, this.array);\n      this.array[index * this.itemSize + 1] = y;\n      return this;\n    }\n    getZ(index) {\n      let z = this.array[index * this.itemSize + 2];\n      if (this.normalized) z = denormalize(z, this.array);\n      return z;\n    }\n    setZ(index, z) {\n      if (this.normalized) z = normalize$1(z, this.array);\n      this.array[index * this.itemSize + 2] = z;\n      return this;\n    }\n    getW(index) {\n      let w = this.array[index * this.itemSize + 3];\n      if (this.normalized) w = denormalize(w, this.array);\n      return w;\n    }\n    setW(index, w) {\n      if (this.normalized) w = normalize$1(w, this.array);\n      this.array[index * this.itemSize + 3] = w;\n      return this;\n    }\n    setXY(index, x2, y) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$1(x2, this.array);\n        y = normalize$1(y, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      return this;\n    }\n    setXYZ(index, x2, y, z) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$1(x2, this.array);\n        y = normalize$1(y, this.array);\n        z = normalize$1(z, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      this.array[index + 2] = z;\n      return this;\n    }\n    setXYZW(index, x2, y, z, w) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$1(x2, this.array);\n        y = normalize$1(y, this.array);\n        z = normalize$1(z, this.array);\n        w = normalize$1(w, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      this.array[index + 2] = z;\n      this.array[index + 3] = w;\n      return this;\n    }\n    onUpload(callback) {\n      this.onUploadCallback = callback;\n      return this;\n    }\n    clone() {\n      return new this.constructor(this.array, this.itemSize).copy(this);\n    }\n    toJSON() {\n      const data = {\n        itemSize: this.itemSize,\n        type: this.array.constructor.name,\n        array: Array.from(this.array),\n        normalized: this.normalized\n      };\n      if (this.name !== \"\") data.name = this.name;\n      if (this.usage !== StaticDrawUsage) data.usage = this.usage;\n      return data;\n    }\n  }\n  class Uint16BufferAttribute extends BufferAttribute {\n    constructor(array, itemSize, normalized) {\n      super(new Uint16Array(array), itemSize, normalized);\n    }\n  }\n  class Uint32BufferAttribute extends BufferAttribute {\n    constructor(array, itemSize, normalized) {\n      super(new Uint32Array(array), itemSize, normalized);\n    }\n  }\n  class Float32BufferAttribute extends BufferAttribute {\n    constructor(array, itemSize, normalized) {\n      super(new Float32Array(array), itemSize, normalized);\n    }\n  }\n  let _id$1 = 0;\n  const _m1 = /* @__PURE__ */ new Matrix4();\n  const _obj = /* @__PURE__ */ new Object3D();\n  const _offset = /* @__PURE__ */ new Vector3();\n  const _box$2 = /* @__PURE__ */ new Box3();\n  const _boxMorphTargets = /* @__PURE__ */ new Box3();\n  const _vector$8 = /* @__PURE__ */ new Vector3();\n  class BufferGeometry extends EventDispatcher {\n    constructor() {\n      super();\n      this.isBufferGeometry = true;\n      Object.defineProperty(this, \"id\", { value: _id$1++ });\n      this.uuid = generateUUID();\n      this.name = \"\";\n      this.type = \"BufferGeometry\";\n      this.index = null;\n      this.indirect = null;\n      this.attributes = {};\n      this.morphAttributes = {};\n      this.morphTargetsRelative = false;\n      this.groups = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n      this.drawRange = { start: 0, count: Infinity };\n      this.userData = {};\n    }\n    getIndex() {\n      return this.index;\n    }\n    setIndex(index) {\n      if (Array.isArray(index)) {\n        this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n      } else {\n        this.index = index;\n      }\n      return this;\n    }\n    setIndirect(indirect) {\n      this.indirect = indirect;\n      return this;\n    }\n    getIndirect() {\n      return this.indirect;\n    }\n    getAttribute(name) {\n      return this.attributes[name];\n    }\n    setAttribute(name, attribute) {\n      this.attributes[name] = attribute;\n      return this;\n    }\n    deleteAttribute(name) {\n      delete this.attributes[name];\n      return this;\n    }\n    hasAttribute(name) {\n      return this.attributes[name] !== void 0;\n    }\n    addGroup(start, count, materialIndex = 0) {\n      this.groups.push({\n        start,\n        count,\n        materialIndex\n      });\n    }\n    clearGroups() {\n      this.groups = [];\n    }\n    setDrawRange(start, count) {\n      this.drawRange.start = start;\n      this.drawRange.count = count;\n    }\n    applyMatrix4(matrix) {\n      const position = this.attributes.position;\n      if (position !== void 0) {\n        position.applyMatrix4(matrix);\n        position.needsUpdate = true;\n      }\n      const normal = this.attributes.normal;\n      if (normal !== void 0) {\n        const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n        normal.applyNormalMatrix(normalMatrix);\n        normal.needsUpdate = true;\n      }\n      const tangent = this.attributes.tangent;\n      if (tangent !== void 0) {\n        tangent.transformDirection(matrix);\n        tangent.needsUpdate = true;\n      }\n      if (this.boundingBox !== null) {\n        this.computeBoundingBox();\n      }\n      if (this.boundingSphere !== null) {\n        this.computeBoundingSphere();\n      }\n      return this;\n    }\n    applyQuaternion(q) {\n      _m1.makeRotationFromQuaternion(q);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateX(angle) {\n      _m1.makeRotationX(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateY(angle) {\n      _m1.makeRotationY(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateZ(angle) {\n      _m1.makeRotationZ(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    translate(x2, y, z) {\n      _m1.makeTranslation(x2, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    scale(x2, y, z) {\n      _m1.makeScale(x2, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    lookAt(vector) {\n      _obj.lookAt(vector);\n      _obj.updateMatrix();\n      this.applyMatrix4(_obj.matrix);\n      return this;\n    }\n    center() {\n      this.computeBoundingBox();\n      this.boundingBox.getCenter(_offset).negate();\n      this.translate(_offset.x, _offset.y, _offset.z);\n      return this;\n    }\n    setFromPoints(points) {\n      const positionAttribute = this.getAttribute(\"position\");\n      if (positionAttribute === void 0) {\n        const position = [];\n        for (let i2 = 0, l = points.length; i2 < l; i2++) {\n          const point = points[i2];\n          position.push(point.x, point.y, point.z || 0);\n        }\n        this.setAttribute(\"position\", new Float32BufferAttribute(position, 3));\n      } else {\n        const l = Math.min(points.length, positionAttribute.count);\n        for (let i2 = 0; i2 < l; i2++) {\n          const point = points[i2];\n          positionAttribute.setXYZ(i2, point.x, point.y, point.z || 0);\n        }\n        if (points.length > positionAttribute.count) {\n          console.warn(\"THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.\");\n        }\n        positionAttribute.needsUpdate = true;\n      }\n      return this;\n    }\n    computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new Box3();\n      }\n      const position = this.attributes.position;\n      const morphAttributesPosition = this.morphAttributes.position;\n      if (position && position.isGLBufferAttribute) {\n        console.error(\"THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.\", this);\n        this.boundingBox.set(\n          new Vector3(-Infinity, -Infinity, -Infinity),\n          new Vector3(Infinity, Infinity, Infinity)\n        );\n        return;\n      }\n      if (position !== void 0) {\n        this.boundingBox.setFromBufferAttribute(position);\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            _box$2.setFromBufferAttribute(morphAttribute);\n            if (this.morphTargetsRelative) {\n              _vector$8.addVectors(this.boundingBox.min, _box$2.min);\n              this.boundingBox.expandByPoint(_vector$8);\n              _vector$8.addVectors(this.boundingBox.max, _box$2.max);\n              this.boundingBox.expandByPoint(_vector$8);\n            } else {\n              this.boundingBox.expandByPoint(_box$2.min);\n              this.boundingBox.expandByPoint(_box$2.max);\n            }\n          }\n        }\n      } else {\n        this.boundingBox.makeEmpty();\n      }\n      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n        console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n      }\n    }\n    computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new Sphere();\n      }\n      const position = this.attributes.position;\n      const morphAttributesPosition = this.morphAttributes.position;\n      if (position && position.isGLBufferAttribute) {\n        console.error(\"THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.\", this);\n        this.boundingSphere.set(new Vector3(), Infinity);\n        return;\n      }\n      if (position) {\n        const center = this.boundingSphere.center;\n        _box$2.setFromBufferAttribute(position);\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n            if (this.morphTargetsRelative) {\n              _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);\n              _box$2.expandByPoint(_vector$8);\n              _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);\n              _box$2.expandByPoint(_vector$8);\n            } else {\n              _box$2.expandByPoint(_boxMorphTargets.min);\n              _box$2.expandByPoint(_boxMorphTargets.max);\n            }\n          }\n        }\n        _box$2.getCenter(center);\n        let maxRadiusSq = 0;\n        for (let i2 = 0, il = position.count; i2 < il; i2++) {\n          _vector$8.fromBufferAttribute(position, i2);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n        }\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            const morphTargetsRelative = this.morphTargetsRelative;\n            for (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n              _vector$8.fromBufferAttribute(morphAttribute, j);\n              if (morphTargetsRelative) {\n                _offset.fromBufferAttribute(position, j);\n                _vector$8.add(_offset);\n              }\n              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n            }\n          }\n        }\n        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n        if (isNaN(this.boundingSphere.radius)) {\n          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n        }\n      }\n    }\n    computeTangents() {\n      const index = this.index;\n      const attributes = this.attributes;\n      if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {\n        console.error(\"THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)\");\n        return;\n      }\n      const positionAttribute = attributes.position;\n      const normalAttribute = attributes.normal;\n      const uvAttribute = attributes.uv;\n      if (this.hasAttribute(\"tangent\") === false) {\n        this.setAttribute(\"tangent\", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));\n      }\n      const tangentAttribute = this.getAttribute(\"tangent\");\n      const tan1 = [], tan2 = [];\n      for (let i2 = 0; i2 < positionAttribute.count; i2++) {\n        tan1[i2] = new Vector3();\n        tan2[i2] = new Vector3();\n      }\n      const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();\n      function handleTriangle(a, b, c) {\n        vA.fromBufferAttribute(positionAttribute, a);\n        vB.fromBufferAttribute(positionAttribute, b);\n        vC.fromBufferAttribute(positionAttribute, c);\n        uvA.fromBufferAttribute(uvAttribute, a);\n        uvB.fromBufferAttribute(uvAttribute, b);\n        uvC.fromBufferAttribute(uvAttribute, c);\n        vB.sub(vA);\n        vC.sub(vA);\n        uvB.sub(uvA);\n        uvC.sub(uvA);\n        const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);\n        if (!isFinite(r)) return;\n        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n        tan1[a].add(sdir);\n        tan1[b].add(sdir);\n        tan1[c].add(sdir);\n        tan2[a].add(tdir);\n        tan2[b].add(tdir);\n        tan2[c].add(tdir);\n      }\n      let groups = this.groups;\n      if (groups.length === 0) {\n        groups = [{\n          start: 0,\n          count: index.count\n        }];\n      }\n      for (let i2 = 0, il = groups.length; i2 < il; ++i2) {\n        const group = groups[i2];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          handleTriangle(\n            index.getX(j + 0),\n            index.getX(j + 1),\n            index.getX(j + 2)\n          );\n        }\n      }\n      const tmp = new Vector3(), tmp2 = new Vector3();\n      const n = new Vector3(), n2 = new Vector3();\n      function handleVertex(v) {\n        n.fromBufferAttribute(normalAttribute, v);\n        n2.copy(n);\n        const t = tan1[v];\n        tmp.copy(t);\n        tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n        tmp2.crossVectors(n2, t);\n        const test = tmp2.dot(tan2[v]);\n        const w = test < 0 ? -1 : 1;\n        tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);\n      }\n      for (let i2 = 0, il = groups.length; i2 < il; ++i2) {\n        const group = groups[i2];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          handleVertex(index.getX(j + 0));\n          handleVertex(index.getX(j + 1));\n          handleVertex(index.getX(j + 2));\n        }\n      }\n    }\n    computeVertexNormals() {\n      const index = this.index;\n      const positionAttribute = this.getAttribute(\"position\");\n      if (positionAttribute !== void 0) {\n        let normalAttribute = this.getAttribute(\"normal\");\n        if (normalAttribute === void 0) {\n          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n          this.setAttribute(\"normal\", normalAttribute);\n        } else {\n          for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {\n            normalAttribute.setXYZ(i2, 0, 0, 0);\n          }\n        }\n        const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n        const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n        const cb = new Vector3(), ab = new Vector3();\n        if (index) {\n          for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {\n            const vA = index.getX(i2 + 0);\n            const vB = index.getX(i2 + 1);\n            const vC = index.getX(i2 + 2);\n            pA.fromBufferAttribute(positionAttribute, vA);\n            pB.fromBufferAttribute(positionAttribute, vB);\n            pC.fromBufferAttribute(positionAttribute, vC);\n            cb.subVectors(pC, pB);\n            ab.subVectors(pA, pB);\n            cb.cross(ab);\n            nA.fromBufferAttribute(normalAttribute, vA);\n            nB.fromBufferAttribute(normalAttribute, vB);\n            nC.fromBufferAttribute(normalAttribute, vC);\n            nA.add(cb);\n            nB.add(cb);\n            nC.add(cb);\n            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n          }\n        } else {\n          for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {\n            pA.fromBufferAttribute(positionAttribute, i2 + 0);\n            pB.fromBufferAttribute(positionAttribute, i2 + 1);\n            pC.fromBufferAttribute(positionAttribute, i2 + 2);\n            cb.subVectors(pC, pB);\n            ab.subVectors(pA, pB);\n            cb.cross(ab);\n            normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);\n            normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);\n            normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);\n          }\n        }\n        this.normalizeNormals();\n        normalAttribute.needsUpdate = true;\n      }\n    }\n    normalizeNormals() {\n      const normals = this.attributes.normal;\n      for (let i2 = 0, il = normals.count; i2 < il; i2++) {\n        _vector$8.fromBufferAttribute(normals, i2);\n        _vector$8.normalize();\n        normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);\n      }\n    }\n    toNonIndexed() {\n      function convertBufferAttribute(attribute, indices2) {\n        const array = attribute.array;\n        const itemSize = attribute.itemSize;\n        const normalized = attribute.normalized;\n        const array2 = new array.constructor(indices2.length * itemSize);\n        let index = 0, index2 = 0;\n        for (let i2 = 0, l = indices2.length; i2 < l; i2++) {\n          if (attribute.isInterleavedBufferAttribute) {\n            index = indices2[i2] * attribute.data.stride + attribute.offset;\n          } else {\n            index = indices2[i2] * itemSize;\n          }\n          for (let j = 0; j < itemSize; j++) {\n            array2[index2++] = array[index++];\n          }\n        }\n        return new BufferAttribute(array2, itemSize, normalized);\n      }\n      if (this.index === null) {\n        console.warn(\"THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.\");\n        return this;\n      }\n      const geometry2 = new BufferGeometry();\n      const indices = this.index.array;\n      const attributes = this.attributes;\n      for (const name in attributes) {\n        const attribute = attributes[name];\n        const newAttribute = convertBufferAttribute(attribute, indices);\n        geometry2.setAttribute(name, newAttribute);\n      }\n      const morphAttributes = this.morphAttributes;\n      for (const name in morphAttributes) {\n        const morphArray = [];\n        const morphAttribute = morphAttributes[name];\n        for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {\n          const attribute = morphAttribute[i2];\n          const newAttribute = convertBufferAttribute(attribute, indices);\n          morphArray.push(newAttribute);\n        }\n        geometry2.morphAttributes[name] = morphArray;\n      }\n      geometry2.morphTargetsRelative = this.morphTargetsRelative;\n      const groups = this.groups;\n      for (let i2 = 0, l = groups.length; i2 < l; i2++) {\n        const group = groups[i2];\n        geometry2.addGroup(group.start, group.count, group.materialIndex);\n      }\n      return geometry2;\n    }\n    toJSON() {\n      const data = {\n        metadata: {\n          version: 4.6,\n          type: \"BufferGeometry\",\n          generator: \"BufferGeometry.toJSON\"\n        }\n      };\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== \"\") data.name = this.name;\n      if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n      if (this.parameters !== void 0) {\n        const parameters = this.parameters;\n        for (const key in parameters) {\n          if (parameters[key] !== void 0) data[key] = parameters[key];\n        }\n        return data;\n      }\n      data.data = { attributes: {} };\n      const index = this.index;\n      if (index !== null) {\n        data.data.index = {\n          type: index.array.constructor.name,\n          array: Array.prototype.slice.call(index.array)\n        };\n      }\n      const attributes = this.attributes;\n      for (const key in attributes) {\n        const attribute = attributes[key];\n        data.data.attributes[key] = attribute.toJSON(data.data);\n      }\n      const morphAttributes = {};\n      let hasMorphAttributes = false;\n      for (const key in this.morphAttributes) {\n        const attributeArray = this.morphAttributes[key];\n        const array = [];\n        for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {\n          const attribute = attributeArray[i2];\n          array.push(attribute.toJSON(data.data));\n        }\n        if (array.length > 0) {\n          morphAttributes[key] = array;\n          hasMorphAttributes = true;\n        }\n      }\n      if (hasMorphAttributes) {\n        data.data.morphAttributes = morphAttributes;\n        data.data.morphTargetsRelative = this.morphTargetsRelative;\n      }\n      const groups = this.groups;\n      if (groups.length > 0) {\n        data.data.groups = JSON.parse(JSON.stringify(groups));\n      }\n      const boundingSphere = this.boundingSphere;\n      if (boundingSphere !== null) {\n        data.data.boundingSphere = {\n          center: boundingSphere.center.toArray(),\n          radius: boundingSphere.radius\n        };\n      }\n      return data;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.index = null;\n      this.attributes = {};\n      this.morphAttributes = {};\n      this.groups = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n      const data = {};\n      this.name = source.name;\n      const index = source.index;\n      if (index !== null) {\n        this.setIndex(index.clone(data));\n      }\n      const attributes = source.attributes;\n      for (const name in attributes) {\n        const attribute = attributes[name];\n        this.setAttribute(name, attribute.clone(data));\n      }\n      const morphAttributes = source.morphAttributes;\n      for (const name in morphAttributes) {\n        const array = [];\n        const morphAttribute = morphAttributes[name];\n        for (let i2 = 0, l = morphAttribute.length; i2 < l; i2++) {\n          array.push(morphAttribute[i2].clone(data));\n        }\n        this.morphAttributes[name] = array;\n      }\n      this.morphTargetsRelative = source.morphTargetsRelative;\n      const groups = source.groups;\n      for (let i2 = 0, l = groups.length; i2 < l; i2++) {\n        const group = groups[i2];\n        this.addGroup(group.start, group.count, group.materialIndex);\n      }\n      const boundingBox = source.boundingBox;\n      if (boundingBox !== null) {\n        this.boundingBox = boundingBox.clone();\n      }\n      const boundingSphere = source.boundingSphere;\n      if (boundingSphere !== null) {\n        this.boundingSphere = boundingSphere.clone();\n      }\n      this.drawRange.start = source.drawRange.start;\n      this.drawRange.count = source.drawRange.count;\n      this.userData = source.userData;\n      return this;\n    }\n    dispose() {\n      this.dispatchEvent({ type: \"dispose\" });\n    }\n  }\n  const _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();\n  const _ray$3 = /* @__PURE__ */ new Ray();\n  const _sphere$6 = /* @__PURE__ */ new Sphere();\n  const _sphereHitAt = /* @__PURE__ */ new Vector3();\n  const _vA$1 = /* @__PURE__ */ new Vector3();\n  const _vB$1 = /* @__PURE__ */ new Vector3();\n  const _vC$1 = /* @__PURE__ */ new Vector3();\n  const _tempA = /* @__PURE__ */ new Vector3();\n  const _morphA = /* @__PURE__ */ new Vector3();\n  const _intersectionPoint = /* @__PURE__ */ new Vector3();\n  const _intersectionPointWorld = /* @__PURE__ */ new Vector3();\n  class Mesh extends Object3D {\n    constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {\n      super();\n      this.isMesh = true;\n      this.type = \"Mesh\";\n      this.geometry = geometry;\n      this.material = material;\n      this.updateMorphTargets();\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      if (source.morphTargetInfluences !== void 0) {\n        this.morphTargetInfluences = source.morphTargetInfluences.slice();\n      }\n      if (source.morphTargetDictionary !== void 0) {\n        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n      }\n      this.material = Array.isArray(source.material) ? source.material.slice() : source.material;\n      this.geometry = source.geometry;\n      return this;\n    }\n    updateMorphTargets() {\n      const geometry = this.geometry;\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n        if (morphAttribute !== void 0) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    }\n    getVertexPosition(index, target) {\n      const geometry = this.geometry;\n      const position = geometry.attributes.position;\n      const morphPosition = geometry.morphAttributes.position;\n      const morphTargetsRelative = geometry.morphTargetsRelative;\n      target.fromBufferAttribute(position, index);\n      const morphInfluences = this.morphTargetInfluences;\n      if (morphPosition && morphInfluences) {\n        _morphA.set(0, 0, 0);\n        for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {\n          const influence = morphInfluences[i2];\n          const morphAttribute = morphPosition[i2];\n          if (influence === 0) continue;\n          _tempA.fromBufferAttribute(morphAttribute, index);\n          if (morphTargetsRelative) {\n            _morphA.addScaledVector(_tempA, influence);\n          } else {\n            _morphA.addScaledVector(_tempA.sub(target), influence);\n          }\n        }\n        target.add(_morphA);\n      }\n      return target;\n    }\n    raycast(raycaster, intersects) {\n      const geometry = this.geometry;\n      const material = this.material;\n      const matrixWorld = this.matrixWorld;\n      if (material === void 0) return;\n      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n      _sphere$6.copy(geometry.boundingSphere);\n      _sphere$6.applyMatrix4(matrixWorld);\n      _ray$3.copy(raycaster.ray).recast(raycaster.near);\n      if (_sphere$6.containsPoint(_ray$3.origin) === false) {\n        if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;\n        if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;\n      }\n      _inverseMatrix$3.copy(matrixWorld).invert();\n      _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);\n      if (geometry.boundingBox !== null) {\n        if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;\n      }\n      this._computeIntersections(raycaster, intersects, _ray$3);\n    }\n    _computeIntersections(raycaster, intersects, rayLocalSpace) {\n      let intersection;\n      const geometry = this.geometry;\n      const material = this.material;\n      const index = geometry.index;\n      const position = geometry.attributes.position;\n      const uv = geometry.attributes.uv;\n      const uv1 = geometry.attributes.uv1;\n      const normal = geometry.attributes.normal;\n      const groups = geometry.groups;\n      const drawRange = geometry.drawRange;\n      if (index !== null) {\n        if (Array.isArray(material)) {\n          for (let i2 = 0, il = groups.length; i2 < il; i2++) {\n            const group = groups[i2];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = index.getX(j);\n              const b = index.getX(j + 1);\n              const c = index.getX(j + 2);\n              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3);\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(index.count, drawRange.start + drawRange.count);\n          for (let i2 = start, il = end; i2 < il; i2 += 3) {\n            const a = index.getX(i2);\n            const b = index.getX(i2 + 1);\n            const c = index.getX(i2 + 2);\n            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i2 / 3);\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else if (position !== void 0) {\n        if (Array.isArray(material)) {\n          for (let i2 = 0, il = groups.length; i2 < il; i2++) {\n            const group = groups[i2];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = j;\n              const b = j + 1;\n              const c = j + 2;\n              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3);\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(position.count, drawRange.start + drawRange.count);\n          for (let i2 = start, il = end; i2 < il; i2 += 3) {\n            const a = i2;\n            const b = i2 + 1;\n            const c = i2 + 2;\n            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i2 / 3);\n              intersects.push(intersection);\n            }\n          }\n        }\n      }\n    }\n  }\n  function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {\n    let intersect;\n    if (material.side === BackSide) {\n      intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n    } else {\n      intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);\n    }\n    if (intersect === null) return null;\n    _intersectionPointWorld.copy(point);\n    _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n    if (distance < raycaster.near || distance > raycaster.far) return null;\n    return {\n      distance,\n      point: _intersectionPointWorld.clone(),\n      object\n    };\n  }\n  function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {\n    object.getVertexPosition(a, _vA$1);\n    object.getVertexPosition(b, _vB$1);\n    object.getVertexPosition(c, _vC$1);\n    const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);\n    if (intersection) {\n      const barycoord = new Vector3();\n      Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);\n      if (uv) {\n        intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2());\n      }\n      if (uv1) {\n        intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());\n      }\n      if (normal) {\n        intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3());\n        if (intersection.normal.dot(ray.direction) > 0) {\n          intersection.normal.multiplyScalar(-1);\n        }\n      }\n      const face = {\n        a,\n        b,\n        c,\n        normal: new Vector3(),\n        materialIndex: 0\n      };\n      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);\n      intersection.face = face;\n      intersection.barycoord = barycoord;\n    }\n    return intersection;\n  }\n  function cloneUniforms(src) {\n    const dst = {};\n    for (const u in src) {\n      dst[u] = {};\n      for (const p in src[u]) {\n        const property = src[u][p];\n        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {\n          if (property.isRenderTargetTexture) {\n            console.warn(\"UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().\");\n            dst[u][p] = null;\n          } else {\n            dst[u][p] = property.clone();\n          }\n        } else if (Array.isArray(property)) {\n          dst[u][p] = property.slice();\n        } else {\n          dst[u][p] = property;\n        }\n      }\n    }\n    return dst;\n  }\n  function cloneUniformsGroups(src) {\n    const dst = [];\n    for (let u = 0; u < src.length; u++) {\n      dst.push(src[u].clone());\n    }\n    return dst;\n  }\n  var default_vertex = \"void main() {\\\\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n}\";\n  var default_fragment = \"void main() {\\\\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\\\n}\";\n  class ShaderMaterial extends Material {\n    constructor(parameters) {\n      super();\n      this.isShaderMaterial = true;\n      this.type = \"ShaderMaterial\";\n      this.defines = {};\n      this.uniforms = {};\n      this.uniformsGroups = [];\n      this.vertexShader = default_vertex;\n      this.fragmentShader = default_fragment;\n      this.linewidth = 1;\n      this.wireframe = false;\n      this.wireframeLinewidth = 1;\n      this.fog = false;\n      this.lights = false;\n      this.clipping = false;\n      this.forceSinglePass = true;\n      this.extensions = {\n        clipCullDistance: false,\n        // set to use vertex shader clipping\n        multiDraw: false\n        // set to use vertex shader multi_draw / enable gl_DrawID\n      };\n      this.defaultAttributeValues = {\n        \"color\": [1, 1, 1],\n        \"uv\": [0, 0],\n        \"uv1\": [0, 0]\n      };\n      this.index0AttributeName = void 0;\n      this.uniformsNeedUpdate = false;\n      this.glslVersion = null;\n      if (parameters !== void 0) {\n        this.setValues(parameters);\n      }\n    }\n    copy(source) {\n      super.copy(source);\n      this.fragmentShader = source.fragmentShader;\n      this.vertexShader = source.vertexShader;\n      this.uniforms = cloneUniforms(source.uniforms);\n      this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);\n      this.defines = Object.assign({}, source.defines);\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.fog = source.fog;\n      this.lights = source.lights;\n      this.clipping = source.clipping;\n      this.extensions = Object.assign({}, source.extensions);\n      this.glslVersion = source.glslVersion;\n      return this;\n    }\n    toJSON(meta) {\n      const data = super.toJSON(meta);\n      data.glslVersion = this.glslVersion;\n      data.uniforms = {};\n      for (const name in this.uniforms) {\n        const uniform = this.uniforms[name];\n        const value = uniform.value;\n        if (value && value.isTexture) {\n          data.uniforms[name] = {\n            type: \"t\",\n            value: value.toJSON(meta).uuid\n          };\n        } else if (value && value.isColor) {\n          data.uniforms[name] = {\n            type: \"c\",\n            value: value.getHex()\n          };\n        } else if (value && value.isVector2) {\n          data.uniforms[name] = {\n            type: \"v2\",\n            value: value.toArray()\n          };\n        } else if (value && value.isVector3) {\n          data.uniforms[name] = {\n            type: \"v3\",\n            value: value.toArray()\n          };\n        } else if (value && value.isVector4) {\n          data.uniforms[name] = {\n            type: \"v4\",\n            value: value.toArray()\n          };\n        } else if (value && value.isMatrix3) {\n          data.uniforms[name] = {\n            type: \"m3\",\n            value: value.toArray()\n          };\n        } else if (value && value.isMatrix4) {\n          data.uniforms[name] = {\n            type: \"m4\",\n            value: value.toArray()\n          };\n        } else {\n          data.uniforms[name] = {\n            value\n          };\n        }\n      }\n      if (Object.keys(this.defines).length > 0) data.defines = this.defines;\n      data.vertexShader = this.vertexShader;\n      data.fragmentShader = this.fragmentShader;\n      data.lights = this.lights;\n      data.clipping = this.clipping;\n      const extensions = {};\n      for (const key in this.extensions) {\n        if (this.extensions[key] === true) extensions[key] = true;\n      }\n      if (Object.keys(extensions).length > 0) data.extensions = extensions;\n      return data;\n    }\n  }\n  class Camera extends Object3D {\n    constructor() {\n      super();\n      this.isCamera = true;\n      this.type = \"Camera\";\n      this.matrixWorldInverse = new Matrix4();\n      this.projectionMatrix = new Matrix4();\n      this.projectionMatrixInverse = new Matrix4();\n      this.coordinateSystem = WebGLCoordinateSystem;\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      this.matrixWorldInverse.copy(source.matrixWorldInverse);\n      this.projectionMatrix.copy(source.projectionMatrix);\n      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n      this.coordinateSystem = source.coordinateSystem;\n      return this;\n    }\n    getWorldDirection(target) {\n      return super.getWorldDirection(target).negate();\n    }\n    updateMatrixWorld(force) {\n      super.updateMatrixWorld(force);\n      this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n    updateWorldMatrix(updateParents, updateChildren) {\n      super.updateWorldMatrix(updateParents, updateChildren);\n      this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  class Scene extends Object3D {\n    constructor() {\n      super();\n      this.isScene = true;\n      this.type = \"Scene\";\n      this.background = null;\n      this.environment = null;\n      this.fog = null;\n      this.backgroundBlurriness = 0;\n      this.backgroundIntensity = 1;\n      this.backgroundRotation = new Euler();\n      this.environmentIntensity = 1;\n      this.environmentRotation = new Euler();\n      this.overrideMaterial = null;\n      if (typeof __THREE_DEVTOOLS__ !== \"undefined\") {\n        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"observe\", { detail: this }));\n      }\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      if (source.background !== null) this.background = source.background.clone();\n      if (source.environment !== null) this.environment = source.environment.clone();\n      if (source.fog !== null) this.fog = source.fog.clone();\n      this.backgroundBlurriness = source.backgroundBlurriness;\n      this.backgroundIntensity = source.backgroundIntensity;\n      this.backgroundRotation.copy(source.backgroundRotation);\n      this.environmentIntensity = source.environmentIntensity;\n      this.environmentRotation.copy(source.environmentRotation);\n      if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      return this;\n    }\n    toJSON(meta) {\n      const data = super.toJSON(meta);\n      if (this.fog !== null) data.object.fog = this.fog.toJSON();\n      if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;\n      if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;\n      data.object.backgroundRotation = this.backgroundRotation.toArray();\n      if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;\n      data.object.environmentRotation = this.environmentRotation.toArray();\n      return data;\n    }\n  }\n  class DataTexture extends Texture {\n    constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {\n      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);\n      this.isDataTexture = true;\n      this.image = { data, width, height };\n      this.generateMipmaps = false;\n      this.flipY = false;\n      this.unpackAlignment = 1;\n    }\n  }\n  class PlaneGeometry extends BufferGeometry {\n    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {\n      super();\n      this.type = \"PlaneGeometry\";\n      this.parameters = {\n        width,\n        height,\n        widthSegments,\n        heightSegments\n      };\n      const width_half = width / 2;\n      const height_half = height / 2;\n      const gridX = Math.floor(widthSegments);\n      const gridY = Math.floor(heightSegments);\n      const gridX1 = gridX + 1;\n      const gridY1 = gridY + 1;\n      const segment_width = width / gridX;\n      const segment_height = height / gridY;\n      const indices = [];\n      const vertices = [];\n      const normals = [];\n      const uvs = [];\n      for (let iy = 0; iy < gridY1; iy++) {\n        const y = iy * segment_height - height_half;\n        for (let ix = 0; ix < gridX1; ix++) {\n          const x2 = ix * segment_width - width_half;\n          vertices.push(x2, -y, 0);\n          normals.push(0, 0, 1);\n          uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY);\n        }\n      }\n      for (let iy = 0; iy < gridY; iy++) {\n        for (let ix = 0; ix < gridX; ix++) {\n          const a = ix + gridX1 * iy;\n          const b = ix + gridX1 * (iy + 1);\n          const c = ix + 1 + gridX1 * (iy + 1);\n          const d = ix + 1 + gridX1 * iy;\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n        }\n      }\n      this.setIndex(indices);\n      this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n      this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n      this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    }\n    copy(source) {\n      super.copy(source);\n      this.parameters = Object.assign({}, source.parameters);\n      return this;\n    }\n    static fromJSON(data) {\n      return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);\n    }\n  }\n  class RawShaderMaterial extends ShaderMaterial {\n    constructor(parameters) {\n      super(parameters);\n      this.isRawShaderMaterial = true;\n      this.type = \"RawShaderMaterial\";\n    }\n  }\n  class Matrix2 {\n    constructor(n11, n12, n21, n22) {\n      Matrix2.prototype.isMatrix2 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n21, n22);\n      }\n    }\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 4; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    set(n11, n12, n21, n22) {\n      const te = this.elements;\n      te[0] = n11;\n      te[2] = n12;\n      te[1] = n21;\n      te[3] = n22;\n      return this;\n    }\n  }\n  if (typeof __THREE_DEVTOOLS__ !== \"undefined\") {\n    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"register\", { detail: {\n      revision: REVISION\n    } }));\n  }\n  if (typeof window !== \"undefined\") {\n    if (window.__THREE__) {\n      console.warn(\"WARNING: Multiple instances of Three.js being imported.\");\n    } else {\n      window.__THREE__ = REVISION;\n    }\n  }\n  const LN_SCALE_MIN = -9;\n  const LN_SCALE_MAX = 9;\n  const LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254;\n  const SCALE_MIN = Math.exp(LN_SCALE_MIN);\n  const SPLAT_TEX_WIDTH_BITS = 11;\n  const SPLAT_TEX_HEIGHT_BITS = 11;\n  const SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;\n  const SPLAT_TEX_HEIGHT = 1 << SPLAT_TEX_HEIGHT_BITS;\n  const SPLAT_TEX_MIN_HEIGHT = 1;\n  const WASM_SPLAT_SORT = true;\n  function isIntType(type) {\n    return type === \"int\" || type === \"ivec2\" || type === \"ivec3\" || type === \"ivec4\";\n  }\n  function isUintType(type) {\n    return type === \"uint\" || type === \"uvec2\" || type === \"uvec3\" || type === \"uvec4\";\n  }\n  function isFloatType(type) {\n    return type === \"float\" || type === \"vec2\" || type === \"vec3\" || type === \"vec4\";\n  }\n  function isMatFloatType(type) {\n    return type === \"mat2\" || type === \"mat2x2\" || type === \"mat2x3\" || type === \"mat2x4\" || type === \"mat3\" || type === \"mat3x2\" || type === \"mat3x3\" || type === \"mat3x4\" || type === \"mat4\" || type === \"mat4x2\" || type === \"mat4x3\" || type === \"mat4x4\";\n  }\n  function isAllFloatType(type) {\n    return isFloatType(type) || isMatFloatType(type);\n  }\n  function isMat2(type) {\n    return type === \"mat2\" || type === \"mat2x2\";\n  }\n  function isMat3(type) {\n    return type === \"mat3\" || type === \"mat3x3\";\n  }\n  function isMat4(type) {\n    return type === \"mat4\" || type === \"mat4x4\";\n  }\n  function numberAsInt(value) {\n    return Math.trunc(value).toString();\n  }\n  function numberAsUint(value) {\n    const v = Math.max(0, Math.trunc(value));\n    return \\`\\${v.toString()}u\\`;\n  }\n  function numberAsFloat(value) {\n    return value === Number.POSITIVE_INFINITY ? \"INFINITY\" : value === Number.NEGATIVE_INFINITY ? \"-INFINITY\" : Number.isInteger(value) ? value.toFixed(1) : value.toString();\n  }\n  function valType(val) {\n    if (val instanceof DynoValue) {\n      return val.type;\n    }\n    const value = val.dynoOut();\n    return value.type;\n  }\n  class DynoValue {\n    constructor(type) {\n      this.__isDynoValue = true;\n      this.type = type;\n    }\n  }\n  class DynoOutput extends DynoValue {\n    constructor(dyno2, key) {\n      super(dyno2.outTypes[key]);\n      this.dyno = dyno2;\n      this.key = key;\n    }\n  }\n  class DynoLiteral extends DynoValue {\n    constructor(type, literal) {\n      super(type);\n      this.literal = literal;\n    }\n    getLiteral() {\n      return this.literal;\n    }\n  }\n  class DynoConst extends DynoLiteral {\n    constructor(type, value) {\n      super(type, \"\");\n      this.value = value;\n    }\n    getLiteral() {\n      const { type, value } = this;\n      switch (type) {\n        case \"bool\":\n          return value ? \"true\" : \"false\";\n        case \"uint\":\n          return numberAsUint(value);\n        case \"int\":\n          return numberAsInt(value);\n        case \"float\":\n          return numberAsFloat(value);\n        case \"bvec2\": {\n          const v = value;\n          return \\`bvec2(\\${v[0]}, \\${v[1]})\\`;\n        }\n        case \"uvec2\": {\n          if (value instanceof Vector2) {\n            return \\`uvec2(\\${numberAsUint(value.x)}, \\${numberAsUint(value.y)})\\`;\n          }\n          const v = value;\n          return \\`uvec2(\\${numberAsUint(v[0])}, \\${numberAsUint(v[1])})\\`;\n        }\n        case \"ivec2\": {\n          if (value instanceof Vector2) {\n            return \\`ivec2(\\${numberAsInt(value.x)}, \\${numberAsInt(value.y)})\\`;\n          }\n          const v = value;\n          return \\`ivec2(\\${numberAsInt(v[0])}, \\${numberAsInt(v[1])})\\`;\n        }\n        case \"vec2\": {\n          if (value instanceof Vector2) {\n            return \\`vec2(\\${numberAsFloat(value.x)}, \\${numberAsFloat(value.y)})\\`;\n          }\n          const v = value;\n          return \\`vec2(\\${numberAsFloat(v[0])}, \\${numberAsFloat(v[1])})\\`;\n        }\n        case \"bvec3\": {\n          const v = value;\n          return \\`bvec3(\\${v[0]}, \\${v[1]}, \\${v[2]})\\`;\n        }\n        case \"uvec3\": {\n          if (value instanceof Vector3) {\n            return \\`uvec3(\\${numberAsUint(value.x)}, \\${numberAsUint(value.y)}, \\${numberAsUint(value.z)})\\`;\n          }\n          const v = value;\n          return \\`uvec3(\\${numberAsUint(v[0])}, \\${numberAsUint(v[1])}, \\${numberAsUint(v[2])})\\`;\n        }\n        case \"ivec3\": {\n          if (value instanceof Vector3) {\n            return \\`ivec3(\\${numberAsInt(value.x)}, \\${numberAsInt(value.y)}, \\${numberAsInt(value.z)})\\`;\n          }\n          const v = value;\n          return \\`ivec3(\\${numberAsInt(v[0])}, \\${numberAsInt(v[1])}, \\${numberAsInt(v[2])})\\`;\n        }\n        case \"vec3\": {\n          if (value instanceof Vector3) {\n            return \\`vec3(\\${numberAsFloat(value.x)}, \\${numberAsFloat(value.y)}, \\${numberAsFloat(value.z)})\\`;\n          }\n          const v = value;\n          return \\`vec3(\\${numberAsFloat(v[0])}, \\${numberAsFloat(v[1])}, \\${numberAsFloat(v[2])})\\`;\n        }\n        case \"bvec4\": {\n          const v = value;\n          return \\`bvec4(\\${v[0]}, \\${v[1]}, \\${v[2]}, \\${v[3]})\\`;\n        }\n        case \"uvec4\": {\n          if (value instanceof Vector4) {\n            return \\`uvec4(\\${numberAsUint(value.x)}, \\${numberAsUint(value.y)}, \\${numberAsUint(value.z)}, \\${numberAsUint(value.w)})\\`;\n          }\n          const v = value;\n          return \\`uvec4(\\${numberAsUint(v[0])}, \\${numberAsUint(v[1])}, \\${numberAsUint(v[2])}, \\${numberAsUint(v[3])})\\`;\n        }\n        case \"ivec4\": {\n          if (value instanceof Vector4) {\n            return \\`ivec4(\\${numberAsInt(value.x)}, \\${numberAsInt(value.y)}, \\${numberAsInt(value.z)}, \\${numberAsInt(value.w)})\\`;\n          }\n          const v = value;\n          return \\`ivec4(\\${numberAsInt(v[0])}, \\${numberAsInt(v[1])}, \\${numberAsInt(v[2])}, \\${numberAsInt(v[3])})\\`;\n        }\n        case \"vec4\": {\n          if (value instanceof Vector4) {\n            return \\`vec4(\\${numberAsFloat(value.x)}, \\${numberAsFloat(value.y)}, \\${numberAsFloat(value.z)}, \\${numberAsFloat(value.w)})\\`;\n          }\n          if (value instanceof Quaternion) {\n            return \\`vec4(\\${numberAsFloat(value.x)}, \\${numberAsFloat(value.y)}, \\${numberAsFloat(value.z)}, \\${numberAsFloat(value.w)})\\`;\n          }\n          const v = value;\n          return \\`vec4(\\${numberAsFloat(v[0])}, \\${numberAsFloat(v[1])}, \\${numberAsFloat(v[2])}, \\${numberAsFloat(v[3])})\\`;\n        }\n        case \"mat2\":\n        case \"mat2x2\": {\n          const m = value;\n          const e = m instanceof Matrix2 ? m.elements : value;\n          const arg = new Array(4).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        case \"mat2x3\": {\n          const e = value;\n          const arg = new Array(6).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        case \"mat2x4\": {\n          const e = value;\n          const arg = new Array(8).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        case \"mat3\":\n        case \"mat3x3\": {\n          const m = value;\n          const e = m instanceof Matrix3 ? m.elements : value;\n          const arg = new Array(9).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        case \"mat3x2\": {\n          const e = value;\n          const arg = new Array(6).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        case \"mat3x4\": {\n          const e = value;\n          const arg = new Array(12).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        case \"mat4\":\n        case \"mat4x4\": {\n          const m = value;\n          const e = m instanceof Matrix4 ? m.elements : value;\n          const arg = new Array(16).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        case \"mat4x2\": {\n          const e = value;\n          const arg = new Array(8).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        case \"mat4x3\": {\n          const e = value;\n          const arg = new Array(12).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        default:\n          throw new Error(\\`Type not implemented: \\${String(type)}\\`);\n      }\n    }\n  }\n  function dynoConst(type, value) {\n    return new DynoConst(type, value);\n  }\n  const DEFAULT_INDENT = \"    \";\n  class Compilation {\n    constructor({ indent } = {}) {\n      this.globals = /* @__PURE__ */ new Set();\n      this.statements = [];\n      this.uniforms = {};\n      this.declares = /* @__PURE__ */ new Set();\n      this.updaters = [];\n      this.sequence = 0;\n      this.indent = DEFAULT_INDENT;\n      this.indent = indent ?? DEFAULT_INDENT;\n    }\n    nextSequence() {\n      return this.sequence++;\n    }\n  }\n  class Dyno {\n    constructor({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      statements,\n      generate\n    }) {\n      this.inTypes = inTypes ?? {};\n      this.outTypes = outTypes ?? {};\n      this.inputs = inputs ?? {};\n      this.update = update;\n      this.globals = globals;\n      this.statements = statements;\n      this.generate = generate ?? (({ inputs: inputs2, outputs, compile }) => {\n        var _a2, _b2;\n        return {\n          globals: (_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs: inputs2, outputs, compile }),\n          statements: (_b2 = this.statements) == null ? void 0 : _b2.call(this, { inputs: inputs2, outputs, compile })\n        };\n      });\n    }\n    get outputs() {\n      const outputs = {};\n      for (const key in this.outTypes) {\n        outputs[key] = new DynoOutput(this, key);\n      }\n      return outputs;\n    }\n    apply(inputs) {\n      Object.assign(this.inputs, inputs);\n      return this.outputs;\n    }\n    compile({\n      inputs,\n      outputs,\n      compile\n    }) {\n      const result = [\n        \\`// \\${this.constructor.name}(\\${Object.values(inputs).join(\", \")}) => (\\${Object.values(outputs).join(\", \")})\\`\n      ];\n      const declares = [];\n      for (const key in outputs) {\n        const name = outputs[key];\n        if (name && !compile.declares.has(name)) {\n          compile.declares.add(name);\n          declares.push(key);\n        }\n      }\n      const { globals, statements, uniforms } = this.generate({\n        inputs,\n        outputs,\n        compile\n      });\n      for (const global of globals ?? []) {\n        compile.globals.add(global);\n      }\n      for (const key in uniforms) {\n        compile.uniforms[key] = uniforms[key];\n      }\n      if (this.update) {\n        compile.updaters.push(this.update);\n      }\n      for (const key of declares) {\n        const name = outputs[key];\n        if (name) {\n          if (!compile.uniforms[name]) {\n            result.push(\\`\\${dynoDeclare(name, this.outTypes[key])};\\`);\n          }\n        }\n      }\n      if (statements == null ? void 0 : statements.length) {\n        result.push(\"{\");\n        result.push(...statements.map((line) => compile.indent + line));\n        result.push(\"}\");\n      }\n      return result;\n    }\n  }\n  class DynoBlock extends Dyno {\n    constructor({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      construct\n    }) {\n      super({\n        inTypes,\n        outTypes,\n        inputs,\n        update,\n        globals,\n        generate: (args) => this.generateBlock(args)\n      });\n      this.construct = construct;\n    }\n    generateBlock({\n      inputs,\n      outputs,\n      compile\n    }) {\n      var _a2, _b2;\n      const blockInputs = {};\n      const blockOutputs = {};\n      for (const key in inputs) {\n        if (inputs[key] != null) {\n          blockInputs[key] = new DynoLiteral(this.inTypes[key], inputs[key]);\n        }\n      }\n      for (const key in outputs) {\n        if (outputs[key] != null) {\n          blockOutputs[key] = new DynoValue(this.outTypes[key]);\n        }\n      }\n      const options = { roots: [] };\n      const returned = this.construct(blockInputs, blockOutputs, options);\n      for (const global of ((_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs, outputs, compile })) ?? []) {\n        compile.globals.add(global);\n      }\n      const ordering = [];\n      const nodeOuts = /* @__PURE__ */ new Map();\n      function visit(node, outKey, outName) {\n        let outs = nodeOuts.get(node);\n        if (!outs) {\n          outs = {\n            sequence: compile.nextSequence(),\n            outNames: /* @__PURE__ */ new Map(),\n            newOuts: /* @__PURE__ */ new Set()\n          };\n          nodeOuts.set(node, outs);\n          for (const key in node.inputs) {\n            let input = node.inputs[key];\n            while (input) {\n              if (input instanceof DynoValue) {\n                if (input instanceof DynoOutput) {\n                  visit(input.dyno, input.key);\n                }\n                break;\n              }\n              input = input.dynoOut();\n            }\n          }\n          ordering.push(node);\n        }\n        if (outKey) {\n          if (!outName) {\n            outs.newOuts.add(outKey);\n          }\n          outs.outNames.set(outKey, outName ?? \\`\\${outKey}_\\${outs.sequence}\\`);\n        }\n      }\n      for (const root of options.roots) {\n        visit(root);\n      }\n      for (const key in blockOutputs) {\n        let value = (returned == null ? void 0 : returned[key]) ?? blockOutputs[key];\n        while (value) {\n          if (value instanceof DynoValue) {\n            if (value instanceof DynoOutput) {\n              visit(value.dyno, value.key, outputs[key]);\n            }\n            break;\n          }\n          value = value.dynoOut();\n        }\n        blockOutputs[key] = value;\n      }\n      const steps = [];\n      for (const dyno2 of ordering) {\n        const inputs2 = {};\n        const outputs2 = {};\n        for (const key in dyno2.inputs) {\n          let value = dyno2.inputs[key];\n          while (value) {\n            if (value instanceof DynoValue) {\n              if (value instanceof DynoLiteral) {\n                inputs2[key] = value.getLiteral();\n              } else if (value instanceof DynoOutput) {\n                const source = (_b2 = nodeOuts.get(value.dyno)) == null ? void 0 : _b2.outNames.get(value.key);\n                if (!source) {\n                  throw new Error(\n                    \\`Source not found for \\${value.dyno.constructor.name}.\\${value.key}\\`\n                  );\n                }\n                inputs2[key] = source;\n              }\n              break;\n            }\n            value = value.dynoOut();\n          }\n        }\n        const outs = nodeOuts.get(dyno2) ?? { outNames: /* @__PURE__ */ new Map() };\n        for (const [key, name] of outs.outNames.entries()) {\n          outputs2[key] = name;\n        }\n        const newSteps = dyno2.compile({ inputs: inputs2, outputs: outputs2, compile });\n        steps.push(newSteps);\n      }\n      const literalOutputs = [];\n      for (const key in outputs) {\n        if (blockOutputs[key] instanceof DynoLiteral) {\n          literalOutputs.push(\n            \\`\\${outputs[key]} = \\${blockOutputs[key].getLiteral()};\\`\n          );\n        }\n      }\n      if (literalOutputs.length > 0) {\n        steps.push(literalOutputs);\n      }\n      const statements = steps.flatMap((step, index) => {\n        return index === 0 ? step : [\"\", ...step];\n      });\n      return { statements };\n    }\n  }\n  function dynoBlock(inTypes, outTypes, construct, { update, globals } = {}) {\n    return new DynoBlock({ inTypes, outTypes, construct, update, globals });\n  }\n  function dyno({\n    inTypes,\n    outTypes,\n    inputs,\n    update,\n    globals,\n    statements,\n    generate\n  }) {\n    return new Dyno({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      statements,\n      generate\n    });\n  }\n  function dynoDeclare(name, type, count) {\n    const typeStr = typeof type === \"string\" ? type : type.type;\n    if (!typeStr) {\n      throw new Error(\\`Invalid DynoType: \\${String(type)}\\`);\n    }\n    return \\`\\${typeStr} \\${name}\\${count != null ? \\`[\\${count}]\\` : \"\"}\\`;\n  }\n  function unindentLines(s) {\n    var _a2;\n    let seenNonEmpty = false;\n    const lines = s.split(\"\\\\n\").map((line) => {\n      const trimmedLine = line.trimEnd();\n      if (seenNonEmpty) {\n        return trimmedLine;\n      }\n      if (trimmedLine.length > 0) {\n        seenNonEmpty = true;\n        return trimmedLine;\n      }\n      return null;\n    }).filter((line) => line != null);\n    while (lines.length > 0 && lines[lines.length - 1].length === 0) {\n      lines.pop();\n    }\n    if (lines.length === 0) {\n      return [];\n    }\n    const indent = (_a2 = lines[0].match(/^\\\\s*/)) == null ? void 0 : _a2[0];\n    if (!indent) {\n      return lines;\n    }\n    const regex = new RegExp(\\`^\\${indent}\\`);\n    return lines.map((line) => line.replace(regex, \"\"));\n  }\n  function unindent(s) {\n    return unindentLines(s).join(\"\\\\n\");\n  }\n  class UnaryOp extends Dyno {\n    constructor({\n      a,\n      outKey,\n      outTypeFunc\n    }) {\n      const inTypes = { a: valType(a) };\n      const outType = outTypeFunc(valType(a));\n      const outTypes = { [outKey]: outType };\n      super({ inTypes, outTypes, inputs: { a } });\n      this.outKey = outKey;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  class BinaryOp extends Dyno {\n    constructor({\n      a,\n      b,\n      outKey,\n      outTypeFunc\n    }) {\n      const inTypes = { a: valType(a), b: valType(b) };\n      const outType = outTypeFunc(valType(a), valType(b));\n      const outTypes = { [outKey]: outType };\n      super({ inTypes, outTypes, inputs: { a, b } });\n      this.outKey = outKey;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  const f32buffer = new Float32Array(1);\n  const u32buffer = new Uint32Array(f32buffer.buffer);\n  function toHalf(f) {\n    f32buffer[0] = f;\n    const bits2 = u32buffer[0];\n    const sign = bits2 >> 31 & 1;\n    const exp = bits2 >> 23 & 255;\n    const frac = bits2 & 8388607;\n    const halfSign = sign << 15;\n    if (exp === 255) {\n      if (frac !== 0) {\n        return halfSign | 32767;\n      }\n      return halfSign | 31744;\n    }\n    const newExp = exp - 127 + 15;\n    if (newExp >= 31) {\n      return halfSign | 31744;\n    }\n    if (newExp <= 0) {\n      if (newExp < -10) {\n        return halfSign;\n      }\n      const subFrac = (frac | 8388608) >> 1 - newExp + 13;\n      return halfSign | subFrac;\n    }\n    const halfFrac = frac >> 13;\n    return halfSign | newExp << 10 | halfFrac;\n  }\n  function fromHalf(h) {\n    const sign = h >> 15 & 1;\n    const exp = h >> 10 & 31;\n    const frac = h & 1023;\n    let f32bits;\n    if (exp === 0) {\n      if (frac === 0) {\n        f32bits = sign << 31;\n      } else {\n        let mant = frac;\n        let e = -14;\n        while ((mant & 1024) === 0) {\n          mant <<= 1;\n          e--;\n        }\n        mant &= 1023;\n        const newExp = e + 127;\n        const newFrac = mant << 13;\n        f32bits = sign << 31 | newExp << 23 | newFrac;\n      }\n    } else if (exp === 31) {\n      if (frac === 0) {\n        f32bits = sign << 31 | 2139095040;\n      } else {\n        f32bits = sign << 31 | 2143289344;\n      }\n    } else {\n      const newExp = exp - 15 + 127;\n      const newFrac = frac << 13;\n      f32bits = sign << 31 | newExp << 23 | newFrac;\n    }\n    u32buffer[0] = f32bits;\n    return f32buffer[0];\n  }\n  function floatToUint8(v) {\n    return Math.max(0, Math.min(255, Math.round(v * 255)));\n  }\n  function getArrayBuffers(ctx) {\n    const buffers = [];\n    const seen = /* @__PURE__ */ new Set();\n    function traverse(obj) {\n      if (obj && typeof obj === \"object\" && !seen.has(obj)) {\n        seen.add(obj);\n        if (obj instanceof ArrayBuffer) {\n          buffers.push(obj);\n        } else if (ArrayBuffer.isView(obj)) {\n          buffers.push(obj.buffer);\n        } else if (Array.isArray(obj)) {\n          obj.forEach(traverse);\n        } else {\n          Object.values(obj).forEach(traverse);\n        }\n      }\n    }\n    traverse(ctx);\n    return buffers;\n  }\n  function setPackedSplat(packedSplats, index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) {\n    const uR = floatToUint8(r);\n    const uG = floatToUint8(g);\n    const uB = floatToUint8(b);\n    const uA = floatToUint8(opacity);\n    const uQuat = encodeQuatOctXy88R8(\n      new Quaternion(quatX, quatY, quatZ, quatW)\n    );\n    const uQuatX = uQuat & 255;\n    const uQuatY = uQuat >>> 8 & 255;\n    const uQuatZ = uQuat >>> 16 & 255;\n    const uScaleX = scaleX === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleX) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleY = scaleY === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleY) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleZ = scaleZ === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleZ) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uCenterX = toHalf(x2);\n    const uCenterY = toHalf(y);\n    const uCenterZ = toHalf(z);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n    packedSplats[i4 + 2] = uCenterZ | uQuatX << 16 | uQuatY << 24;\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;\n  }\n  function setPackedSplatCenter(packedSplats, index, x2, y, z) {\n    const uCenterX = toHalf(x2);\n    const uCenterY = toHalf(y);\n    const uCenterZ = toHalf(z);\n    const i4 = index * 4;\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n    packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & 4294901760;\n  }\n  function setPackedSplatScales(packedSplats, index, scaleX, scaleY, scaleZ) {\n    const uScaleX = scaleX === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleX) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleY = scaleY === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleY) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleZ = scaleZ === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleZ) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const i4 = index * 4;\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;\n  }\n  function setPackedSplatQuat(packedSplats, index, quatX, quatY, quatZ, quatW) {\n    const uQuat = encodeQuatOctXy88R8(\n      new Quaternion(quatX, quatY, quatZ, quatW)\n    );\n    const uQuatX = uQuat & 255;\n    const uQuatY = uQuat >>> 8 & 255;\n    const uQuatZ = uQuat >>> 16 & 255;\n    const i4 = index * 4;\n    packedSplats[i4 + 2] = packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;\n    packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;\n  }\n  function setPackedSplatRgb(packedSplats, index, r, g, b) {\n    const uR = floatToUint8(r);\n    const uG = floatToUint8(g);\n    const uB = floatToUint8(b);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & 4278190080;\n  }\n  function setPackedSplatOpacity(packedSplats, index, opacity) {\n    const uA = floatToUint8(opacity);\n    const i4 = index * 4;\n    packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;\n  }\n  const packedCenter = new Vector3();\n  const packedScales = new Vector3();\n  const packedQuaternion = new Quaternion();\n  const packedColor = new Color();\n  const packedFields = {\n    center: packedCenter,\n    scales: packedScales,\n    quaternion: packedQuaternion,\n    color: packedColor,\n    opacity: 0\n  };\n  function unpackSplat(packedSplats, index) {\n    const result = packedFields;\n    const i4 = index * 4;\n    const word0 = packedSplats[i4];\n    const word1 = packedSplats[i4 + 1];\n    const word2 = packedSplats[i4 + 2];\n    const word3 = packedSplats[i4 + 3];\n    result.color.set(\n      (word0 & 255) / 255,\n      (word0 >>> 8 & 255) / 255,\n      (word0 >>> 16 & 255) / 255\n    );\n    result.opacity = (word0 >>> 24 & 255) / 255;\n    result.center.set(\n      fromHalf(word1 & 65535),\n      fromHalf(word1 >>> 16 & 65535),\n      fromHalf(word2 & 65535)\n    );\n    const uScalesX = word3 & 255;\n    result.scales.x = uScalesX === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesX - 1) * LN_RESCALE);\n    const uScalesY = word3 >>> 8 & 255;\n    result.scales.y = uScalesY === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesY - 1) * LN_RESCALE);\n    const uScalesZ = word3 >>> 16 & 255;\n    result.scales.z = uScalesZ === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesZ - 1) * LN_RESCALE);\n    const uQuat = word2 >>> 16 & 65535 | word3 >>> 8 & 16711680;\n    decodeQuatOctXy88R8(uQuat, result.quaternion);\n    return result;\n  }\n  function getTextureSize(numSplats) {\n    const width = SPLAT_TEX_WIDTH;\n    const height = Math.max(\n      SPLAT_TEX_MIN_HEIGHT,\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n    );\n    const depth = Math.ceil(numSplats / (width * height));\n    const maxSplats = width * height * depth;\n    return { width, height, depth, maxSplats };\n  }\n  function computeMaxSplats(numSplats) {\n    const width = SPLAT_TEX_WIDTH;\n    const height = Math.max(\n      SPLAT_TEX_MIN_HEIGHT,\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n    );\n    const depth = Math.ceil(numSplats / (width * height));\n    return width * height * depth;\n  }\n  const IDENT_VERTEX_SHADER = unindent(\\`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n\\`);\n  function encodeQuatOctXy88R8(q) {\n    const qnorm = q.clone().normalize();\n    if (qnorm.w < 0) {\n      qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);\n    }\n    const theta = 2 * Math.acos(qnorm.w);\n    const xyz_norm = Math.sqrt(\n      qnorm.x * qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z\n    );\n    const axis = xyz_norm < 1e-6 ? new Vector3(1, 0, 0) : new Vector3(qnorm.x, qnorm.y, qnorm.z).divideScalar(xyz_norm);\n    const sum = Math.abs(axis.x) + Math.abs(axis.y) + Math.abs(axis.z);\n    let p_x = axis.x / sum;\n    let p_y = axis.y / sum;\n    if (axis.z < 0) {\n      const tmp = p_x;\n      p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);\n      p_y = (1 - Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);\n    }\n    const u_f = p_x * 0.5 + 0.5;\n    const v_f = p_y * 0.5 + 0.5;\n    const quantU = Math.round(u_f * 255);\n    const quantV = Math.round(v_f * 255);\n    const angleInt = Math.round(theta * (255 / Math.PI));\n    return angleInt << 16 | quantV << 8 | quantU;\n  }\n  function decodeQuatOctXy88R8(encoded, out) {\n    const quantU = encoded & 255;\n    const quantV = encoded >>> 8 & 255;\n    const angleInt = encoded >>> 16 & 255;\n    const u_f = quantU / 255;\n    const v_f = quantV / 255;\n    let f_x = (u_f - 0.5) * 2;\n    let f_y = (v_f - 0.5) * 2;\n    const f_z = 1 - (Math.abs(f_x) + Math.abs(f_y));\n    const t = Math.max(-f_z, 0);\n    f_x += f_x >= 0 ? -t : t;\n    f_y += f_y >= 0 ? -t : t;\n    const axis = new Vector3(f_x, f_y, f_z).normalize();\n    const theta = angleInt / 255 * Math.PI;\n    const halfTheta = theta * 0.5;\n    const s = Math.sin(halfTheta);\n    const w = Math.cos(halfTheta);\n    out.set(axis.x * s, axis.y * s, axis.z * s, w);\n    return out;\n  }\n  function packSint8Bytes(b0, b1, b2, b3) {\n    const clampedB0 = Math.max(-127, Math.min(127, b0 * 127));\n    const clampedB1 = Math.max(-127, Math.min(127, b1 * 127));\n    const clampedB2 = Math.max(-127, Math.min(127, b2 * 127));\n    const clampedB3 = Math.max(-127, Math.min(127, b3 * 127));\n    return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << 24;\n  }\n  function encodeSh1Rgb(sh1Array, index, sh1Rgb) {\n    const base = index * 2;\n    for (let i2 = 0; i2 < 9; ++i2) {\n      const value = Math.max(-63, Math.min(63, sh1Rgb[i2] * 63)) & 127;\n      const bitStart = i2 * 7;\n      const bitEnd = bitStart + 7;\n      const wordStart = Math.floor(bitStart / 32);\n      const bitOffset = bitStart - wordStart * 32;\n      const firstWord = value << bitOffset & 4294967295;\n      sh1Array[base + wordStart] |= firstWord;\n      if (bitEnd > wordStart * 32 + 32) {\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\n        sh1Array[base + wordStart + 1] |= secondWord;\n      }\n    }\n  }\n  function encodeSh2Rgb(sh2Array, index, sh2Rgb) {\n    sh2Array[index * 4 + 0] = packSint8Bytes(\n      sh2Rgb[0],\n      sh2Rgb[1],\n      sh2Rgb[2],\n      sh2Rgb[3]\n    );\n    sh2Array[index * 4 + 1] = packSint8Bytes(\n      sh2Rgb[4],\n      sh2Rgb[5],\n      sh2Rgb[6],\n      sh2Rgb[7]\n    );\n    sh2Array[index * 4 + 2] = packSint8Bytes(\n      sh2Rgb[8],\n      sh2Rgb[9],\n      sh2Rgb[10],\n      sh2Rgb[11]\n    );\n    sh2Array[index * 4 + 3] = packSint8Bytes(\n      sh2Rgb[12],\n      sh2Rgb[13],\n      sh2Rgb[14],\n      0\n    );\n  }\n  function encodeSh3Rgb(sh3Array, index, sh3Rgb) {\n    const base = index * 4;\n    for (let i2 = 0; i2 < 21; ++i2) {\n      const value = Math.max(-31, Math.min(31, sh3Rgb[i2] * 31)) & 63;\n      const bitStart = i2 * 6;\n      const bitEnd = bitStart + 6;\n      const wordStart = Math.floor(bitStart / 32);\n      const bitOffset = bitStart - wordStart * 32;\n      const firstWord = value << bitOffset & 4294967295;\n      sh3Array[base + wordStart] |= firstWord;\n      if (bitEnd > wordStart * 32 + 32) {\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\n        sh3Array[base + wordStart + 1] |= secondWord;\n      }\n    }\n  }\n  function decompressPartialGzip(fileBytes, numBytes) {\n    const chunks = [];\n    let totalBytes = 0;\n    let result = null;\n    const gunzip = new Gunzip((data, final) => {\n      chunks.push(data);\n      totalBytes += data.length;\n      if (final || totalBytes >= numBytes) {\n        const allBytes = new Uint8Array(totalBytes);\n        let offset2 = 0;\n        for (const chunk of chunks) {\n          allBytes.set(chunk, offset2);\n          offset2 += chunk.length;\n        }\n        result = allBytes.slice(0, numBytes);\n      }\n    });\n    const CHUNK_SIZE = 1024;\n    let offset = 0;\n    while (result == null && offset < fileBytes.length) {\n      const chunk = fileBytes.slice(offset, offset + CHUNK_SIZE);\n      gunzip.push(chunk, false);\n      offset += CHUNK_SIZE;\n    }\n    if (result == null) {\n      gunzip.push(new Uint8Array(), true);\n      if (result == null) {\n        throw new Error(\"Failed to decompress partial gzip\");\n      }\n    }\n    return result;\n  }\n  class GunzipReader {\n    constructor({\n      fileBytes,\n      chunkBytes = 64 * 1024\n    }) {\n      this.fileBytes = fileBytes;\n      this.chunkBytes = chunkBytes;\n      this.offset = 0;\n      this.chunks = [];\n      this.totalBytes = 0;\n      this.gunzip = new Gunzip((chunk, _final) => {\n        this.chunks.push(chunk);\n        this.totalBytes += chunk.length;\n      });\n    }\n    read(numBytes) {\n      while (this.totalBytes < numBytes && this.offset < this.fileBytes.length) {\n        const end = Math.min(\n          this.offset + this.chunkBytes,\n          this.fileBytes.length\n        );\n        this.gunzip.push(this.fileBytes.subarray(this.offset, end), false);\n        this.offset = end;\n      }\n      if (this.totalBytes < numBytes && this.offset >= this.fileBytes.length) {\n        this.gunzip.push(new Uint8Array(0), true);\n      }\n      if (this.totalBytes < numBytes) {\n        throw new Error(\n          \\`Unexpected EOF: needed \\${numBytes}, got \\${this.totalBytes}\\`\n        );\n      }\n      const allBytes = new Uint8Array(this.totalBytes);\n      let outOffset = 0;\n      for (const chunk of this.chunks) {\n        allBytes.set(chunk, outOffset);\n        outOffset += chunk.length;\n      }\n      const result = allBytes.subarray(0, numBytes);\n      this.chunks = [allBytes.subarray(numBytes)];\n      this.totalBytes -= numBytes;\n      return result;\n    }\n  }\n  function decodeAntiSplat(fileBytes, initNumSplats, splatCallback) {\n    const numSplats = Math.floor(fileBytes.length / 32);\n    if (numSplats * 32 !== fileBytes.length) {\n      throw new Error(\"Invalid .splat file size\");\n    }\n    initNumSplats(numSplats);\n    const f32 = new Float32Array(fileBytes.buffer);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i322 = i2 * 32;\n      const i8 = i2 * 8;\n      const x2 = f32[i8 + 0];\n      const y = f32[i8 + 1];\n      const z = f32[i8 + 2];\n      const scaleX = f32[i8 + 3];\n      const scaleY = f32[i8 + 4];\n      const scaleZ = f32[i8 + 5];\n      const r = fileBytes[i322 + 24] / 255;\n      const g = fileBytes[i322 + 25] / 255;\n      const b = fileBytes[i322 + 26] / 255;\n      const opacity = fileBytes[i322 + 27] / 255;\n      const quatW = (fileBytes[i322 + 28] - 128) / 128;\n      const quatX = (fileBytes[i322 + 29] - 128) / 128;\n      const quatY = (fileBytes[i322 + 30] - 128) / 128;\n      const quatZ = (fileBytes[i322 + 31] - 128) / 128;\n      splatCallback(\n        i2,\n        x2,\n        y,\n        z,\n        scaleX,\n        scaleY,\n        scaleZ,\n        quatX,\n        quatY,\n        quatZ,\n        quatW,\n        opacity,\n        r,\n        g,\n        b\n      );\n    }\n  }\n  function unpackAntiSplat(fileBytes) {\n    let numSplats = 0;\n    let maxSplats = 0;\n    let packedArray = new Uint32Array(0);\n    decodeAntiSplat(\n      fileBytes,\n      (cbNumSplats) => {\n        numSplats = cbNumSplats;\n        maxSplats = computeMaxSplats(numSplats);\n        packedArray = new Uint32Array(maxSplats * 4);\n      },\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n        setPackedSplat(\n          packedArray,\n          index,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n      }\n    );\n    return { packedArray, numSplats };\n  }\n  const KSPLAT_COMPRESSION = {\n    0: {\n      bytesPerCenter: 12,\n      bytesPerScale: 12,\n      bytesPerRotation: 16,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 4,\n      scaleOffsetBytes: 12,\n      rotationOffsetBytes: 24,\n      colorOffsetBytes: 40,\n      sphericalHarmonicsOffsetBytes: 44,\n      scaleRange: 1\n    },\n    1: {\n      bytesPerCenter: 6,\n      bytesPerScale: 6,\n      bytesPerRotation: 8,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 2,\n      scaleOffsetBytes: 6,\n      rotationOffsetBytes: 12,\n      colorOffsetBytes: 20,\n      sphericalHarmonicsOffsetBytes: 24,\n      scaleRange: 32767\n    },\n    2: {\n      bytesPerCenter: 6,\n      bytesPerScale: 6,\n      bytesPerRotation: 8,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 1,\n      scaleOffsetBytes: 6,\n      rotationOffsetBytes: 12,\n      colorOffsetBytes: 20,\n      sphericalHarmonicsOffsetBytes: 24,\n      scaleRange: 32767\n    }\n  };\n  const KSPLAT_SH_DEGREE_TO_COMPONENTS = {\n    0: 0,\n    1: 9,\n    2: 24,\n    3: 45\n  };\n  function decodeKsplat(fileBytes, initNumSplats, splatCallback, shCallback) {\n    var _a2;\n    const HEADER_BYTES = 4096;\n    const SECTION_BYTES = 1024;\n    let headerOffset = 0;\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n    headerOffset += HEADER_BYTES;\n    const versionMajor = header.getUint8(0);\n    const versionMinor = header.getUint8(1);\n    if (versionMajor !== 0 || versionMinor < 1) {\n      throw new Error(\n        \\`Unsupported .ksplat version: \\${versionMajor}.\\${versionMinor}\\`\n      );\n    }\n    const maxSectionCount = header.getUint32(4, true);\n    header.getUint32(16, true);\n    const compressionLevel = header.getUint16(20, true);\n    if (compressionLevel < 0 || compressionLevel > 2) {\n      throw new Error(\\`Invalid .ksplat compression level: \\${compressionLevel}\\`);\n    }\n    header.getFloat32(36, true) || -1.5;\n    header.getFloat32(40, true) || 1.5;\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n    for (let section = 0; section < maxSectionCount; ++section) {\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n      headerOffset += SECTION_BYTES;\n      const sectionSplatCount = section2.getUint32(0, true);\n      const sectionMaxSplatCount = section2.getUint32(4, true);\n      const bucketSize = section2.getUint32(8, true);\n      const bucketCount = section2.getUint32(12, true);\n      const bucketBlockSize = section2.getFloat32(16, true);\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n      const {\n        bytesPerCenter,\n        bytesPerScale,\n        bytesPerRotation,\n        bytesPerColor,\n        bytesPerSphericalHarmonicsComponent,\n        scaleOffsetBytes,\n        rotationOffsetBytes,\n        colorOffsetBytes,\n        sphericalHarmonicsOffsetBytes\n      } = KSPLAT_COMPRESSION[compressionLevel];\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\n      const data = new DataView(\n        fileBytes.buffer,\n        dataBase,\n        splatDataStorageSizeBytes\n      );\n      const bucketArray = new Float32Array(\n        fileBytes.buffer,\n        bucketsBase,\n        bucketCount * 3\n      );\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\n        const splatOffset = i2 * bytesPerSplat;\n        const bucketIndex = Math.floor(i2 / bucketSize);\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n        );\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n        );\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n        );\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n        );\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n        splatCallback(\n          i2,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n        if (sphericalHarmonicsDegree >= 1 && sh1) {\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\n        }\n      }\n      sectionBase += storageSizeBytes;\n    }\n  }\n  function unpackKsplat(fileBytes) {\n    var _a2;\n    const HEADER_BYTES = 4096;\n    const SECTION_BYTES = 1024;\n    let headerOffset = 0;\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n    headerOffset += HEADER_BYTES;\n    const versionMajor = header.getUint8(0);\n    const versionMinor = header.getUint8(1);\n    if (versionMajor !== 0 || versionMinor < 1) {\n      throw new Error(\n        \\`Unsupported .ksplat version: \\${versionMajor}.\\${versionMinor}\\`\n      );\n    }\n    const maxSectionCount = header.getUint32(4, true);\n    const splatCount = header.getUint32(16, true);\n    const compressionLevel = header.getUint16(20, true);\n    if (compressionLevel < 0 || compressionLevel > 2) {\n      throw new Error(\\`Invalid .ksplat compression level: \\${compressionLevel}\\`);\n    }\n    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\n    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\n    const numSplats = splatCount;\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n    for (let section = 0; section < maxSectionCount; ++section) {\n      let getSh = function(splatOffset, component) {\n        if (compressionLevel === 0) {\n          return data.getFloat32(\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\n            true\n          );\n        }\n        if (compressionLevel === 1) {\n          return fromHalf(\n            data.getUint16(\n              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\n              true\n            )\n          );\n        }\n        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\n        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n      };\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n      headerOffset += SECTION_BYTES;\n      const sectionSplatCount = section2.getUint32(0, true);\n      const sectionMaxSplatCount = section2.getUint32(4, true);\n      const bucketSize = section2.getUint32(8, true);\n      const bucketCount = section2.getUint32(12, true);\n      const bucketBlockSize = section2.getFloat32(16, true);\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n      const {\n        bytesPerCenter,\n        bytesPerScale,\n        bytesPerRotation,\n        bytesPerColor,\n        bytesPerSphericalHarmonicsComponent,\n        scaleOffsetBytes,\n        rotationOffsetBytes,\n        colorOffsetBytes,\n        sphericalHarmonicsOffsetBytes\n      } = KSPLAT_COMPRESSION[compressionLevel];\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n      const sh2Index = [\n        9,\n        14,\n        19,\n        10,\n        15,\n        20,\n        11,\n        16,\n        21,\n        12,\n        17,\n        22,\n        13,\n        18,\n        23\n      ];\n      const sh3Index = [\n        24,\n        31,\n        38,\n        25,\n        32,\n        39,\n        26,\n        33,\n        40,\n        27,\n        34,\n        41,\n        28,\n        35,\n        42,\n        29,\n        36,\n        43,\n        30,\n        37,\n        44\n      ];\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\n      const data = new DataView(\n        fileBytes.buffer,\n        dataBase,\n        splatDataStorageSizeBytes\n      );\n      const bucketArray = new Float32Array(\n        fileBytes.buffer,\n        bucketsBase,\n        bucketCount * 3\n      );\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\n        const splatOffset = i2 * bytesPerSplat;\n        const bucketIndex = Math.floor(i2 / bucketSize);\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n        );\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n        );\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n        );\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n        );\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n        setPackedSplat(\n          packedArray,\n          i2,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n        if (sphericalHarmonicsDegree >= 1) {\n          if (sh1) {\n            if (!extra.sh1) {\n              extra.sh1 = new Uint32Array(numSplats * 2);\n            }\n            for (const [i22, key] of sh1Index.entries()) {\n              sh1[i22] = getSh(splatOffset, key);\n            }\n            encodeSh1Rgb(extra.sh1, i2, sh1);\n          }\n          if (sh2) {\n            if (!extra.sh2) {\n              extra.sh2 = new Uint32Array(numSplats * 4);\n            }\n            for (const [i22, key] of sh2Index.entries()) {\n              sh2[i22] = getSh(splatOffset, key);\n            }\n            encodeSh2Rgb(extra.sh2, i2, sh2);\n          }\n          if (sh3) {\n            if (!extra.sh3) {\n              extra.sh3 = new Uint32Array(numSplats * 4);\n            }\n            for (const [i22, key] of sh3Index.entries()) {\n              sh3[i22] = getSh(splatOffset, key);\n            }\n            encodeSh3Rgb(extra.sh3, i2, sh3);\n          }\n        }\n      }\n      sectionBase += storageSizeBytes;\n    }\n    return { packedArray, numSplats, extra };\n  }\n  const _PlyReader = class _PlyReader {\n    // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet\n    constructor({ fileBytes }) {\n      this.header = \"\";\n      this.littleEndian = true;\n      this.elements = {};\n      this.comments = [];\n      this.data = null;\n      this.numSplats = 0;\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n    }\n    // Identify and parse the PLY text header (assumed to be <64KB in size).\n    // this.elements will contain all the elements in the file, typically\n    // \"vertex\" contains the Gsplat data.\n    async parseHeader() {\n      const bufferStream = new ReadableStream({\n        start: (controller) => {\n          controller.enqueue(this.fileBytes.slice(0, 65536));\n          controller.close();\n        }\n      });\n      const decoder = bufferStream.pipeThrough(new TextDecoderStream()).getReader();\n      this.header = \"\";\n      const headerTerminator = \"end_header\\\\n\";\n      while (true) {\n        const { value, done } = await decoder.read();\n        if (done) {\n          throw new Error(\"Failed to read header\");\n        }\n        this.header += value;\n        const endHeader = this.header.indexOf(headerTerminator);\n        if (endHeader >= 0) {\n          this.header = this.header.slice(0, endHeader + headerTerminator.length);\n          break;\n        }\n      }\n      const headerLen = new TextEncoder().encode(this.header).length;\n      this.data = new DataView(this.fileBytes.buffer, headerLen);\n      this.elements = {};\n      let curElement = null;\n      this.comments = [];\n      this.header.trim().split(\"\\\\n\").forEach((line, lineIndex) => {\n        const trimmedLine = line.trim();\n        if (lineIndex === 0) {\n          if (trimmedLine !== \"ply\") {\n            throw new Error(\"Invalid PLY header\");\n          }\n          return;\n        }\n        if (trimmedLine.length === 0) {\n          return;\n        }\n        const fields = trimmedLine.split(\" \");\n        switch (fields[0]) {\n          case \"format\":\n            if (fields[1] === \"binary_little_endian\") {\n              this.littleEndian = true;\n            } else if (fields[1] === \"binary_big_endian\") {\n              this.littleEndian = false;\n            } else {\n              throw new Error(\\`Unsupported PLY format: \\${fields[1]}\\`);\n            }\n            if (fields[2] !== \"1.0\") {\n              throw new Error(\\`Unsupported PLY version: \\${fields[2]}\\`);\n            }\n            break;\n          case \"end_header\":\n            break;\n          case \"comment\":\n            this.comments.push(trimmedLine.slice(\"comment \".length));\n            break;\n          case \"element\": {\n            const name = fields[1];\n            curElement = {\n              name,\n              count: Number.parseInt(fields[2]),\n              properties: {}\n            };\n            this.elements[name] = curElement;\n            break;\n          }\n          case \"property\":\n            if (curElement == null) {\n              throw new Error(\"Property must be inside an element\");\n            }\n            if (fields[1] === \"list\") {\n              curElement.properties[fields[4]] = {\n                isList: true,\n                type: fields[3],\n                countType: fields[2]\n              };\n            } else {\n              curElement.properties[fields[2]] = {\n                isList: false,\n                type: fields[1]\n              };\n            }\n            break;\n        }\n      });\n      if (this.elements.vertex) {\n        this.numSplats = this.elements.vertex.count;\n      }\n    }\n    parseData(elementCallback) {\n      let offset = 0;\n      const data = this.data;\n      if (data == null) {\n        throw new Error(\"No data to parse\");\n      }\n      for (const elementName in this.elements) {\n        const element = this.elements[elementName];\n        const { count, properties } = element;\n        const item = {};\n        const parsers = [];\n        for (const [propertyName, property] of Object.entries(properties)) {\n          if (!property.isList) {\n            item[propertyName] = 0;\n            parsers.push(() => {\n              item[propertyName] = PARSE_FIELD[property.type](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.type];\n            });\n          } else {\n            item[propertyName] = [];\n            parsers.push(() => {\n              const list = item[propertyName];\n              list.length = PARSE_FIELD[property.countType](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.countType];\n              for (let i2 = 0; i2 < list.length; i2++) {\n                list[i2] = PARSE_FIELD[property.type](\n                  data,\n                  offset,\n                  this.littleEndian\n                );\n                offset += FIELD_BYTES[property.type];\n              }\n            });\n          }\n        }\n        const callback = elementCallback(element) ?? (() => {\n        });\n        for (let index = 0; index < count; index++) {\n          for (const parser of parsers) {\n            parser();\n          }\n          callback(index, item);\n        }\n      }\n    }\n    // Parse all the Gsplat data in the PLY file in go, invoking the given\n    // callbacks for each Gsplat.\n    parseSplats(splatCallback, shCallback) {\n      if (this.elements.vertex == null) {\n        throw new Error(\"No vertex element found\");\n      }\n      let isSuperSplat = false;\n      const ssChunks = [];\n      let numSh = 0;\n      let sh1Props = [];\n      let sh2Props = [];\n      let sh3Props = [];\n      let sh1 = void 0;\n      let sh2 = void 0;\n      let sh3 = void 0;\n      function prepareSh() {\n        const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];\n        sh1Props = new Array(3).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => \\`f_rest_\\${k + d * num_f_rest / 3}\\`)\n        );\n        sh2Props = new Array(5).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => \\`f_rest_\\${3 + k + d * num_f_rest / 3}\\`)\n        );\n        sh3Props = new Array(7).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => \\`f_rest_\\${8 + k + d * num_f_rest / 3}\\`)\n        );\n        sh1 = numSh >= 1 ? new Float32Array(3 * 3) : void 0;\n        sh2 = numSh >= 2 ? new Float32Array(5 * 3) : void 0;\n        sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void 0;\n      }\n      function ssShCallback(index, item) {\n        if (!sh1) {\n          throw new Error(\"Missing sh1\");\n        }\n        for (const [i2, key] of sh1Props.entries()) {\n          sh1[i2] = item[key] * 8 / 255 - 4;\n        }\n        if (sh2) {\n          for (const [i2, key] of sh2Props.entries()) {\n            sh2[i2] = item[key] * 8 / 255 - 4;\n          }\n        }\n        if (sh3) {\n          for (const [i2, key] of sh3Props.entries()) {\n            sh3[i2] = item[key] * 8 / 255 - 4;\n          }\n        }\n        shCallback == null ? void 0 : shCallback(index, sh1, sh2, sh3);\n      }\n      function initSuperSplat(element) {\n        const {\n          min_x,\n          min_y,\n          min_z,\n          max_x,\n          max_y,\n          max_z,\n          min_scale_x,\n          min_scale_y,\n          min_scale_z,\n          max_scale_x,\n          max_scale_y,\n          max_scale_z,\n          min_r,\n          min_g,\n          min_b,\n          max_r,\n          max_g,\n          max_b\n        } = element.properties;\n        if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y || !max_scale_z || !min_r || !min_g || !min_b || !max_r || !max_g || !max_b) {\n          throw new Error(\"Missing PLY chunk properties\");\n        }\n        isSuperSplat = true;\n        return (index, item) => {\n          const {\n            min_x: min_x2,\n            min_y: min_y2,\n            min_z: min_z2,\n            max_x: max_x2,\n            max_y: max_y2,\n            max_z: max_z2,\n            min_scale_x: min_scale_x2,\n            min_scale_y: min_scale_y2,\n            min_scale_z: min_scale_z2,\n            max_scale_x: max_scale_x2,\n            max_scale_y: max_scale_y2,\n            max_scale_z: max_scale_z2,\n            min_r: min_r2,\n            min_g: min_g2,\n            min_b: min_b2,\n            max_r: max_r2,\n            max_g: max_g2,\n            max_b: max_b2\n          } = item;\n          ssChunks.push({\n            min_x: min_x2,\n            min_y: min_y2,\n            min_z: min_z2,\n            max_x: max_x2,\n            max_y: max_y2,\n            max_z: max_z2,\n            min_scale_x: min_scale_x2,\n            min_scale_y: min_scale_y2,\n            min_scale_z: min_scale_z2,\n            max_scale_x: max_scale_x2,\n            max_scale_y: max_scale_y2,\n            max_scale_z: max_scale_z2,\n            min_r: min_r2,\n            min_g: min_g2,\n            min_b: min_b2,\n            max_r: max_r2,\n            max_g: max_g2,\n            max_b: max_b2\n          });\n        };\n      }\n      function decodeSuperSplat(element) {\n        if (shCallback && element.name === \"sh\") {\n          numSh = getNumSh(element.properties);\n          prepareSh();\n          return ssShCallback;\n        }\n        if (element.name !== \"vertex\") {\n          return null;\n        }\n        const { packed_position, packed_rotation, packed_scale, packed_color } = element.properties;\n        if (!packed_position || !packed_rotation || !packed_scale || !packed_color) {\n          throw new Error(\n            \"Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color\"\n          );\n        }\n        const SQRT2 = Math.sqrt(2);\n        return (index, item) => {\n          const chunk = ssChunks[index >>> 8];\n          if (chunk == null) {\n            throw new Error(\"Missing PLY chunk\");\n          }\n          const {\n            min_x,\n            min_y,\n            min_z,\n            max_x,\n            max_y,\n            max_z,\n            min_scale_x,\n            min_scale_y,\n            min_scale_z,\n            max_scale_x,\n            max_scale_y,\n            max_scale_z,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          } = chunk;\n          const { packed_position: packed_position2, packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: packed_color2 } = item;\n          const x2 = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + min_x;\n          const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;\n          const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;\n          const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;\n          const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;\n          const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;\n          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\n          const rOrder = packed_rotation2 >>> 30;\n          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n          const quatZ = rOrder <= 2 ? r2 : rr;\n          const quatW = rOrder === 0 ? rr : r0;\n          const scaleX = Math.exp(\n            (packed_scale2 >>> 21 & 2047) / 2047 * (max_scale_x - min_scale_x) + min_scale_x\n          );\n          const scaleY = Math.exp(\n            (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - min_scale_y) + min_scale_y\n          );\n          const scaleZ = Math.exp(\n            (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + min_scale_z\n          );\n          const r = (packed_color2 >>> 24 & 255) / 255 * (max_r - min_r) + min_r;\n          const g = (packed_color2 >>> 16 & 255) / 255 * (max_g - min_g) + min_g;\n          const b = (packed_color2 >>> 8 & 255) / 255 * (max_b - min_b) + min_b;\n          const opacity = (packed_color2 & 255) / 255;\n          splatCallback(\n            index,\n            x2,\n            y,\n            z,\n            scaleX,\n            scaleY,\n            scaleZ,\n            quatX,\n            quatY,\n            quatZ,\n            quatW,\n            opacity,\n            r,\n            g,\n            b\n          );\n        };\n      }\n      const elementCallback = (element) => {\n        if (element.name === \"chunk\") {\n          return initSuperSplat(element);\n        }\n        if (isSuperSplat) {\n          return decodeSuperSplat(element);\n        }\n        if (element.name !== \"vertex\") {\n          return null;\n        }\n        const {\n          x: x2,\n          y,\n          z,\n          scale_0,\n          scale_1,\n          scale_2,\n          rot_0,\n          rot_1,\n          rot_2,\n          rot_3,\n          opacity,\n          f_dc_0,\n          f_dc_1,\n          f_dc_2,\n          red,\n          green,\n          blue,\n          alpha\n        } = element.properties;\n        if (!x2 || !y || !z) {\n          throw new Error(\"Missing PLY properties: x, y, z\");\n        }\n        const hasScales = scale_0 && scale_1 && scale_2;\n        const hasRots = rot_0 && rot_1 && rot_2 && rot_3;\n        const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;\n        const redDiv = red != null ? FIELD_SCALE[red.type] : 1;\n        const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;\n        const blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;\n        numSh = getNumSh(element.properties);\n        prepareSh();\n        return (index, item) => {\n          const scaleX = hasScales ? Math.exp(item.scale_0) : _PlyReader.defaultPointScale;\n          const scaleY = hasScales ? Math.exp(item.scale_1) : _PlyReader.defaultPointScale;\n          const scaleZ = hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;\n          const quatX = hasRots ? item.rot_1 : 0;\n          const quatY = hasRots ? item.rot_2 : 0;\n          const quatZ = hasRots ? item.rot_3 : 0;\n          const quatW = hasRots ? item.rot_0 : 1;\n          const op = opacity != null ? 1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;\n          const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? item.red / redDiv : 1;\n          const g = f_dc_1 != null ? item.f_dc_1 * SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;\n          const b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / blueDiv : 1;\n          splatCallback(\n            index,\n            item.x,\n            item.y,\n            item.z,\n            scaleX,\n            scaleY,\n            scaleZ,\n            quatX,\n            quatY,\n            quatZ,\n            quatW,\n            op,\n            r,\n            g,\n            b\n          );\n          if (shCallback && sh1) {\n            if (sh1) {\n              for (const [i2, key] of sh1Props.entries()) {\n                sh1[i2] = item[key];\n              }\n            }\n            if (sh2) {\n              for (const [i2, key] of sh2Props.entries()) {\n                sh2[i2] = item[key];\n              }\n            }\n            if (sh3) {\n              for (const [i2, key] of sh3Props.entries()) {\n                sh3[i2] = item[key];\n              }\n            }\n            shCallback(index, sh1, sh2, sh3);\n          }\n        };\n      };\n      this.parseData(elementCallback);\n    }\n    // Inject RGBA values into original PLY file, which can be used to modify\n    // the color/opacity of the Gsplats and write out the modified PLY file.\n    injectRgba(rgba) {\n      let offset = 0;\n      const data = this.data;\n      if (data == null) {\n        throw new Error(\"No parsed data\");\n      }\n      if (rgba.length !== this.numSplats * 4) {\n        throw new Error(\"Invalid RGBA array length\");\n      }\n      for (const elementName in this.elements) {\n        const element = this.elements[elementName];\n        const { count, properties } = element;\n        const parsers = [];\n        let rgbaOffset = 0;\n        const isVertex = elementName === \"vertex\";\n        if (isVertex) {\n          for (const name of [\"opacity\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"]) {\n            if (!properties[name] || properties[name].type !== \"float\") {\n              throw new Error(\\`Can't injectRgba due to property: \\${name}\\`);\n            }\n          }\n        }\n        for (const [propertyName, property] of Object.entries(properties)) {\n          if (!property.isList) {\n            if (isVertex) {\n              if (propertyName === \"f_dc_0\" || propertyName === \"f_dc_1\" || propertyName === \"f_dc_2\") {\n                const component = Number.parseInt(\n                  propertyName.slice(\"f_dc_\".length)\n                );\n                parsers.push(() => {\n                  const value = (rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;\n                  SET_FIELD[property.type](\n                    data,\n                    offset,\n                    this.littleEndian,\n                    value\n                  );\n                });\n              } else if (propertyName === \"opacity\") {\n                parsers.push(() => {\n                  const value = Math.max(\n                    -100,\n                    Math.min(\n                      100,\n                      -Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)\n                    )\n                  );\n                  SET_FIELD[property.type](\n                    data,\n                    offset,\n                    this.littleEndian,\n                    value\n                  );\n                });\n              }\n            }\n            parsers.push(() => {\n              offset += FIELD_BYTES[property.type];\n            });\n          } else {\n            parsers.push(() => {\n              const length = PARSE_FIELD[property.countType](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.countType];\n              offset += length * FIELD_BYTES[property.type];\n            });\n          }\n        }\n        for (let index = 0; index < count; index++) {\n          for (const parser of parsers) {\n            parser();\n          }\n          if (isVertex) {\n            rgbaOffset += 4;\n          }\n        }\n      }\n    }\n  };\n  _PlyReader.defaultPointScale = 1e-3;\n  let PlyReader = _PlyReader;\n  const SH_C0$1 = 0.28209479177387814;\n  const PARSE_FIELD = {\n    char: (data, offset, littleEndian) => {\n      return data.getInt8(offset);\n    },\n    uchar: (data, offset, littleEndian) => {\n      return data.getUint8(offset);\n    },\n    short: (data, offset, littleEndian) => {\n      return data.getInt16(offset, littleEndian);\n    },\n    ushort: (data, offset, littleEndian) => {\n      return data.getUint16(offset, littleEndian);\n    },\n    int: (data, offset, littleEndian) => {\n      return data.getInt32(offset, littleEndian);\n    },\n    uint: (data, offset, littleEndian) => {\n      return data.getUint32(offset, littleEndian);\n    },\n    float: (data, offset, littleEndian) => {\n      return data.getFloat32(offset, littleEndian);\n    },\n    double: (data, offset, littleEndian) => {\n      return data.getFloat64(offset, littleEndian);\n    }\n  };\n  const SET_FIELD = {\n    char: (data, offset, littleEndian, value) => {\n      data.setInt8(offset, value);\n    },\n    uchar: (data, offset, littleEndian, value) => {\n      data.setUint8(offset, value);\n    },\n    short: (data, offset, littleEndian, value) => {\n      data.setInt16(offset, value, littleEndian);\n    },\n    ushort: (data, offset, littleEndian, value) => {\n      data.setUint16(offset, value, littleEndian);\n    },\n    int: (data, offset, littleEndian, value) => {\n      data.setInt32(offset, value, littleEndian);\n    },\n    uint: (data, offset, littleEndian, value) => {\n      data.setUint32(offset, value, littleEndian);\n    },\n    float: (data, offset, littleEndian, value) => {\n      data.setFloat32(offset, value, littleEndian);\n    },\n    double: (data, offset, littleEndian, value) => {\n      data.setFloat64(offset, value, littleEndian);\n    }\n  };\n  const FIELD_BYTES = {\n    char: 1,\n    uchar: 1,\n    short: 2,\n    ushort: 2,\n    int: 4,\n    uint: 4,\n    float: 4,\n    double: 8\n  };\n  const FIELD_SCALE = {\n    char: 127,\n    uchar: 255,\n    short: 32767,\n    ushort: 65535,\n    int: 2147483647,\n    uint: 4294967295,\n    float: 1,\n    double: 1\n  };\n  const NUM_F_REST_TO_NUM_SH = {\n    0: 0,\n    9: 1,\n    24: 2,\n    45: 3\n  };\n  const NUM_SH_TO_NUM_F_REST = {\n    0: 0,\n    1: 9,\n    2: 24,\n    3: 45\n  };\n  function getNumSh(properties) {\n    let num_f_rest = 0;\n    while (properties[\\`f_rest_\\${num_f_rest}\\`]) {\n      num_f_rest += 1;\n    }\n    const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];\n    if (numSh == null) {\n      throw new Error(\\`Unsupported number of SH coefficients: \\${num_f_rest}\\`);\n    }\n    return numSh;\n  }\n  const Gsplat = { type: \"Gsplat\" };\n  const TPackedSplats = { type: \"PackedSplats\" };\n  const readPackedSplat = (packedSplats, index) => new ReadPackedSplat({ packedSplats, index });\n  const readPackedSplatRange = (packedSplats, index, base, count) => new ReadPackedSplatRange({ packedSplats, index, base, count });\n  const splitGsplat = (gsplat) => new SplitGsplat({ gsplat });\n  const combineGsplat = ({\n    gsplat,\n    flags,\n    index,\n    center,\n    scales,\n    quaternion,\n    rgba,\n    rgb,\n    opacity,\n    x: x2,\n    y,\n    z,\n    r,\n    g,\n    b\n  }) => {\n    return new CombineGsplat({\n      gsplat,\n      flags,\n      index,\n      center,\n      scales,\n      quaternion,\n      rgba,\n      rgb,\n      opacity,\n      x: x2,\n      y,\n      z,\n      r,\n      g,\n      b\n    });\n  };\n  const transformGsplat = (gsplat, {\n    scale,\n    rotate,\n    translate,\n    recolor\n  }) => {\n    return new TransformGsplat({ gsplat, scale, rotate, translate, recolor });\n  };\n  const defineGsplat = unindent(\\`\n  struct Gsplat {\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n\\`);\n  const definePackedSplats = unindent(\\`\n  struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n  };\n\\`);\n  const defineReadPackedSplat = unindent(\\`\n  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\n      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\\`);\n  class ReadPackedSplat extends Dyno {\n    constructor({\n      packedSplats,\n      index\n    }) {\n      super({\n        inTypes: { packedSplats: TPackedSplats, index: \"int\" },\n        outTypes: { gsplat: Gsplat },\n        inputs: { packedSplats, index },\n        globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat } = outputs;\n          if (!gsplat) {\n            return [];\n          }\n          const { packedSplats: packedSplats2, index: index2 } = inputs;\n          let statements;\n          if (packedSplats2 && index2) {\n            statements = unindentLines(\\`\n            if (readPackedSplat(\\${packedSplats2}.texture, \\${packedSplats2}.numSplats, \\${index2}, \\${gsplat})) {\n              bool zeroSize = all(equal(\\${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n              \\${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } else {\n              \\${gsplat}.flags = 0u;\n            }\n          \\`);\n          } else {\n            statements = [\\`\\${gsplat}.flags = 0u;\\`];\n          }\n          statements.push(\\`\\${gsplat}.index = \\${index2 ?? \"0\"};\\`);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, \"gsplat\");\n    }\n  }\n  class ReadPackedSplatRange extends Dyno {\n    constructor({\n      packedSplats,\n      index,\n      base,\n      count\n    }) {\n      super({\n        inTypes: {\n          packedSplats: TPackedSplats,\n          index: \"int\",\n          base: \"int\",\n          count: \"int\"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: { packedSplats, index, base, count },\n        globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat } = outputs;\n          if (!gsplat) {\n            return [];\n          }\n          const { packedSplats: packedSplats2, index: index2, base: base2, count: count2 } = inputs;\n          let statements;\n          if (packedSplats2 && index2 && base2 && count2) {\n            statements = unindentLines(\\`\n            \\${gsplat}.flags = 0u;\n            if ((\\${index2} >= \\${base2}) && (\\${index2} < (\\${base2} + \\${count2}))) {\n              if (readPackedSplat(\\${packedSplats2}.texture, \\${packedSplats2}.numSplats, \\${index2}, \\${gsplat})) {\n                bool zeroSize = all(equal(\\${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n                \\${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          \\`);\n          } else {\n            statements = [\\`\\${gsplat}.flags = 0u;\\`];\n          }\n          statements.push(\\`\\${gsplat}.index = \\${index2 ?? \"0\"};\\`);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, \"gsplat\");\n    }\n  }\n  class SplitGsplat extends Dyno {\n    constructor({ gsplat }) {\n      super({\n        inTypes: { gsplat: Gsplat },\n        outTypes: {\n          flags: \"uint\",\n          active: \"bool\",\n          index: \"int\",\n          center: \"vec3\",\n          scales: \"vec3\",\n          quaternion: \"vec4\",\n          rgba: \"vec4\",\n          rgb: \"vec3\",\n          opacity: \"float\",\n          x: \"float\",\n          y: \"float\",\n          z: \"float\",\n          r: \"float\",\n          g: \"float\",\n          b: \"float\"\n        },\n        inputs: { gsplat },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat: gsplat2 } = inputs;\n          const {\n            flags,\n            active,\n            index,\n            center,\n            scales,\n            quaternion,\n            rgba,\n            rgb,\n            opacity,\n            x: x2,\n            y,\n            z,\n            r,\n            g,\n            b\n          } = outputs;\n          return [\n            !flags ? null : \\`\\${flags} = \\${gsplat2 ? \\`\\${gsplat2}.flags\\` : \"0u\"};\\`,\n            !active ? null : \\`\\${active} = isGsplatActive(\\${gsplat2 ? \\`\\${gsplat2}.flags\\` : \"0u\"});\\`,\n            !index ? null : \\`\\${index} = \\${gsplat2 ? \\`\\${gsplat2}.index\\` : \"0\"};\\`,\n            !center ? null : \\`\\${center} = \\${gsplat2 ? \\`\\${gsplat2}.center\\` : \"vec3(0.0, 0.0, 0.0)\"};\\`,\n            !scales ? null : \\`\\${scales} = \\${gsplat2 ? \\`\\${gsplat2}.scales\\` : \"vec3(0.0, 0.0, 0.0)\"};\\`,\n            !quaternion ? null : \\`\\${quaternion} = \\${gsplat2 ? \\`\\${gsplat2}.quaternion\\` : \"vec4(0.0, 0.0, 0.0, 1.0)\"};\\`,\n            !rgba ? null : \\`\\${rgba} = \\${gsplat2 ? \\`\\${gsplat2}.rgba\\` : \"vec4(0.0, 0.0, 0.0, 0.0)\"};\\`,\n            !rgb ? null : \\`\\${rgb} = \\${gsplat2 ? \\`\\${gsplat2}.rgba.rgb\\` : \"vec3(0.0, 0.0, 0.0)\"};\\`,\n            !opacity ? null : \\`\\${opacity} = \\${gsplat2 ? \\`\\${gsplat2}.rgba.a\\` : \"0.0\"};\\`,\n            !x2 ? null : \\`\\${x2} = \\${gsplat2 ? \\`\\${gsplat2}.center.x\\` : \"0.0\"};\\`,\n            !y ? null : \\`\\${y} = \\${gsplat2 ? \\`\\${gsplat2}.center.y\\` : \"0.0\"};\\`,\n            !z ? null : \\`\\${z} = \\${gsplat2 ? \\`\\${gsplat2}.center.z\\` : \"0.0\"};\\`,\n            !r ? null : \\`\\${r} = \\${gsplat2 ? \\`\\${gsplat2}.rgba.r\\` : \"0.0\"};\\`,\n            !g ? null : \\`\\${g} = \\${gsplat2 ? \\`\\${gsplat2}.rgba.g\\` : \"0.0\"};\\`,\n            !b ? null : \\`\\${b} = \\${gsplat2 ? \\`\\${gsplat2}.rgba.b\\` : \"0.0\"};\\`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  class CombineGsplat extends Dyno {\n    constructor({\n      gsplat,\n      flags,\n      index,\n      center,\n      scales,\n      quaternion,\n      rgba,\n      rgb,\n      opacity,\n      x: x2,\n      y,\n      z,\n      r,\n      g,\n      b\n    }) {\n      super({\n        inTypes: {\n          gsplat: Gsplat,\n          flags: \"uint\",\n          index: \"int\",\n          center: \"vec3\",\n          scales: \"vec3\",\n          quaternion: \"vec4\",\n          rgba: \"vec4\",\n          rgb: \"vec3\",\n          opacity: \"float\",\n          x: \"float\",\n          y: \"float\",\n          z: \"float\",\n          r: \"float\",\n          g: \"float\",\n          b: \"float\"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: {\n          gsplat,\n          flags,\n          index,\n          center,\n          scales,\n          quaternion,\n          rgba,\n          rgb,\n          opacity,\n          x: x2,\n          y,\n          z,\n          r,\n          g,\n          b\n        },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat: outGsplat } = outputs;\n          if (!outGsplat) {\n            return [];\n          }\n          const {\n            gsplat: gsplat2,\n            flags: flags2,\n            index: index2,\n            center: center2,\n            scales: scales2,\n            quaternion: quaternion2,\n            rgba: rgba2,\n            rgb: rgb2,\n            opacity: opacity2,\n            x: x22,\n            y: y2,\n            z: z2,\n            r: r2,\n            g: g2,\n            b: b2\n          } = inputs;\n          return [\n            \\`\\${outGsplat}.flags = \\${flags2 ?? (gsplat2 ? \\`\\${gsplat2}.flags\\` : \"0u\")};\\`,\n            \\`\\${outGsplat}.index = \\${index2 ?? (gsplat2 ? \\`\\${gsplat2}.index\\` : \"0\")};\\`,\n            \\`\\${outGsplat}.center = \\${center2 ?? (gsplat2 ? \\`\\${gsplat2}.center\\` : \"vec3(0.0, 0.0, 0.0)\")};\\`,\n            \\`\\${outGsplat}.scales = \\${scales2 ?? (gsplat2 ? \\`\\${gsplat2}.scales\\` : \"vec3(0.0, 0.0, 0.0)\")};\\`,\n            \\`\\${outGsplat}.quaternion = \\${quaternion2 ?? (gsplat2 ? \\`\\${gsplat2}.quaternion\\` : \"vec4(0.0, 0.0, 0.0, 1.0)\")};\\`,\n            \\`\\${outGsplat}.rgba = \\${rgba2 ?? (gsplat2 ? \\`\\${gsplat2}.rgba\\` : \"vec4(0.0, 0.0, 0.0, 0.0)\")};\\`,\n            !rgb2 ? null : \\`\\${outGsplat}.rgba.rgb = \\${rgb2};\\`,\n            !opacity2 ? null : \\`\\${outGsplat}.rgba.a = \\${opacity2};\\`,\n            !x22 ? null : \\`\\${outGsplat}.center.x = \\${x22};\\`,\n            !y2 ? null : \\`\\${outGsplat}.center.y = \\${y2};\\`,\n            !z2 ? null : \\`\\${outGsplat}.center.z = \\${z2};\\`,\n            !r2 ? null : \\`\\${outGsplat}.rgba.r = \\${r2};\\`,\n            !g2 ? null : \\`\\${outGsplat}.rgba.g = \\${g2};\\`,\n            !b2 ? null : \\`\\${outGsplat}.rgba.b = \\${b2};\\`\n          ].filter(Boolean);\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, \"gsplat\");\n    }\n  }\n  unindent(\\`\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if (scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if (scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n      normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, normal);\n  }\n\\`);\n  class TransformGsplat extends Dyno {\n    constructor({\n      gsplat,\n      scale,\n      rotate,\n      translate,\n      recolor\n    }) {\n      super({\n        inTypes: {\n          gsplat: Gsplat,\n          scale: \"float\",\n          rotate: \"vec4\",\n          translate: \"vec3\",\n          recolor: \"vec4\"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: { gsplat, scale, rotate, translate, recolor },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs, compile }) => {\n          const { gsplat: gsplat2 } = outputs;\n          if (!gsplat2 || !inputs.gsplat) {\n            return [];\n          }\n          const { scale: scale2, rotate: rotate2, translate: translate2, recolor: recolor2 } = inputs;\n          const indent = compile.indent;\n          const statements = [\n            \\`\\${gsplat2} = \\${inputs.gsplat};\\`,\n            \\`if (isGsplatActive(\\${gsplat2}.flags)) {\\`,\n            scale2 ? \\`\\${indent}\\${gsplat2}.center *= \\${scale2};\\` : null,\n            rotate2 ? \\`\\${indent}\\${gsplat2}.center = quatVec(\\${rotate2}, \\${gsplat2}.center);\\` : null,\n            translate2 ? \\`\\${indent}\\${gsplat2}.center += \\${translate2};\\` : null,\n            scale2 ? \\`\\${indent}\\${gsplat2}.scales *= \\${scale2};\\` : null,\n            rotate2 ? \\`\\${indent}\\${gsplat2}.quaternion = quatQuat(\\${rotate2}, \\${gsplat2}.quaternion);\\` : null,\n            recolor2 ? \\`\\${indent}\\${gsplat2}.rgba *= \\${recolor2};\\` : null,\n            \"}\"\n          ].filter(Boolean);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, \"gsplat\");\n    }\n  }\n  const outputPackedSplat = (gsplat) => new OutputPackedSplat({ gsplat });\n  class OutputPackedSplat extends Dyno {\n    constructor({ gsplat }) {\n      super({\n        inTypes: { gsplat: Gsplat },\n        inputs: { gsplat },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { output } = outputs;\n          if (!output) {\n            return [];\n          }\n          const { gsplat: gsplat2 } = inputs;\n          if (gsplat2) {\n            return unindentLines(\\`\n            if (isGsplatActive(\\${gsplat2}.flags)) {\n              \\${output} = packSplat(\\${gsplat2}.center, \\${gsplat2}.scales, \\${gsplat2}.quaternion, \\${gsplat2}.rgba);\n            } else {\n              \\${output} = uvec4(0u, 0u, 0u, 0u);\n            }\n          \\`);\n          }\n          return [\\`\\${output} = uvec4(0u, 0u, 0u, 0u);\\`];\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, \"output\");\n    }\n  }\n  class OutputRgba8 extends Dyno {\n    constructor({ rgba8 }) {\n      super({\n        inTypes: { rgba8: \"vec4\" },\n        inputs: { rgba8 },\n        statements: ({ inputs, outputs }) => [\n          \\`target = \\${inputs.rgba8 ?? \"vec4(0.0, 0.0, 0.0, 0.0)\"};\\`\n        ]\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, \"rgba8\");\n    }\n  }\n  class DynoUniform extends Dyno {\n    constructor({\n      key,\n      type,\n      count,\n      value,\n      update,\n      globals\n    }) {\n      key = key ?? \"value\";\n      super({\n        outTypes: { [key]: type },\n        update: () => {\n          if (update) {\n            const value2 = update(this.value);\n            if (value2 !== void 0) {\n              this.value = value2;\n            }\n          }\n          this.uniform.value = this.value;\n        },\n        generate: ({ inputs, outputs }) => {\n          const allGlobals = (globals == null ? void 0 : globals({ inputs, outputs })) ?? [];\n          const uniforms = {};\n          const name = outputs[key];\n          if (name) {\n            allGlobals.push(\\`uniform \\${dynoDeclare(name, type, count)};\\`);\n            uniforms[name] = this.uniform;\n          }\n          return { globals: allGlobals, uniforms };\n        }\n      });\n      this.type = type;\n      this.count = count;\n      this.value = value;\n      this.uniform = { value };\n      this.outKey = key;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  class DynoInt extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: \"int\", value, update });\n    }\n  }\n  class DynoFloat extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: \"float\", value, update });\n    }\n  }\n  class DynoVec3 extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: \"vec3\", value, update });\n    }\n  }\n  class DynoVec4 extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: \"vec4\", value, update });\n    }\n  }\n  class DynoUsampler2DArray extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: \"usampler2DArray\", value, update });\n    }\n  }\n  class DynoProgram {\n    constructor({\n      graph,\n      inputs,\n      outputs,\n      template\n    }) {\n      this.graph = graph;\n      this.template = template;\n      this.inputs = inputs ?? {};\n      this.outputs = outputs ?? {};\n      const compile = new Compilation({ indent: this.template.indent });\n      for (const key in this.outputs) {\n        if (this.outputs[key]) {\n          compile.declares.add(this.outputs[key]);\n        }\n      }\n      const statements = graph.compile({\n        inputs: this.inputs,\n        outputs: this.outputs,\n        compile\n      });\n      this.shader = template.generate({ globals: compile.globals, statements });\n      this.uniforms = compile.uniforms;\n      this.updaters = compile.updaters;\n    }\n    prepareMaterial() {\n      return getMaterial(this);\n    }\n    update() {\n      for (const updater of this.updaters) {\n        updater();\n      }\n    }\n  }\n  class DynoProgramTemplate {\n    constructor(template) {\n      const globals = template.match(/^([ \\\\t]*)\\\\{\\\\{\\\\s*GLOBALS\\\\s*\\\\}\\\\}/m);\n      const statements = template.match(/^([ \\\\t]*)\\\\{\\\\{\\\\s*STATEMENTS\\\\s*\\\\}\\\\}/m);\n      if (!globals || !statements) {\n        throw new Error(\n          \"Template must contain {{ GLOBALS }} and {{ STATEMENTS }}\"\n        );\n      }\n      this.before = template.substring(0, globals.index);\n      this.between = template.substring(\n        globals.index + globals[0].length,\n        statements.index\n      );\n      this.after = template.substring(\n        statements.index + statements[0].length\n      );\n      this.indent = statements[1];\n    }\n    generate({\n      globals,\n      statements\n    }) {\n      return this.before + Array.from(globals).join(\"\\\\n\\\\n\") + this.between + statements.map((s) => this.indent + s).join(\"\\\\n\") + this.after;\n    }\n  }\n  const programMaterial = /* @__PURE__ */ new Map();\n  function getMaterial(program) {\n    let material = programMaterial.get(program);\n    if (material) {\n      return material;\n    }\n    material = new RawShaderMaterial({\n      glslVersion: GLSL3,\n      vertexShader: IDENT_VERTEX_SHADER,\n      fragmentShader: program.shader,\n      uniforms: program.uniforms\n    });\n    programMaterial.set(program, material);\n    return material;\n  }\n  function addOutputType(a, b, operation = \"add\") {\n    const error = () => {\n      throw new Error(\\`Invalid \\${operation} types: \\${a}, \\${b}\\`);\n    };\n    if (a === b) return a;\n    if (a === \"int\") {\n      if (isIntType(b)) return b;\n      error();\n    }\n    if (b === \"int\") {\n      if (isIntType(a)) return a;\n      error();\n    }\n    if (a === \"uint\") {\n      if (isUintType(b)) return b;\n      error();\n    }\n    if (b === \"uint\") {\n      if (isUintType(a)) return a;\n      error();\n    }\n    if (a === \"float\") {\n      if (isAllFloatType(b)) return b;\n      error();\n    }\n    if (b === \"float\") {\n      if (isAllFloatType(a)) return a;\n      error();\n    }\n    throw new Error(\\`Invalid \\${operation} types: \\${a}, \\${b}\\`);\n  }\n  function subOutputType(a, b) {\n    return addOutputType(a, b, \"sub\");\n  }\n  function mulOutputType(a, b) {\n    const error = () => {\n      throw new Error(\\`Invalid mul types: \\${a}, \\${b}\\`);\n    };\n    const result = (value) => value;\n    if (a === \"int\") {\n      if (isIntType(b)) return result(b);\n      error();\n    }\n    if (b === \"int\") {\n      if (isIntType(a)) return result(a);\n      error();\n    }\n    if (a === \"uint\") {\n      if (isUintType(b)) return result(b);\n      error();\n    }\n    if (b === \"uint\") {\n      if (isUintType(a)) return result(a);\n      error();\n    }\n    if (a === \"float\") {\n      if (isAllFloatType(b)) return result(b);\n      error();\n    }\n    if (b === \"float\") {\n      if (isAllFloatType(a)) return result(a);\n      error();\n    }\n    if (isIntType(a) || isUintType(a) || isIntType(b) || isUintType(b)) {\n      if (a === b) return result(a);\n      error();\n    }\n    if (a === \"vec2\") {\n      if (b === \"vec2\" || isMat2(b)) return result(\"vec2\");\n      if (b === \"mat3x2\") return result(\"vec3\");\n      if (b === \"mat4x2\") return result(\"vec4\");\n      error();\n    }\n    if (a === \"vec3\") {\n      if (b === \"mat2x3\") return result(\"vec2\");\n      if (b === \"vec3\" || isMat3(b)) return result(\"vec3\");\n      if (b === \"mat4x3\") return result(\"vec4\");\n      error();\n    }\n    if (a === \"vec4\") {\n      if (b === \"mat2x4\") return result(\"vec2\");\n      if (b === \"mat3x4\") return result(\"vec3\");\n      if (b === \"vec4\" || isMat4(b)) return result(\"vec4\");\n      error();\n    }\n    if (b === \"vec2\") {\n      if (isMat2(a)) return result(\"vec2\");\n      if (a === \"mat2x3\") return result(\"vec3\");\n      if (a === \"mat2x4\") return result(\"vec4\");\n      error();\n    }\n    if (b === \"vec3\") {\n      if (a === \"mat3x2\") return result(\"vec2\");\n      if (isMat3(a)) return result(\"vec3\");\n      if (a === \"mat3x4\") return result(\"vec4\");\n      error();\n    }\n    if (b === \"vec4\") {\n      if (a === \"mat4x2\") return result(\"vec2\");\n      if (a === \"mat4x3\") return result(\"vec3\");\n      if (isMat4(a)) return result(\"vec4\");\n      error();\n    }\n    if (isMat2(a)) {\n      if (isMat2(b)) return result(\"mat2\");\n      if (b === \"mat3x2\") return result(\"mat3x2\");\n      if (b === \"mat4x2\") return result(\"mat4x2\");\n      error();\n    }\n    if (a === \"mat2x3\") {\n      if (isMat2(b)) return result(\"mat2x3\");\n      if (b === \"mat3x2\") return result(\"mat3\");\n      if (b === \"mat4x2\") return result(\"mat4x3\");\n      error();\n    }\n    if (a === \"mat2x4\") {\n      if (isMat2(b)) return result(\"mat2x4\");\n      if (b === \"mat3x2\") return result(\"mat3x4\");\n      if (b === \"mat4x2\") return result(\"mat4\");\n      error();\n    }\n    if (a === \"mat3x2\") {\n      if (b === \"mat2x3\") return result(\"mat2\");\n      if (isMat3(b)) return result(\"mat3x2\");\n      if (b === \"mat4x3\") return result(\"mat4x2\");\n      error();\n    }\n    if (isMat3(a)) {\n      if (b === \"mat2x3\") return result(\"mat2x3\");\n      if (isMat3(b)) return result(\"mat3\");\n      if (b === \"mat4x3\") return result(\"mat4x3\");\n      error();\n    }\n    if (a === \"mat3x4\") {\n      if (b === \"mat2x3\") return result(\"mat2x4\");\n      if (isMat3(b)) return result(\"mat3x4\");\n      if (b === \"mat4x3\") return result(\"mat4\");\n      error();\n    }\n    if (a === \"mat4x2\") {\n      if (b === \"mat2x4\") return result(\"mat2\");\n      if (b === \"mat3x4\") return result(\"mat3x2\");\n      if (isMat4(b)) return result(\"mat4x2\");\n      error();\n    }\n    if (a === \"mat4x3\") {\n      if (b === \"mat2x4\") return result(\"mat2x3\");\n      if (b === \"mat3x4\") return result(\"mat3\");\n      if (isMat4(b)) return result(\"mat4x3\");\n      error();\n    }\n    if (isMat4(a)) {\n      if (b === \"mat2x4\") return result(\"mat2x4\");\n      if (b === \"mat3x4\") return result(\"mat3x4\");\n      if (isMat4(b)) return result(\"mat4\");\n      error();\n    }\n    throw new Error(\\`Invalid mul types: \\${a}, \\${b}\\`);\n  }\n  const add = (a, b) => new Add({ a, b });\n  const sub = (a, b) => new Sub({ a, b });\n  const mul = (a, b) => new Mul({ a, b });\n  class Add extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: \"sum\", outTypeFunc: addOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [\\`\\${outputs.sum} = \\${inputs.a} + \\${inputs.b};\\`];\n      };\n    }\n  }\n  class Sub extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: \"difference\", outTypeFunc: subOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [\\`\\${outputs.difference} = \\${inputs.a} - \\${inputs.b};\\`];\n      };\n    }\n  }\n  class Mul extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: \"product\", outTypeFunc: mulOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [\\`\\${outputs.product} = \\${inputs.a} * \\${inputs.b};\\`];\n      };\n    }\n  }\n  const normalize = (a) => new Normalize({ a });\n  const extendVec = (a, b) => new ExtendVec({ a, b });\n  class Normalize extends UnaryOp {\n    constructor({ a }) {\n      super({ a, outTypeFunc: (aType) => aType, outKey: \"normalize\" });\n      this.statements = ({ inputs, outputs }) => [\n        \\`\\${outputs.normalize} = normalize(\\${inputs.a});\\`\n      ];\n    }\n  }\n  function extendVecOutputType(type) {\n    if (type === \"float\") return \"vec2\";\n    if (type === \"vec2\") return \"vec3\";\n    if (type === \"vec3\") return \"vec4\";\n    throw new Error(\"Invalid type\");\n  }\n  class ExtendVec extends BinaryOp {\n    constructor({ a, b }) {\n      const type = valType(a);\n      const outType = extendVecOutputType(type);\n      super({ a, b, outKey: \"extend\", outTypeFunc: () => outType });\n      this.statements = ({ inputs, outputs }) => [\n        \\`\\${outputs.extend} = \\${outType}(\\${inputs.a}, \\${inputs.b});\\`\n      ];\n    }\n  }\n  const transformPos = (position, {\n    scale,\n    scales,\n    rotate,\n    translate\n  }) => {\n    return new TransformPosition({ position, scale, scales, rotate, translate }).outputs.position;\n  };\n  const transformDir = (dir, {\n    scale,\n    scales,\n    rotate\n  }) => {\n    return new TransformDir({ dir, scale, scales, rotate }).outputs.dir;\n  };\n  class TransformPosition extends Dyno {\n    constructor({\n      position,\n      scale,\n      scales,\n      rotate,\n      translate\n    }) {\n      super({\n        inTypes: {\n          position: \"vec3\",\n          scale: \"float\",\n          scales: \"vec3\",\n          rotate: \"vec4\",\n          translate: \"vec3\"\n        },\n        outTypes: { position: \"vec3\" },\n        inputs: { position, scale, scales, rotate, translate },\n        statements: ({ inputs, outputs }) => {\n          const { position: position2 } = outputs;\n          if (!position2) {\n            return [];\n          }\n          const { scale: scale2, scales: scales2, rotate: rotate2, translate: translate2 } = inputs;\n          return [\n            \\`\\${position2} = \\${inputs.position ?? \"vec3(0.0, 0.0, 0.0)\"};\\`,\n            !scale2 ? null : \\`\\${position2} *= \\${scale2};\\`,\n            !scales2 ? null : \\`\\${position2} *= \\${scales2};\\`,\n            !rotate2 ? null : \\`\\${position2} = quatVec(\\${rotate2}, \\${position2});\\`,\n            !translate2 ? null : \\`\\${position2} += \\${translate2};\\`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  class TransformDir extends Dyno {\n    constructor({\n      dir,\n      scale,\n      scales,\n      rotate\n    }) {\n      super({\n        inTypes: { dir: \"vec3\", scale: \"float\", scales: \"vec3\", rotate: \"vec4\" },\n        outTypes: { dir: \"vec3\" },\n        inputs: { dir, scale, scales, rotate },\n        statements: ({ inputs, outputs }) => {\n          const { dir: dir2 } = outputs;\n          if (!dir2) {\n            return [];\n          }\n          const { scale: scale2, scales: scales2, rotate: rotate2 } = inputs;\n          return [\n            \\`\\${dir2} = \\${inputs.dir ?? \"vec3(0.0, 0.0, 0.0)\"};\\`,\n            !scale2 ? null : \\`\\${dir2} *= \\${scale2};\\`,\n            !scales2 ? null : \\`\\${dir2} *= \\${scales2};\\`,\n            !rotate2 ? null : \\`\\${dir2} = quatVec(\\${rotate2}, \\${dir2});\\`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  var computeUvec4_default = \"precision highp float;\\\\nprecision highp int;\\\\nprecision highp sampler2D;\\\\nprecision highp usampler2D;\\\\nprecision highp isampler2D;\\\\nprecision highp sampler2DArray;\\\\nprecision highp usampler2DArray;\\\\nprecision highp isampler2DArray;\\\\nprecision highp sampler3D;\\\\nprecision highp usampler3D;\\\\nprecision highp isampler3D;\\\\n\\\\n#include <splatDefines>\\\\n\\\\nuniform uint targetLayer;\\\\nuniform int targetBase;\\\\nuniform int targetCount;\\\\n\\\\nout uvec4 target;\\\\n\\\\n{{ GLOBALS }}\\\\n\\\\nvoid produceSplat(int index) {\\\\n    {{ STATEMENTS }}\\\\n}\\\\n\\\\nvoid main() {\\\\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\\\\n    int index = targetIndex - targetBase;\\\\n\\\\n    if ((index >= 0) && (index < targetCount)) {\\\\n        produceSplat(index);\\\\n    } else {\\\\n        target = uvec4(0u, 0u, 0u, 0u);\\\\n    }\\\\n}\";\n  const _PackedSplats = class _PackedSplats {\n    constructor(options = {}) {\n      this.maxSplats = 0;\n      this.numSplats = 0;\n      this.packedArray = null;\n      this.isInitialized = false;\n      this.target = null;\n      this.source = null;\n      this.needsUpdate = true;\n      this.extra = {};\n      this.dyno = new DynoPackedSplats({ packedSplats: this });\n      this.initialized = Promise.resolve(this);\n      this.reinitialize(options);\n    }\n    reinitialize(options) {\n      this.isInitialized = false;\n      if (options.url || options.fileBytes || options.construct) {\n        this.initialized = this.asyncInitialize(options).then(() => {\n          this.isInitialized = true;\n          return this;\n        });\n      } else {\n        this.initialize(options);\n        this.isInitialized = true;\n        this.initialized = Promise.resolve(this);\n      }\n    }\n    initialize(options) {\n      if (options.packedArray) {\n        this.packedArray = options.packedArray;\n        this.maxSplats = Math.floor(this.packedArray.length / 4);\n        this.maxSplats = Math.floor(this.maxSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        this.numSplats = Math.min(\n          this.maxSplats,\n          options.numSplats ?? Number.POSITIVE_INFINITY\n        );\n      } else {\n        this.maxSplats = options.maxSplats ?? 0;\n        this.numSplats = 0;\n      }\n      this.extra = options.extra ?? {};\n    }\n    async asyncInitialize(options) {\n      let { url, fileBytes, construct } = options;\n      if (url) {\n        fileBytes = await fetch(url).then(async (response) => {\n          if (!response.ok) {\n            throw new Error(\n              \\`\\${response.status} \"\\${response.statusText}\" fetching URL: \\${url}\\`\n            );\n          }\n          const arrayBuffer = await response.arrayBuffer();\n          return arrayBuffer;\n        });\n      }\n      if (fileBytes) {\n        const unpacked = await unpackSplats({\n          input: fileBytes,\n          fileType: options.fileType,\n          pathOrUrl: options.fileName ?? url\n        });\n        this.initialize(unpacked);\n      }\n      if (construct) {\n        const maybePromise = construct(this);\n        if (maybePromise instanceof Promise) {\n          await maybePromise;\n        }\n      }\n    }\n    // Call this when you are finished with the PackedSplats and want to free\n    // any buffers it holds.\n    dispose() {\n      if (this.target) {\n        this.target.dispose();\n        this.target = null;\n      }\n      if (this.source) {\n        this.source.dispose();\n        this.source = null;\n      }\n    }\n    // Ensures that this.packedArray can fit numSplats Gsplats. If it's too small,\n    // resize exponentially and copy over the original data.\n    //\n    // Typically you don't need to call this, because calling this.setSplat(index, ...)\n    // and this.pushSplat(...) will automatically call ensureSplats() so we have\n    // enough splats.\n    ensureSplats(numSplats) {\n      const targetSize = numSplats <= this.maxSplats ? this.maxSplats : (\n        // Grow exponentially to avoid frequent reallocations\n        Math.max(numSplats, 2 * this.maxSplats)\n      );\n      const currentSize = !this.packedArray ? 0 : this.packedArray.length / 4;\n      if (!this.packedArray || targetSize > currentSize) {\n        this.maxSplats = getTextureSize(targetSize).maxSplats;\n        const newArray = new Uint32Array(this.maxSplats * 4);\n        if (this.packedArray) {\n          newArray.set(this.packedArray);\n        }\n        this.packedArray = newArray;\n      }\n      return this.packedArray;\n    }\n    // Ensure the extra array for the given level is large enough to hold numSplats\n    ensureSplatsSh(level, numSplats) {\n      let wordsPerSplat;\n      let key;\n      if (level === 0) {\n        return this.ensureSplats(numSplats);\n      }\n      if (level === 1) {\n        wordsPerSplat = 2;\n        key = \"sh1\";\n      } else if (level === 2) {\n        wordsPerSplat = 4;\n        key = \"sh2\";\n      } else if (level === 3) {\n        wordsPerSplat = 4;\n        key = \"sh3\";\n      } else {\n        throw new Error(\\`Invalid level: \\${level}\\`);\n      }\n      let maxSplats = !this.extra[key] ? 0 : this.extra[key].length / wordsPerSplat;\n      const targetSize = numSplats <= maxSplats ? maxSplats : Math.max(numSplats, 2 * maxSplats);\n      if (!this.extra[key] || targetSize > maxSplats) {\n        maxSplats = getTextureSize(targetSize).maxSplats;\n        const newArray = new Uint32Array(maxSplats * wordsPerSplat);\n        if (this.extra[key]) {\n          newArray.set(this.extra[key]);\n        }\n        this.extra[key] = newArray;\n      }\n      return this.extra[key];\n    }\n    // Unpack the 16-byte Gsplat data at index into the Three.js components\n    // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n    // opacity: number 0..1, color: THREE.Color 0..1.\n    getSplat(index) {\n      if (!this.packedArray || index >= this.numSplats) {\n        throw new Error(\"Invalid index\");\n      }\n      return unpackSplat(this.packedArray, index);\n    }\n    // Set all PackedSplat components at index with the provided Gsplat attributes\n    // (can be the same objects returned by getSplat). Ensures there is capacity\n    // for at least index+1 Gsplats.\n    setSplat(index, center, scales, quaternion, opacity, color) {\n      const packedSplats = this.ensureSplats(index + 1);\n      setPackedSplat(\n        packedSplats,\n        index,\n        center.x,\n        center.y,\n        center.z,\n        scales.x,\n        scales.y,\n        scales.z,\n        quaternion.x,\n        quaternion.y,\n        quaternion.z,\n        quaternion.w,\n        opacity,\n        color.r,\n        color.g,\n        color.b\n      );\n      this.numSplats = Math.max(this.numSplats, index + 1);\n    }\n    // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on\n    // construction where you just want to iterate and create a collection of Gsplats.\n    pushSplat(center, scales, quaternion, opacity, color) {\n      const packedSplats = this.ensureSplats(this.numSplats + 1);\n      setPackedSplat(\n        packedSplats,\n        this.numSplats,\n        center.x,\n        center.y,\n        center.z,\n        scales.x,\n        scales.y,\n        scales.z,\n        quaternion.x,\n        quaternion.y,\n        quaternion.z,\n        quaternion.w,\n        opacity,\n        color.r,\n        color.g,\n        color.b\n      );\n      ++this.numSplats;\n    }\n    // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat\n    // and invoke the callback function with the Gsplat attributes.\n    forEachSplat(callback) {\n      if (!this.packedArray || !this.numSplats) {\n        return;\n      }\n      for (let i2 = 0; i2 < this.numSplats; ++i2) {\n        const unpacked = unpackSplat(this.packedArray, i2);\n        callback(\n          i2,\n          unpacked.center,\n          unpacked.scales,\n          unpacked.quaternion,\n          unpacked.opacity,\n          unpacked.color\n        );\n      }\n    }\n    // Ensures our PackedSplats.target render target has enough space to generate\n    // maxSplats total Gsplats, and reallocate if not large enough.\n    ensureGenerate(maxSplats) {\n      if (this.target && (maxSplats ?? 1) <= this.maxSplats) {\n        return false;\n      }\n      this.dispose();\n      const textureSize = getTextureSize(maxSplats ?? 1);\n      const { width, height, depth } = textureSize;\n      this.maxSplats = textureSize.maxSplats;\n      this.target = new WebGLArrayRenderTarget(width, height, depth, {\n        depthBuffer: false,\n        stencilBuffer: false,\n        generateMipmaps: false,\n        magFilter: NearestFilter,\n        minFilter: NearestFilter\n      });\n      this.target.texture.format = RGBAIntegerFormat;\n      this.target.texture.type = UnsignedIntType;\n      this.target.texture.internalFormat = \"RGBA32UI\";\n      return true;\n    }\n    // Given an array of splatCounts (.numSplats for each\n    // SplatGenerator/SplatMesh in the scene), compute a\n    // \"mapping layout\" in the composite array of generated outputs.\n    generateMapping(splatCounts) {\n      let maxSplats = 0;\n      const mapping = splatCounts.map((numSplats) => {\n        const base = maxSplats;\n        const rounded = Math.ceil(numSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        maxSplats += rounded;\n        return { base, count: numSplats };\n      });\n      return { maxSplats, mapping };\n    }\n    // Returns a THREE.DataArrayTexture representing the PackedSplats content as\n    // a Uint32x4 data array texture (2048 x 2048 x depth in size)\n    getTexture() {\n      if (this.target) {\n        return this.target.texture;\n      }\n      if (this.source || this.packedArray) {\n        const source = this.maybeUpdateSource();\n        return source;\n      }\n      return _PackedSplats.getEmpty();\n    }\n    // Check if source texture needs to be created/updated\n    maybeUpdateSource() {\n      if (!this.packedArray) {\n        throw new Error(\"No packed splats\");\n      }\n      if (this.needsUpdate || !this.source) {\n        this.needsUpdate = false;\n        if (this.source) {\n          const { width, height, depth } = this.source.image;\n          if (this.maxSplats !== width * height * depth) {\n            this.source.dispose();\n            this.source = null;\n          }\n        }\n        if (!this.source) {\n          const { width, height, depth } = getTextureSize(this.maxSplats);\n          this.source = new DataArrayTexture(\n            this.packedArray,\n            width,\n            height,\n            depth\n          );\n          this.source.format = RGBAIntegerFormat;\n          this.source.type = UnsignedIntType;\n          this.source.internalFormat = \"RGBA32UI\";\n          this.source.needsUpdate = true;\n        } else if (this.packedArray.buffer !== this.source.image.data.buffer) {\n          this.source.image.data = new Uint8Array(this.packedArray.buffer);\n        }\n        this.source.needsUpdate = true;\n      }\n      return this.source;\n    }\n    // Can be used where you need an uninitialized THREE.DataArrayTexture like\n    // a uniform you will update with the result of this.getTexture() later.\n    static getEmpty() {\n      if (!_PackedSplats.emptySource) {\n        const { width, height, depth, maxSplats } = getTextureSize(1);\n        const emptyArray = new Uint32Array(maxSplats * 4);\n        _PackedSplats.emptySource = new DataArrayTexture(\n          emptyArray,\n          width,\n          height,\n          depth\n        );\n        _PackedSplats.emptySource.format = RGBAIntegerFormat;\n        _PackedSplats.emptySource.type = UnsignedIntType;\n        _PackedSplats.emptySource.internalFormat = \"RGBA32UI\";\n        _PackedSplats.emptySource.needsUpdate = true;\n      }\n      return _PackedSplats.emptySource;\n    }\n    // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,\n    // generating it if necessary and caching the result.\n    prepareProgramMaterial(generator) {\n      let program = _PackedSplats.generatorProgram.get(generator);\n      if (!program) {\n        const graph = dynoBlock(\n          { index: \"int\" },\n          { output: \"uvec4\" },\n          ({ index }) => {\n            generator.inputs.index = index;\n            const gsplat = generator.outputs.gsplat;\n            const output = outputPackedSplat(gsplat);\n            return { output };\n          }\n        );\n        if (!_PackedSplats.programTemplate) {\n          _PackedSplats.programTemplate = new DynoProgramTemplate(\n            computeUvec4_default\n          );\n        }\n        program = new DynoProgram({\n          graph,\n          inputs: { index: \"index\" },\n          outputs: { output: \"target\" },\n          template: _PackedSplats.programTemplate\n        });\n        Object.assign(program.uniforms, {\n          targetLayer: { value: 0 },\n          targetBase: { value: 0 },\n          targetCount: { value: 0 }\n        });\n        _PackedSplats.generatorProgram.set(generator, program);\n      }\n      const material = program.prepareMaterial();\n      _PackedSplats.mesh.material = material;\n      return { program, material };\n    }\n    saveRenderState(renderer) {\n      return {\n        xrPresenting: renderer.xr.isPresenting,\n        autoClear: renderer.autoClear,\n        scissorTest: renderer.getScissorTest(),\n        pixelRatio: renderer.getPixelRatio()\n      };\n    }\n    resetRenderState(renderer, state) {\n      renderer.setRenderTarget(null);\n      renderer.setPixelRatio(state.pixelRatio);\n      renderer.xr.isPresenting = state.xrPresenting;\n      renderer.autoClear = state.autoClear;\n      renderer.setScissorTest(state.scissorTest);\n    }\n    // Executes a dyno program specified by generator which is any DynoBlock that\n    // maps { index: \"int\" } to { gsplat: Gsplat }. This is called in\n    // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for\n    // SplatGenerator instances whose version is newer than what was generated\n    // for it last time.\n    generate({\n      generator,\n      base,\n      count,\n      renderer\n    }) {\n      if (!this.target) {\n        throw new Error(\"Target must be initialized with ensureSplats\");\n      }\n      if (base + count > this.maxSplats) {\n        throw new Error(\"Base + count exceeds maxSplats\");\n      }\n      const { program, material } = this.prepareProgramMaterial(generator);\n      program.update();\n      const renderState = this.saveRenderState(renderer);\n      const nextBase = Math.ceil((base + count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      material.uniforms.targetBase.value = base;\n      material.uniforms.targetCount.value = count;\n      while (base < nextBase) {\n        const layer = Math.floor(base / layerSize);\n        material.uniforms.targetLayer.value = layer;\n        const layerBase = layer * layerSize;\n        const layerYStart = Math.floor((base - layerBase) / SPLAT_TEX_WIDTH);\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((nextBase - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        renderer.setPixelRatio(1);\n        renderer.setRenderTarget(this.target, layer);\n        renderer.xr.isPresenting = false;\n        renderer.autoClear = false;\n        renderer.setScissorTest(true);\n        renderer.setScissor(\n          0,\n          layerYStart,\n          SPLAT_TEX_WIDTH,\n          layerYEnd - layerYStart\n        );\n        renderer.render(_PackedSplats.scene, _PackedSplats.camera);\n        base += SPLAT_TEX_WIDTH * (layerYEnd - layerYStart);\n      }\n      this.resetRenderState(renderer, renderState);\n      return { nextBase };\n    }\n  };\n  _PackedSplats.emptySource = null;\n  _PackedSplats.programTemplate = null;\n  _PackedSplats.generatorProgram = /* @__PURE__ */ new Map();\n  _PackedSplats.geometry = new PlaneGeometry(2, 2);\n  _PackedSplats.mesh = new Mesh(\n    _PackedSplats.geometry,\n    new RawShaderMaterial({ visible: false })\n  );\n  _PackedSplats.scene = new Scene().add(_PackedSplats.mesh);\n  _PackedSplats.camera = new Camera();\n  let PackedSplats = _PackedSplats;\n  class DynoPackedSplats extends DynoUniform {\n    constructor({ packedSplats } = {}) {\n      super({\n        key: \"packedSplats\",\n        type: TPackedSplats,\n        globals: () => [definePackedSplats],\n        value: {\n          texture: PackedSplats.getEmpty(),\n          numSplats: 0\n        },\n        update: (value) => {\n          var _a2, _b2;\n          value.texture = ((_a2 = this.packedSplats) == null ? void 0 : _a2.getTexture()) ?? PackedSplats.getEmpty();\n          value.numSplats = ((_b2 = this.packedSplats) == null ? void 0 : _b2.numSplats) ?? 0;\n          return value;\n        }\n      });\n      this.packedSplats = packedSplats;\n    }\n  }\n  var computeVec4_default = \"precision highp float;\\\\nprecision highp int;\\\\nprecision highp sampler2D;\\\\nprecision highp usampler2D;\\\\nprecision highp isampler2D;\\\\nprecision highp sampler2DArray;\\\\nprecision highp usampler2DArray;\\\\nprecision highp isampler2DArray;\\\\nprecision highp sampler3D;\\\\nprecision highp usampler3D;\\\\nprecision highp isampler3D;\\\\n\\\\n#include <splatDefines>\\\\n\\\\nuniform uint targetLayer;\\\\nuniform int targetBase;\\\\nuniform int targetCount;\\\\n\\\\nout vec4 target;\\\\n\\\\n{{ GLOBALS }}\\\\n\\\\nvoid computeReadback(int index) {\\\\n    {{ STATEMENTS }}\\\\n}\\\\n\\\\nvoid main() {\\\\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\\\\n    int index = targetIndex - targetBase;\\\\n\\\\n    if ((index >= 0) && (index < targetCount)) {\\\\n        computeReadback(index);\\\\n    } else {\\\\n        target = vec4(0.0, 0.0, 0.0, 0.0);\\\\n    }\\\\n}\";\n  const _Readback = class _Readback {\n    constructor({ renderer } = {}) {\n      this.renderer = renderer;\n      this.capacity = 0;\n      this.count = 0;\n    }\n    dispose() {\n      if (this.target) {\n        this.target.dispose();\n        this.target = void 0;\n      }\n    }\n    // Ensure we have a buffer large enough for the readback of count indices.\n    // Pass in previous bufer of the desired type.\n    ensureBuffer(count, buffer) {\n      const roundedCount = Math.ceil(Math.max(1, count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      const bytes = roundedCount * 4;\n      if (buffer.byteLength >= bytes) {\n        return buffer;\n      }\n      const newBuffer = new ArrayBuffer(bytes);\n      if (buffer instanceof ArrayBuffer) {\n        return newBuffer;\n      }\n      const ctor = buffer.constructor;\n      return new ctor(newBuffer);\n    }\n    // Ensure our render target is large enough for the readback of capacity indices.\n    ensureCapacity(capacity) {\n      const { width, height, depth, maxSplats } = getTextureSize(capacity);\n      if (!this.target || maxSplats > this.capacity) {\n        this.dispose();\n        this.capacity = maxSplats;\n        this.target = new WebGLArrayRenderTarget(width, height, depth, {\n          depthBuffer: false,\n          stencilBuffer: false,\n          generateMipmaps: false,\n          magFilter: NearestFilter,\n          minFilter: NearestFilter\n        });\n        this.target.texture.format = RGBAFormat;\n        this.target.texture.type = UnsignedByteType;\n        this.target.texture.internalFormat = \"RGBA8\";\n      }\n    }\n    // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,\n    // generating it if necessary and caching the result.\n    prepareProgramMaterial(reader) {\n      let program = _Readback.readbackProgram.get(reader);\n      if (!program) {\n        const graph = dynoBlock(\n          { index: \"int\" },\n          { rgba8: \"vec4\" },\n          ({ index }) => {\n            reader.inputs.index = index;\n            const rgba8 = new OutputRgba8({ rgba8: reader.outputs.rgba8 });\n            return { rgba8 };\n          }\n        );\n        if (!_Readback.programTemplate) {\n          _Readback.programTemplate = new DynoProgramTemplate(computeVec4_default);\n        }\n        program = new DynoProgram({\n          graph,\n          inputs: { index: \"index\" },\n          outputs: { rgba8: \"target\" },\n          template: _Readback.programTemplate\n        });\n        Object.assign(program.uniforms, {\n          targetLayer: { value: 0 },\n          targetBase: { value: 0 },\n          targetCount: { value: 0 }\n        });\n        _Readback.readbackProgram.set(reader, program);\n      }\n      const material = program.prepareMaterial();\n      _Readback.mesh.material = material;\n      return { program, material };\n    }\n    saveRenderState(renderer) {\n      return {\n        xrPresenting: renderer.xr.isPresenting,\n        autoClear: renderer.autoClear,\n        scissorTest: renderer.getScissorTest(),\n        pixelRatio: renderer.getPixelRatio()\n      };\n    }\n    resetRenderState(renderer, state) {\n      renderer.setRenderTarget(null);\n      renderer.setPixelRatio(state.pixelRatio);\n      renderer.xr.isPresenting = state.xrPresenting;\n      renderer.autoClear = state.autoClear;\n      renderer.setScissorTest(state.scissorTest);\n    }\n    process({\n      count,\n      material\n    }) {\n      const renderer = this.renderer;\n      if (!renderer) {\n        throw new Error(\"No renderer\");\n      }\n      if (!this.target) {\n        throw new Error(\"No target\");\n      }\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      material.uniforms.targetBase.value = 0;\n      material.uniforms.targetCount.value = count;\n      let baseIndex = 0;\n      while (baseIndex < count) {\n        const layer = Math.floor(baseIndex / layerSize);\n        const layerBase = layer * layerSize;\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((count - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        material.uniforms.targetLayer.value = layer;\n        renderer.setPixelRatio(1);\n        renderer.setRenderTarget(this.target, layer);\n        renderer.xr.isPresenting = false;\n        renderer.autoClear = false;\n        renderer.setScissorTest(true);\n        renderer.setScissor(0, 0, SPLAT_TEX_WIDTH, layerYEnd);\n        renderer.render(_Readback.scene, _Readback.camera);\n        baseIndex += SPLAT_TEX_WIDTH * layerYEnd;\n      }\n      this.count = count;\n    }\n    async read({\n      readback\n    }) {\n      const renderer = this.renderer;\n      if (!renderer) {\n        throw new Error(\"No renderer\");\n      }\n      if (!this.target) {\n        throw new Error(\"No target\");\n      }\n      const roundedCount = Math.ceil(this.count / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      if (readback.byteLength < roundedCount * 4) {\n        throw new Error(\n          \\`Readback buffer too small: \\${readback.byteLength} < \\${roundedCount * 4}\\`\n        );\n      }\n      const readbackUint8 = new Uint8Array(\n        readback instanceof ArrayBuffer ? readback : readback.buffer\n      );\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      let baseIndex = 0;\n      const promises = [];\n      while (baseIndex < this.count) {\n        const layer = Math.floor(baseIndex / layerSize);\n        const layerBase = layer * layerSize;\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((this.count - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        renderer.setPixelRatio(1);\n        renderer.setRenderTarget(this.target, layer);\n        const readbackSize = SPLAT_TEX_WIDTH * layerYEnd * 4;\n        const subReadback = readbackUint8.subarray(\n          layerBase * 4,\n          layerBase * 4 + readbackSize\n        );\n        const promise = renderer == null ? void 0 : renderer.readRenderTargetPixelsAsync(\n          this.target,\n          0,\n          0,\n          SPLAT_TEX_WIDTH,\n          layerYEnd,\n          subReadback\n        );\n        promises.push(promise);\n        baseIndex += SPLAT_TEX_WIDTH * layerYEnd;\n      }\n      return Promise.all(promises).then(() => readback);\n    }\n    // Perform render operation to run the Rgba8Readback program\n    // but don't perform the readback yet.\n    render({\n      reader,\n      count,\n      renderer\n    }) {\n      this.renderer = renderer || this.renderer;\n      if (!this.renderer) {\n        throw new Error(\"No renderer\");\n      }\n      this.ensureCapacity(count);\n      const { program, material } = this.prepareProgramMaterial(reader);\n      program.update();\n      const renderState = this.saveRenderState(this.renderer);\n      this.process({ count, material });\n      this.resetRenderState(this.renderer, renderState);\n    }\n    // Perform a readback of the render target, returning a buffer of the\n    // given type.\n    async readback({\n      readback\n    }) {\n      if (!this.renderer) {\n        throw new Error(\"No renderer\");\n      }\n      const renderState = this.saveRenderState(this.renderer);\n      const promise = this.read({ readback });\n      this.resetRenderState(this.renderer, renderState);\n      return promise;\n    }\n    // Perform a render and readback operation for the given Rgba8Readback,\n    // and readback buffer (call ensureBuffer first).\n    async renderReadback({\n      reader,\n      count,\n      renderer,\n      readback\n    }) {\n      this.renderer = renderer || this.renderer;\n      if (!this.renderer) {\n        throw new Error(\"No renderer\");\n      }\n      this.ensureCapacity(count);\n      const { program, material } = this.prepareProgramMaterial(reader);\n      program.update();\n      const renderState = this.saveRenderState(this.renderer);\n      this.process({ count, material });\n      const promise = this.read({ readback });\n      this.resetRenderState(this.renderer, renderState);\n      return promise;\n    }\n    getTexture() {\n      var _a2;\n      return (_a2 = this.target) == null ? void 0 : _a2.texture;\n    }\n  };\n  _Readback.programTemplate = null;\n  _Readback.readbackProgram = /* @__PURE__ */ new Map();\n  _Readback.geometry = new PlaneGeometry(2, 2);\n  _Readback.mesh = new Mesh(\n    _Readback.geometry,\n    new RawShaderMaterial({ visible: false })\n  );\n  _Readback.scene = new Scene().add(_Readback.mesh);\n  _Readback.camera = new Camera();\n  let Readback = _Readback;\n  const _RgbaArray = class _RgbaArray {\n    constructor(options = {}) {\n      this.capacity = 0;\n      this.count = 0;\n      this.array = null;\n      this.readback = null;\n      this.source = null;\n      this.needsUpdate = true;\n      this.dyno = new DynoUniform({\n        key: \"rgbaArray\",\n        type: TRgbaArray,\n        globals: () => [defineRgbaArray],\n        value: {\n          texture: _RgbaArray.getEmpty(),\n          count: 0\n        },\n        update: (value) => {\n          var _a2;\n          value.texture = ((_a2 = this.readback) == null ? void 0 : _a2.getTexture()) ?? this.source ?? _RgbaArray.getEmpty();\n          value.count = this.count;\n          return value;\n        }\n      });\n      if (options.array) {\n        this.array = options.array;\n        this.capacity = Math.floor(this.array.length / 4);\n        this.capacity = Math.floor(this.capacity / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        this.count = Math.min(\n          this.capacity,\n          options.count ?? Number.POSITIVE_INFINITY\n        );\n      } else {\n        this.capacity = options.capacity ?? 0;\n        this.count = 0;\n      }\n    }\n    // Free up resources\n    dispose() {\n      if (this.readback) {\n        this.readback.dispose();\n        this.readback = null;\n      }\n      if (this.source) {\n        this.source.dispose();\n        this.source = null;\n      }\n    }\n    // Ensure that our array is large enough to hold capacity RGBA8 values.\n    ensureCapacity(capacity) {\n      var _a2;\n      if (!this.array || capacity > (((_a2 = this.array) == null ? void 0 : _a2.length) ?? 0) / 4) {\n        this.capacity = getTextureSize(capacity).maxSplats;\n        const newArray = new Uint8Array(this.capacity * 4);\n        if (this.array) {\n          newArray.set(this.array);\n        }\n        this.array = newArray;\n      }\n      return this.array;\n    }\n    // Get the THREE.DataArrayTexture from either the readback or the source.\n    getTexture() {\n      var _a2;\n      let texture = (_a2 = this.readback) == null ? void 0 : _a2.getTexture();\n      if (this.source || this.array) {\n        texture = this.maybeUpdateSource();\n      }\n      return texture ?? _RgbaArray.getEmpty();\n    }\n    // Create or get a THREE.DataArrayTexture from the data array.\n    maybeUpdateSource() {\n      if (!this.array) {\n        throw new Error(\"No array\");\n      }\n      if (this.needsUpdate || !this.source) {\n        this.needsUpdate = false;\n        if (this.source) {\n          const { width, height, depth } = this.source.image;\n          if (this.capacity !== width * height * depth) {\n            this.source.dispose();\n            this.source = null;\n          }\n        }\n        if (!this.source) {\n          const { width, height, depth } = getTextureSize(this.capacity);\n          this.source = new DataArrayTexture(\n            this.array,\n            width,\n            height,\n            depth\n          );\n          this.source.format = RGBAFormat;\n          this.source.type = UnsignedByteType;\n          this.source.internalFormat = \"RGBA8\";\n          this.source.needsUpdate = true;\n        } else if (this.array.buffer !== this.source.image.data.buffer) {\n          this.source.image.data = new Uint8Array(this.array.buffer);\n        }\n        this.source.needsUpdate = true;\n      }\n      return this.source;\n    }\n    // Generate the RGBA8 values from a Rgba8Readback dyno program.\n    render({\n      reader,\n      count,\n      renderer\n    }) {\n      if (!this.readback) {\n        this.readback = new Readback({ renderer });\n      }\n      this.readback.render({ reader, count, renderer });\n      this.capacity = this.readback.capacity;\n      this.count = this.readback.count;\n    }\n    // Extract the RGBA8 values from a PackedSplats collection.\n    fromPackedSplats({\n      packedSplats,\n      base,\n      count,\n      renderer\n    }) {\n      const { dynoSplats, dynoBase, dynoCount, reader } = _RgbaArray.makeDynos();\n      dynoSplats.packedSplats = packedSplats;\n      dynoBase.value = base;\n      dynoCount.value = count;\n      this.render({ reader, count, renderer });\n      return this;\n    }\n    // Read back the RGBA8 values from the readback buffer.\n    async read() {\n      if (!this.readback) {\n        throw new Error(\"No readback\");\n      }\n      if (!this.array || this.array.length < this.count * 4) {\n        this.array = new Uint8Array(this.capacity * 4);\n      }\n      const result = await this.readback.readback({ readback: this.array });\n      return result.subarray(0, this.count * 4);\n    }\n    // Can be used where you need an uninitialized THREE.DataArrayTexture like\n    // a uniform you will update with the result of this.getTexture() later.\n    static getEmpty() {\n      if (!_RgbaArray.emptySource) {\n        const emptyArray = new Uint8Array(1 * 4);\n        _RgbaArray.emptySource = new DataArrayTexture(emptyArray, 1, 1, 1);\n        _RgbaArray.emptySource.format = RGBAFormat;\n        _RgbaArray.emptySource.type = UnsignedByteType;\n        _RgbaArray.emptySource.internalFormat = \"RGBA8\";\n        _RgbaArray.emptySource.needsUpdate = true;\n      }\n      return _RgbaArray.emptySource;\n    }\n    // Create a dyno program that can extract RGBA8 values from a PackedSplats\n    static makeDynos() {\n      if (!_RgbaArray.dynos) {\n        const dynoSplats = new DynoPackedSplats();\n        const dynoBase = new DynoInt({ value: 0 });\n        const dynoCount = new DynoInt({ value: 0 });\n        const reader = dynoBlock(\n          { index: \"int\" },\n          { rgba8: \"vec4\" },\n          ({ index }) => {\n            if (!index) {\n              throw new Error(\"index is undefined\");\n            }\n            index = add(index, dynoBase);\n            const gsplat = readPackedSplatRange(\n              dynoSplats,\n              index,\n              dynoBase,\n              dynoCount\n            );\n            return { rgba8: splitGsplat(gsplat).outputs.rgba };\n          }\n        );\n        _RgbaArray.dynos = { dynoSplats, dynoBase, dynoCount, reader };\n      }\n      return _RgbaArray.dynos;\n    }\n  };\n  _RgbaArray.emptySource = null;\n  _RgbaArray.dynos = null;\n  let RgbaArray = _RgbaArray;\n  const TRgbaArray = { type: \"RgbaArray\" };\n  const defineRgbaArray = unindent(\\`\n  struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  };\n\\`);\n  function readRgbaArray(rgba, index) {\n    const dyno2 = new Dyno({\n      inTypes: { rgba: TRgbaArray, index: \"int\" },\n      outTypes: { rgba: \"vec4\" },\n      inputs: { rgba, index },\n      globals: () => [defineRgbaArray],\n      statements: ({ inputs, outputs }) => unindentLines(\\`\n        if ((index >= 0) && (index < \\${inputs.rgba}.count)) {\n          \\${outputs.rgba} = texelFetch(\\${inputs.rgba}.texture, splatTexCoord(index), 0);\n        } else {\n          \\${outputs.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      \\`)\n    });\n    return dyno2.outputs.rgba;\n  }\n  function sdfTypeToNumber(type) {\n    switch (type) {\n      case \"all\":\n        return 0;\n      case \"plane\":\n        return 1;\n      case \"sphere\":\n        return 2;\n      case \"box\":\n        return 3;\n      case \"ellipsoid\":\n        return 4;\n      case \"cylinder\":\n        return 5;\n      case \"capsule\":\n        return 6;\n      case \"infinite_cone\":\n        return 7;\n      default:\n        throw new Error(\\`Unknown SDF type: \\${type}\\`);\n    }\n  }\n  function rgbaBlendModeToNumber(mode) {\n    switch (mode) {\n      case \"multiply\":\n        return 0;\n      case \"set_rgb\":\n        return 1;\n      case \"add_rgba\":\n        return 2;\n      default:\n        throw new Error(\\`Unknown blend mode: \\${mode}\\`);\n    }\n  }\n  class SplatEditSdf extends Object3D {\n    constructor(options = {}) {\n      super();\n      const { type, invert, opacity, color, displace, radius } = options;\n      this.type = type ?? \"sphere\";\n      this.invert = invert ?? false;\n      this.opacity = opacity ?? 1;\n      this.color = color ?? new Color(1, 1, 1);\n      this.displace = displace ?? new Vector3(0, 0, 0);\n      this.radius = radius ?? 0;\n    }\n  }\n  const _SplatEdit = class _SplatEdit extends Object3D {\n    constructor(options = {}) {\n      const {\n        name,\n        rgbaBlendMode = \"multiply\",\n        sdfSmooth = 0,\n        softEdge = 0,\n        invert = false,\n        sdfs = null\n      } = options;\n      super();\n      this.rgbaBlendMode = rgbaBlendMode;\n      this.sdfSmooth = sdfSmooth;\n      this.softEdge = softEdge;\n      this.invert = invert;\n      this.sdfs = sdfs;\n      this.ordering = _SplatEdit.nextOrdering++;\n      this.name = name ?? \\`Edit \\${this.ordering}\\`;\n    }\n    addSdf(sdf) {\n      if (this.sdfs == null) {\n        this.sdfs = [];\n      }\n      this.sdfs.push(sdf);\n    }\n    removeSdf(sdf) {\n      if (this.sdfs == null) {\n        return;\n      }\n      this.sdfs = this.sdfs.filter((s) => s !== sdf);\n    }\n  };\n  _SplatEdit.nextOrdering = 1;\n  let SplatEdit = _SplatEdit;\n  class SplatEdits {\n    constructor({ maxSdfs, maxEdits }) {\n      this.maxSdfs = Math.max(16, maxSdfs ?? 0);\n      this.numSdfs = 0;\n      this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\n      this.sdfFloatData = new Float32Array(this.sdfData.buffer);\n      this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);\n      this.dynoSdfArray = new DynoUniform({\n        key: \"sdfArray\",\n        type: SdfArray,\n        globals: () => [defineSdfArray],\n        value: {\n          numSdfs: 0,\n          sdfTexture: this.sdfTexture\n        },\n        update: (uniform) => {\n          uniform.numSdfs = this.numSdfs;\n          uniform.sdfTexture = this.sdfTexture;\n          return uniform;\n        }\n      });\n      this.maxEdits = Math.max(16, maxEdits ?? 0);\n      this.numEdits = 0;\n      this.editData = new Uint32Array(this.maxEdits * 4);\n      this.editFloatData = new Float32Array(this.editData.buffer);\n      this.dynoNumEdits = new DynoInt({ value: 0 });\n      this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n    }\n    newSdfTexture(data, maxSdfs) {\n      const texture = new DataTexture(\n        data,\n        8,\n        maxSdfs,\n        RGBAIntegerFormat,\n        UnsignedIntType\n      );\n      texture.internalFormat = \"RGBA32UI\";\n      texture.needsUpdate = true;\n      return texture;\n    }\n    newEdits(data, maxEdits) {\n      return new DynoUniform({\n        key: \"edits\",\n        type: \"uvec4\",\n        count: maxEdits,\n        globals: () => [defineEdit],\n        value: data\n      });\n    }\n    // Ensure our SDF texture and edits uniform array have enough capacity.\n    // Reallocate if not.\n    ensureCapacity({\n      maxSdfs,\n      maxEdits\n    }) {\n      let dynoUpdated = false;\n      if (maxSdfs > this.sdfTexture.image.height) {\n        this.sdfTexture.dispose();\n        this.maxSdfs = Math.max(this.maxSdfs * 2, maxSdfs);\n        this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\n        this.sdfFloatData = new Float32Array(this.sdfData.buffer);\n        this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);\n      }\n      if (maxEdits > (this.dynoEdits.count ?? 0)) {\n        this.maxEdits = Math.max(this.maxEdits * 2, maxEdits);\n        this.editData = new Uint32Array(this.maxEdits * 4);\n        this.editFloatData = new Float32Array(this.editData.buffer);\n        this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n        dynoUpdated = true;\n      }\n      return dynoUpdated;\n    }\n    updateEditData(offset, value) {\n      const updated = this.editData[offset] !== value;\n      this.editData[offset] = value;\n      return updated;\n    }\n    updateEditFloatData(offset, value) {\n      tempFloat32[0] = value;\n      const updated = this.editFloatData[offset] !== tempFloat32[0];\n      if (updated) {\n        this.editFloatData[offset] = tempFloat32[0];\n      }\n      return updated;\n    }\n    encodeEdit(editIndex, {\n      sdfFirst,\n      sdfCount,\n      invert,\n      rgbaBlendMode,\n      softEdge,\n      sdfSmooth\n    }) {\n      const base = editIndex * 4;\n      let updated = false;\n      updated = this.updateEditData(base + 0, rgbaBlendMode | (invert ? 1 << 8 : 0)) || updated;\n      updated = this.updateEditData(base + 1, sdfFirst | sdfCount << 16) || updated;\n      updated = this.updateEditFloatData(base + 2, softEdge) || updated;\n      updated = this.updateEditFloatData(base + 3, sdfSmooth) || updated;\n      return updated;\n    }\n    updateSdfData(offset, value) {\n      const updated = this.sdfData[offset] !== value;\n      this.sdfData[offset] = value;\n      return updated;\n    }\n    updateSdfFloatData(offset, value) {\n      tempFloat32[0] = value;\n      const updated = this.sdfFloatData[offset] !== tempFloat32[0];\n      if (updated) {\n        this.sdfFloatData[offset] = tempFloat32[0];\n      }\n      return updated;\n    }\n    encodeSdf(sdfIndex, {\n      sdfType,\n      invert,\n      center,\n      quaternion,\n      scale,\n      sizes\n    }, values) {\n      const base = sdfIndex * (8 * 4);\n      const flags = sdfType | (invert ? 1 << 8 : 0);\n      let updated = false;\n      updated = this.updateSdfFloatData(base + 0, (center == null ? void 0 : center.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 1, (center == null ? void 0 : center.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 2, (center == null ? void 0 : center.z) ?? 0) || updated;\n      updated = this.updateSdfData(base + 3, flags) || updated;\n      updated = this.updateSdfFloatData(base + 4, (quaternion == null ? void 0 : quaternion.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 5, (quaternion == null ? void 0 : quaternion.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 6, (quaternion == null ? void 0 : quaternion.z) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 7, (quaternion == null ? void 0 : quaternion.w) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 8, (scale == null ? void 0 : scale.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 9, (scale == null ? void 0 : scale.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 10, (scale == null ? void 0 : scale.z) ?? 0) || updated;\n      updated = this.updateSdfData(base + 11, 0) || updated;\n      updated = this.updateSdfFloatData(base + 12, (sizes == null ? void 0 : sizes.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 13, (sizes == null ? void 0 : sizes.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 14, (sizes == null ? void 0 : sizes.z) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 15, (sizes == null ? void 0 : sizes.w) ?? 0) || updated;\n      const nValues = Math.min(4, values.length);\n      for (let i2 = 0; i2 < nValues; ++i2) {\n        const vBase = base + 16 + i2 * 4;\n        updated = this.updateSdfFloatData(vBase + 0, values[i2].x) || updated;\n        updated = this.updateSdfFloatData(vBase + 1, values[i2].y) || updated;\n        updated = this.updateSdfFloatData(vBase + 2, values[i2].z) || updated;\n        updated = this.updateSdfFloatData(vBase + 3, values[i2].w) || updated;\n      }\n      return updated;\n    }\n    // Update the SDFs and edits from an array of SplatEdits and their\n    // associated SplatEditSdfs, updating it for the dyno shader program.\n    update(edits) {\n      const sdfCount = edits.reduce((total, { sdfs }) => total + sdfs.length, 0);\n      const dynoUpdated = this.ensureCapacity({\n        maxEdits: edits.length,\n        maxSdfs: sdfCount\n      });\n      const values = [new Vector4(), new Vector4()];\n      const center = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      const sizes = new Vector4();\n      let sdfIndex = 0;\n      let updated = dynoUpdated;\n      if (edits.length !== this.dynoNumEdits.value) {\n        this.dynoNumEdits.value = edits.length;\n        this.numEdits = edits.length;\n        updated = true;\n      }\n      for (const [editIndex, { edit, sdfs }] of edits.entries()) {\n        updated = this.encodeEdit(editIndex, {\n          sdfFirst: sdfIndex,\n          sdfCount: sdfs.length,\n          invert: edit.invert,\n          rgbaBlendMode: rgbaBlendModeToNumber(edit.rgbaBlendMode),\n          softEdge: edit.softEdge,\n          sdfSmooth: edit.sdfSmooth\n        }) || updated;\n        let sdfUpdated = false;\n        for (const sdf of sdfs) {\n          sizes.set(sdf.scale.x, sdf.scale.y, sdf.scale.z, sdf.radius);\n          sdf.scale.setScalar(1);\n          sdf.updateMatrixWorld();\n          const worldToSdf = sdf.matrixWorld.clone().invert();\n          worldToSdf.decompose(center, quaternion, scale);\n          sdf.scale.set(sizes.x, sizes.y, sizes.z);\n          sdf.updateMatrixWorld();\n          values[0].set(sdf.color.r, sdf.color.g, sdf.color.b, sdf.opacity);\n          values[1].set(sdf.displace.x, sdf.displace.y, sdf.displace.z, 1);\n          sdfUpdated = this.encodeSdf(\n            sdfIndex,\n            {\n              sdfType: sdfTypeToNumber(sdf.type),\n              invert: sdf.invert,\n              center,\n              quaternion,\n              scale,\n              sizes\n            },\n            values\n          ) || sdfUpdated;\n          sdfIndex += 1;\n        }\n        this.numSdfs = sdfIndex;\n        if (sdfUpdated) {\n          this.sdfTexture.needsUpdate = true;\n        }\n        updated || (updated = sdfUpdated);\n      }\n      return { updated, dynoUpdated };\n    }\n    // Modify a Gsplat in a dyno shader program using the current edits and SDFs.\n    modify(gsplat) {\n      return applyGsplatRgbaDisplaceEdits(\n        gsplat,\n        this.dynoSdfArray,\n        this.dynoNumEdits,\n        this.dynoEdits\n      );\n    }\n  }\n  const SdfArray = { type: \"SdfArray\" };\n  const defineSdfArray = unindent(\\`\n  struct SdfArray {\n    int numSdfs;\n    usampler2D sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n    }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    }\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n    vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n    for (int index = sdfFirst; index < sdfLast; ++index) {\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n          distance = sdfPos.z;\n          break;\n        }\n        case SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n          float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n        case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n          float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        }\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance = -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < distanceAccum) {\n          distanceAccum = distance;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          }\n        }\n      } else {\n        float scaledDistance = -distance / smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n          }\n          maxExp = scaledDistance;\n        }\n\n        float weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n        for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      return distanceAccum;\n    } else {\n      // Very distant SDFs may result in 0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / 0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n      distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  }\n\\`);\n  const defineEdit = unindent(\\`\n  const uint EDIT_FLAG_BLEND = 0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = uintBitsToFloat(packedEdit.z);\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\n    // On Android, moving values[0] is necessary to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) {\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n        target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    }\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\n  }\n\\`);\n  function applyGsplatRgbaDisplaceEdits(gsplat, sdfArray, numEdits, rgbaDisplaceEdits) {\n    const dyno2 = new Dyno({\n      inTypes: {\n        gsplat: Gsplat,\n        sdfArray: SdfArray,\n        numEdits: \"int\",\n        rgbaDisplaceEdits: \"uvec4\"\n      },\n      outTypes: { gsplat: Gsplat },\n      globals: () => [defineSdfArray, defineEdit],\n      inputs: { gsplat, sdfArray, numEdits, rgbaDisplaceEdits },\n      statements: ({ inputs, outputs }) => {\n        const { sdfArray: sdfArray2, numEdits: numEdits2, rgbaDisplaceEdits: rgbaDisplaceEdits2 } = inputs;\n        const { gsplat: gsplat2 } = outputs;\n        return unindentLines(\\`\n        \\${gsplat2} = \\${inputs.gsplat};\n        if (isGsplatActive(\\${gsplat2}.flags)) {\n          for (int editIndex = 0; editIndex < \\${numEdits2}; ++editIndex) {\n            applyPackedRgbaDisplaceEdit(\n              \\${rgbaDisplaceEdits2}[editIndex], \\${sdfArray2}.sdfTexture, \\${sdfArray2}.numSdfs,\n              \\${gsplat2}.center, \\${gsplat2}.rgba\n            );\n          }\n        }\n      \\`);\n      }\n    });\n    return dyno2.outputs.gsplat;\n  }\n  const tempFloat32 = new Float32Array(1);\n  class SplatTransformer {\n    // Create the dyno uniforms that parameterize the transform, setting them\n    // to initial values that are different from any valid transform.\n    constructor() {\n      this.scale = new DynoFloat({ value: Number.NEGATIVE_INFINITY });\n      this.rotate = new DynoVec4({\n        value: new Quaternion(\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY\n        )\n      });\n      this.translate = new DynoVec3({\n        value: new Vector3(\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY\n        )\n      });\n    }\n    // Apply the transform to a Vec3 position in a dyno program.\n    apply(position) {\n      return transformPos(position, {\n        scale: this.scale,\n        rotate: this.rotate,\n        translate: this.translate\n      });\n    }\n    applyDir(dir) {\n      return transformDir(dir, {\n        rotate: this.rotate\n      });\n    }\n    // Apply the transform to a Gsplat in a dyno program.\n    applyGsplat(gsplat) {\n      return transformGsplat(gsplat, {\n        scale: this.scale,\n        rotate: this.rotate,\n        translate: this.translate\n      });\n    }\n    // Update the uniforms to match the given transform matrix.\n    updateFromMatrix(transform) {\n      const scale = new Vector3();\n      const quaternion = new Quaternion();\n      const position = new Vector3();\n      transform.decompose(position, quaternion, scale);\n      const newScale = (scale.x + scale.y + scale.z) / 3;\n      let updated = false;\n      if (newScale !== this.scale.value) {\n        this.scale.value = newScale;\n        updated = true;\n      }\n      if (!position.equals(this.translate.value)) {\n        this.translate.value.copy(position);\n        updated = true;\n      }\n      if (!quaternion.equals(this.rotate.value)) {\n        this.rotate.value.copy(quaternion);\n        updated = true;\n      }\n      return updated;\n    }\n    // Update this transform to match the object's to-world transform.\n    update(object) {\n      object.updateMatrixWorld();\n      return this.updateFromMatrix(object.matrixWorld);\n    }\n  }\n  class SplatGenerator extends Object3D {\n    constructor({\n      numSplats,\n      generator,\n      construct,\n      update\n    }) {\n      super();\n      this.numSplats = numSplats ?? 0;\n      this.generator = generator;\n      this.frameUpdate = update;\n      this.version = 0;\n      if (construct) {\n        const constructed = construct(this);\n        Object.assign(this, constructed);\n      }\n    }\n    updateVersion() {\n      this.version += 1;\n    }\n    set needsUpdate(value) {\n      if (value) {\n        this.updateVersion();\n      }\n    }\n  }\n  const _SplatMesh = class _SplatMesh extends SplatGenerator {\n    constructor(options = {}) {\n      const transform = new SplatTransformer();\n      const viewToWorld = new SplatTransformer();\n      const worldToView = new SplatTransformer();\n      const viewToObject = new SplatTransformer();\n      const recolor = new DynoVec4({\n        value: new Vector4(\n          Number.NEGATIVE_INFINITY,\n          Number.NEGATIVE_INFINITY,\n          Number.NEGATIVE_INFINITY,\n          Number.NEGATIVE_INFINITY\n        )\n      });\n      const time = new DynoFloat({ value: 0 });\n      const deltaTime = new DynoFloat({ value: 0 });\n      const context = {\n        transform,\n        viewToWorld,\n        worldToView,\n        viewToObject,\n        recolor,\n        time,\n        deltaTime\n      };\n      super({\n        update: ({ time: time2, deltaTime: deltaTime2, viewToWorld: viewToWorld2, globalEdits }) => this.update({ time: time2, deltaTime: deltaTime2, viewToWorld: viewToWorld2, globalEdits })\n      });\n      this.isInitialized = false;\n      this.recolor = new Color(1, 1, 1);\n      this.opacity = 1;\n      this.enableViewToObject = false;\n      this.enableViewToWorld = false;\n      this.enableWorldToView = false;\n      this.skinning = null;\n      this.edits = null;\n      this.rgbaDisplaceEdits = null;\n      this.splatRgba = null;\n      this.maxSh = 3;\n      this.packedSplats = options.packedSplats ?? new PackedSplats();\n      this.numSplats = this.packedSplats.numSplats;\n      this.editable = options.editable ?? true;\n      this.onFrame = options.onFrame;\n      this.context = context;\n      this.objectModifier = options.objectModifier;\n      this.worldModifier = options.worldModifier;\n      this.updateGenerator();\n      if (options.url || options.fileBytes || options.constructSplats || options.packedSplats && !options.packedSplats.isInitialized) {\n        this.initialized = this.asyncInitialize(options).then(async () => {\n          this.updateGenerator();\n          this.isInitialized = true;\n          if (options.onLoad) {\n            const maybePromise = options.onLoad(this);\n            if (maybePromise instanceof Promise) {\n              await maybePromise;\n            }\n          }\n          return this;\n        });\n      } else {\n        this.isInitialized = true;\n        this.initialized = Promise.resolve(this);\n        if (options.onLoad) {\n          const maybePromise = options.onLoad(this);\n          if (maybePromise instanceof Promise) {\n            this.initialized = maybePromise.then(() => this);\n          }\n        }\n      }\n    }\n    async asyncInitialize(options) {\n      const { url, fileBytes, fileType, fileName, maxSplats, constructSplats } = options;\n      if (url || fileBytes || constructSplats) {\n        const packedSplatsOptions = {\n          url,\n          fileBytes,\n          fileType,\n          fileName,\n          maxSplats,\n          construct: constructSplats\n        };\n        this.packedSplats.reinitialize(packedSplatsOptions);\n      }\n      if (this.packedSplats) {\n        await this.packedSplats.initialized;\n        this.numSplats = this.packedSplats.numSplats;\n        this.updateGenerator();\n      }\n    }\n    static async staticInitialize() {\n      await __wbg_init();\n      _SplatMesh.isStaticInitialized = true;\n    }\n    // Creates a new Gsplat with the provided parameters (all values in \"float\" space,\n    // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,\n    // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential\n    // doubling strategy to fit the new data, so it's fairly efficient to just\n    // pushSplat(...) each Gsplat you want to create in a loop.\n    pushSplat(center, scales, quaternion, opacity, color) {\n      this.packedSplats.pushSplat(center, scales, quaternion, opacity, color);\n    }\n    // This method iterates over all Gsplats in this instance's packedSplats,\n    // invoking the provided callback with index: number in 0..=(this.numSplats-1) and\n    // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n    // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).\n    // Note that the objects passed in as center etc. are the same for every callback\n    // invocation: these objects are reused for efficiency. Changing these values has\n    // no effect as they are decoded/unpacked copies of the underlying data. To update\n    // the packedSplats, call .packedSplats.setSplat(index, center, scales,\n    // quaternion, opacity, color).\n    forEachSplat(callback) {\n      this.packedSplats.forEachSplat(callback);\n    }\n    // Call this when you are finished with the SplatMesh and want to free\n    // any buffers it holds (via packedSplats).\n    dispose() {\n      this.packedSplats.dispose();\n    }\n    constructGenerator(context) {\n      const { transform, viewToObject, recolor } = context;\n      const generator = dynoBlock(\n        { index: \"int\" },\n        { gsplat: Gsplat },\n        ({ index }) => {\n          if (!index) {\n            throw new Error(\"index is undefined\");\n          }\n          let gsplat = readPackedSplat(this.packedSplats.dyno, index);\n          if (this.maxSh >= 1) {\n            const { sh1Texture, sh2Texture, sh3Texture } = this.ensureShTextures();\n            if (sh1Texture) {\n              const viewCenterInObject = viewToObject.translate;\n              const { center } = splitGsplat(gsplat).outputs;\n              const viewDir = normalize(sub(center, viewCenterInObject));\n              let rgb = evaluateSH1(gsplat, sh1Texture, viewDir);\n              if (this.maxSh >= 2 && sh2Texture) {\n                rgb = add(rgb, evaluateSH2(gsplat, sh2Texture, viewDir));\n              }\n              if (this.maxSh >= 3 && sh3Texture) {\n                rgb = add(rgb, evaluateSH3(gsplat, sh3Texture, viewDir));\n              }\n              let { rgba } = splitGsplat(gsplat).outputs;\n              rgba = add(rgba, extendVec(rgb, dynoConst(\"float\", 0)));\n              gsplat = combineGsplat({ gsplat, rgba });\n            }\n          }\n          if (this.splatRgba) {\n            const rgba = readRgbaArray(this.splatRgba.dyno, index);\n            gsplat = combineGsplat({ gsplat, rgba });\n          }\n          if (this.skinning) {\n            gsplat = this.skinning.modify(gsplat);\n          }\n          if (this.objectModifier) {\n            gsplat = this.objectModifier.apply({ gsplat }).gsplat;\n          }\n          gsplat = transform.applyGsplat(gsplat);\n          const recolorRgba = mul(recolor, splitGsplat(gsplat).outputs.rgba);\n          gsplat = combineGsplat({ gsplat, rgba: recolorRgba });\n          if (this.rgbaDisplaceEdits) {\n            gsplat = this.rgbaDisplaceEdits.modify(gsplat);\n          }\n          if (this.worldModifier) {\n            gsplat = this.worldModifier.apply({ gsplat }).gsplat;\n          }\n          return { gsplat };\n        }\n      );\n      this.generator = generator;\n    }\n    // Call this whenever something changes in the Gsplat processing pipeline,\n    // for example changing maxSh or updating objectModifier or worldModifier.\n    // Compiled generators are cached for efficiency and re-use when the same\n    // pipeline structure emerges after successive changes.\n    updateGenerator() {\n      this.constructGenerator(this.context);\n    }\n    // This is called automatically by SparkRenderer and you should not have to\n    // call it. It updates parameters for the generated pipeline and calls\n    // updateGenerator() if the pipeline needs to change.\n    update({\n      time,\n      viewToWorld,\n      deltaTime,\n      globalEdits\n    }) {\n      var _a2;\n      this.numSplats = this.packedSplats.numSplats;\n      this.context.time.value = time;\n      this.context.deltaTime.value = deltaTime;\n      _SplatMesh.dynoTime.value = time;\n      const { transform, viewToObject, recolor } = this.context;\n      let updated = transform.update(this);\n      if (this.context.viewToWorld.updateFromMatrix(viewToWorld) && this.enableViewToWorld) {\n        updated = true;\n      }\n      const worldToView = viewToWorld.clone().invert();\n      if (this.context.worldToView.updateFromMatrix(worldToView) && this.enableWorldToView) {\n        updated = true;\n      }\n      const objectToWorld = new Matrix4().compose(\n        transform.translate.value,\n        transform.rotate.value,\n        new Vector3().setScalar(transform.scale.value)\n      );\n      const worldToObject = objectToWorld.invert();\n      const viewToObjectMatrix = worldToObject.multiply(viewToWorld);\n      if (viewToObject.updateFromMatrix(viewToObjectMatrix) && (this.enableViewToObject || this.packedSplats.extra.sh1)) {\n        updated = true;\n      }\n      const newRecolor = new Vector4(\n        this.recolor.r,\n        this.recolor.g,\n        this.recolor.b,\n        this.opacity\n      );\n      if (!newRecolor.equals(recolor.value)) {\n        recolor.value.copy(newRecolor);\n        updated = true;\n      }\n      const edits = this.editable ? (this.edits ?? []).concat(globalEdits) : [];\n      if (this.editable && !this.edits) {\n        this.traverseVisible((node) => {\n          if (node instanceof SplatEdit) {\n            edits.push(node);\n          }\n        });\n      }\n      edits.sort((a, b) => a.ordering - b.ordering);\n      const editsSdfs = edits.map((edit) => {\n        if (edit.sdfs != null) {\n          return { edit, sdfs: edit.sdfs };\n        }\n        const sdfs = [];\n        edit.traverseVisible((node) => {\n          if (node instanceof SplatEditSdf) {\n            sdfs.push(node);\n          }\n        });\n        return { edit, sdfs };\n      });\n      if (editsSdfs.length > 0 && !this.rgbaDisplaceEdits) {\n        const edits2 = editsSdfs.length;\n        const sdfs = editsSdfs.reduce(\n          (total, edit) => total + edit.sdfs.length,\n          0\n        );\n        this.rgbaDisplaceEdits = new SplatEdits({\n          maxEdits: edits2,\n          maxSdfs: sdfs\n        });\n        this.updateGenerator();\n      }\n      if (this.rgbaDisplaceEdits) {\n        const editResult = this.rgbaDisplaceEdits.update(editsSdfs);\n        updated || (updated = editResult.updated);\n        if (editResult.dynoUpdated) {\n          this.updateGenerator();\n        }\n      }\n      if (updated) {\n        this.updateVersion();\n      }\n      (_a2 = this.onFrame) == null ? void 0 : _a2.call(this, { mesh: this, time, deltaTime });\n    }\n    // This method conforms to the standard THREE.Raycaster API, performing object-ray\n    // intersections using this method to populate the provided intersects[] array\n    // with each intersection point.\n    raycast(raycaster, intersects) {\n      if (!this.packedSplats.packedArray || !this.packedSplats.numSplats) {\n        return;\n      }\n      const { near, far, ray } = raycaster;\n      const worldToMesh = this.matrixWorld.clone().invert();\n      const worldToMeshRot = new Matrix3().setFromMatrix4(worldToMesh);\n      const origin = ray.origin.clone().applyMatrix4(worldToMesh);\n      const direction = ray.direction.clone().applyMatrix3(worldToMeshRot);\n      const scales = new Vector3();\n      worldToMesh.decompose(new Vector3(), new Quaternion(), scales);\n      (scales.x * scales.y * scales.z) ** (1 / 3);\n      const RAYCAST_ELLIPSOID = true;\n      const distances = raycast_splats(\n        origin.x,\n        origin.y,\n        origin.z,\n        direction.x,\n        direction.y,\n        direction.z,\n        near,\n        far,\n        this.packedSplats.numSplats,\n        this.packedSplats.packedArray,\n        RAYCAST_ELLIPSOID\n      );\n      for (const distance of distances) {\n        const point = ray.direction.clone().multiplyScalar(distance).add(ray.origin);\n        intersects.push({\n          distance,\n          point,\n          object: this\n        });\n      }\n    }\n    ensureShTextures() {\n      if (!this.packedSplats.extra.sh1) {\n        return {};\n      }\n      let sh1Texture = this.packedSplats.extra.sh1Texture;\n      if (!sh1Texture) {\n        let sh1 = this.packedSplats.extra.sh1;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh1.length / 2\n        );\n        if (sh1.length < maxSplats * 2) {\n          const newSh1 = new Uint32Array(maxSplats * 2);\n          newSh1.set(sh1);\n          this.packedSplats.extra.sh1 = newSh1;\n          sh1 = newSh1;\n        }\n        const texture = new DataArrayTexture(sh1, width, height, depth);\n        texture.format = RGIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = \"RG32UI\";\n        texture.needsUpdate = true;\n        sh1Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: \"sh1\"\n        });\n        this.packedSplats.extra.sh1Texture = sh1Texture;\n      }\n      if (!this.packedSplats.extra.sh2) {\n        return { sh1Texture };\n      }\n      let sh2Texture = this.packedSplats.extra.sh2Texture;\n      if (!sh2Texture) {\n        let sh2 = this.packedSplats.extra.sh2;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh2.length / 4\n        );\n        if (sh2.length < maxSplats * 4) {\n          const newSh2 = new Uint32Array(maxSplats * 4);\n          newSh2.set(sh2);\n          this.packedSplats.extra.sh2 = newSh2;\n          sh2 = newSh2;\n        }\n        const texture = new DataArrayTexture(sh2, width, height, depth);\n        texture.format = RGBAIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = \"RGBA32UI\";\n        texture.needsUpdate = true;\n        sh2Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: \"sh2\"\n        });\n        this.packedSplats.extra.sh2Texture = sh2Texture;\n      }\n      if (!this.packedSplats.extra.sh3) {\n        return { sh1Texture, sh2Texture };\n      }\n      let sh3Texture = this.packedSplats.extra.sh3Texture;\n      if (!sh3Texture) {\n        let sh3 = this.packedSplats.extra.sh3;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh3.length / 4\n        );\n        if (sh3.length < maxSplats * 4) {\n          const newSh3 = new Uint32Array(maxSplats * 4);\n          newSh3.set(sh3);\n          this.packedSplats.extra.sh3 = newSh3;\n          sh3 = newSh3;\n        }\n        const texture = new DataArrayTexture(sh3, width, height, depth);\n        texture.format = RGBAIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = \"RGBA32UI\";\n        texture.needsUpdate = true;\n        sh3Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: \"sh3\"\n        });\n        this.packedSplats.extra.sh3Texture = sh3Texture;\n      }\n      return { sh1Texture, sh2Texture, sh3Texture };\n    }\n  };\n  _SplatMesh.staticInitialized = _SplatMesh.staticInitialize();\n  _SplatMesh.isStaticInitialized = false;\n  _SplatMesh.dynoTime = new DynoFloat({ value: 0 });\n  let SplatMesh = _SplatMesh;\n  const defineEvaluateSH1 = unindent(\\`\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n      int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> 25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * (-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + sh1_2 * (-0.4886025 * viewDir.x);\n  }\n\\`);\n  const defineEvaluateSH2 = unindent(\\`\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> 24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n      int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n      int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> 24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> 24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (1.0925484 * viewDir.y * viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (1.0925484 * viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\n  }\n\\`);\n  const defineEvaluateSH3 = unindent(\\`\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // Extract sint6 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> 26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> 26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n    vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / 31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) >> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << 18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> 26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> 26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    )) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n      int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / 31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n\\`);\n  function evaluateSH1(gsplat, sh1, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh1: \"usampler2DArray\", viewDir: \"vec3\" },\n      outTypes: { rgb: \"vec3\" },\n      inputs: { gsplat, sh1, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH1],\n      statements: ({ inputs, outputs }) => {\n        const statements = unindentLines(\\`\n        if (isGsplatActive(\\${inputs.gsplat}.flags)) {\n          \\${outputs.rgb} = evaluateSH1(\\${inputs.gsplat}, \\${inputs.sh1}, \\${inputs.viewDir});\n        } else {\n          \\${outputs.rgb} = vec3(0.0);\n        }\n      \\`);\n        return statements;\n      }\n    }).outputs.rgb;\n  }\n  function evaluateSH2(gsplat, sh2, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh2: \"usampler2DArray\", viewDir: \"vec3\" },\n      outTypes: { rgb: \"vec3\" },\n      inputs: { gsplat, sh2, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH2],\n      statements: ({ inputs, outputs }) => unindentLines(\\`\n        if (isGsplatActive(\\${inputs.gsplat}.flags)) {\n          \\${outputs.rgb} = evaluateSH2(\\${inputs.gsplat}, \\${inputs.sh2}, \\${inputs.viewDir});\n        } else {\n          \\${outputs.rgb} = vec3(0.0);\n        }\n      \\`)\n    }).outputs.rgb;\n  }\n  function evaluateSH3(gsplat, sh3, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh3: \"usampler2DArray\", viewDir: \"vec3\" },\n      outTypes: { rgb: \"vec3\" },\n      inputs: { gsplat, sh3, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH3],\n      statements: ({ inputs, outputs }) => unindentLines(\\`\n        if (isGsplatActive(\\${inputs.gsplat}.flags)) {\n          \\${outputs.rgb} = evaluateSH3(\\${inputs.gsplat}, \\${inputs.sh3}, \\${inputs.viewDir});\n        } else {\n          \\${outputs.rgb} = vec3(0.0);\n        }\n      \\`)\n    }).outputs.rgb;\n  }\n  function WorkerWrapper(options) {\n    return new Worker(\n      self.location.href,\n      {\n        name: options == null ? void 0 : options.name\n      }\n    );\n  }\n  class SplatWorker {\n    constructor() {\n      this.messages = {};\n      this.messageIdNext = 0;\n      this.worker = new WorkerWrapper();\n      this.worker.onmessage = (event) => this.onMessage(event);\n    }\n    makeMessageId() {\n      return ++this.messageIdNext;\n    }\n    makeMessagePromiseId() {\n      const id = this.makeMessageId();\n      const promise = new Promise((resolve, reject) => {\n        this.messages[id] = { resolve, reject };\n      });\n      return { id, promise };\n    }\n    onMessage(event) {\n      const { id, result, error } = event.data;\n      const handler = this.messages[id];\n      if (handler) {\n        delete this.messages[id];\n        if (error) {\n          handler.reject(error);\n        } else {\n          handler.resolve(result);\n        }\n      }\n    }\n    // Invoke an RPC on the worker with the given name and arguments.\n    // The normal usage of a worker is to run one activity at a time,\n    // but this function allows for concurrent calls, tagging each request\n    // with a unique message Id and awaiting a response to that same Id.\n    // The method will automatically transfer any ArrayBuffers in the\n    // arguments to the worker. If you'd like to transfer a copy of a\n    // buffer then you must clone it before passing to this function.\n    async call(name, args) {\n      const { id, promise } = this.makeMessagePromiseId();\n      this.worker.postMessage(\n        { name, args, id },\n        { transfer: getArrayBuffers(args) }\n      );\n      return promise;\n    }\n  }\n  let maxWorkers = 4;\n  let numWorkers = 0;\n  const freeWorkers = [];\n  const workerQueue = [];\n  async function allocWorker() {\n    const worker = freeWorkers.shift();\n    if (worker) {\n      return worker;\n    }\n    if (numWorkers < maxWorkers) {\n      const worker2 = new SplatWorker();\n      numWorkers += 1;\n      return worker2;\n    }\n    return new Promise((resolve) => {\n      workerQueue.push(resolve);\n    });\n  }\n  function freeWorker(worker) {\n    if (numWorkers > maxWorkers) {\n      numWorkers -= 1;\n      return;\n    }\n    const waiter = workerQueue.shift();\n    if (waiter) {\n      waiter(worker);\n      return;\n    }\n    freeWorkers.push(worker);\n  }\n  async function withWorker(callback) {\n    const worker = await allocWorker();\n    try {\n      return await callback(worker);\n    } finally {\n      freeWorker(worker);\n    }\n  }\n  var SplatFileType = /* @__PURE__ */ ((SplatFileType2) => {\n    SplatFileType2[\"PLY\"] = \"ply\";\n    SplatFileType2[\"SPZ\"] = \"spz\";\n    SplatFileType2[\"SPLAT\"] = \"splat\";\n    SplatFileType2[\"KSPLAT\"] = \"ksplat\";\n    return SplatFileType2;\n  })(SplatFileType || {});\n  function getSplatFileType(fileBytes) {\n    const view = new DataView(fileBytes.buffer);\n    if ((view.getUint32(0, true) & 16777215) === 7957616) {\n      return \"ply\";\n    }\n    if ((view.getUint32(0, true) & 16777215) === 559903) {\n      const header = decompressPartialGzip(fileBytes, 4);\n      const gView = new DataView(header.buffer);\n      if (gView.getUint32(0, true) === 1347635022) {\n        return \"spz\";\n      }\n      return void 0;\n    }\n    return void 0;\n  }\n  function getFileExtension(pathOrUrl) {\n    const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];\n    const lastSlash = Math.max(\n      noTrailing.lastIndexOf(\"/\"),\n      noTrailing.lastIndexOf(\"\\\\\\\\\")\n    );\n    const filename = noTrailing.slice(lastSlash + 1);\n    const lastDot = filename.lastIndexOf(\".\");\n    if (lastDot <= 0 || lastDot === filename.length - 1) {\n      return \"\";\n    }\n    return filename.slice(lastDot + 1).toLowerCase();\n  }\n  function getSplatFileTypeFromPath(pathOrUrl) {\n    const extension = getFileExtension(pathOrUrl);\n    if (extension === \"ply\") {\n      return \"ply\";\n    }\n    if (extension === \"spz\") {\n      return \"spz\";\n    }\n    if (extension === \"splat\") {\n      return \"splat\";\n    }\n    if (extension === \"ksplat\") {\n      return \"ksplat\";\n    }\n    return void 0;\n  }\n  async function unpackSplats({\n    input,\n    fileType,\n    pathOrUrl\n  }) {\n    const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n    let splatFileType = fileType;\n    if (!fileType) {\n      splatFileType = getSplatFileType(fileBytes);\n      if (!splatFileType && pathOrUrl) {\n        splatFileType = getSplatFileTypeFromPath(pathOrUrl);\n      }\n    }\n    switch (splatFileType) {\n      case \"ply\": {\n        const ply = new PlyReader({ fileBytes });\n        await ply.parseHeader();\n        const numSplats = ply.numSplats;\n        const maxSplats = getTextureSize(numSplats).maxSplats;\n        const args = { fileBytes, packedArray: new Uint32Array(maxSplats * 4) };\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats: numSplats2, extra } = await worker.call(\n            \"unpackPly\",\n            args\n          );\n          return { packedArray, numSplats: numSplats2, extra };\n        });\n      }\n      case \"spz\": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats, extra } = await worker.call(\n            \"decodeSpz\",\n            {\n              fileBytes\n            }\n          );\n          return { packedArray, numSplats, extra };\n        });\n      }\n      case \"splat\": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats } = await worker.call(\n            \"decodeAntiSplat\",\n            {\n              fileBytes\n            }\n          );\n          return { packedArray, numSplats };\n        });\n      }\n      case \"ksplat\":\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats, extra } = await worker.call(\n            \"decodeKsplat\",\n            { fileBytes }\n          );\n          return { packedArray, numSplats, extra };\n        });\n      default: {\n        throw new Error(\\`Unknown splat file type: \\${splatFileType}\\`);\n      }\n    }\n  }\n  class SplatData {\n    constructor({ maxSplats = 1 } = {}) {\n      this.numSplats = 0;\n      this.maxSplats = getTextureSize(maxSplats).maxSplats;\n      this.centers = new Float32Array(this.maxSplats * 3);\n      this.scales = new Float32Array(this.maxSplats * 3);\n      this.quaternions = new Float32Array(this.maxSplats * 4);\n      this.opacities = new Float32Array(this.maxSplats);\n      this.colors = new Float32Array(this.maxSplats * 3);\n    }\n    pushSplat() {\n      const index = this.numSplats;\n      this.ensureIndex(index);\n      this.numSplats += 1;\n      return index;\n    }\n    unpushSplat(index) {\n      if (index === this.numSplats - 1) {\n        this.numSplats -= 1;\n      } else {\n        throw new Error(\"Cannot unpush splat from non-last position\");\n      }\n    }\n    ensureCapacity(numSplats) {\n      if (numSplats > this.maxSplats) {\n        const targetSplats = Math.max(numSplats, this.maxSplats * 2);\n        const newCenters = new Float32Array(targetSplats * 3);\n        const newScales = new Float32Array(targetSplats * 3);\n        const newQuaternions = new Float32Array(targetSplats * 4);\n        const newOpacities = new Float32Array(targetSplats);\n        const newColors = new Float32Array(targetSplats * 3);\n        newCenters.set(this.centers);\n        newScales.set(this.scales);\n        newQuaternions.set(this.quaternions);\n        newOpacities.set(this.opacities);\n        newColors.set(this.colors);\n        this.centers = newCenters;\n        this.scales = newScales;\n        this.quaternions = newQuaternions;\n        this.opacities = newOpacities;\n        this.colors = newColors;\n        if (this.sh1) {\n          const newSh1 = new Float32Array(targetSplats * 9);\n          newSh1.set(this.sh1);\n          this.sh1 = newSh1;\n        }\n        if (this.sh2) {\n          const newSh2 = new Float32Array(targetSplats * 15);\n          newSh2.set(this.sh2);\n          this.sh2 = newSh2;\n        }\n        if (this.sh3) {\n          const newSh3 = new Float32Array(targetSplats * 21);\n          newSh3.set(this.sh3);\n          this.sh3 = newSh3;\n        }\n        this.maxSplats = targetSplats;\n      }\n    }\n    ensureIndex(index) {\n      this.ensureCapacity(index + 1);\n    }\n    setCenter(index, x2, y, z) {\n      this.centers[index * 3] = x2;\n      this.centers[index * 3 + 1] = y;\n      this.centers[index * 3 + 2] = z;\n    }\n    setScale(index, scaleX, scaleY, scaleZ) {\n      this.scales[index * 3] = scaleX;\n      this.scales[index * 3 + 1] = scaleY;\n      this.scales[index * 3 + 2] = scaleZ;\n    }\n    setQuaternion(index, x2, y, z, w) {\n      this.quaternions[index * 4] = x2;\n      this.quaternions[index * 4 + 1] = y;\n      this.quaternions[index * 4 + 2] = z;\n      this.quaternions[index * 4 + 3] = w;\n    }\n    setOpacity(index, opacity) {\n      this.opacities[index] = opacity;\n    }\n    setColor(index, r, g, b) {\n      this.colors[index * 3] = r;\n      this.colors[index * 3 + 1] = g;\n      this.colors[index * 3 + 2] = b;\n    }\n    setSh1(index, sh1) {\n      if (!this.sh1) {\n        this.sh1 = new Float32Array(this.maxSplats * 9);\n      }\n      for (let j = 0; j < 9; ++j) {\n        this.sh1[index * 9 + j] = sh1[j];\n      }\n    }\n    setSh2(index, sh2) {\n      if (!this.sh2) {\n        this.sh2 = new Float32Array(this.maxSplats * 15);\n      }\n      for (let j = 0; j < 15; ++j) {\n        this.sh2[index * 15 + j] = sh2[j];\n      }\n    }\n    setSh3(index, sh3) {\n      if (!this.sh3) {\n        this.sh3 = new Float32Array(this.maxSplats * 21);\n      }\n      for (let j = 0; j < 21; ++j) {\n        this.sh3[index * 21 + j] = sh3[j];\n      }\n    }\n  }\n  class SpzReader {\n    constructor({ fileBytes }) {\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n      this.reader = new GunzipReader({ fileBytes: this.fileBytes });\n      const header = new DataView(this.reader.read(16).buffer);\n      if (header.getUint32(0, true) !== 1347635022) {\n        throw new Error(\"Invalid SPZ file\");\n      }\n      this.version = header.getUint32(4, true);\n      if (this.version < 1 || this.version > 2) {\n        throw new Error(\\`Unsupported SPZ version: \\${this.version}\\`);\n      }\n      this.numSplats = header.getUint32(8, true);\n      this.shDegree = header.getUint8(12);\n      this.fractionalBits = header.getUint8(13);\n      this.flags = header.getUint8(14);\n      this.flagAntiAlias = (this.flags & 1) !== 0;\n      this.reserved = header.getUint8(15);\n      this.parsed = false;\n    }\n    parseSplats(centerCallback, alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback) {\n      if (this.parsed) {\n        throw new Error(\"SPZ file already parsed\");\n      }\n      this.parsed = true;\n      if (this.version === 1) {\n        const centerBytes = this.reader.read(this.numSplats * 3 * 2);\n        const centerUint16 = new Uint16Array(centerBytes.buffer);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const x2 = fromHalf(centerUint16[i3]);\n          const y = fromHalf(centerUint16[i3 + 1]);\n          const z = fromHalf(centerUint16[i3 + 2]);\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\n        }\n      } else if (this.version === 2) {\n        const fixed = 1 << this.fractionalBits;\n        const centerBytes = this.reader.read(this.numSplats * 3 * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i9 = i2 * 9;\n          const x2 = ((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << 8) >> 8) / fixed;\n          const y = ((centerBytes[i9 + 5] << 24 | centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;\n          const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | centerBytes[i9 + 6] << 8) >> 8) / fixed;\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\n        }\n      } else {\n        throw new Error(\"Unreachable\");\n      }\n      {\n        const bytes = this.reader.read(this.numSplats);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          alphaCallback == null ? void 0 : alphaCallback(i2, bytes[i2] / 255);\n        }\n      }\n      {\n        const rgbBytes = this.reader.read(this.numSplats * 3);\n        const scale = SH_C0 / 0.15;\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;\n          const g = (rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;\n          const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + 0.5;\n          rgbCallback == null ? void 0 : rgbCallback(i2, r, g, b);\n        }\n      }\n      {\n        const scalesBytes = this.reader.read(this.numSplats * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const scaleX = Math.exp(scalesBytes[i3] / 16 - 10);\n          const scaleY = Math.exp(scalesBytes[i3 + 1] / 16 - 10);\n          const scaleZ = Math.exp(scalesBytes[i3 + 2] / 16 - 10);\n          scalesCallback == null ? void 0 : scalesCallback(i2, scaleX, scaleY, scaleZ);\n        }\n      }\n      {\n        const quatBytes = this.reader.read(this.numSplats * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const quatX = quatBytes[i3] / 127.5 - 1;\n          const quatY = quatBytes[i3 + 1] / 127.5 - 1;\n          const quatZ = quatBytes[i3 + 2] / 127.5 - 1;\n          const quatW = Math.sqrt(\n            Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)\n          );\n          quatCallback == null ? void 0 : quatCallback(i2, quatX, quatY, quatZ, quatW);\n        }\n      }\n      if (shCallback && this.shDegree >= 1) {\n        const sh1 = new Float32Array(3 * 3);\n        const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n        const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n        const shBytes = this.reader.read(\n          this.numSplats * SH_DEGREE_TO_VECS[this.shDegree] * 3\n        );\n        let offset = 0;\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          for (let j = 0; j < 9; ++j) {\n            sh1[j] = (shBytes[offset + j] - 128) / 128;\n          }\n          offset += 9;\n          if (sh2) {\n            for (let j = 0; j < 15; ++j) {\n              sh2[j] = (shBytes[offset + j] - 128) / 128;\n            }\n            offset += 15;\n          }\n          if (sh3) {\n            for (let j = 0; j < 21; ++j) {\n              sh3[j] = (shBytes[offset + j] - 128) / 128;\n            }\n            offset += 21;\n          }\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\n        }\n      }\n    }\n  }\n  const SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };\n  const SH_C0 = 0.28209479177387814;\n  const SPZ_MAGIC = 1347635022;\n  const SPZ_VERSION = 2;\n  const FLAG_ANTIALIASED = 1;\n  class SpzWriter {\n    constructor({\n      numSplats,\n      shDegree,\n      fractionalBits = 12,\n      flagAntiAlias = true\n    }) {\n      this.clippedCount = 0;\n      const splatSize = 9 + 1 + 3 + 3 + 3 + (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);\n      const bufferSize = 16 + numSplats * splatSize;\n      this.buffer = new ArrayBuffer(bufferSize);\n      this.view = new DataView(this.buffer);\n      this.view.setUint32(0, SPZ_MAGIC, true);\n      this.view.setUint32(4, SPZ_VERSION, true);\n      this.view.setUint32(8, numSplats, true);\n      this.view.setUint8(12, shDegree);\n      this.view.setUint8(13, fractionalBits);\n      this.view.setUint8(14, flagAntiAlias ? FLAG_ANTIALIASED : 0);\n      this.view.setUint8(15, 0);\n      this.numSplats = numSplats;\n      this.shDegree = shDegree;\n      this.fractionalBits = fractionalBits;\n      this.fraction = 1 << fractionalBits;\n      this.flagAntiAlias = flagAntiAlias;\n    }\n    setCenter(index, x2, y, z) {\n      const xRounded = Math.round(x2 * this.fraction);\n      const xInt = Math.max(-8388607, Math.min(8388607, xRounded));\n      const yRounded = Math.round(y * this.fraction);\n      const yInt = Math.max(-8388607, Math.min(8388607, yRounded));\n      const zRounded = Math.round(z * this.fraction);\n      const zInt = Math.max(-8388607, Math.min(8388607, zRounded));\n      const clipped = xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;\n      if (clipped) {\n        this.clippedCount += 1;\n      }\n      const i9 = index * 9;\n      const base = 16 + i9;\n      this.view.setUint8(base, xInt & 255);\n      this.view.setUint8(base + 1, xInt >> 8 & 255);\n      this.view.setUint8(base + 2, xInt >> 16 & 255);\n      this.view.setUint8(base + 3, yInt & 255);\n      this.view.setUint8(base + 4, yInt >> 8 & 255);\n      this.view.setUint8(base + 5, yInt >> 16 & 255);\n      this.view.setUint8(base + 6, zInt & 255);\n      this.view.setUint8(base + 7, zInt >> 8 & 255);\n      this.view.setUint8(base + 8, zInt >> 16 & 255);\n    }\n    setAlpha(index, alpha) {\n      const base = 16 + this.numSplats * 9 + index;\n      this.view.setUint8(\n        base,\n        Math.max(0, Math.min(255, Math.round(alpha * 255)))\n      );\n    }\n    static scaleRgb(r) {\n      const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;\n      return Math.max(0, Math.min(255, Math.round(v)));\n    }\n    setRgb(index, r, g, b) {\n      const base = 16 + this.numSplats * 10 + index * 3;\n      this.view.setUint8(base, SpzWriter.scaleRgb(r));\n      this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));\n      this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));\n    }\n    setScale(index, scaleX, scaleY, scaleZ) {\n      const base = 16 + this.numSplats * 13 + index * 3;\n      this.view.setUint8(\n        base,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) * 16)))\n      );\n      this.view.setUint8(\n        base + 1,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))\n      );\n      this.view.setUint8(\n        base + 2,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))\n      );\n    }\n    setQuat(index, quatX, quatY, quatZ, quatW) {\n      const base = 16 + this.numSplats * 16 + index * 3;\n      const quatNeg = quatW < 0;\n      this.view.setUint8(\n        base,\n        Math.max(\n          0,\n          Math.min(255, Math.round(((quatNeg ? -quatX : quatX) + 1) * 127.5))\n        )\n      );\n      this.view.setUint8(\n        base + 1,\n        Math.max(\n          0,\n          Math.min(255, Math.round(((quatNeg ? -quatY : quatY) + 1) * 127.5))\n        )\n      );\n      this.view.setUint8(\n        base + 2,\n        Math.max(\n          0,\n          Math.min(255, Math.round(((quatNeg ? -quatZ : quatZ) + 1) * 127.5))\n        )\n      );\n    }\n    static quantizeSh(sh, bits2) {\n      const value = Math.round(sh * 128) + 128;\n      const bucketSize = 1 << 8 - bits2;\n      const quantized = Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;\n      return Math.max(0, Math.min(255, quantized));\n    }\n    setSh(index, sh1, sh2, sh3) {\n      const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;\n      const base1 = 16 + this.numSplats * 19 + index * shVecs * 3;\n      for (let j = 0; j < 9; ++j) {\n        this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));\n      }\n      if (sh2) {\n        const base2 = base1 + 9;\n        for (let j = 0; j < 15; ++j) {\n          this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));\n        }\n        if (sh3) {\n          const base3 = base2 + 15;\n          for (let j = 0; j < 21; ++j) {\n            this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));\n          }\n        }\n      }\n    }\n    async finalize() {\n      const input = new Uint8Array(this.buffer);\n      const stream = new ReadableStream({\n        async start(controller) {\n          controller.enqueue(input);\n          controller.close();\n        }\n      });\n      const compressed = stream.pipeThrough(new CompressionStream(\"gzip\"));\n      const response = new Response(compressed);\n      const buffer = await response.arrayBuffer();\n      console.log(\n        \"Compressed\",\n        input.length,\n        \"bytes to\",\n        buffer.byteLength,\n        \"bytes\"\n      );\n      return new Uint8Array(buffer);\n    }\n  }\n  async function transcodeSpz(input) {\n    var _a2, _b2, _c;\n    const splats = new SplatData();\n    const {\n      inputs,\n      clipXyz,\n      maxSh,\n      fractionalBits = 12,\n      opacityThreshold\n    } = input;\n    for (const input2 of inputs) {\n      let transformPos2 = function(pos) {\n        pos.multiplyScalar(scale);\n        pos.applyQuaternion(quaternion);\n        pos.add(translate);\n        return pos;\n      }, transformScales = function(scales) {\n        scales.multiplyScalar(scale);\n        return scales;\n      }, transformQuaternion = function(quat) {\n        quat.premultiply(quaternion);\n        return quat;\n      }, withinClip = function(p) {\n        return !clip || clip.containsPoint(p);\n      }, withinOpacity = function(opacity) {\n        return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;\n      };\n      const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;\n      const quaternion = new Quaternion().fromArray(\n        ((_b2 = input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]\n      );\n      const translate = new Vector3().fromArray(\n        ((_c = input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]\n      );\n      const clip = clipXyz ? new Box3(\n        new Vector3().fromArray(clipXyz.min),\n        new Vector3().fromArray(clipXyz.max)\n      ) : void 0;\n      let fileType = input2.fileType;\n      if (!fileType) {\n        fileType = getSplatFileType(input2.fileBytes);\n        if (!fileType && input2.pathOrUrl) {\n          fileType = getSplatFileTypeFromPath(input2.pathOrUrl);\n        }\n      }\n      switch (fileType) {\n        case SplatFileType.PLY: {\n          const ply = new PlyReader({ fileBytes: input2.fileBytes });\n          await ply.parseHeader();\n          let lastIndex = null;\n          ply.parseSplats(\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                lastIndex = splats.pushSplat();\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  lastIndex,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(lastIndex, opacity);\n                splats.setColor(lastIndex, r, g, b);\n              } else {\n                lastIndex = null;\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (sh1 && lastIndex !== null) {\n                splats.setSh1(lastIndex, sh1);\n              }\n              if (sh2 && lastIndex !== null) {\n                splats.setSh2(lastIndex, sh2);\n              }\n              if (sh3 && lastIndex !== null) {\n                splats.setSh3(lastIndex, sh3);\n              }\n            }\n          );\n          break;\n        }\n        case SplatFileType.SPZ: {\n          const spz2 = new SpzReader({ fileBytes: input2.fileBytes });\n          const mapping = new Int32Array(spz2.numSplats);\n          mapping.fill(-1);\n          const centers = new Float32Array(spz2.numSplats * 3);\n          const center = new Vector3();\n          spz2.parseSplats(\n            (index, x2, y, z) => {\n              const center2 = transformPos2(new Vector3(x2, y, z));\n              centers[index * 3] = center2.x;\n              centers[index * 3 + 1] = center2.y;\n              centers[index * 3 + 2] = center2.z;\n            },\n            (index, alpha) => {\n              center.fromArray(centers, index * 3);\n              if (withinClip(center) && withinOpacity(alpha)) {\n                mapping[index] = splats.pushSplat();\n                splats.setCenter(mapping[index], center.x, center.y, center.z);\n                splats.setOpacity(mapping[index], alpha);\n              }\n            },\n            (index, r, g, b) => {\n              if (mapping[index] >= 0) {\n                splats.setColor(mapping[index], r, g, b);\n              }\n            },\n            (index, scaleX, scaleY, scaleZ) => {\n              if (mapping[index] >= 0) {\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(mapping[index], scales.x, scales.y, scales.z);\n              }\n            },\n            (index, quatX, quatY, quatZ, quatW) => {\n              if (mapping[index] >= 0) {\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  mapping[index],\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (mapping[index] >= 0) {\n                splats.setSh1(mapping[index], sh1);\n                if (sh2) {\n                  splats.setSh2(mapping[index], sh2);\n                }\n                if (sh3) {\n                  splats.setSh3(mapping[index], sh3);\n                }\n              }\n            }\n          );\n          break;\n        }\n        case SplatFileType.SPLAT:\n          decodeAntiSplat(\n            input2.fileBytes,\n            (numSplats) => {\n            },\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                const index2 = splats.pushSplat();\n                splats.setCenter(index2, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(index2, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  index2,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(index2, opacity);\n                splats.setColor(index2, r, g, b);\n              }\n            }\n          );\n          break;\n        case SplatFileType.KSPLAT: {\n          let lastIndex = null;\n          decodeKsplat(\n            input2.fileBytes,\n            (numSplats) => {\n            },\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                lastIndex = splats.pushSplat();\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  lastIndex,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(lastIndex, opacity);\n                splats.setColor(lastIndex, r, g, b);\n              } else {\n                lastIndex = null;\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (lastIndex !== null) {\n                splats.setSh1(lastIndex, sh1);\n                if (sh2) {\n                  splats.setSh2(lastIndex, sh2);\n                }\n                if (sh3) {\n                  splats.setSh3(lastIndex, sh3);\n                }\n              }\n            }\n          );\n          break;\n        }\n        default:\n          throw new Error(\\`transcodeSpz not implemented for \\${fileType}\\`);\n      }\n    }\n    const shDegree = Math.min(\n      maxSh ?? 3,\n      splats.sh3 ? 3 : splats.sh2 ? 2 : splats.sh1 ? 1 : 0\n    );\n    const spz = new SpzWriter({\n      numSplats: splats.numSplats,\n      shDegree,\n      fractionalBits,\n      flagAntiAlias: true\n    });\n    for (let i2 = 0; i2 < splats.numSplats; ++i2) {\n      const i3 = i2 * 3;\n      const i4 = i2 * 4;\n      spz.setCenter(\n        i2,\n        splats.centers[i3],\n        splats.centers[i3 + 1],\n        splats.centers[i3 + 2]\n      );\n      spz.setScale(\n        i2,\n        splats.scales[i3],\n        splats.scales[i3 + 1],\n        splats.scales[i3 + 2]\n      );\n      spz.setQuat(\n        i2,\n        splats.quaternions[i4],\n        splats.quaternions[i4 + 1],\n        splats.quaternions[i4 + 2],\n        splats.quaternions[i4 + 3]\n      );\n      spz.setAlpha(i2, splats.opacities[i2]);\n      spz.setRgb(\n        i2,\n        splats.colors[i3],\n        splats.colors[i3 + 1],\n        splats.colors[i3 + 2]\n      );\n      if (splats.sh1 && shDegree >= 1) {\n        spz.setSh(\n          i2,\n          splats.sh1.slice(i2 * 9, (i2 + 1) * 9),\n          shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i2 * 15, (i2 + 1) * 15) : void 0,\n          shDegree >= 3 && splats.sh3 ? splats.sh3.slice(i2 * 21, (i2 + 1) * 21) : void 0\n        );\n      }\n    }\n    const spzBytes = await spz.finalize();\n    return { fileBytes: spzBytes, clippedCount: spz.clippedCount };\n  }\n  async function onMessage(event) {\n    const { name, args, id } = event.data;\n    let result = void 0;\n    let error = void 0;\n    try {\n      switch (name) {\n        case \"unpackPly\": {\n          const { packedArray, fileBytes } = args;\n          const decoded = await unpackPly({ packedArray, fileBytes });\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case \"decodeSpz\": {\n          const { fileBytes } = args;\n          const decoded = unpackSpz(fileBytes);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case \"decodeAntiSplat\": {\n          const { fileBytes } = args;\n          const decoded = unpackAntiSplat(fileBytes);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray\n          };\n          break;\n        }\n        case \"decodeKsplat\": {\n          const { fileBytes } = args;\n          const decoded = unpackKsplat(fileBytes);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case \"sortSplats\": {\n          const { maxSplats, totalSplats, readback, ordering } = args;\n          result = {\n            id,\n            readback,\n            ...sortSplats({ totalSplats, readback, ordering })\n          };\n          break;\n        }\n        case \"sortDoubleSplats\": {\n          const { numSplats, readback, ordering } = args;\n          result = {\n            id,\n            readback,\n            ordering\n          };\n          if (WASM_SPLAT_SORT) {\n            result = {\n              id,\n              readback,\n              ordering,\n              activeSplats: sort_splats(numSplats, readback, ordering)\n            };\n          }\n          break;\n        }\n        case \"transcodeSpz\": {\n          const input = args;\n          const spzBytes = await transcodeSpz(input);\n          result = {\n            id,\n            fileBytes: spzBytes,\n            input\n          };\n          break;\n        }\n        default: {\n          throw new Error(\\`Unknown name: \\${name}\\`);\n        }\n      }\n    } catch (e) {\n      error = e;\n    }\n    self.postMessage(\n      { id, result, error },\n      { transfer: getArrayBuffers(result) }\n    );\n  }\n  async function unpackPly({\n    packedArray,\n    fileBytes\n  }) {\n    const ply = new PlyReader({ fileBytes });\n    await ply.parseHeader();\n    const numSplats = ply.numSplats;\n    const extra = {};\n    const ZERO_CUTOFF = Math.exp(-20);\n    ply.parseSplats(\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n        setPackedSplat(\n          packedArray,\n          index,\n          x2,\n          y,\n          z,\n          scaleX < ZERO_CUTOFF ? 0 : Math.max(SCALE_MIN, scaleX),\n          scaleY < ZERO_CUTOFF ? 0 : Math.max(SCALE_MIN, scaleY),\n          scaleZ < ZERO_CUTOFF ? 0 : Math.max(SCALE_MIN, scaleZ),\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n      },\n      (index, sh1, sh2, sh3) => {\n        if (sh1) {\n          if (!extra.sh1) {\n            extra.sh1 = new Uint32Array(numSplats * 2);\n          }\n          encodeSh1Rgb(extra.sh1, index, sh1);\n        }\n        if (sh2) {\n          if (!extra.sh2) {\n            extra.sh2 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh2Rgb(extra.sh2, index, sh2);\n        }\n        if (sh3) {\n          if (!extra.sh3) {\n            extra.sh3 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh3Rgb(extra.sh3, index, sh3);\n        }\n      }\n    );\n    return { packedArray, numSplats, extra };\n  }\n  function unpackSpz(fileBytes) {\n    const spz = new SpzReader({ fileBytes });\n    const numSplats = spz.numSplats;\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    spz.parseSplats(\n      (index, x2, y, z) => {\n        setPackedSplatCenter(packedArray, index, x2, y, z);\n      },\n      (index, alpha) => {\n        setPackedSplatOpacity(packedArray, index, alpha);\n      },\n      (index, r, g, b) => {\n        setPackedSplatRgb(packedArray, index, r, g, b);\n      },\n      (index, scaleX, scaleY, scaleZ) => {\n        setPackedSplatScales(packedArray, index, scaleX, scaleY, scaleZ);\n      },\n      (index, quatX, quatY, quatZ, quatW) => {\n        setPackedSplatQuat(packedArray, index, quatX, quatY, quatZ, quatW);\n      },\n      (index, sh1, sh2, sh3) => {\n        if (sh1) {\n          if (!extra.sh1) {\n            extra.sh1 = new Uint32Array(numSplats * 2);\n          }\n          encodeSh1Rgb(extra.sh1, index, sh1);\n        }\n        if (sh2) {\n          if (!extra.sh2) {\n            extra.sh2 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh2Rgb(extra.sh2, index, sh2);\n        }\n        if (sh3) {\n          if (!extra.sh3) {\n            extra.sh3 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh3Rgb(extra.sh3, index, sh3);\n        }\n      }\n    );\n    return { packedArray, numSplats, extra };\n  }\n  const DEPTH_INFINITY = 31744;\n  const DEPTH_SIZE = DEPTH_INFINITY + 1;\n  let depthArray = null;\n  function sortSplats({\n    totalSplats,\n    readback,\n    ordering\n  }) {\n    if (!depthArray) {\n      depthArray = new Uint32Array(DEPTH_SIZE);\n    }\n    depthArray.fill(0);\n    const readbackUint32 = readback.map((layer) => new Uint32Array(layer.buffer));\n    const layerSize = readbackUint32[0].length;\n    const numLayers = Math.ceil(totalSplats / layerSize);\n    let layerBase = 0;\n    for (let layer = 0; layer < numLayers; ++layer) {\n      const readbackLayer = readbackUint32[layer];\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\n        const pri = readbackLayer[i2] & 32767;\n        if (pri < DEPTH_INFINITY) {\n          depthArray[pri] += 1;\n        }\n      }\n      layerBase += layerSplats;\n    }\n    let activeSplats = 0;\n    for (let j = 0; j < DEPTH_SIZE; ++j) {\n      const nextIndex = activeSplats + depthArray[j];\n      depthArray[j] = activeSplats;\n      activeSplats = nextIndex;\n    }\n    layerBase = 0;\n    for (let layer = 0; layer < numLayers; ++layer) {\n      const readbackLayer = readbackUint32[layer];\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\n        const pri = readbackLayer[i2] & 32767;\n        if (pri < DEPTH_INFINITY) {\n          ordering[depthArray[pri]] = layerBase + i2;\n          depthArray[pri] += 1;\n        }\n      }\n      layerBase += layerSplats;\n    }\n    if (depthArray[DEPTH_SIZE - 1] !== activeSplats) {\n      throw new Error(\n        \\`Expected \\${activeSplats} active splats but got \\${depthArray[DEPTH_SIZE - 1]}\\`\n      );\n    }\n    return { activeSplats, ordering };\n  }\n  function sortDoubleSplats({\n    numSplats,\n    readback,\n    ordering\n  }) {\n    if (!depthArray) {\n      depthArray = new Uint32Array(DEPTH_SIZE);\n    }\n    depthArray.fill(0);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const pri = readback[i2];\n      if (pri < DEPTH_INFINITY) {\n        depthArray[pri] += 1;\n      }\n    }\n    let activeSplats = 0;\n    for (let j = DEPTH_INFINITY - 1; j >= 0; --j) {\n      const nextIndex = activeSplats + depthArray[j];\n      depthArray[j] = activeSplats;\n      activeSplats = nextIndex;\n    }\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const pri = readback[i2];\n      if (pri < DEPTH_INFINITY) {\n        ordering[depthArray[pri]] = i2;\n        depthArray[pri] += 1;\n      }\n    }\n    if (depthArray[0] !== activeSplats) {\n      throw new Error(\n        \\`Expected \\${activeSplats} active splats but got \\${depthArray[0]}\\`\n      );\n    }\n    return { activeSplats, ordering };\n  }\n  const messageBuffer = [];\n  function bufferMessage(event) {\n    messageBuffer.push(event);\n  }\n  async function initialize() {\n    self.addEventListener(\"message\", bufferMessage);\n    await __wbg_init();\n    self.removeEventListener(\"message\", bufferMessage);\n    self.addEventListener(\"message\", onMessage);\n    for (const event of messageBuffer) {\n      onMessage(event);\n    }\n    messageBuffer.length = 0;\n  }\n  initialize().catch(console.error);\n})();\n//# sourceMappingURL=worker-Do1mGyaZ.js.map\n`, jn = typeof self < \"u\" && self.Blob && new Blob([bt], { type: \"text/javascript;charset=utf-8\" });\nfunction Ts(e) {\n  let A;\n  try {\n    if (A = jn && (self.URL || self.webkitURL).createObjectURL(jn), !A) throw \"\";\n    const n = new Worker(A, {\n      name: e == null ? void 0 : e.name\n    });\n    return n.addEventListener(\"error\", () => {\n      (self.URL || self.webkitURL).revokeObjectURL(A);\n    }), n;\n  } catch {\n    return new Worker(\n      \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(bt),\n      {\n        name: e == null ? void 0 : e.name\n      }\n    );\n  } finally {\n    A && (self.URL || self.webkitURL).revokeObjectURL(A);\n  }\n}\nclass Js {\n  constructor() {\n    this.messages = {}, this.messageIdNext = 0, this.worker = new Ts(), this.worker.onmessage = (A) => this.onMessage(A);\n  }\n  makeMessageId() {\n    return ++this.messageIdNext;\n  }\n  makeMessagePromiseId() {\n    const A = this.makeMessageId(), n = new Promise((t, s) => {\n      this.messages[A] = { resolve: t, reject: s };\n    });\n    return { id: A, promise: n };\n  }\n  onMessage(A) {\n    const { id: n, result: t, error: s } = A.data, i = this.messages[n];\n    i && (delete this.messages[n], s ? i.reject(s) : i.resolve(t));\n  }\n  // Invoke an RPC on the worker with the given name and arguments.\n  // The normal usage of a worker is to run one activity at a time,\n  // but this function allows for concurrent calls, tagging each request\n  // with a unique message Id and awaiting a response to that same Id.\n  // The method will automatically transfer any ArrayBuffers in the\n  // arguments to the worker. If you'd like to transfer a copy of a\n  // buffer then you must clone it before passing to this function.\n  async call(A, n) {\n    const { id: t, promise: s } = this.makeMessagePromiseId();\n    return this.worker.postMessage(\n      { name: A, args: n, id: t },\n      { transfer: Ye(n) }\n    ), s;\n  }\n}\nlet Mt = 4, Qn = 0;\nconst Ft = [], Nt = [];\nasync function Hs() {\n  const e = Ft.shift();\n  if (e)\n    return e;\n  if (Qn < Mt) {\n    const A = new Js();\n    return Qn += 1, A;\n  }\n  return new Promise((A) => {\n    Nt.push(A);\n  });\n}\nfunction qs(e) {\n  if (Qn > Mt) {\n    Qn -= 1;\n    return;\n  }\n  const A = Nt.shift();\n  if (A) {\n    A(e);\n    return;\n  }\n  Ft.push(e);\n}\nasync function qA(e) {\n  const A = await Hs();\n  try {\n    return await e(A);\n  } finally {\n    qs(A);\n  }\n}\nfunction zs(e) {\n  const A = new DataView(e.buffer);\n  if ((A.getUint32(0, !0) & 16777215) === 7957616)\n    return \"ply\";\n  if ((A.getUint32(0, !0) & 16777215) === 559903) {\n    const n = $e(e, 4);\n    return new DataView(n.buffer).getUint32(0, !0) === 1347635022 ? \"spz\" : void 0;\n  }\n}\nfunction Ks(e) {\n  const A = e.split(/[?#]/, 1)[0], n = Math.max(\n    A.lastIndexOf(\"/\"),\n    A.lastIndexOf(\"\\\\\")\n  ), t = A.slice(n + 1), s = t.lastIndexOf(\".\");\n  return s <= 0 || s === t.length - 1 ? \"\" : t.slice(s + 1).toLowerCase();\n}\nfunction Ps(e) {\n  const A = Ks(e);\n  if (A === \"ply\")\n    return \"ply\";\n  if (A === \"spz\")\n    return \"spz\";\n  if (A === \"splat\")\n    return \"splat\";\n  if (A === \"ksplat\")\n    return \"ksplat\";\n}\nasync function Os({\n  input: e,\n  fileType: A,\n  pathOrUrl: n\n}) {\n  const t = e instanceof ArrayBuffer ? new Uint8Array(e) : e;\n  let s = A;\n  switch (A || (s = zs(t), !s && n && (s = Ps(n))), s) {\n    case \"ply\": {\n      const i = new Ls({ fileBytes: t });\n      await i.parseHeader();\n      const a = i.numSplats, r = W(a).maxSplats, I = { fileBytes: t, packedArray: new Uint32Array(r * 4) };\n      return await qA(async (g) => {\n        const { packedArray: Q, numSplats: o, extra: c } = await g.call(\n          \"unpackPly\",\n          I\n        );\n        return { packedArray: Q, numSplats: o, extra: c };\n      });\n    }\n    case \"spz\":\n      return await qA(async (i) => {\n        const { packedArray: a, numSplats: r, extra: I } = await i.call(\n          \"decodeSpz\",\n          {\n            fileBytes: t\n          }\n        );\n        return { packedArray: a, numSplats: r, extra: I };\n      });\n    case \"splat\":\n      return await qA(async (i) => {\n        const { packedArray: a, numSplats: r } = await i.call(\n          \"decodeAntiSplat\",\n          {\n            fileBytes: t\n          }\n        );\n        return { packedArray: a, numSplats: r };\n      });\n    case \"ksplat\":\n      return await qA(async (i) => {\n        const { packedArray: a, numSplats: r, extra: I } = await i.call(\n          \"decodeKsplat\",\n          { fileBytes: t }\n        );\n        return { packedArray: a, numSplats: r, extra: I };\n      });\n    default:\n      throw new Error(`Unknown splat file type: ${s}`);\n  }\n}\nvar Vs = `precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout uvec4 target;\n\n{{ GLOBALS }}\n\nvoid produceSplat(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        produceSplat(index);\n    } else {\n        target = uvec4(0u, 0u, 0u, 0u);\n    }\n}`;\nconst IA = class L {\n  constructor(A = {}) {\n    this.maxSplats = 0, this.numSplats = 0, this.packedArray = null, this.isInitialized = !1, this.target = null, this.source = null, this.needsUpdate = !0, this.extra = {}, this.dyno = new _n({ packedSplats: this }), this.initialized = Promise.resolve(this), this.reinitialize(A);\n  }\n  reinitialize(A) {\n    this.isInitialized = !1, A.url || A.fileBytes || A.construct ? this.initialized = this.asyncInitialize(A).then(() => (this.isInitialized = !0, this)) : (this.initialize(A), this.isInitialized = !0, this.initialized = Promise.resolve(this));\n  }\n  initialize(A) {\n    A.packedArray ? (this.packedArray = A.packedArray, this.maxSplats = Math.floor(this.packedArray.length / 4), this.maxSplats = Math.floor(this.maxSplats / S) * S, this.numSplats = Math.min(\n      this.maxSplats,\n      A.numSplats ?? Number.POSITIVE_INFINITY\n    )) : (this.maxSplats = A.maxSplats ?? 0, this.numSplats = 0), this.extra = A.extra ?? {};\n  }\n  async asyncInitialize(A) {\n    let { url: n, fileBytes: t, construct: s } = A;\n    if (n && (t = await fetch(n).then(async (i) => {\n      if (!i.ok)\n        throw new Error(\n          `${i.status} \"${i.statusText}\" fetching URL: ${n}`\n        );\n      return await i.arrayBuffer();\n    })), t) {\n      const i = await Os({\n        input: t,\n        fileType: A.fileType,\n        pathOrUrl: A.fileName ?? n\n      });\n      this.initialize(i);\n    }\n    if (s) {\n      const i = s(this);\n      i instanceof Promise && await i;\n    }\n  }\n  // Call this when you are finished with the PackedSplats and want to free\n  // any buffers it holds.\n  dispose() {\n    this.target && (this.target.dispose(), this.target = null), this.source && (this.source.dispose(), this.source = null);\n  }\n  // Ensures that this.packedArray can fit numSplats Gsplats. If it's too small,\n  // resize exponentially and copy over the original data.\n  //\n  // Typically you don't need to call this, because calling this.setSplat(index, ...)\n  // and this.pushSplat(...) will automatically call ensureSplats() so we have\n  // enough splats.\n  ensureSplats(A) {\n    const n = A <= this.maxSplats ? this.maxSplats : (\n      // Grow exponentially to avoid frequent reallocations\n      Math.max(A, 2 * this.maxSplats)\n    ), t = this.packedArray ? this.packedArray.length / 4 : 0;\n    if (!this.packedArray || n > t) {\n      this.maxSplats = W(n).maxSplats;\n      const s = new Uint32Array(this.maxSplats * 4);\n      this.packedArray && s.set(this.packedArray), this.packedArray = s;\n    }\n    return this.packedArray;\n  }\n  // Ensure the extra array for the given level is large enough to hold numSplats\n  ensureSplatsSh(A, n) {\n    let t, s;\n    if (A === 0)\n      return this.ensureSplats(n);\n    if (A === 1)\n      t = 2, s = \"sh1\";\n    else if (A === 2)\n      t = 4, s = \"sh2\";\n    else if (A === 3)\n      t = 4, s = \"sh3\";\n    else\n      throw new Error(`Invalid level: ${A}`);\n    let i = this.extra[s] ? this.extra[s].length / t : 0;\n    const a = n <= i ? i : Math.max(n, 2 * i);\n    if (!this.extra[s] || a > i) {\n      i = W(a).maxSplats;\n      const r = new Uint32Array(i * t);\n      this.extra[s] && r.set(this.extra[s]), this.extra[s] = r;\n    }\n    return this.extra[s];\n  }\n  // Unpack the 16-byte Gsplat data at index into the Three.js components\n  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n  // opacity: number 0..1, color: THREE.Color 0..1.\n  getSplat(A) {\n    if (!this.packedArray || A >= this.numSplats)\n      throw new Error(\"Invalid index\");\n    return Kn(this.packedArray, A);\n  }\n  // Set all PackedSplat components at index with the provided Gsplat attributes\n  // (can be the same objects returned by getSplat). Ensures there is capacity\n  // for at least index+1 Gsplats.\n  setSplat(A, n, t, s, i, a) {\n    const r = this.ensureSplats(A + 1);\n    zn(\n      r,\n      A,\n      n.x,\n      n.y,\n      n.z,\n      t.x,\n      t.y,\n      t.z,\n      s.x,\n      s.y,\n      s.z,\n      s.w,\n      i,\n      a.r,\n      a.g,\n      a.b\n    ), this.numSplats = Math.max(this.numSplats, A + 1);\n  }\n  // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on\n  // construction where you just want to iterate and create a collection of Gsplats.\n  pushSplat(A, n, t, s, i) {\n    const a = this.ensureSplats(this.numSplats + 1);\n    zn(\n      a,\n      this.numSplats,\n      A.x,\n      A.y,\n      A.z,\n      n.x,\n      n.y,\n      n.z,\n      t.x,\n      t.y,\n      t.z,\n      t.w,\n      s,\n      i.r,\n      i.g,\n      i.b\n    ), ++this.numSplats;\n  }\n  // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat\n  // and invoke the callback function with the Gsplat attributes.\n  forEachSplat(A) {\n    if (!(!this.packedArray || !this.numSplats))\n      for (let n = 0; n < this.numSplats; ++n) {\n        const t = Kn(this.packedArray, n);\n        A(\n          n,\n          t.center,\n          t.scales,\n          t.quaternion,\n          t.opacity,\n          t.color\n        );\n      }\n  }\n  // Ensures our PackedSplats.target render target has enough space to generate\n  // maxSplats total Gsplats, and reallocate if not large enough.\n  ensureGenerate(A) {\n    if (this.target && (A ?? 1) <= this.maxSplats)\n      return !1;\n    this.dispose();\n    const n = W(A ?? 1), { width: t, height: s, depth: i } = n;\n    return this.maxSplats = n.maxSplats, this.target = new B.WebGLArrayRenderTarget(t, s, i, {\n      depthBuffer: !1,\n      stencilBuffer: !1,\n      generateMipmaps: !1,\n      magFilter: B.NearestFilter,\n      minFilter: B.NearestFilter\n    }), this.target.texture.format = B.RGBAIntegerFormat, this.target.texture.type = B.UnsignedIntType, this.target.texture.internalFormat = \"RGBA32UI\", !0;\n  }\n  // Given an array of splatCounts (.numSplats for each\n  // SplatGenerator/SplatMesh in the scene), compute a\n  // \"mapping layout\" in the composite array of generated outputs.\n  generateMapping(A) {\n    let n = 0;\n    const t = A.map((s) => {\n      const i = n, a = Math.ceil(s / S) * S;\n      return n += a, { base: i, count: s };\n    });\n    return { maxSplats: n, mapping: t };\n  }\n  // Returns a THREE.DataArrayTexture representing the PackedSplats content as\n  // a Uint32x4 data array texture (2048 x 2048 x depth in size)\n  getTexture() {\n    return this.target ? this.target.texture : this.source || this.packedArray ? this.maybeUpdateSource() : L.getEmpty();\n  }\n  // Check if source texture needs to be created/updated\n  maybeUpdateSource() {\n    if (!this.packedArray)\n      throw new Error(\"No packed splats\");\n    if (this.needsUpdate || !this.source) {\n      if (this.needsUpdate = !1, this.source) {\n        const { width: A, height: n, depth: t } = this.source.image;\n        this.maxSplats !== A * n * t && (this.source.dispose(), this.source = null);\n      }\n      if (this.source)\n        this.packedArray.buffer !== this.source.image.data.buffer && (this.source.image.data = new Uint8Array(this.packedArray.buffer));\n      else {\n        const { width: A, height: n, depth: t } = W(this.maxSplats);\n        this.source = new B.DataArrayTexture(\n          this.packedArray,\n          A,\n          n,\n          t\n        ), this.source.format = B.RGBAIntegerFormat, this.source.type = B.UnsignedIntType, this.source.internalFormat = \"RGBA32UI\", this.source.needsUpdate = !0;\n      }\n      this.source.needsUpdate = !0;\n    }\n    return this.source;\n  }\n  // Can be used where you need an uninitialized THREE.DataArrayTexture like\n  // a uniform you will update with the result of this.getTexture() later.\n  static getEmpty() {\n    if (!L.emptySource) {\n      const { width: A, height: n, depth: t, maxSplats: s } = W(1), i = new Uint32Array(s * 4);\n      L.emptySource = new B.DataArrayTexture(\n        i,\n        A,\n        n,\n        t\n      ), L.emptySource.format = B.RGBAIntegerFormat, L.emptySource.type = B.UnsignedIntType, L.emptySource.internalFormat = \"RGBA32UI\", L.emptySource.needsUpdate = !0;\n    }\n    return L.emptySource;\n  }\n  // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,\n  // generating it if necessary and caching the result.\n  prepareProgramMaterial(A) {\n    let n = L.generatorProgram.get(A);\n    if (!n) {\n      const s = SA(\n        { index: \"int\" },\n        { output: \"uvec4\" },\n        ({ index: i }) => {\n          A.inputs.index = i;\n          const a = A.outputs.gsplat;\n          return { output: fe(a) };\n        }\n      );\n      L.programTemplate || (L.programTemplate = new Et(\n        Vs\n      )), n = new Ct({\n        graph: s,\n        inputs: { index: \"index\" },\n        outputs: { output: \"target\" },\n        template: L.programTemplate\n      }), Object.assign(n.uniforms, {\n        targetLayer: { value: 0 },\n        targetBase: { value: 0 },\n        targetCount: { value: 0 }\n      }), L.generatorProgram.set(A, n);\n    }\n    const t = n.prepareMaterial();\n    return L.mesh.material = t, { program: n, material: t };\n  }\n  saveRenderState(A) {\n    return {\n      xrPresenting: A.xr.isPresenting,\n      autoClear: A.autoClear,\n      scissorTest: A.getScissorTest(),\n      pixelRatio: A.getPixelRatio()\n    };\n  }\n  resetRenderState(A, n) {\n    A.setRenderTarget(null), A.setPixelRatio(n.pixelRatio), A.xr.isPresenting = n.xrPresenting, A.autoClear = n.autoClear, A.setScissorTest(n.scissorTest);\n  }\n  // Executes a dyno program specified by generator which is any DynoBlock that\n  // maps { index: \"int\" } to { gsplat: Gsplat }. This is called in\n  // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for\n  // SplatGenerator instances whose version is newer than what was generated\n  // for it last time.\n  generate({\n    generator: A,\n    base: n,\n    count: t,\n    renderer: s\n  }) {\n    if (!this.target)\n      throw new Error(\"Target must be initialized with ensureSplats\");\n    if (n + t > this.maxSplats)\n      throw new Error(\"Base + count exceeds maxSplats\");\n    const { program: i, material: a } = this.prepareProgramMaterial(A);\n    i.update();\n    const r = this.saveRenderState(s), I = Math.ceil((n + t) / S) * S, g = S * bA;\n    for (a.uniforms.targetBase.value = n, a.uniforms.targetCount.value = t; n < I; ) {\n      const Q = Math.floor(n / g);\n      a.uniforms.targetLayer.value = Q;\n      const o = Q * g, c = Math.floor((n - o) / S), C = Math.min(\n        bA,\n        Math.ceil((I - o) / S)\n      );\n      s.setPixelRatio(1), s.setRenderTarget(this.target, Q), s.xr.isPresenting = !1, s.autoClear = !1, s.setScissorTest(!0), s.setScissor(\n        0,\n        c,\n        S,\n        C - c\n      ), s.render(L.scene, L.camera), n += S * (C - c);\n    }\n    return this.resetRenderState(s, r), { nextBase: I };\n  }\n};\nIA.emptySource = null;\nIA.programTemplate = null;\nIA.generatorProgram = /* @__PURE__ */ new Map();\nIA.geometry = new B.PlaneGeometry(2, 2);\nIA.mesh = new B.Mesh(\n  IA.geometry,\n  new B.RawShaderMaterial({ visible: !1 })\n);\nIA.scene = new B.Scene().add(IA.mesh);\nIA.camera = new B.Camera();\nlet TA = IA;\nclass _n extends oA {\n  constructor({ packedSplats: A } = {}) {\n    super({\n      key: \"packedSplats\",\n      type: En,\n      globals: () => [vn],\n      value: {\n        texture: TA.getEmpty(),\n        numSplats: 0\n      },\n      update: (n) => {\n        var t, s;\n        return n.texture = ((t = this.packedSplats) == null ? void 0 : t.getTexture()) ?? TA.getEmpty(), n.numSplats = ((s = this.packedSplats) == null ? void 0 : s.numSplats) ?? 0, n;\n      }\n    }), this.packedSplats = A;\n  }\n}\nclass bn extends B.InstancedBufferGeometry {\n  constructor(A, n) {\n    super(), this.ordering = A, this.setAttribute(\"position\", new B.BufferAttribute(js, 3)), this.setIndex(new B.BufferAttribute(Zs, 1)), this._maxInstanceCount = A.length, this.instanceCount = n, this.attribute = new B.InstancedBufferAttribute(A, 1, !1, 1), this.attribute.setUsage(B.DynamicDrawUsage), this.setAttribute(\"splatIndex\", this.attribute);\n  }\n  update(A, n) {\n    this.ordering = A, this.attribute.array = A, this.instanceCount = n, this.attribute.addUpdateRange(0, n), this.attribute.needsUpdate = !0;\n  }\n}\nconst js = new Float32Array([\n  -1,\n  -1,\n  0,\n  1,\n  -1,\n  0,\n  1,\n  1,\n  0,\n  -1,\n  1,\n  0\n]), Zs = new Uint16Array([0, 1, 2, 0, 2, 3]), Yn = class zA {\n  constructor(A) {\n    if (this.lastTime = null, this.encodeLinear = !1, this.superXY = 1, this.display = null, this.sorting = null, this.pending = null, this.sortingCheck = !1, this.readback = new Uint16Array(0), this.spark = A.spark, this.camera = A.camera, this.viewToWorld = A.viewToWorld ?? new B.Matrix4(), A.target) {\n      const { width: n, height: t, doubleBuffer: s } = A.target, i = Math.max(1, Math.min(4, A.target.superXY ?? 1));\n      if (this.superXY = i, n * i > 8192 || t * i > 8192)\n        throw new Error(\"Target size too large\");\n      this.target = new B.WebGLRenderTarget(\n        n * i,\n        t * i,\n        {\n          format: B.RGBAFormat,\n          type: B.UnsignedByteType,\n          colorSpace: B.SRGBColorSpace\n        }\n      ), s && (this.back = new B.WebGLRenderTarget(\n        n * i,\n        t * i,\n        {\n          format: B.RGBAFormat,\n          type: B.UnsignedByteType,\n          colorSpace: B.SRGBColorSpace\n        }\n      )), this.encodeLinear = !0;\n    }\n    this.onTextureUpdated = A.onTextureUpdated, this.sortRadial = A.sortRadial ?? !0, this.sortDistance = A.sortDistance, this.sortCoorient = A.sortCoorient, this.depthBias = A.depthBias, this.sort360 = A.sort360, this.orderingFreelist = new Te({\n      allocate: (n) => new Uint32Array(n),\n      valid: (n, t) => n.length === t\n    }), this.autoUpdate = !1, this.setAutoUpdate(A.autoUpdate ?? !1);\n  }\n  // Call this when you are done with the SparkViewpoint and want to\n  // free up its resources (GPU targets, pixel buffers, etc.)\n  dispose() {\n    var A;\n    this.setAutoUpdate(!1), this.target && (this.target.dispose(), this.target = void 0), this.back && (this.back.dispose(), this.back = void 0), this.display && (this.spark.releaseAccumulator(this.display.accumulator), this.display.geometry.dispose(), this.display = null), (A = this.pending) != null && A.accumulator && (this.spark.releaseAccumulator(this.pending.accumulator), this.pending = null);\n  }\n  // Use this function to change whether this viewpoint will auto-update\n  // its sort order whenever the attached SparkRenderer updates the Gsplats.\n  // Turn this on or off depending on whether you expect to do renders from\n  // this viewpoint most frames.\n  setAutoUpdate(A) {\n    !this.autoUpdate && A ? this.spark.autoViewpoints.push(this) : this.autoUpdate && !A && (this.spark.autoViewpoints = this.spark.autoViewpoints.filter(\n      (n) => n !== this\n    )), this.autoUpdate = A;\n  }\n  // See below async prepareRenderPixels() for explanation of parameters.\n  // Awaiting this method updates the Gsplats in the scene and performs a sort of the\n  // Gsplats from this viewpoint, preparing it for a subsequent this.renderTarget()\n  // call in the same tick.\n  async prepare({\n    scene: A,\n    camera: n,\n    viewToWorld: t,\n    update: s,\n    forceOrigin: i\n  }) {\n    var a;\n    for (t ? this.viewToWorld = t : (this.camera = n ?? this.camera, this.camera && (this.camera.updateMatrixWorld(), this.viewToWorld = this.camera.matrixWorld.clone())); s ?? !0; ) {\n      const I = i ? this.viewToWorld : void 0;\n      if (this.spark.updateInternal({ scene: A, originToWorld: I }))\n        break;\n      await new Promise((Q) => setTimeout(Q, 10));\n    }\n    const r = this.spark.active;\n    r !== ((a = this.display) == null ? void 0 : a.accumulator) && (this.spark.active.refCount += 1), await this.sortUpdate({ accumulator: r, viewToWorld: this.viewToWorld });\n  }\n  // Render out the viewpoint to the view target RGBA buffer.\n  // Swaps buffers if doubleBuffer: true was set.\n  // Calls onTextureUpdated(texture) with the resulting texture.\n  renderTarget({\n    scene: A,\n    camera: n\n  }) {\n    var t;\n    const s = this.back ?? this.target;\n    if (!s)\n      throw new Error(\"Must initialize SparkViewpoint with target\");\n    if (n = n ?? this.camera, !n)\n      throw new Error(\"Must provide camera\");\n    if (n instanceof B.PerspectiveCamera) {\n      const i = new B.PerspectiveCamera().copy(n, !1);\n      i.aspect = s.width / s.height, i.updateProjectionMatrix(), n = i;\n    }\n    this.viewToWorld = n.matrixWorld.clone();\n    try {\n      this.spark.renderer.setRenderTarget(s), this.spark.prepareViewpoint(this), this.spark.renderer.render(A, n);\n    } finally {\n      this.spark.prepareViewpoint(this.spark.defaultView), this.spark.renderer.setRenderTarget(null);\n    }\n    s !== this.target && ([this.target, this.back] = [this.back, this.target]), (t = this.onTextureUpdated) == null || t.call(this, s.texture);\n  }\n  // Read back the previously rendered target image as a Uint8Array of packed\n  // RGBA values (in that order). If superXY was set greater than 1 then\n  // downsampling is performed in the target pixel array with simple averaging\n  // to derive the returned pixel values. Subsequent calls to this.readTarget()\n  // will reuse the same buffers to minimize memory allocations.\n  async readTarget() {\n    if (!this.target)\n      throw new Error(\"Must initialize SparkViewpoint with target\");\n    const { width: A, height: n } = this.target, t = A * n * 4;\n    (!this.superPixels || this.superPixels.length < t) && (this.superPixels = new Uint8Array(t)), await this.spark.renderer.readRenderTargetPixelsAsync(\n      this.target,\n      0,\n      0,\n      A,\n      n,\n      this.superPixels\n    );\n    const { superXY: s } = this;\n    if (s === 1)\n      return this.superPixels;\n    const i = A / s, a = n / s, r = i * a * 4;\n    (!this.pixels || this.pixels.length < r) && (this.pixels = new Uint8Array(r));\n    const { superPixels: I, pixels: g } = this, Q = s * s;\n    for (let o = 0; o < a; o++) {\n      const c = o * i;\n      for (let C = 0; C < i; C++) {\n        const E = C * s;\n        let l = 0, u = 0, d = 0, p = 0;\n        for (let m = 0; m < s; m++) {\n          const y = (o * s + m) * this.target.width;\n          for (let f = 0; f < s; f++) {\n            const D = (y + E + f) * 4;\n            l += I[D], u += I[D + 1], d += I[D + 2], p += I[D + 3];\n          }\n        }\n        const h = (c + C) * 4;\n        g[h] = l / Q, g[h + 1] = u / Q, g[h + 2] = d / Q, g[h + 3] = p / Q;\n      }\n    }\n    return g;\n  }\n  // Render out a viewpoint as a Uint8Array of RGBA values for the provided scene\n  // and any camera/viewToWorld viewpoint overrides. By default update is true,\n  // which triggers its SparkRenderer to check and potentially update the Gsplats.\n  // Setting update to false disables this and sorts the Gsplats as they are.\n  // Setting forceOrigin (default: false) to true forces the view update to\n  // recalculate the splats with this view origin, potentially altering any\n  // view-dependent effects. If you expect view-dependent effects to play a role\n  // in the rendering quality, enable this.\n  //\n  // Underneath, prepareRenderPixels() simply calls await this.prepare(...),\n  // this.renderTarget(...), and finally returns the result this.readTarget(),\n  // a Promise to a Uint8Array with RGBA values for all the pixels (potentially\n  // downsampled if the superXY parameter was used). These steps can also be called\n  // manually, for example if you need to alter the scene before and after\n  // this.renderTarget(...) to hide UI elements from being rendered.\n  async prepareRenderPixels({\n    scene: A,\n    camera: n,\n    viewToWorld: t,\n    update: s,\n    forceOrigin: i\n  }) {\n    return await this.prepare({ scene: A, camera: n, viewToWorld: t, update: s, forceOrigin: i }), this.renderTarget({ scene: A, camera: n }), this.readTarget();\n  }\n  // This is called automatically by SparkRenderer, there is no need to call it!\n  // The method cannot be private because then SparkRenderer would\n  // not be able to call it.\n  autoPoll({ accumulator: A }) {\n    var n, t, s, i;\n    this.camera && (this.camera.updateMatrixWorld(), this.viewToWorld = this.camera.matrixWorld.clone());\n    let a = !1, r = !1;\n    if (!this.display)\n      a = !0;\n    else if (A) {\n      a = !0;\n      const { mappingVersion: g } = this.display.accumulator;\n      A.mappingVersion === g && (this.spark.releaseAccumulator(this.display.accumulator), this.display.accumulator = A, r = !0);\n    }\n    const I = ((n = this.sorting) == null ? void 0 : n.viewToWorld) ?? ((t = this.display) == null ? void 0 : t.viewToWorld);\n    I && !Sn({\n      matrix1: this.viewToWorld,\n      matrix2: I,\n      // By default update sort each 1 cm\n      maxDistance: this.sortDistance ?? 0.01,\n      // By default for radial sort, update for intermittent movement so that\n      // we bring back splats culled by being behind the camera.\n      // For depth sort, small rotations can change sort order a lot, so\n      // update sort for even small rotations.\n      minCoorient: this.sortCoorient ?? this.sortRadial ? 0.99 : 0.999\n    }) && (a = !0), a && (A && (A.refCount += 1), A && ((s = this.pending) != null && s.accumulator) && this.pending.accumulator !== ((i = this.display) == null ? void 0 : i.accumulator) && this.spark.releaseAccumulator(this.pending.accumulator), this.pending = { accumulator: A, viewToWorld: this.viewToWorld, displayed: r }, this.driveSort());\n  }\n  async driveSort() {\n    for (var A; ; ) {\n      if (this.sorting || !this.pending)\n        return;\n      const { viewToWorld: n, displayed: t } = this.pending;\n      let s = this.pending.accumulator ?? ((A = this.display) == null ? void 0 : A.accumulator);\n      if (s || (s = this.spark.active, s.refCount += 1), this.pending = null, !s)\n        throw new Error(\"No accumulator to sort\");\n      this.sorting = { viewToWorld: n }, await this.sortUpdate({ accumulator: s, viewToWorld: n, displayed: t }), this.sorting = null;\n    }\n  }\n  async sortUpdate({\n    accumulator: A,\n    viewToWorld: n,\n    displayed: t = !1\n  }) {\n    if (this.sortingCheck)\n      throw new Error(\"Only one sort at a time\");\n    this.sortingCheck = !0, A = A ?? this.spark.active;\n    const { numSplats: s, maxSplats: i } = A.splats;\n    let a = 0, r = this.orderingFreelist.alloc(i);\n    if (s > 0) {\n      const {\n        reader: I,\n        doubleSortReader: g,\n        dynoSortRadial: Q,\n        dynoOrigin: o,\n        dynoDirection: c,\n        dynoDepthBias: C,\n        dynoSort360: E,\n        dynoSplats: l\n      } = zA.makeSorter(), u = Math.ceil(i / 2);\n      this.readback = I.ensureBuffer(u, this.readback);\n      const d = A.toWorld.clone().invert(), p = n.clone().premultiply(d);\n      Q.value = this.sort360 ? !0 : this.sortRadial, o.value.set(0, 0, 0).applyMatrix4(p), c.value.set(0, 0, -1).applyMatrix4(p).sub(o.value).normalize(), C.value = this.depthBias ?? 1, E.value = this.sort360 ?? !1, l.packedSplats = A.splats, await I.renderReadback({\n        renderer: this.spark.renderer,\n        reader: g,\n        count: Math.ceil(s / 2),\n        readback: this.readback\n      });\n      const h = await qA(async (m) => m.call(\"sortDoubleSplats\", {\n        numSplats: s,\n        readback: this.readback,\n        ordering: r\n      }));\n      this.readback = h.readback, r = h.ordering, a = h.activeSplats;\n    }\n    this.updateDisplay({\n      accumulator: A,\n      viewToWorld: n,\n      ordering: r,\n      activeSplats: a,\n      displayed: t\n    }), this.sortingCheck = !1;\n  }\n  updateDisplay({\n    accumulator: A,\n    viewToWorld: n,\n    ordering: t,\n    activeSplats: s,\n    displayed: i = !1\n  }) {\n    if (!this.display)\n      this.display = {\n        accumulator: A,\n        viewToWorld: n,\n        geometry: new bn(t, s)\n      };\n    else {\n      !i && A !== this.display.accumulator && (this.spark.releaseAccumulator(this.display.accumulator), this.display.accumulator = A), this.display.viewToWorld = n;\n      const a = this.display.geometry.ordering;\n      a.length === t.length ? this.display.geometry.update(t, s) : (this.display.geometry.dispose(), this.display.geometry = new bn(t, s)), this.orderingFreelist.free(a);\n    }\n    this.spark.viewpoint === this && this.spark.prepareViewpoint(this);\n  }\n  static makeSorter() {\n    if (!zA.dynos) {\n      const A = new qn({ value: !0 }), n = new In({ value: new B.Vector3() }), t = new In({ value: new B.Vector3() }), s = new jA({ value: 1 }), i = new qn({ value: !1 }), a = new _n(), r = new ut(), I = SA(\n        { index: \"int\" },\n        { rgba8: \"vec4\" },\n        ({ index: g }) => {\n          if (!g)\n            throw new Error(\"No index\");\n          const Q = {\n            sortRadial: A,\n            sortOrigin: n,\n            sortDirection: t,\n            sortDepthBias: s,\n            sort360: i\n          }, o = ht(g, Dn(\"int\", 2)), c = on(a, o), C = Xn({ gsplat: c, ...Q }), E = on(\n            a,\n            OA(o, Dn(\"int\", 1))\n          ), l = Xn({ gsplat: E, ...Q }), u = Qs({\n            vectorType: \"vec2\",\n            x: C,\n            y: l\n          });\n          return { rgba8: gs(rs(u)) };\n        }\n      );\n      zA.dynos = {\n        dynoSortRadial: A,\n        dynoOrigin: n,\n        dynoDirection: t,\n        dynoDepthBias: s,\n        dynoSort360: i,\n        dynoSplats: a,\n        reader: r,\n        doubleSortReader: I\n      };\n    }\n    return zA.dynos;\n  }\n};\nYn.EMPTY_TEXTURE = new B.Texture();\nYn.dynos = null;\nlet Zn = Yn;\nconst Xs = O(`\n  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {\n    if (!isGsplatActive(gsplat.flags)) {\n      return INFINITY;\n    }\n\n    vec3 center = gsplat.center - sortOrigin;\n    float biasedDepth = dot(center, sortDirection) + sortDepthBias;\n    if (!sort360 && (biasedDepth <= 0.0)) {\n      return INFINITY;\n    }\n\n    return sortRadial ? length(center) : biasedDepth;\n  }\n`);\nfunction Xn({\n  gsplat: e,\n  sortRadial: A,\n  sortOrigin: n,\n  sortDirection: t,\n  sortDepthBias: s,\n  sort360: i\n}) {\n  return cn({\n    inTypes: {\n      gsplat: N,\n      sortRadial: \"bool\",\n      sortOrigin: \"vec3\",\n      sortDirection: \"vec3\",\n      sortDepthBias: \"float\",\n      sort360: \"bool\"\n    },\n    outTypes: { metric: \"float\" },\n    globals: () => [QA, Xs],\n    inputs: {\n      gsplat: e,\n      sortRadial: A,\n      sortOrigin: n,\n      sortDirection: t,\n      sortDepthBias: s,\n      sort360: i\n    },\n    statements: ({ inputs: a, outputs: r }) => {\n      const {\n        gsplat: I,\n        sortRadial: g,\n        sortOrigin: Q,\n        sortDirection: o,\n        sortDepthBias: c,\n        sort360: C\n      } = a;\n      return BA(`\n        ${r.metric} = computeSort(${I}, ${g}, ${Q}, ${o}, ${c}, ${C});\n      `);\n    }\n  }).outputs.metric;\n}\nclass mn {\n  constructor() {\n    this.splats = new TA(), this.toWorld = new B.Matrix4(), this.mapping = [], this.refCount = 0, this.splatsVersion = -1, this.mappingVersion = -1;\n  }\n  ensureGenerate(A) {\n    this.splats.ensureGenerate(A) && (this.mapping = []);\n  }\n  // Generate all Gsplats from an array of generators\n  generateSplats({\n    renderer: A,\n    modifier: n,\n    generators: t,\n    forceUpdate: s,\n    originToWorld: i\n  }) {\n    const a = this.mapping.reduce((g, Q) => (g.set(Q.node, Q), g), /* @__PURE__ */ new Map());\n    let r = 0, I = 0;\n    for (const { node: g, generator: Q, version: o, base: c, count: C } of t) {\n      const E = a.get(g);\n      if ((s || Q !== (E == null ? void 0 : E.generator) || o !== (E == null ? void 0 : E.version) || c !== (E == null ? void 0 : E.base) || C !== (E == null ? void 0 : E.count)) && Q && C > 0) {\n        const l = n.apply(Q);\n        try {\n          this.splats.generate({\n            generator: l,\n            base: c,\n            count: C,\n            renderer: A\n          });\n        } catch (u) {\n          g.generator = void 0, g.generatorError = u;\n        }\n        r += 1;\n      }\n      I = Math.max(I, c + C);\n    }\n    return this.splats.numSplats = I, this.toWorld = i, this.mapping = t, r !== 0;\n  }\n  // Check if this accumulator has exactly the same generator mapping as\n  // the previous one. If so, we can reuse the Gsplat sort order.\n  hasCorrespondence(A) {\n    return this.mapping.length !== A.mapping.length ? !1 : this.mapping.every(({ node: n, base: t, count: s }, i) => {\n      const {\n        node: a,\n        base: r,\n        count: I\n      } = A.mapping[i];\n      return n === a && t === r && s === I;\n    });\n  }\n}\nvar Ws = `const float LN_SCALE_MIN = -9.0;\nconst float LN_SCALE_MAX = 9.0;\nconst float LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254.0; \n\nconst uint SPLAT_TEX_WIDTH_BITS = 11u;\nconst uint SPLAT_TEX_HEIGHT_BITS = 11u;\nconst uint SPLAT_TEX_DEPTH_BITS = 11u;\nconst uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;\n\nconst uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;\nconst uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;\nconst uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;\n\nconst uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;\nconst uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;\nconst uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;\n\nconst uint F16_INF = 0x7c00u;\nconst float PI = 3.1415926535897932384626433832795;\n\nconst float INFINITY = 1.0 / 0.0;\nconst float NEG_INFINITY = -INFINITY;\n\nconst float MAX_PIXEL_RADIUS = 512.0;\nconst float MIN_ALPHA = 0.5 * (1.0 / 255.0); \nconst float MAX_STDDEV = sqrt(8.0);\n\nfloat sqr(float x) {\n    return x * x;\n}\n\nfloat pow4(float x) {\n    float x2 = x * x;\n    return x2 * x2;\n}\n\nfloat pow8(float x) {\n    float x4 = pow4(x);\n    return x4 * x4;\n}\n\nvec3 srgbToLinear(vec3 rgb) {\n    return pow(rgb, vec3(2.2));\n}\n\nvec3 linearToSrgb(vec3 rgb) {\n    return pow(rgb, vec3(1.0 / 2.2));\n}\n\nuint encodeQuatOctXy88R8(vec4 q) {\n    \n    if (q.w < 0.0) {\n        q = -q;\n    }\n    \n    float theta = 2.0 * acos(q.w);\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    \n    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;\n    \n    \n    \n    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);\n    vec2 p = vec2(axis.x, axis.y) / sum;\n    \n    if (axis.z < 0.0) {\n        float oldPx = p.x;\n        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);\n        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);\n    }\n    \n    float u_f = p.x * 0.5 + 0.5;\n    float v_f = p.y * 0.5 + 0.5;\n    \n    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));\n    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));\n    \n    \n    \n    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));\n    \n    \n    return (angleInt << 16u) | (quantV << 8u) | quantU;\n}\n\nvec4 decodeQuatOctXy88R8(uint encoded) {\n    \n    uint quantU = encoded & uint(0xFFu);               \n    uint quantV = (encoded >> 8u) & uint(0xFFu);         \n    uint angleInt = encoded >> 16u;                      \n\n    \n    float u_f = float(quantU) / 255.0;\n    float v_f = float(quantV) / 255.0;\n    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);\n\n    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));\n    float t = max(-axis.z, 0.0);\n    axis.x += (axis.x >= 0.0) ? -t : t;\n    axis.y += (axis.y >= 0.0) ? -t : t;\n    axis = normalize(axis);\n    \n    \n    float theta = (float(angleInt) / 255.0) * 3.14159265359;\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    float w = cos(halfTheta);\n    \n    return vec4(axis * s, w);\n}\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\nuvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {\n    uvec4 uRgba = uvec4(round(clamp(rgba * 255.0, 0.0, 255.0)));\n\n    uint uQuat = encodeQuatOctXy88R8(quaternion);\n    \n    \n    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);\n\n    \n    uvec3 uScales = uvec3(\n        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,\n        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,\n        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u\n    );\n\n    \n    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);\n    uint word1 = packHalf2x16(center.xy);\n    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);\n    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);\n    return uvec4(word0, word1, word2, word3);\n}\n\nvoid unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {\n    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;\n\n    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);\n    rgba = vec4(uRgba) / 255.0;\n\n    center = vec4(\n        unpackHalf2x16(word1),\n        unpackHalf2x16(word2 & 0xffffu)\n    ).xyz;\n\n    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);\n    scales = vec3(\n        (uScales.x == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.x - 1u) * LN_RESCALE),\n        (uScales.y == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.y - 1u) * LN_RESCALE),\n        (uScales.z == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.z - 1u) * LN_RESCALE)\n    );\n\n    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);\n    quaternion = decodeQuatOctXy88R8(uQuat);\n    \n    \n}\n\nvec3 quatVec(vec4 q, vec3 v) {\n    \n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\nvec4 quatQuat(vec4 q1, vec4 q2) {\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\n        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,\n        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n    );\n}\n\nmat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {\n    \n    return mat3(\n        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),\n        s.x * (2.0 * (q.x * q.y + q.w * q.z)),\n        s.x * (2.0 * (q.x * q.z - q.w * q.y)),\n        s.y * (2.0 * (q.x * q.y - q.w * q.z)),\n        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),\n        s.y * (2.0 * (q.y * q.z + q.w * q.x)),\n        s.z * (2.0 * (q.x * q.z + q.w * q.y)),\n        s.z * (2.0 * (q.y * q.z - q.w * q.x)),\n        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))\n    );\n}\n\nvec4 slerp(vec4 q1, vec4 q2, float t) {\n    \n    float cosHalfTheta = dot(q1, q2);\n\n    \n    if (abs(cosHalfTheta) >= 0.999) {\n        return q1;\n    }\n    \n    \n    \n    if (cosHalfTheta < 0.0) {\n        q2 = -q2;\n        cosHalfTheta = -cosHalfTheta;\n    }\n\n    \n    float halfTheta = acos(cosHalfTheta);\n    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);\n\n    \n    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;\n    float ratioB = sin(t * halfTheta) / sinHalfTheta;\n\n    \n    return q1 * ratioA + q2 * ratioB;\n}\n\nivec3 splatTexCoord(int index) {\n    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;\n    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;\n    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;\n    return ivec3(x, y, z);\n}`, $s = `precision highp float;\nprecision highp int;\n\n#include <splatDefines>\n\nuniform bool encodeLinear;\nuniform float maxStdDev;\nuniform bool disableFalloff;\nuniform float falloff;\n\nout vec4 fragColor;\n\nin vec4 vRgba;\nin vec2 vSplatUv;\nin vec3 vNdc;\n\nvoid main() {\n    float z = dot(vSplatUv, vSplatUv);\n    if (z > (maxStdDev * maxStdDev)) {\n        discard;\n    }\n\n    float alpha = vRgba.a;\n    alpha *= mix(1.0, exp(-0.5 * z), falloff);\n    if (alpha < MIN_ALPHA) {\n        discard;\n    }\n\n    vec3 rgb = vRgba.rgb;\n    if (encodeLinear) {\n        rgb = srgbToLinear(rgb);\n    }\n    fragColor = vec4(rgb, alpha);\n}`, Ai = `precision highp float;\nprecision highp int;\nprecision highp usampler2DArray;\n\n#include <splatDefines>\n\nattribute uint splatIndex;\n\nout vec4 vRgba;\nout vec2 vSplatUv;\nout vec3 vNdc;\n\nuniform vec2 renderSize;\nuniform uint numSplats;\nuniform vec4 renderToViewQuat;\nuniform vec3 renderToViewPos;\nuniform float maxStdDev;\nuniform float time;\nuniform float deltaTime;\nuniform bool debugFlag;\nuniform bool enable2DGS;\nuniform float blurAmount;\nuniform float preBlurAmount;\nuniform float clipXY;\n\nuniform usampler2DArray packedSplats;\n\nvoid main() {\n    \n    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n\n    if (uint(gl_InstanceID) >= numSplats) {\n        return;\n    }\n    if (splatIndex == 0xffffffffu) {\n        \n        return;\n    }\n\n    ivec3 texCoord = ivec3(\n        splatIndex & SPLAT_TEX_WIDTH_MASK,\n        (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\n        splatIndex >> SPLAT_TEX_LAYER_BITS\n    );\n    uvec4 packed = texelFetch(packedSplats, texCoord, 0);\n\n    vec3 center, scales;\n    vec4 quaternion, rgba;\n    unpackSplat(packed, center, scales, quaternion, rgba);\n\n    if (rgba.a < MIN_ALPHA) {\n        return;\n    }\n    bvec3 zeroScales = equal(scales, vec3(0.0));\n    if (all(zeroScales)) {\n        return;\n    }\n\n    \n    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;\n\n    \n    if (viewCenter.z >= 0.0) {\n        return;\n    }\n\n    \n    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);\n\n    \n    if (abs(clipCenter.z) >= clipCenter.w) {\n        return;\n    }\n\n    \n    float clip = clipXY * clipCenter.w;\n    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {\n        return;\n    }\n\n    \n    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);\n\n    if (enable2DGS && any(zeroScales)) {\n        vRgba = rgba;\n        vSplatUv = position.xy * maxStdDev;\n\n        vec3 offset;\n        if (zeroScales.z) {\n            offset = vec3(vSplatUv.xy * scales.xy, 0.0);\n        } else if (zeroScales.y) {\n            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);\n        } else {\n            offset = vec3(0.0, vSplatUv.xy * scales.yz);\n        }\n\n        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);\n        gl_Position = projectionMatrix * vec4(viewPos, 1.0);\n        vNdc = gl_Position.xyz / gl_Position.w;\n        return;\n    }\n\n    \n    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n    \n    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);\n    mat3 cov3D = RS * transpose(RS);\n\n    \n    vec2 focal = 0.5 * renderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);\n    float invZ = 1.0 / viewCenter.z;\n    vec2 J1 = focal * invZ;\n    vec2 J2 = -(J1 * viewCenter.xy) * invZ;\n    mat3 J = mat3(\n        J1.x, 0.0, J2.x,\n        0.0, J1.y, J2.y,\n        0.0, 0.0, 0.0\n    );\n\n    \n    \n    \n    \n    \n    \n    \n    mat3 cov2D = transpose(J) * cov3D * J;\n    float a = cov2D[0][0];\n    float d = cov2D[1][1];\n    float b = cov2D[0][1];\n\n    \n    a += preBlurAmount;\n    d += preBlurAmount;\n\n    \n    float detOrig = a * d - b * b;\n    a += blurAmount;\n    d += blurAmount;\n    float det = a * d - b * b;\n\n    \n    float blurAdjust = sqrt(max(0.0, detOrig / det));\n    rgba.a *= blurAdjust;\n    if (rgba.a < MIN_ALPHA) {\n        return;\n    }\n\n    \n    float eigenAvg = 0.5 * (a + d);\n    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));\n    float eigen1 = eigenAvg + eigenDelta;\n    float eigen2 = eigenAvg - eigenDelta;\n\n    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));\n    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);\n\n    float scale1 = position.x * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen1));\n    float scale2 = position.y * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen2));\n\n    \n    vec2 pixelOffset = eigenVec1 * scale1 + eigenVec2 * scale2;\n    vec2 ndcOffset = (2.0 / renderSize) * pixelOffset;\n    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);\n\n    vRgba = rgba;\n    vSplatUv = position.xy * maxStdDev;\n    vNdc = ndc;\n    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);\n}`;\nlet wn = null;\nfunction ni() {\n  return wn || (B.ShaderChunk.splatDefines = Ws, wn = {\n    splatVertex: Ai,\n    splatFragment: $s\n  }), wn;\n}\nconst Wn = 5;\nlet Mn = !1, Fn = !1, Rt;\nfunction ti(e) {\n  let A = !1;\n  return e instanceof Bn ? !0 : (e.traverse((n) => {\n    A = A || n instanceof Bn;\n  }), A);\n}\nconst vt = B.Scene.prototype.add;\nB.Scene.prototype.add = function(e) {\n  return Mn = Mn || ti(e), Fn = Fn || e instanceof Gt, vt.call(this, e), this;\n};\nconst ei = B.Scene.prototype.onBeforeRender;\nB.Scene.prototype.onBeforeRender = function(e) {\n  if (Mn) {\n    if (!Fn) {\n      const A = Rt || new Gt({ renderer: e });\n      this.add(A);\n    }\n    B.Scene.prototype.onBeforeRender = ei, B.Scene.prototype.add = vt;\n  }\n};\nconst Tn = class j extends B.Mesh {\n  constructor(A) {\n    const n = j.makeUniforms(), t = ni(), s = new B.ShaderMaterial({\n      glslVersion: B.GLSL3,\n      vertexShader: t.splatVertex,\n      fragmentShader: t.splatFragment,\n      uniforms: n,\n      transparent: !0,\n      blending: B.NormalBlending,\n      depthTest: !0,\n      depthWrite: !1,\n      side: B.DoubleSide\n    });\n    super($n, s), this.autoViewpoints = [], this.rotateToAccumulator = new Gn({ value: new B.Quaternion() }), this.translateToAccumulator = new In({ value: new B.Vector3() }), this.lastFrame = -1, this.lastUpdateTime = null, this.defaultCameras = [], this.pendingUpdate = null, this.envViewpoint = null, this.frustumCulled = !1, this.renderer = A.renderer, this.material = s, this.uniforms = n;\n    const i = SA(\n      { gsplat: N },\n      { gsplat: N },\n      ({ gsplat: a }) => {\n        if (!a)\n          throw new Error(\"gsplat not defined\");\n        return a = et(a, {\n          rotate: this.rotateToAccumulator,\n          translate: this.translateToAccumulator\n        }), { gsplat: a };\n      }\n    );\n    this.modifier = new Ms(i), this.autoUpdate = A.autoUpdate ?? !0, this.preUpdate = A.preUpdate ?? !1, this.originDistance = A.originDistance ?? 1, this.maxStdDev = A.maxStdDev ?? Math.sqrt(8), this.enable2DGS = A.enable2DGS ?? !0, this.preBlurAmount = A.preBlurAmount ?? 0, this.blurAmount = A.blurAmount ?? 0.3, this.falloff = A.falloff ?? 1, this.clipXY = A.clipXY ?? 1.4, this.active = new mn(), this.accumulatorCount = 1, this.freeAccumulators = [];\n    for (let a = 0; a < 1; ++a)\n      this.freeAccumulators.push(new mn()), this.accumulatorCount += 1;\n    this.defaultView = new Zn({\n      ...A.view,\n      autoUpdate: !0,\n      spark: this\n    }), this.viewpoint = this.defaultView, this.prepareViewpoint(this.viewpoint), this.clock = A.clock ? Pe(A.clock) : new B.Clock(), Rt = this;\n  }\n  static makeUniforms() {\n    return {\n      // Size of render viewport in pixels\n      renderSize: { value: new B.Vector2() },\n      // Total number of Gsplats in packedSplats to render\n      numSplats: { value: 0 },\n      // SplatAccumulator to view transformation quaternion\n      renderToViewQuat: { value: new B.Quaternion() },\n      // SplatAccumulator to view transformation translation\n      renderToViewPos: { value: new B.Vector3() },\n      // Maximum distance (in stddevs) from Gsplat center to render\n      maxStdDev: { value: 1 },\n      // Enable interpreting 0-thickness Gsplats as 2DGS\n      enable2DGS: { value: !1 },\n      // Add to projected 2D splat covariance diagonal (thickens and brightens)\n      preBlurAmount: { value: 0 },\n      // Add to 2D splat covariance diagonal and adjust opacity (anti-aliasing)\n      blurAmount: { value: 0.3 },\n      // Modulate Gaussian kernal falloff. 0 means \"no falloff, flat shading\",\n      // 1 is normal e^-x^2 falloff.\n      falloff: { value: 1 },\n      // Clip Gsplats that are clipXY times beyond the +-1 frustum bounds\n      clipXY: { value: 1.4 },\n      // Gsplat collection to render\n      packedSplats: { type: \"t\", value: TA.getEmpty() },\n      // Time in seconds for time-based effects\n      time: { value: 0 },\n      // Delta time in seconds since last frame\n      deltaTime: { value: 0 },\n      // Whether to encode Gsplat with linear RGB (for environment mapping)\n      encodeLinear: { value: !1 },\n      // Debug flag that alternates each frame\n      debugFlag: { value: !1 }\n    };\n  }\n  canAllocAccumulator() {\n    return this.freeAccumulators.length > 0 || this.accumulatorCount < Wn;\n  }\n  maybeAllocAccumulator() {\n    let A = this.freeAccumulators.pop();\n    if (A === void 0) {\n      if (this.accumulatorCount >= Wn)\n        return null;\n      A = new mn(), this.accumulatorCount += 1;\n    }\n    return A.refCount = 1, A;\n  }\n  releaseAccumulator(A) {\n    A.refCount -= 1, A.refCount === 0 && this.freeAccumulators.push(A);\n  }\n  newViewpoint(A) {\n    return new Zn({ ...A, spark: this });\n  }\n  onBeforeRender(A, n, t) {\n    var s, i;\n    const a = this.time ?? this.clock.getElapsedTime(), r = a - (this.viewpoint.lastTime ?? a);\n    this.viewpoint.lastTime = a;\n    const I = A.info.render.frame, g = I !== this.lastFrame;\n    this.lastFrame = I;\n    const Q = this.viewpoint;\n    if (Q === this.defaultView) {\n      if (g)\n        if (!A.xr.isPresenting)\n          this.defaultView.viewToWorld = t.matrixWorld.clone(), this.defaultCameras = [this.defaultView.viewToWorld];\n        else {\n          const E = A.xr.getCamera().cameras;\n          this.defaultCameras = [\n            E[0].matrixWorld,\n            E[1].matrixWorld\n          ], this.defaultView.viewToWorld = si(this.defaultCameras) ?? new B.Matrix4();\n        }\n      this.autoUpdate && this.update({ scene: n, viewToWorld: this.defaultView.viewToWorld });\n    }\n    if (g && (this.uniforms.time.value = a, this.uniforms.deltaTime.value = r, this.uniforms.debugFlag.value = performance.now() / 1e3 % 2 < 1), Q.target)\n      this.uniforms.renderSize.value.set(\n        Q.target.width,\n        Q.target.height\n      );\n    else {\n      const E = A.getSize(this.uniforms.renderSize.value);\n      if (E.x === 1 && E.y === 1) {\n        const l = (s = A.xr.getSession()) == null ? void 0 : s.renderState.baseLayer;\n        l && (E.x = l.framebufferWidth, E.y = l.framebufferHeight);\n      }\n    }\n    this.uniforms.encodeLinear.value = Q.encodeLinear, this.uniforms.maxStdDev.value = this.maxStdDev, this.uniforms.enable2DGS.value = this.enable2DGS, this.uniforms.preBlurAmount.value = this.preBlurAmount, this.uniforms.blurAmount.value = this.blurAmount, this.uniforms.falloff.value = this.falloff, this.uniforms.clipXY.value = this.clipXY;\n    const o = ((i = Q.display) == null ? void 0 : i.accumulator.toWorld) ?? new B.Matrix4(), c = t.matrixWorld.clone().invert();\n    o.clone().premultiply(c).decompose(\n      this.uniforms.renderToViewPos.value,\n      this.uniforms.renderToViewQuat.value,\n      new B.Vector3()\n    );\n  }\n  // Update the uniforms for the given viewpoint.\n  // Note that the client expects to be able to call render() at any point\n  // to update the canvas, so we must switch the viewpoint back to\n  // defaultView when we're finished.\n  prepareViewpoint(A) {\n    if (this.viewpoint = A ?? this.viewpoint, this.viewpoint.display) {\n      const { accumulator: n, geometry: t } = this.viewpoint.display;\n      this.uniforms.numSplats.value = n.splats.numSplats, this.uniforms.packedSplats.value = n.splats.getTexture(), this.geometry = t;\n    } else\n      this.uniforms.numSplats.value = 0, this.uniforms.packedSplats.value = TA.getEmpty(), this.geometry = $n;\n  }\n  // If spark.autoUpdate is false then you must manually call\n  // spark.update({ scene }) to have the scene Gsplats be re-generated.\n  update({\n    scene: A,\n    viewToWorld: n\n  }) {\n    const t = this.matrixWorld.clone();\n    this.preUpdate ? this.updateInternal({ scene: A, originToWorld: t, viewToWorld: n }) : (this.pendingUpdate = {\n      scene: A,\n      originToWorld: t\n    }, setTimeout(() => {\n      if (this.pendingUpdate) {\n        const { scene: s, originToWorld: i } = this.pendingUpdate;\n        this.pendingUpdate = null, this.updateInternal({ scene: s, originToWorld: i, viewToWorld: n });\n      }\n    }, 1));\n  }\n  updateInternal({\n    scene: A,\n    originToWorld: n,\n    viewToWorld: t\n  }) {\n    var s;\n    if (!this.canAllocAccumulator())\n      return !1;\n    n || (n = this.active.toWorld), t = t ?? n.clone();\n    const i = this.time ?? this.clock.getElapsedTime(), a = i - (this.lastUpdateTime ?? i);\n    this.lastUpdateTime = i;\n    const r = this.active.mapping.reduce((C, E) => (C.set(E.node, E), C), /* @__PURE__ */ new Map()), { generators: I, globalEdits: g } = this.compileScene(A);\n    for (const C of I)\n      (s = C.frameUpdate) == null || s.call(C, {\n        object: C,\n        time: i,\n        deltaTime: a,\n        viewToWorld: t,\n        globalEdits: g\n      });\n    for (const C of I) {\n      const E = r.get(C), l = C.generator ? C.numSplats : 0;\n      (C.generator !== (E == null ? void 0 : E.generator) || l !== (E == null ? void 0 : E.count)) && C.updateVersion();\n    }\n    const o = !Sn({\n      matrix1: n,\n      matrix2: this.active.toWorld,\n      maxDistance: this.originDistance\n    }) || I.length !== r.size || I.some((C) => {\n      var E;\n      return C.version !== ((E = r.get(C)) == null ? void 0 : E.version);\n    });\n    let c = null;\n    if (o) {\n      if (c = this.maybeAllocAccumulator(), !c)\n        throw new Error(\"Unreachable\");\n      const C = !Sn({\n        matrix1: n,\n        matrix2: this.active.toWorld,\n        maxDistance: 1e-5,\n        minCoorient: 0.99999\n      }), l = I.map((y, f) => {\n        const D = r.get(y);\n        return D ? (\n          // Sort by version deltas then by previous ordering in the mapping,\n          // attempting to keep unchanging generators near the front\n          // to improve our chances of avoiding a re-generation.\n          [y.version - D.version, D.base, y]\n        ) : [Number.POSITIVE_INFINITY, y.version, y];\n      }).sort((y, f) => y[0] !== f[0] ? y[0] - f[0] : y[1] - f[1]).map(([y, f, D]) => D), u = l.map((y) => y.numSplats), { maxSplats: d, mapping: p } = c.splats.generateMapping(u), h = l.map((y, f) => {\n        const { base: D, count: T } = p[f];\n        return {\n          node: y,\n          generator: y.generator,\n          version: y.version,\n          base: D,\n          count: T\n        };\n      });\n      n.clone().invert().decompose(\n        this.translateToAccumulator.value,\n        this.rotateToAccumulator.value,\n        new B.Vector3()\n      ), c.ensureGenerate(d), c.generateSplats({\n        renderer: this.renderer,\n        modifier: this.modifier,\n        generators: h,\n        forceUpdate: C,\n        originToWorld: n\n      }), c.splatsVersion = this.active.splatsVersion + 1;\n      const m = c.hasCorrespondence(this.active);\n      c.mappingVersion = this.active.mappingVersion + (m ? 0 : 1), this.releaseAccumulator(this.active), this.active = c, this.prepareViewpoint();\n    }\n    return setTimeout(() => {\n      for (const C of this.autoViewpoints)\n        C.autoPoll({ accumulator: c ?? void 0 });\n    }, 1), !0;\n  }\n  compileScene(A) {\n    const n = [];\n    A.traverse((s) => {\n      s instanceof St && n.push(s);\n    });\n    const t = /* @__PURE__ */ new Set();\n    return A.traverseVisible((s) => {\n      if (s instanceof mt) {\n        let i = s.parent;\n        for (; i != null && !(i instanceof Bn); )\n          i = i.parent;\n        i == null && t.add(s);\n      }\n    }), { generators: n, globalEdits: Array.from(t) };\n  }\n  // Renders out the scene to an environment map that can be used for\n  // Image-based lighting or similar applications. First optionally updates Gsplats,\n  // sorts them with respect to the provided worldCenter, renders 6 cube faces,\n  // then pre-filters them using THREE.PMREMGenerator and returns a THREE.Texture\n  // that can assigned directly to a THREE.MeshStandardMaterial.envMap property.\n  async renderEnvMap({\n    renderer: A,\n    scene: n,\n    worldCenter: t,\n    size: s = 256,\n    near: i = 0.1,\n    far: a = 1e3,\n    hideObjects: r = [],\n    update: I = !1\n  }) {\n    var g, Q;\n    if (this.envViewpoint || (this.envViewpoint = this.newViewpoint({ sort360: !0 })), !j.cubeRender || j.cubeRender.target.width !== s || j.cubeRender.near !== i || j.cubeRender.far !== a) {\n      j.cubeRender && j.cubeRender.target.dispose();\n      const l = new B.WebGLCubeRenderTarget(s, {\n        format: B.RGBAFormat,\n        generateMipmaps: !0,\n        minFilter: B.LinearMipMapLinearFilter\n      }), u = new B.CubeCamera(i, a, l);\n      j.cubeRender = { target: l, camera: u, near: i, far: a };\n    }\n    j.pmrem || (j.pmrem = new B.PMREMGenerator(A ?? this.renderer));\n    const o = new B.Matrix4().setPosition(t);\n    await ((g = this.envViewpoint) == null ? void 0 : g.prepare({ scene: n, viewToWorld: o, update: I }));\n    const { target: c, camera: C } = j.cubeRender;\n    C.position.copy(t);\n    const E = /* @__PURE__ */ new Map();\n    for (const l of r)\n      E.set(l, l.visible), l.visible = !1;\n    this.prepareViewpoint(this.envViewpoint), C.update(A ?? this.renderer, n), this.prepareViewpoint(this.defaultView);\n    for (const [l, u] of E.entries())\n      l.visible = u;\n    return (Q = j.pmrem) == null ? void 0 : Q.fromCubemap(c.texture).texture;\n  }\n  // Utility function to recursively set the envMap property for any\n  // THREE.MeshStandardMaterial within the subtree of root.\n  recurseSetEnvMap(A, n) {\n    A.traverse((t) => {\n      if (t instanceof B.Mesh)\n        if (Array.isArray(t.material))\n          for (const s of t.material)\n            s instanceof B.MeshStandardMaterial && (s.envMap = n);\n        else\n          t.material instanceof B.MeshStandardMaterial && (t.material.envMap = n);\n    });\n  }\n  // Utility function that helps extract the Gsplat RGBA values from a\n  // SplatGenerator, including the result of any real-time RGBA SDF edits applied\n  // to a SplatMesh. This effectively \"bakes\" any computed RGBA values, which can\n  // now be used as a pipeline input via SplatMesh.splatRgba to inject these\n  // baked values into the Gsplat data.\n  getRgba({\n    generator: A,\n    rgba: n\n  }) {\n    const t = this.active.mapping.find(({ node: s }) => s === A);\n    if (!t)\n      throw new Error(\"Generator not found\");\n    return n = n ?? new ms(), n.fromPackedSplats({\n      packedSplats: this.active.splats,\n      base: t.base,\n      count: t.count,\n      renderer: this.renderer\n    }), n;\n  }\n  // Utility function that builds on getRgba({ generator }) and additionally\n  // reads back the RGBA values to the CPU in a Uint8Array with packed RGBA\n  // in that byte order.\n  async readRgba({\n    generator: A,\n    rgba: n\n  }) {\n    return n = this.getRgba({ generator: A, rgba: n }), n.read();\n  }\n};\nTn.cubeRender = null;\nTn.pmrem = null;\nlet Gt = Tn;\nconst $n = new bn(new Uint32Array(1), 0);\nSA(\n  { packedSplats: En, index: \"int\" },\n  { gsplat: N },\n  ({ packedSplats: e, index: A }) => {\n    if (!e || !A)\n      throw new Error(\"Invalid input\");\n    return { gsplat: on(e, A) };\n  }\n);\nfunction si(e) {\n  if (e.length === 0)\n    return null;\n  const A = new B.Vector3(), n = new B.Quaternion(), t = new B.Vector3(), s = [], i = [];\n  for (const a of e)\n    a.decompose(A, n, t), s.push(A), i.push(n);\n  return new B.Matrix4().compose(\n    Ve(s),\n    je(i),\n    new B.Vector3(1, 1, 1)\n  );\n}\nO(`\n  struct GsplatSkinning {\n    int numSplats;\n    int numBones;\n    usampler2DArray skinTexture;\n    sampler2D boneTexture;\n  };\n`);\nO(`\n  void applyGsplatSkinning(\n    int numSplats, int numBones,\n    usampler2DArray skinTexture, sampler2D boneTexture,\n    int splatIndex, inout vec3 center, inout vec4 quaternion\n  ) {\n    if ((splatIndex < 0) || (splatIndex >= numSplats)) {\n      return;\n    }\n\n    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);\n\n    float weights[4];\n    weights[0] = float(skinData.x & 0xffu) / 255.0;\n    weights[1] = float(skinData.y & 0xffu) / 255.0;\n    weights[2] = float(skinData.z & 0xffu) / 255.0;\n    weights[3] = float(skinData.w & 0xffu) / 255.0;\n\n    uint boneIndices[4];\n    boneIndices[0] = (skinData.x >> 8u) & 0xffu;\n    boneIndices[1] = (skinData.y >> 8u) & 0xffu;\n    boneIndices[2] = (skinData.z >> 8u) & 0xffu;\n    boneIndices[3] = (skinData.w >> 8u) & 0xffu;\n\n    vec4 quat = vec4(0.0);\n    vec4 dual = vec4(0.0);\n    for (int i = 0; i < 4; i++) {\n      if (weights[i] > 0.0) {\n        int boneIndex = int(boneIndices[i]);\n        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);\n        vec4 boneDual = vec4(0.0);\n        if (boneIndex < numBones) {\n          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);\n          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);\n        }\n\n        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {\n          // Flip sign if next blend is pointing in the opposite direction\n          boneQuat = -boneQuat;\n          boneDual = -boneDual;\n        }\n        quat += weights[i] * boneQuat;\n        dual += weights[i] * boneDual;\n      }\n    }\n\n    // Normalize dual quaternion\n    float norm = length(quat);\n    quat /= norm;\n    dual /= norm;\n    vec3 translate = vec3(\n      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),\n      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),\n      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)\n    );\n\n    center = quatVec(quat, center) + translate;\n    quaternion = quatQuat(quat, quaternion);\n  }\n`);\nnew B.Box3(\n  new B.Vector3(-1, -1, -1),\n  new B.Vector3(1, 1, 1)\n), new B.Vector3(-1, -3, 1).normalize(), new B.Color(1, 1, 1), new B.Color(0.5, 0.5, 1), new B.Vector3(1, 1, 1);\nnew B.Box3(\n  new B.Vector3(-2, -1, -2),\n  new B.Vector3(2, 5, 2)\n), new B.Vector3(0, -1, 0), new B.Color(1, 1, 1), new B.Color(0.25, 0.25, 0.5), new B.Vector3(0.1, 1, 0.1);\nconst Ut = class Nn {\n  static createButton(A, n = {}) {\n    const t = navigator.xr;\n    if (!t)\n      return null;\n    const s = t, i = document.createElement(\"button\");\n    A.xr.enabled = !0, A.xr.setReferenceSpaceType(\"local\");\n    function a() {\n      let o = null;\n      async function c(l) {\n        console.log(\"onSessionStarted\"), l.addEventListener(\"end\", C), await A.xr.setSession(l), i.textContent = \"EXIT VR\", o = l;\n      }\n      function C() {\n        console.log(\"onSessionEnded\"), o == null || o.removeEventListener(\"end\", C), i.textContent = \"ENTER VR\", o = null;\n      }\n      i.style.display = \"\", i.style.cursor = \"pointer\", i.style.left = \"calc(50% - 100px)\", i.style.width = \"200px\", i.style.height = \"100px\", i.textContent = \"ENTER VR\";\n      const E = {\n        ...n,\n        optionalFeatures: [\n          // \"local-floor\",\n          // \"bounded-floor\",\n          // \"layers\",\n          ...n.optionalFeatures || []\n        ]\n      };\n      i.onmouseenter = () => {\n        i.style.opacity = \"1.0\";\n      }, i.onmouseleave = () => {\n        i.style.opacity = \"0.5\";\n      }, i.onclick = () => {\n        o === null ? (console.log(\"requesting session\"), s.requestSession(\"immersive-vr\", E).then(\n          c\n        )) : (console.log(\"ending session\"), o.end());\n      };\n    }\n    function r() {\n      i.style.display = \"none\", i.style.cursor = \"auto\", i.style.left = \"calc(50% - 75px)\", i.style.width = \"150px\", i.onmouseenter = null, i.onmouseleave = null, i.onclick = null;\n    }\n    function I() {\n      r(), i.textContent = \"VR NOT SUPPORTED\";\n    }\n    function g(o) {\n      r(), console.warn(\n        \"Exception when trying to call xr.isSessionSupported\",\n        o\n      ), i.textContent = \"VR NOT ALLOWED\";\n    }\n    function Q(o) {\n      o.style.position = \"absolute\", o.style.bottom = \"20px\", o.style.padding = \"12px 6px\", o.style.border = \"1px solid #fff\", o.style.borderRadius = \"4px\", o.style.background = \"rgba(0,0,0,0.1)\", o.style.color = \"#fff\", o.style.font = \"normal 13px sans-serif\", o.style.textAlign = \"center\", o.style.opacity = \"0.5\", o.style.outline = \"none\", o.style.zIndex = \"999\";\n    }\n    return i.id = \"VRButton\", i.style.display = \"none\", Q(i), s.isSessionSupported(\"immersive-vr\").then((o) => {\n      o ? a() : I(), o && Nn.xrSessionIsGranted && i.click();\n    }).catch(g), i;\n  }\n  static registerSessionGrantedListener() {\n    const A = navigator.xr;\n    if (!A)\n      return null;\n    const n = A;\n    /WebXRViewer\\//i.test(navigator.userAgent) || n.addEventListener(\"sessiongranted\", () => {\n      Nn.xrSessionIsGranted = !0;\n    });\n  }\n};\nUt.xrSessionIsGranted = !1;\nlet ii = Ut;\nii.registerSessionGrantedListener();\nvar Lt = /* @__PURE__ */ ((e) => (e.w = \"wrist\", e.t0 = \"thumb-metacarpal\", e.t1 = \"thumb-phalanx-proximal\", e.t2 = \"thumb-phalanx-distal\", e.t3 = \"thumb-tip\", e.i0 = \"index-finger-metacarpal\", e.i1 = \"index-finger-phalanx-proximal\", e.i2 = \"index-finger-phalanx-intermediate\", e.i3 = \"index-finger-phalanx-distal\", e.i4 = \"index-finger-tip\", e.m0 = \"middle-finger-metacarpal\", e.m1 = \"middle-finger-phalanx-proximal\", e.m2 = \"middle-finger-phalanx-intermediate\", e.m3 = \"middle-finger-phalanx-distal\", e.m4 = \"middle-finger-tip\", e.r0 = \"ring-finger-metacarpal\", e.r1 = \"ring-finger-phalanx-proximal\", e.r2 = \"ring-finger-phalanx-intermediate\", e.r3 = \"ring-finger-phalanx-distal\", e.r4 = \"ring-finger-tip\", e.p0 = \"pinky-finger-metacarpal\", e.p1 = \"pinky-finger-phalanx-proximal\", e.p2 = \"pinky-finger-phalanx-intermediate\", e.p3 = \"pinky-finger-phalanx-distal\", e.p4 = \"pinky-finger-tip\", e))(Lt || {});\nconst ai = Object.keys(Lt);\nai.length;\nnew B.Vector3(0, 0, -1), new B.Vector3(0, 0, 1), new B.Vector3(-1, 0, 0), new B.Vector3(1, 0, 0), new B.Vector3(0, 1, 0), new B.Vector3(0, -1, 0);\nnew B.Vector3(0, 0, -1), new B.Vector3(0, 0, 1), new B.Vector3(-1, 0, 0), new B.Vector3(1, 0, 0), new B.Vector3(0, 1, 0), new B.Vector3(0, -1, 0);\nnew B.Vector3(0, 0, 1), new B.Vector3(0, 0, -1);\nnew B.Vector3(0, -1, 0), new B.Vector3(0, 1, 0), new B.Vector3(-1, 0, 0), new B.Vector3(1, 0, 0);\nfunction Ii({ _ref: e, _key: A, src: n, ...t }) {\n  const s = jt(null), i = e || s, a = Xt(({ scene: g }) => g), [r, I] = Zt(null);\n  return Jn(() => {\n    if (!n) return;\n    const g = new Bn({ url: n });\n    I(g);\n  }, [n]), Jn(() => {\n    var g;\n    if (i.current && r)\n      return a.add(r), a.remove(r), (g = i.current) == null || g.add(r), () => {\n        var Q;\n        r && ((Q = i.current) == null || Q.remove(r), r == null || r.dispose());\n      };\n  }, [i.current, r]), /* @__PURE__ */ Vt(\"group\", { ref: i, ...t }, A);\n}\nexport {\n  Ii as default\n};\n"],"names":["lA","At","HA","Wt","$t","e","Ae","n","t","s","i","a","r","g","Q","ne","te","ee","nt","RA","se","YA","ie","ae","S","bA","re","ge","MA","FA","oe","Ie","VA","vA","GA","UA","Be","Qe","M","F","w","xA","NA","sn","ce","B.Vector2","B.Vector3","B.Vector4","B.Quaternion","B.Matrix2","B.Matrix3","B.Matrix4","Dn","WA","Hn","Ce","o","c","tt","Ee","u","d","p","h","m","y","C","SA","cn","BA","Rn","Cn","N","En","on","he","le","ue","an","de","ln","pe","et","ye","QA","vn","st","l","f","D","T","R","U","k","v","Z","q","$","G","J","fe","me","we","oA","qn","xn","jA","In","Gn","hn","KA","De","it","at","xe","rt","gt","ot","Se","ke","be","It","b","DA","PA","XA","Bt","Me","Fe","un","sA","dn","Qt","rn","Ne","X","Re","eA","dA","pA","AA","H","uA","iA","aA","V","nA","rA","x","gA","tA","CA","ve","Ge","pn","Ue","Le","_e","Un","ct","yn","fn","$A","Ye","Te","zn","Xe","Je","He","qe","ze","B.Color","Ke","Kn","We","W","Pe","B.Clock","Oe","Ve","je","Ze","Sn","E","$e","Ct","As","Et","Pn","B.RawShaderMaterial","B.GLSL3","lt","ns","ts","OA","ss","es","is","ht","as","rs","os","gs","Is","Bs","Cs","Qs","hs","cs","ls","Es","us","ps","ds","ys","fs","hA","EA","B.WebGLArrayRenderTarget","B.NearestFilter","B.RGBAFormat","B.UnsignedByteType","B.PlaneGeometry","B.Mesh","B.Scene","B.Camera","ut","Ln","z","dt","pt","B.DataArrayTexture","_n","ms","ws","Ds","xs","Ss","B.Object3D","yt","ft","mt","ks","wt","Dt","B.DataTexture","B.RGBAIntegerFormat","B.UnsignedIntType","xt","LA","bs","I","Ms","An","St","ZA","kn","TA","vs","Gs","Us","B.RGIntegerFormat","Bn","Fs","Ns","Rs","kt","gn","tn","_A","Ys","JA","yA","fA","mA","wA","Vn","kA","_t","Yt","Tt","Jt","Ht","qt","zt","Kt","Pt","Ot","en","nn","On","Ls","_s","bt","jn","Ts","Js","Mt","Qn","Ft","Nt","Hs","qs","qA","zs","Ks","Ps","Os","Vs","IA","bn","B.InstancedBufferGeometry","B.BufferAttribute","js","Zs","B.InstancedBufferAttribute","B.DynamicDrawUsage","Yn","zA","B.WebGLRenderTarget","B.SRGBColorSpace","B.PerspectiveCamera","Xn","B.Texture","Zn","Xs","mn","Ws","$s","Ai","wn","ni","B.ShaderChunk","Wn","Mn","Fn","Rt","ti","vt","Gt","ei","Tn","j","B.ShaderMaterial","B.NormalBlending","B.DoubleSide","$n","si","B.WebGLCubeRenderTarget","B.LinearMipMapLinearFilter","B.CubeCamera","B.PMREMGenerator","B.MeshStandardMaterial","B.Box3","Ut","Nn","ii","Lt","ai","Ii","jt","Xt","Zt","Jn","Vt"],"mappings":"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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAkPLC,GAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAiCLC,GAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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","x_google_ignoreList":[0]}
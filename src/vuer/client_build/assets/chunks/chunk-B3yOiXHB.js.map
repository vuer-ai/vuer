{"version":3,"file":"chunk-B3yOiXHB.js","sources":["../../../../node_modules/@vuer-ai/vuer/dist/index-tKDsVx4T-CLfNgJMZ-CLfNgJMZ-CLfNgJMZ-CLfNgJMZ-CLfNgJMZ.js"],"sourcesContent":["import { jsx as Oe } from \"react/jsx-runtime\";\nimport { useRef as Ve, useState as je, useEffect as Tt } from \"react\";\nimport * as B from \"three\";\nimport { useThree as Ze } from \"@react-three/fiber\";\nlet lA;\nconst $t = typeof TextDecoder < \"u\" ? new TextDecoder(\"utf-8\", { ignoreBOM: !0, fatal: !0 }) : { decode: () => {\n  throw Error(\"TextDecoder not available\");\n} };\ntypeof TextDecoder < \"u\" && $t.decode();\nlet HA = null;\nfunction We() {\n  return (HA === null || HA.byteLength === 0) && (HA = new Uint8Array(lA.memory.buffer)), HA;\n}\nfunction Xe(s, A) {\n  return s = s >>> 0, $t.decode(We().subarray(s, s + A));\n}\nfunction $e(s, A, t, e, i, a, r, n, I, o, Q) {\n  return lA.raycast_splats(s, A, t, e, i, a, r, n, I, o, Q);\n}\nasync function As(s, A) {\n  if (typeof Response == \"function\" && s instanceof Response) {\n    if (typeof WebAssembly.instantiateStreaming == \"function\")\n      try {\n        return await WebAssembly.instantiateStreaming(s, A);\n      } catch (e) {\n        if (s.headers.get(\"Content-Type\") != \"application/wasm\")\n          console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n        else\n          throw e;\n      }\n    const t = await s.arrayBuffer();\n    return await WebAssembly.instantiate(t, A);\n  } else {\n    const t = await WebAssembly.instantiate(s, A);\n    return t instanceof WebAssembly.Instance ? { instance: t, module: s } : t;\n  }\n}\nfunction ts() {\n  const s = {};\n  return s.wbg = {}, s.wbg.__wbg_buffer_609cc3eee51ed158 = function(A) {\n    return A.buffer;\n  }, s.wbg.__wbg_length_3b4f022188ae8db6 = function(A) {\n    return A.length;\n  }, s.wbg.__wbg_length_6ca527665d89694d = function(A) {\n    return A.length;\n  }, s.wbg.__wbg_length_8cfd2c6409af88ad = function(A) {\n    return A.length;\n  }, s.wbg.__wbg_new_9fee97a409b32b68 = function(A) {\n    return new Uint16Array(A);\n  }, s.wbg.__wbg_new_e3b321dcfef89fc7 = function(A) {\n    return new Uint32Array(A);\n  }, s.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(A, t, e) {\n    return new Float32Array(A, t >>> 0, e >>> 0);\n  }, s.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(A, t, e) {\n    return new Uint32Array(A, t >>> 0, e >>> 0);\n  }, s.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(A) {\n    return new Float32Array(A >>> 0);\n  }, s.wbg.__wbg_set_10bad9bee0e9c58b = function(A, t, e) {\n    A.set(t, e >>> 0);\n  }, s.wbg.__wbg_set_d23661d19148b229 = function(A, t, e) {\n    A.set(t, e >>> 0);\n  }, s.wbg.__wbg_set_f4f1f0daa30696fc = function(A, t, e) {\n    A.set(t, e >>> 0);\n  }, s.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(A, t, e) {\n    return A.subarray(t >>> 0, e >>> 0);\n  }, s.wbg.__wbg_subarray_769e1e0f81bb259b = function(A, t, e) {\n    return A.subarray(t >>> 0, e >>> 0);\n  }, s.wbg.__wbindgen_init_externref_table = function() {\n    const A = lA.__wbindgen_export_0, t = A.grow(4);\n    A.set(0, void 0), A.set(t + 0, void 0), A.set(t + 1, null), A.set(t + 2, !0), A.set(t + 3, !1);\n  }, s.wbg.__wbindgen_memory = function() {\n    return lA.memory;\n  }, s.wbg.__wbindgen_throw = function(A, t) {\n    throw new Error(Xe(A, t));\n  }, s;\n}\nfunction es(s, A) {\n  return lA = s.exports, Ae.__wbindgen_wasm_module = A, HA = null, lA.__wbindgen_start(), lA;\n}\nasync function Ae(s) {\n  if (lA !== void 0) return lA;\n  typeof s < \"u\" && (Object.getPrototypeOf(s) === Object.prototype ? { module_or_path: s } = s : console.warn(\"using deprecated parameters for the initialization function; pass a single object instead\")), typeof s > \"u\" && (s = new URL(\"data:application/wasm;base64,AGFzbQEAAAAB9wEkYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAF/AW9gAAFvYAd/f39/f39/AGACf34Bf2ADf35+AGACf34AYAt9fX19fX19fX9vfwFvYAZ/f39/f38Bf2AFf398f38AYAR/fH9/AGAFf399f38AYAR/fX9/AGAFf39+f38AYAR/fn9/AGADf35+AX9gA39vbwF/YAJ9fQF9AvIEEQN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgACgN3YmcaX193YmdfbmV3XzlmZWU5N2E0MDliMzJiNjgACgN3YmcaX193Ymdfc2V0X2Y0ZjFmMGRhYTMwNjk2ZmMACwN3YmcdX193YmdfbGVuZ3RoXzhjZmQyYzY0MDlhZjg4YWQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAHA3diZxpfX3diZ19uZXdfZTNiMzIxZGNmZWY4OWZjNwAKA3diZxpfX3diZ19zZXRfZDIzNjYxZDE5MTQ4YjIyOQALA3diZx1fX3diZ19sZW5ndGhfNmNhNTI3NjY1ZDg5Njk0ZAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AAcDd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiAAsDd2JnHV9fd2JnX2xlbmd0aF8zYjRmMDIyMTg4YWU4ZGI2AAwDd2JnH19fd2JnX3N1YmFycmF5Xzc2OWUxZTBmODFiYjI1OWIABwN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAHA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAUA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA4DwAG+AQUAAAYPAAUF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BSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBlM/AACgCACAFQRBqQZjPwAAoAgAoAhQRAgBBkM/AACgCAEEBawUgBgs2AgBB6NLAAEEAOgAAIANFDQAACwALsgEBBn8CQAJAIABBhAFJDQAgANBvJgEQRSIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnRBBBCwAQsPCwALqQEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAkEEELABDAELIAMgAkEEIAFBAnQiAhCXASIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQZiPwABBMhC5AQALQQQgAhCUAQALowEBAn8jAEEgayIDJAACQCABRQRAQQFBACACEMYBIQAMAQsgAyABNgIMIAMgADYCCCADQRBqIANBCGoQLSADKAIQIgEEQANAIAMoAhQhBCADKAIcRQRAIAEgBCACEMYBIQAMAwtBASEAIAIgASAEEJkBDQIgAkH9/wMQnAENAiADQRBqIANBCGoQLSADKAIQIgENAAsLQQAhAAsgA0EgaiQAIAALiwEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhCXAQwCCwsgASACRQ0AGkH9zsAALQAAGiACIAEQpgELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIABBKEEEELABIAFBIGokAAuaAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIAFBIGokAAuSAQEEfyMAQRBrIgIkAEEBIQQCQCABKAIUIgNBJyABKAIYIgUoAhAiAREAAA0AIAJBBGogACgCAEGBAhAiAkAgAi0ABEGAAUYEQCADIAIoAgggAREAAEUNAQwCCyADIAItAA4iACACQQRqaiACLQAPIABrIAUoAgwRAQANAQsgA0EnIAERAAAhBAsgAkEQaiQAIAQLlQEBAn8jAEEgayIDJAACQCAAKAIEIgRBA0YgBEECSXINAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GshcAANgIEIANCADcCECADIANBHGo2AgwgA0EEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiBEUNACAAKAIMIARBDGxBBBCwAQsgAEEoQQQQsAEgA0EgaiQAC4QBAQN/An8CQCAAKAIAIgFFDQADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIDAILAkAgAkUNACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBAQ8LQQEgAEEBEBMNAhogAkEBayECIAAoAgAiAQ0ACwtBAAsLegEBfyMAQSBrIgIkAAJ/IAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQmQEMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahApCyACQSBqJAALSQEDfiAAIAFC/////w+DIgJCPn4iA0IAIgIgAUIgiEI+fnwiAUIghnwiBDcDACAAIAMgBFatIAEgAlStQiCGIAFCIIiEfDcDCAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUG8rsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICADIQ3AzggBSAFQQhqrUKAgICAkAyENwMwIAUgBUEwajYCICAFQRhqIAQQhAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCwAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEEAAsgAygCBCICBEAgASACIAMoAggQsAELIABBDEEEELABCwvzAwIIfwF+IwBBEGsiAyQAIAAoAgQhBSAAKAIAIQAgASgCFEG4rMAAQQEgASgCGCgCDBEBACEEIANBBGoiAkEAOgAFIAIgBDoABCACIAE2AgAgBQRAA0AgAyAANgIMIANBDGohCCMAQUBqIgEkAEEBIQYCQCADQQRqIgQtAAQNACAELQAFIQkCQCAEKAIAIgIoAhwiB0EEcUUEQCAJQQFxRQ0BIAIoAhRB667AAEECIAIoAhgoAgwRAQBFDQEMAgsgCUEBcUUEQCACKAIUQfWuwABBASACKAIYKAIMEQEADQIgAigCHCEHCyABQQE6ABsgASACKQIUNwIMIAFBzK7AADYCNCABIAFBG2o2AhQgASACKQIINwIkIAIpAgAhCiABIAc2AjggASACKAIQNgIsIAEgAi0AIDoAPCABIAo3AhwgASABQQxqNgIwIAggAUEcakGAmcAAKAIAEQAADQEgASgCMEHwrsAAQQIgASgCNCgCDBEBACEGDAELIAggAkGAmcAAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUFAayQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIUQfauwABBASAAKAIYKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0HYscAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQZitwAA2AgggA0ICNwIUIANCgICAgPACIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhCEAQALagIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIMIANB+LHAADYCCCADQgI3AhQgA0KAgICA8AIiBCADQQRqrYQ3AyggAyAEIAOthDcDICADIANBIGo2AhAgA0EIaiACEIQBAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0GsssAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2MBAX8jAEEQayIAJAACfyACKAIABEBBwJXAACEDQQkMAQsgAEEEaiACKAIEIAIoAggQJEHAlcAAIAAoAgggACgCBCICGyEDQQkgACgCDCACGwshAiADIAIgARBcIABBEGokAAtnACMAQTBrIgAkAEH8zsAALQAABEAgAEECNgIMIABB8JXAADYCCCAAQgE3AhQgACABNgIsIAAgAEEsaq1CgICAgPAChDcDICAAIABBIGo2AhAgAEEIakGQlsAAEIQBAAsgAEEwaiQAC+caAhJ/AX4jAEEgayIPJAACfyAAKAIAIgAoAgAEQAJ/IAEhDCMAQTBrIgYkACAAKAIIIREgACgCBCEIIAAoAgAhDgJAAkACQAJAAkADQAJAIBEgECIJRgRAQQAhAgwBCyAIRQ0GIAkgEUchEiAJQQFqIRAgCEEBayEHIA4iBC0AACEBQQAhAAJAAkACQAJAA0ACQCABwEEASARAIAFBH3EhAiAAIARqIgVBAWotAABBP3EhAyABQf8BcSIOQd8BTQRAIAJBBnQgA3IhAQwCCyAFQQJqLQAAQT9xIANBBnRyIQEgDkHwAUkEQCABIAJBDHRyIQEMAgsgAkESdEGAgPAAcSAFQQNqLQAAQT9xIAFBBnRyciIBQYCAxABHDQEMDQsgAUH/AXEhAQsCQAJAIAFBMGtBCU0EQCAAIAdGDQ4gACAEaiICQQFqLAAAIgFBv39KDQEgAiAIIABrIgBBASAAQcCdwAAQnQEACyAABEAgACAEaiwAAEG/f0wNAgsgBkEUaiEHIAQhAkEAIQMCQAJAAkACQAJAAkACQCAAIgEOAgQAAQtBASEDIAItAABBK2sOAwMBAwELIAItAABBK0YEQCACQQFqIQIgAUEKSSABQQFrIgMhAQ0BDAILIAEhAyABQQhLDQELQQAhBQNAIAItAABBMGsiAUEJSwRAQQEhAwwDCyACQQFqIQIgASAFQQpsaiEFIANBAWsiAw0ACwwCC0EAIQUDQCABRQ0CIAItAABBMGsiDkEJSwRAQQEhAwwCC0ECIQMgBa1CCn4iFEIgiKcNASACQQFqIQIgAUEBayEBIA4gFKciCmoiBSAKTw0ACwsgByADOgABIAdBAToAAAwBCyAHIAU2AgQgB0EAOgAACyAGLQAUDQMgCCAGKAIYIgVrIQoCQCAFRQ0AIAggAGsiASAFSwRAIAQgBWogAGoiAiwAAEG/f0wNBiACLAAAQb9/Sg0BIAAgBGogAUEAIAVB8J3AABCdAQALIAAgCkcNBQsgACAEaiIBIQcgBCAFaiAAaiEOIAVFIBAgEUdyDQYgDCgCHEEEcUUNBiAHLQAAQegARw0GIAVBAUcEQCABQQFqLAAAQb9/TA0GCyAAIARqQQFqIQEDQEEAIQIgASAORg0IAn8gASwAACIDQQBOBEAgA0H/AXEhCCABQQFqDAELIAEtAAFBP3EhDSADQR9xIQggA0FfTQRAIAhBBnQgDXIhCCABQQJqDAELIAEtAAJBP3EgDUEGdHIhDSADQXBJBEAgDSAIQQx0ciEIIAFBA2oMAQsgCEESdEGAgPAAcSABLQADQT9xIA1BBnRyciIIQYCAxABGDQkgAUEEagshASAIQTBrQQpJIAhBIHJB4QBrQQZJcg0ACwwGCyAAQQFqIQAMAQsLIAQgCEEAIABB0J3AABCdAQALIAYgBi0AFToACEGEm8AAQSsgBkEIakG0n8AAQcSfwAAQZQALIAAgBGogASAFIAFB4J3AABCdAQALIAEgBUEBIAVBoJ3AABCdAQALAkAgCUUNACAMQYCewABBAhCZAUUNACASIQIMAQsCQCAFQQJJDQAgBy8AAEHfyABHDQAgACAEaiIBQQFqIgcsAABBv39MDQMgBUEBayEFCyAKIABrIQgDQCAHIQQCQAJAAkACQAJAAkACQAJAAkACQCAFIgNFDQACQCAELQAAQSRrDgsCAQEBAQEBAQEBAAELIANBAUYNBSAELAABQb9/Sg0EIAQgA0EBIANBgJ/AABCdAQALIAMgBGohCUEAIQAgBCEBA0AgACECIAEiACAJRg0IAn8gACwAACIFQQBOBEAgBUH/AXEhBSAAQQFqDAELIAAtAAFBP3EhByAFQR9xIQEgBUFfTQRAIAFBBnQgB3IhBSAAQQJqDAELIAAtAAJBP3EgB0EGdHIhByAFQXBJBEAgByABQQx0ciEFIABBA2oMAQsgAUESdEGAgPAAcSAALQADQT9xIAdBBnRyciEFIABBBGoLIgEgAiAAa2ohACAFQSRrDgsCAAAAAAAAAAAAAgALAAsgA0EBRg0BIAQsAAFBv39KDQEgBCADQQEgA0G0nsAAEJ0BAAsCQAJAAkAgAgRAAkAgAiADTyIARQRAIAIgBGosAABBv39MDQEgDCAEIAIQmQFFDQRBASECDA4LIAIgA0YNAgsgBCADQQAgAkGUnsAAEJ0BAAsgDCAEIAIQmQFFDQJBASECDAsLIAwgBCACEJkBRQ0AQQEhAgwKCyAARQRAIAIgBGosAABBv39KDQEMDwsgAiADRw0OCyACIARqIQcgAyACayEFDAcLIAYgA0EBayIANgIkIAZBADYCICAGIAA2AhwgBkEkNgIUIAZBJDYCKCAGQQE6ACwgBiAEQQFqIgA2AhggBkEIaiAGQRRqEC4gBigCCEEBRw0EAkAgBigCDCICQX9HBEAgAkEBaiEBIANBAUcNAQwFCyMAQSBrIgAkACAAQQA2AhggAEEBNgIMIABB2LPAADYCCCAAQgQ3AhAgAEEIakHEnsAAEIQBAAsgACwAAEG/f0oNAwwLCwJAAn8gBCwAASIAQQBOBEAgAEH/AXEMAQsgBC0AAkE/cSICIABBH3EiAUEGdHIgAEFfTQ0AGiAELQADQT9xIAJBBnRyIgIgAUEMdHIgAEFwSQ0AGiABQRJ0QYCA8ABxIAQtAARBP3EgAkEGdHJyC0EuRwRAQQEhAiAMQaCfwABBARCZAQ0IIAQsAAFBQEgNAQwDCyAMQYCewABBAhCZAQRAQQEhAgwICwJAIANBA08EQCAELAACQUBIDQELIARBAmohByADQQJrIQUMBwsgBCADQQIgA0GQn8AAEJ0BAAsgBCADQQEgA0Gkn8AAEJ0BAAtBASECIAxBoJ/AAEEBEJkBDQULIARBAWohByADQQFrIQUMAwsCQAJAAkACQCABIANJBEAgASAEaiwAAEFASA0MIAJBAmohAQwBCyABIANHDQsgAkECaiIBRQ0BCwJAIAEgA0kEQCABIARqLAAAQb9/Sg0BDAsLIAEgA0cNCgsgASAEaiEHIAMgAWshBQJAAkAgAg4DBQEAAgsgAC8AAEHToAFGBEBB/57AACEADAYLIAAvAABBwqABRgRAQf6ewAAhAAwGCyAALwAAQdKMAUYEQEH9nsAAIQAMBgsgAC8AAEHMqAFGBEBB/J7AACEADAYLIAAvAABBx6gBRgRAQfuewAAhAAwGCyAALwAAQcygAUYEQEH6nsAAIQAMBgsgAC8AAEHSoAFHDQFB+Z7AACEADAULIAAtAABBwwBGBEBB+J7AACEADAULIAAtAABB9QBGDQEMAwsgBC0AAUH1AEcNAiACQQJJDQEgBCwAAkG/f0wNAQsgACACaiETIAJBAWshCSAEQQJqIgIhAAJAA0BBASENIAAgE0YNAQJ/IAAsAAAiAUEATgRAIAFB/wFxIQEgAEEBagwBCyAALQABQT9xIQsgAUEfcSEKIAFBX00EQCAKQQZ0IAtyIQEgAEECagwBCyAALQACQT9xIAtBBnRyIQsgAUFwSQRAIAsgCkEMdHIhASAAQQNqDAELIApBEnRBgIDwAHEgAC0AA0E/cSALQQZ0cnIiAUGAgMQARg0CIABBBGoLIQAgAUEwa0EKSSABQeEAa0EGSXINAAtBACENCyAGQRRqIQoCQAJAAkACQAJAAkACQCAJIgAOAgABAgsgCkEAOgABDAQLIAItAAAiAUEraw4DAgECAQsgAi0AACEBCwJAAkACQCABQf8BcUErRgRAIABBAWshASACQQFqIQIgAEEJSwRAIAEhAAwCCyABIgANAkEAIQEMAwsgAEEISw0ADAELQQAhAQJAA0AgAEUNAyACLQAAIgtBMGsiCUEKTwRAQX8gC0EgciIJQdcAayILIAsgCUHhAGtJGyIJQRBPDQULIAGtQgSGIhRCIIinDQEgAkEBaiECIABBAWshACAJIBSnIgtqIgEgC08NAAsgCkECOgABDAQLIApBAjoAAQwDC0EAIQEDQCACLQAAIgtBMGsiCUEKTwRAQX8gC0EgciIJQdcAayILIAsgCUHhAGtJGyIJQRBPDQMLIAJBAWohAiAJIAFBBHRqIQEgAEEBayIADQALCyAKIAE2AgQgCkEAOgAADAILIApBAToAASAKQQE6AAAMAQsgCkEBOgAACyAGLQAUDQEgDUVBgIDEACAGKAIYIgAgAEGAsANzQYCAxABrQYCQvH9JGyIAQYCAxABGcg0BIAYgADYCBCAAQSBJIABB/wBrQSFJcg0BIAZBBGogDBBGRQ0DQQEhAgwECyAAIAJBASACQeiewAAQnQEACyASIQIgDCAEIAMQmQFFDQMMAgtBASECIAwgAEEBEJkBRQ0ACwsLIAZBMGokACACDAULIAEgBUEBIAVBhJ7AABCdAQALIAQgAyABIANB1J7AABCdAQALIAQgA0EBIAFBxJ7AABCdAQALIAQgAyACIANBpJ7AABCdAQALQbCdwAAQswEACwwBCyAPQQA2AhwgDyABNgIYIA9CADcCECAPIAApAgQ3AgggD0EIakEBEBILIA9BIGokAAuYAQIDfwFvIwBBIGsiAyQAIAMgACgCABDLASIENgIAIAMgAjYCBCACIARHBEAgA0EANgIIIAMgA0EEaiADQQhqEH4ACxCeASIEEJUBIgUlARAFIQYQMyICIAYmASAFQYQBTwRAIAUQWgsgAiAAKAIAIAFBAnYQrwEgAkGEAU8EQCACEFoLIARBhAFPBEAgBBBaCyADQSBqJAALUAEBfyMAQTBrIgAkACAAQQE2AgwgAEGorMAANgIIIABCATcCFCAAIABBL2qtQoCAgIDwC4Q3AyAgACAAQSBqNgIQIABBCGpB/IPAABCEAQALQwEDfwJAIAJFDQADQCAALQAAIgQgAS0AACIFRgRAIABBAWohACABQQFqIQEgAkEBayICDQEMAgsLIAQgBWshAwsgAwtBAQF/IAIgACgCACAAKAIIIgNrSwRAIAAgAyACEEQgACgCCCEDCyAAKAIEIANqIAEgAhA8GiAAIAIgA2o2AghBAAtBAQF/IAIgACgCACAAKAIIIgNrSwRAIAAgAyACEEogACgCCCEDCyAAKAIEIANqIAEgAhA8GiAAIAIgA2o2AghBAAtPAQJ/IAAoAgQhAiAAKAIAIQMCQCAAKAIIIgAtAABFDQAgA0HkrsAAQQQgAigCDBEBAEUNAEEBDwsgACABQQpGOgAAIAMgASACKAIQEQAAC0cBAX8jAEEQayICJAAgAkEIaiABEHogAiACKAIIIAIoAgwoAhgRAgAgAigCBCEBIAAgAigCADYCACAAIAE2AgQgAkEQaiQAC08BAn9B/c7AAC0AABogASgCBCECIAEoAgAhA0EIQQQQpgEiAUUEQEEEQQgQxAEACyABIAI2AgQgASADNgIAIABBtJbAADYCBCAAIAE2AgALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhBVIAAoAgghAwsgACgCBCADaiABIAIQPBogACACIANqNgIIQQALQgEBfyMAQSBrIgMkACADQQA2AhAgA0EBNgIEIANCBDcCCCADIAE2AhwgAyAANgIYIAMgA0EYajYCACADIAIQhAEACz0BAn8gACAAKAIEIgMgAms2AgQgACAAKAIAIAIgA0tyIgQ2AgBBASEDIAQEfyADBSAAKAIIIAEgAhCZAQsLPgEBfyMAQRBrIgIkACACQQhqIAEgASgCACgCBBECACACKAIMIQEgACACKAIINgIAIAAgATYCBCACQRBqJAALxAIBA38gACgCACECIAEoAhwiAEEQcUUEQCAAQSBxRQRAIAIgARCyAQ8LQQAhACMAQYABayIEJAAgAigCACECA0AgACAEakH/AGogAkEPcSIDQTByIANBN2ogA0EKSRs6AAAgAEEBayEAIAJBEEkgAkEEdiECRQ0ACyAAQYABaiICQYEBTwRAIAJBgAFBjK/AABBoAAsgAUGcr8AAQQIgACAEakGAAWpBACAAaxAhIARBgAFqJAAPC0EAIQAjAEGAAWsiBCQAIAIoAgAhAgNAIAAgBGpB/wBqIAJBD3EiA0EwciADQdcAaiADQQpJGzoAACAAQQFrIQAgAkEQSSACQQR2IQJFDQALIABBgAFqIgJBgQFPBEAgAkGAAUGMr8AAEGgACyABQZyvwABBAiAAIARqQYABakEAIABrECEgBEGAAWokAAvNAwEDfyAAKAIAIQAgASgCHCIDQRBxRQRAIANBIHFFBEAjAEEQayIDJAACQAJAAkAgAC0AACIAQeQATwRAIAMgACAAQeQAbiIAQeQAbGtB/wFxQQF0QZ6vwABqLwAAOwAODAELQQIhAiAAQQpPDQELIANBDWogAmogAEEwcjoAAAwBC0EBIQIgAyAAQQF0QZ6vwABqLwAAOwAOCyABQQFBACADQQ1qIAJqIAJBA3MQISADQRBqJAAPCyMAQYABayIEJAAgAC0AACEAA0AgAiAEakH/AGogAEEPcSIDQTByIANBN2ogA0EKSRs6AAAgAkEBayECIAAiA0EEdiEAIANBEE8NAAsgAkGAAWoiAEGBAU8EQCAAQYABQYyvwAAQaAALIAFBnK/AAEECIAIgBGpBgAFqQQAgAmsQISAEQYABaiQADwsjAEGAAWsiBCQAIAAtAAAhAANAIAIgBGpB/wBqIABBD3EiA0EwciADQdcAaiADQQpJGzoAACACQQFrIQIgACIDQQR2IQAgA0EQTw0ACyACQYABaiIAQYEBTwRAIABBgAFBjK/AABBoAAsgAUGcr8AAQQIgAiAEakGAAWpBACACaxAhIARBgAFqJAALOAACQCACQYCAxABGDQAgACACIAEoAhARAABFDQBBAQ8LIANFBEBBAA8LIAAgAyAEIAEoAgwRAQALOQEBfyMAQRBrIgMkACADIAE2AgwgAyAANgIIIANBCGpBiI/AACADQQxqQYiPwAAgAkH4jsAAEDgACzwBAX8jAEEQayICJAAgAkGUkcAANgIMIAIgADYCCCACQQhqQZiRwAAgAkEMakGYkcAAIAFBjJXAABA4AAvcBAIHfwF+IwBBEGsiBiQAIAYgADYCDCAGQQxqIQgjAEEQayICJAAgASgCFEHwm8AAQQ0gASgCGCgCDBEBACEAIAJBADoADSACIAA6AAwgAiABNgIIIwBBQGoiACQAQQEhAwJAIAJBCGoiBC0ABA0AIAQtAAUhBSAEKAIAIgEoAhwiB0EEcUUEQCABKAIUQeuuwABB6K7AACAFQQFxIgUbQQJBAyAFGyABKAIYKAIMEQEADQEgASgCFEH9m8AAQQQgASgCGCgCDBEBAA0BIAEoAhRBuK7AAEECIAEoAhgoAgwRAQANASAIIAFB7JvAACgCABEAACEDDAELIAVBAXFFBEAgASgCFEHtrsAAQQMgASgCGCgCDBEBAA0BIAEoAhwhBwsgAEEBOgAbIAAgASkCFDcCDCAAQcyuwAA2AjQgACAAQRtqNgIUIAAgASkCCDcCJCABKQIAIQkgACAHNgI4IAAgASgCEDYCLCAAIAEtACA6ADwgACAJNwIcIAAgAEEMaiIBNgIwIAFB/ZvAAEEEECoNACABQbiuwABBAhAqDQAgCCAAQRxqQeybwAAoAgARAAANACAAKAIwQfCuwABBAiAAKAI0KAIMEQEAIQMLIARBAToABSAEIAM6AAQgAEFAayQAIAItAA0iASACLQAMIgNyIQACQCADQQFxIAFBAUdyDQAgBCgCACIALQAcQQRxRQRAIAAoAhRB867AAEECIAAoAhgoAgwRAQAhAAwBCyAAKAIUQfKuwABBASAAKAIYKAIMEQEAIQALIAJBEGokACAAQQFxIAZBEGokAAsvAQF/IwBBEGsiAiQAIAJBCGogABB6IAIoAgggASACKAIMKAIQEQAAIAJBEGokAAs5AQF/QQEhAgJAIAAgARA/DQAgASgCFEH0q8AAQQIgASgCGCgCDBEBAA0AIABBBGogARA/IQILIAIL1hMCF30LfxAzIiMgCSYBAn8gCCEqIwBBMGsiIiQAICIgIzYCBCAiQoCAgIDAADcCCCAiQQA2AhBB7M7AACErQejOwAAoAgBFBEACf0H9zsAALQAAGgJAQYCAwAAQESIIRQ0AIAhBBGstAABBA3FFDQAgCEGAgMAAEFcaCyAIBEBB+M7AAEGAgBA2AgBB7M7AAEEANgIAQfTOwAAoAgAhI0H0zsAAIAg2AgBB8M7AACgCACEmQfDOwABBgIAQNgIAQejOwAAoAgBB6M7AAEEBNgIARSAmRXJFBEAgIyAmQQJ0QQQQsAELQezOwAAMAQtBBEGAgMAAEJQBAAshKwsgKygCAEUEQCArQX82AgACQCArAn8gKkUEQEEAISNBAAwBCyArQQxqKAIAISwgK0EIaigCACEIAkAgCgRAQQAhIwNAICIgIkEEaiAjQQJ0ICNBgIAEICogI2siCiAKQYCABE8bIgpqIiZBAnQQsQE2AhQgCkECdCIjICxLDQQgIkEUaiAIICMQbyAiIAI4AiAgIiABOAIcICIgADgCGCAiIAU4AiwgIiAEOAIoICIgAzgCJCAIIQojAEEQayInJAAgIwRAICJBCGohKCAiQSRqIiQqAgAhFSAkKgIEIRggJCoCCCEZICJBGGoiJCoCCCEfICQqAgQhICAkKgIAISEDQCAjQQQgI0EESSIkGyEpAkAgCi0AA7NDAAB/Q5VDzczMPV0NACAnQQRqIAogKRAmAn0CQCAkRQRAICcqAgwhDiAnKgIIIQwgJyoCBCELQwAAAAAhFkMAAAAAIRcgCigCDCIlQf8BcQRAICVBAWtB/wFxs0NFIpE9lEMAABDBkhAsIRcLICVBCHYiJEH/AXEEQCAkQQFrQf8BcbNDRSKRPZRDAAAQwZIQLCEWCyAfIA6TIQ8gICAMkyESICEgC5MhESAlQRB2IiRB/wFxDQFDAAAAAAwCC0EDIClBnIPAABBpAAsgJEEBa0H/AXGzQ0UikT2UQwAAEMGSECwLIRogGSAKKAIIIiRBGHWyQwAA/kKVIhMgGCAlQRh1skMAAP5ClSIUlCAZIBOUkyIQlCAkQRB2wLJDAAD+QpUiDSAZIA2UIBUgFJSTIg6UkyAVIBOUIBggDZSTIgxDAACAPyANIA2UkyATIBOUkyAUIBSUk0MAAAAAEJIBkSIblJIiCyALkpIhHCAYIA0gDJQgFCAQlJMgDiAblJIiCyALkpIhHSAVIBQgDpQgEyAMlJMgECAblJIiCyALkpIhHiAPIBMgEiAUlCAPIBOUkyIQlCANIA8gDZQgESAUlJMiDpSTIBEgE5QgEiANlJMiDCAblJIiCyALkpIhDyASIA0gDJQgFCAQlJMgDiAblJIiCyALkpIhDSARIBQgDpQgEyAMlJMgECAblJIiCyALkpIhDAJAIBogFyAWEJIBIBoQkgFDCtcjPJQiC11FBEAgCyAWXkUEQCALIBdeRQRAQwAAgD8gGpUiCyAPlCIPIAsgHJQiEpRDAACAPyAXlSILIAyUIhEgCyAelCIMlEMAAIA/IBaVIgsgDZQiECALIB2UIguUkpIiDiAOlCASIBKUIAwgDJQgCyALlJKSIgwgDyAPlCARIBGUIBAgEJSSkkMAAIC/kpSTIgtDAAAAAF0NBCAOjCALkZMgDJUhDAwDCyAei0O9N4Y1XQ0DIA0gHSAMjCAelSIMlJIgFpUiCyALlCAPIBwgDJSSIBqVIgsgC5SSQwAAgD9eRQ0CDAMLIB2LQ703hjVdDQIgDCAeIA2MIB2VIgyUkiAXlSILIAuUIA8gHCAMlJIgGpUiCyALlJJDAACAP14NAgwBCyAci0O9N4Y1XQ0BIAwgHiAPjCAclSIMlJIgF5UiCyALlCANIB0gDJSSIBaVIgsgC5SSQwAAgD9eDQELIAYgDF9FIAcgDGBFcg0AICgoAggiJCAoKAIARgRAICgQTwsgKCgCBCAkQQJ0aiAMOAIAICggJEEBajYCCAsgCiApQQJ0aiEKICMgKWsiIw0ACwsgJ0EQaiQAICIoAhQiCkGEAU8EQCAKEFoLICYiIyAqSQ0ACwwBC0EAISMDQCAiICJBBGogI0ECdCAjQYCABCAqICNrIgogCkGAgARPGyIKaiImQQJ0ELEBNgIUIApBAnQiIyAsSw0DICJBFGogCCAjEG8gIiACOAIgICIgATgCHCAiIAA4AhggIiAFOAIsICIgBDgCKCAiIAM4AiQgCCEKIwBBEGsiJyQAICMEQCAiQQhqISggIkEkaiIkKgIAIhggGJQgJCoCBCIZIBmUkiAkKgIIIg8gD5SSIRIgIkEYaiIkKgIIIR8gJCoCBCEgICQqAgAhIQNAICNBBCAjQQRJIiQbISkCQCAKLQADs0MAAH9DlUPNzMw9XQ0AICdBBGogCiApECYCfQJAICRFBEAgJyoCDCEOICcqAgghDCAnKgIEIQtDAAAAACERQwAAAAAhECAKKAIMIiVB/wFxBEAgJUEBa0H/AXGzQ0UikT2UQwAAEMGSEMwBIRALICVBCHYiJEH/AXEEQCAkQQFrQf8BcbNDRSKRPZRDAAAQwZIQzAEhEQsgHyAOkyENICAgDJMhFSAhIAuTIQ4gJUEQdiIkQf8BcQ0BQwAAAAAMAgtBAyApQZyDwAAQaQALICRBAWtB/wFxs0NFIpE9lEMAABDBkhDMAQshCyAYIA6UIBkgFZSSIA8gDZSSIgwgDJQgEiAOIA6UIBUgFZSSIA0gDZSSIBAgEZIgC5JDAABAQJUiCyALlJOUkyILQwAAAABdDQAgDIwgC5GTIBKVIgsgBmBFIAcgC2BFcg0AICgoAggiJCAoKAIARgRAICgQTwsgKCgCBCAkQQJ0aiALOAIAICggJEEBajYCCAsgCiApQQJ0aiEKICMgKWsiIw0ACwsgJ0EQaiQAICIoAhQiCkGEAU8EQCAKEFoLICYiIyAqSQ0ACwsgIigCECEjICsoAgBBAWoLNgIAICMQDSEJEDMiCCAJJgEgIiAINgIkICIoAgwhIyAiKAIQISQjAEEgayIlJAAgIkEkaigCACIKJQEQCiEmICUgJDYCBCAlICY2AgACQCAkICZGBEAQngEiKhCVASImJQEgIyAkEAghCRAzIiMgCSYBICpBhAFPBEAgKhBaCyAmQYQBTwRAICYQWgsgCiUBICMlAUEAEAkgI0GEAU8EQCAjEFoLICVBIGokAAwBCyAlQQA2AgggJSAlQQRqICVBCGoQfgALICIoAggiCgRAICIoAgwgCkECdEEEELABCyAiKAIEIgpBhAFPBEAgChBaCyAiQTBqJAAgCAwCCyAjICxB5IbAABBqAAsQcAALIgglASAIEFoL+gECAn8BfiMAQRBrIgIkACACQQE7AQwgAiABNgIIIAIgADYCBCMAQRBrIgEkACACQQRqIgApAgAhBCABIAA2AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEHglsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALIAAgAzYCBCAAIAI2AgAgAEHElsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALJQAgAEUEQEGYj8AAQTIQuQEACyAAIAIgAyAEIAUgASgCEBEIAAsoACABIAAoAgAtAABBAnQiAEHkp8AAaigCACAAQdCnwABqKAIAEJkBCyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQEQkACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQER4ACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQESAACygBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAFBARCwAQsLJwAgAEEcakEAIAJC2KGkg7Hi0d18URtBACABQpXX3ZjDl4qMC1EbCyEAIABFBEBBmI/AAEEyELkBAAsgACACIAMgASgCEBEDAAsfACAARQRAQZiPwABBMhC5AQALIAAgAiABKAIQEQAAC+MVAQx/EDMiBCABJgECfyAAIQYQMyIAIAImASMAQdAAayIIJAAgCCAANgIYIAggBDYCFCAIQRRqKAIAEMoBIQtBvM7AACgCAEUEQEHkzsAAQQA2AgBB2M7AAEEANgIAQczOwABBADYCAEHAzsAAQQA2AgBB4M7AACgCACEFQeDOwABBBDYCAEHczsAAKAIAIQ1B3M7AAEEANgIAQdTOwAAoAgAhA0HUzsAAQQQ2AgBB0M7AACgCACEJQdDOwABBADYCAEHIzsAAKAIAIQRByM7AAEECNgIAQcTOwAAoAgAhB0HEzsAAQQA2AgBBvM7AACgCACEAQbzOwABBATYCAAJAIABFDQAgBwRAIAQgB0EBdEECELABCyAJBEAgAyAJQQJ0QQQQsAELIA1FDQAgBSAN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IABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAUkEQCABQZyvwABBAiAAIARqQYABakEAIABrECEgASAFNgIcIAEgBzYCBCABIAY2AgAgBEGAAWokAAwBCyACQYABQYyvwAAQaAALCwwAIAAgASkCADcDAAsNACABQfCYwABBAhAeCw0AIABBhJzAACABECkLDgAgAUGvm8AAQQUQmQELDgAgAUG8p8AAQRIQmQELDQAgAEHQqcAAIAEQKQsOACABQcipwABBBRCZAQsZACAAIAFBjM/AACgCACIAQTogABsRAgAACw0AIABBzK7AACABECkLCgAgAiAAIAEQHguQBQEHfwJAAn8CQCACIgUgACABa0sEQCABIAJqIQMgACACaiECIAAgBUEQSQ0CGiACQXxxIQRBACACQQNxIgZrIQcgBgRAIANBAWshAANAIAJBAWsiAiAALQAAOgAAIABBAWshACACIARLDQALCyAEIAUgBmsiBkF8cSIFayECIAMgB2oiA0EDcQRAIAVBAEwNAiADQQN0IgBBGHEhByADQXxxIghBBGshAUEAIABrQRhxIQkgCCgCACEAA0AgBEEEayIEIAAgCXQgASgCACIAIAd2cjYCACABQQRrIQEgAiAESQ0ACwwCCyAFQQBMDQEgASAGakEEayEBA0AgBEEEayIEIAEoAgA2AgAgAUEEayEBIAIgBEkNAAsMAQsCQCAFQRBJBEAgACECDAELIABBACAAa0EDcSIDaiEEIAMEQCAAIQIgASEAA0AgAiAALQAAOgAAIABBAWohACACQQFqIgIgBEkNAAsLIAQgBSADayIFQXxxIgZqIQICQCABIANqIgNBA3EEQCAGQQBMDQEgA0EDdCIAQRhxIQcgA0F8cSIIQQRqIQFBACAAa0EYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkkNAAsMAQsgBkEATA0AIAMhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJJDQALCyAFQQNxIQUgAyAGaiEBCyAFRQ0CIAIgBWohAANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIABJDQALDAILIAZBA3EiAEUNASADIAVrIQMgAiAAawshACADQQFrIQEDQCACQQFrIgIgAS0AADoA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YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwB0AxAATwAAAGgDAAA0AAAAdAMQAE8AAABvAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAA4EEABLAAAAxAcAAB0AAAAOBBAASwAAAMwHAAAdAAAAHAAAAAwAAAAEAAAAHQAAAB4AAAAfAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikvcnVzdGMvOTBiMzVhNjIzOWMzZDhiZGFiYzUzMGE2YTA4MTZmN2ZmODlhMGFhZi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnPJBBAASwAAAMAFAAANAAAAAAAAABAAAAAEAAAAIgAAACMAAAAkAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwAAVAUQAF4AAABnBAAADgAAAAEAAAAAAAAAOiAAAMwFEAACAAAACgpDYXVzZWQgYnk6CgAAACUAAAAMAAAABAAAACYAAAAnAAAAHwAAAAoKc3RhY2sgYmFja3RyYWNlOlN0YWNrIGJhY2t0cmFjZToKABIGEAARAAAAUwBBuIzAAAvZBAEAAAAoAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQDJBBAASwAAAHsKAAAOAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc4gGEABMAAAALQoAACQAAAAAAAAAEAAAAAQAAAAiAAAAIwAAACQAAAAgICAgOiAAAAEAAAAAAAAAAAcQAAIAAAAgICAgICAgL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnMAGwcQAFwAAAD7GAAAAQAAAAAAAAAEAAAABAAAADUAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZMoHEAAqAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMA/AcQAF8AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABsCBAADgAAAPwHEABfAAAAegIAAA0AQZyRwAALlQ8EAAAABAAAADsAAAA6AAAAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAMQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADECBAAKQAAAK4EAAANAAAAc3RkL3NyYy9iYWNrdHJhY2UucnNvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtgAkQACgAAAAkAAAAAAAAAAIAAACoCRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAGwJEAAUAAAAigEAAB0AAABAAAAAEAAAAAQAAABBAAAAQgAAAAEAAAAAAAAAOiBzdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzABYKEAAZAAAA0AAAABMAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleEAKEAAgAAAAc3RkL3NyYy9zeXMvc3luYy9tdXRleC9ub190aHJlYWRzLnJzaAoQACQAAAAUAAAACQAAAHN0ZC9zcmMvc3luYy9vbmNlLnJznAoQABQAAACeAAAAMgAAADx1bmtub3duPu+/vW1lbW9yeSBhbGxvY2F0aW9uIG9mICBieXRlcyBmYWlsZWQAAMwKEAAVAAAA4QoQAA0AAABzdGQvc3JjL2FsbG9jLnJzAAsQABAAAABjAQAACQAAAAoAAAA8AAAADAAAAAQAAABDAAAAAAAAAAgAAAAEAAAARAAAAAAAAAAIAAAABAAAAEUAAABGAAAARwAAAEgAAABJAAAAEAAAAAQAAABKAAAASwAAAEwAAABNAAAAc3RkL3NyYy8uLi8uLi9iYWNrdHJhY2Uvc3JjL3N5bWJvbGl6ZS9tb2QucnN8CxAALAAAAGcBAAAwAAAAAQAAAAAAAAAUChAAAgAAACAtIAABAAAAAAAAAMgLEAADAAAAICAgICAgICAgICAgICAgICAgIGF0IAAAqAgQAAEAAABPbmNlIGluc3RhbmNlIGhhcyBwcmV2aW91c2x5IGJlZW4gcG9pc29uZWQAAPwLEAAqAAAAb25lLXRpbWUgaW5pdGlhbGl6YXRpb24gbWF5IG5vdCBiZSBwZXJmb3JtZWQgcmVjdXJzaXZlbHkwDBAAOAAAACgpAAAAAAAABAAAAAQAAABRAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9vcHMvZnVuY3Rpb24ucnOEDBAAUAAAAKYAAAAFAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zdHIvcGF0dGVybi5ycwDkDBAATwAAAMgFAAAUAAAA5AwQAE8AAADIBQAAIQAAAOQMEABPAAAAvAUAACEAAAAwMTIzNDU2Nzg5YWJjZGVmAAAAAAAAAAABAAAAUgAAAGNhbGxlZCBgUmVzdWx0Ojp1bndyYXAoKWAgb24gYW4gYEVycmAgdmFsdWVFcnJvckVtcHR5SW52YWxpZERpZ2l0UG9zT3ZlcmZsb3dOZWdPdmVyZmxvd1plcm8AAAAAAAQAAAAEAAAAUwAAAFBhcnNlSW50RXJyb3JraW5kAAAAAAAAAAwAAAAEAAAAVAAAAFUAAABWAAAA5AwQAE8AAABMBAAAJAAAAOQMEABPAAAAvgEAADcAAABfWk4vcnVzdC9kZXBzL3J1c3RjLWRlbWFuZ2xlLTAuMS4yNC9zcmMvbGVnYWN5LnJzAAAAPw4QAC4AAAA9AAAACwAAAD8OEAAuAAAAOgAAAAsAAAA/DhAALgAAADYAAAALAAAAPw4QAC4AAABmAAAAHAAAAD8OEAAuAAAAbwAAACcAAAA/DhAALgAAAHAAAAAdAAAAPw4QAC4AAAByAAAAIQAAAD8OEAAuAAAAcwAAABoAAAA/DhAALgAAAHQAAAAZAAAAOjoAAD8OEAAuAAAAfgAAAB0AAAA/DhAALgAAALQAAAAmAAAAPw4QAC4AAAC1AAAAIQAAAD8OEAAuAAAAigAAAEkAAAA/DhAALgAAAIsAAAAfAAAAPw4QAC4AAACLAAAALwAAAEMAAAA/DhAALgAAAJ0AAAA1AAAALCkoPjwmKkA/DhAALgAAAIIAAAAsAAAAPw4QAC4AAACEAAAAJQAAAC4AAAA/DhAALgAAAIcAAAAlAAAAAAAAAAEAAAABAAAAVwAAAD8OEAAuAAAAcgAAAEgAAABfX1IvcnVzdC9kZXBzL3J1c3RjLWRlbWFuZ2xlLTAuMS4yNC9zcmMvdjAucnMAAADXDxAAKgAAADIAAAATAAAA1w8QACoAAAAvAAAAEwAAANcPEAAqAAAAKwAAABMAQbygwAAL6QkBAAAAWAAAAGBmbXQ6OkVycm9yYHMgc2hvdWxkIGJlIGltcG9zc2libGUgd2l0aG91dCBhIGBmbXQ6OkZvcm1hdHRlcmAAAADXDxAAKgAAAEsAAAAOAAAA1w8QACoAAABaAAAAKAAAANcPEAAqAAAAigAAAA0AAABwdW55Y29kZXstfTDXDxAAKgAAAB4BAAAxAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZdcPEAAqAAAAMQEAABYAAADXDxAAKgAAADQBAABHAAAAaW50ZXJuYWwgZXJyb3I6IGVudGVyZWQgdW5yZWFjaGFibGUgY29kZTogc3RyOjpmcm9tX3V0ZjgoKSA9ICB3YXMgZXhwZWN0ZWQgdG8gaGF2ZSAxIGNoYXIsIGJ1dCAgY2hhcnMgd2VyZSBmb3VuZBgREAA5AAAAUREQAAQAAABVERAAIgAAAHcREAARAAAA1w8QACoAAABcAQAAGgAAAGJvb2xjaGFyc3RyaThpMTZpMzJpNjRpMTI4aXNpemV1OHUxNnUzMnU2NHUxMjh1c2l6ZWYzMmY2NCFfLi4uAADXDxAAKgAAAL8BAAAfAAAA1w8QACoAAAAeAgAAHgAAANcPEAAqAAAAIwIAACIAAADXDxAAKgAAACQCAAAlAAAA1w8QACoAAACHAgAAEQAAAHtpbnZhbGlkIHN5bnRheH17cmVjdXJzaW9uIGxpbWl0IHJlYWNoZWR9Pydmb3I8PiAsIFtdOjp7Y2xvc3VyZXNoaW06IyBhcyAgbXV0IGNvbnN0IDsgZHluICArIHVuc2FmZSBleHRlcm4gItcPEAAqAAAA1AMAAC0AAAAiIGZuKCAtPiAgPSBmYWxzZXRydWV7IHsgIH06IDB4ANcPEAAqAAAAygQAAC0AAAAubGx2bS4vcnVzdC9kZXBzL3J1c3RjLWRlbWFuZ2xlLTAuMS4yNC9zcmMvbGliLnJzAAAA+hIQACsAAABiAAAAGwAAAPoSEAArAAAAaQAAABMAAAABAAAAAAAAAHtzaXplIGxpbWl0IHJlYWNoZWR9AAAAAAAAAAABAAAAWQAAAGBmbXQ6OkVycm9yYCBmcm9tIGBTaXplTGltaXRlZEZtdEFkYXB0ZXJgIHdhcyBkaXNjYXJkZWQA+hIQACsAAABTAQAAHgAAAFNpemVMaW1pdEV4aGF1c3RlZAAABQAAAAwAAAALAAAACwAAAAQAAAC0DRAAuQ0QAMUNEADQDRAA2w0QAAIAAAAEAAAABAAAAAMAAAADAAAAAwAAAAQAAAACAAAABQAAAAUAAAAEAAAAAwAAAAMAAAAEAAAABAAAAAEAAAAEAAAABAAAAAMAAAADAAAAAgAAAAMAAAAEAAAAAwAAAAMAAAABAAAAwxEQALgREAC8ERAA7hEQAMAREADrERAAuBEQANcREADSERAA5hEQALgREADIERAA3BEQAM4READiERAA8hEQALgREAC4ERAAxREQANkREABwDBAA8xEQALgREADLERAA3xEQAPEREABFcnJvcgAAAFoAAAAMAAAABAAAAFsAAABcAAAAXQAAAGNhcGFjaXR5IG92ZXJmbG93AAAA6BQQABEAAABhbGxvYy9zcmMvcmF3X3ZlYy5ycwQVEAAUAAAAGAAAAAUAQbCqwAALsAoBAAAAXgAAAGEgZm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAjhUQABAAAAB+AgAADgAAAGZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kILAVEAA8AAAALi4wMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAAABQWEAASAAAAAQAAAAAAAABbY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABkFhAAIAAAAIQWEAASAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAsxYQABAAAADDFhAAFwAAANoWEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAALMWEAAQAAAA/BYQABAAAAAMFxAACQAAANoWEAAJAAAAOiAAAAEAAAAAAAAAOBcQAAIAAAAAAAAADAAAAAQAAABlAAAAZgAAAGcAAAAgICAgIHsgLCAgewosCn0gfQpdY29yZS9zcmMvZm10L251bS5ycwAAdxcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9mbXQvbW9kLnJzZmFsc2V0cnVlAABmGBAAEwAAAKMJAAAmAAAAZhgQABMAAACsCQAAGgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2Yg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\", import.meta.url));\n  const A = ts();\n  (typeof s == \"string\" || typeof Request == \"function\" && s instanceof Request || typeof URL == \"function\" && s instanceof URL) && (s = fetch(s));\n  const { instance: t, module: e } = await As(await s, A);\n  return es(t, e);\n}\nconst RA = -9, ss = 9, YA = (ss - RA) / 254, is = 11, as = 11, x = 1 << is, kA = 1 << as, rs = 1;\nfunction ns(s) {\n  return s === \"bool\" || s === \"bvec2\" || s === \"bvec3\" || s === \"bvec4\";\n}\nfunction MA(s) {\n  return s === \"int\" || s === \"ivec2\" || s === \"ivec3\" || s === \"ivec4\";\n}\nfunction FA(s) {\n  return s === \"uint\" || s === \"uvec2\" || s === \"uvec3\" || s === \"uvec4\";\n}\nfunction gs(s) {\n  return s === \"float\" || s === \"vec2\" || s === \"vec3\" || s === \"vec4\";\n}\nfunction os(s) {\n  return s === \"mat2\" || s === \"mat2x2\" || s === \"mat2x3\" || s === \"mat2x4\" || s === \"mat3\" || s === \"mat3x2\" || s === \"mat3x3\" || s === \"mat3x4\" || s === \"mat4\" || s === \"mat4x2\" || s === \"mat4x3\" || s === \"mat4x4\";\n}\nfunction VA(s) {\n  return gs(s) || os(s);\n}\nfunction vA(s) {\n  return s === \"mat2\" || s === \"mat2x2\";\n}\nfunction GA(s) {\n  return s === \"mat3\" || s === \"mat3x3\";\n}\nfunction UA(s) {\n  return s === \"mat4\" || s === \"mat4x4\";\n}\nfunction Is(s) {\n  switch (s) {\n    case \"vec2\":\n      return \"float\";\n    case \"vec3\":\n      return \"float\";\n    case \"vec4\":\n      return \"float\";\n    case \"ivec2\":\n      return \"int\";\n    case \"ivec3\":\n      return \"int\";\n    case \"ivec4\":\n      return \"int\";\n    case \"uvec2\":\n      return \"uint\";\n    case \"uvec3\":\n      return \"uint\";\n    case \"uvec4\":\n      return \"uint\";\n    default:\n      throw new Error(`Invalid vector type: ${s}`);\n  }\n}\nfunction Bs(s) {\n  switch (s) {\n    case \"vec2\":\n    case \"ivec2\":\n    case \"uvec2\":\n      return 2;\n    case \"vec3\":\n    case \"ivec3\":\n    case \"uvec3\":\n      return 3;\n    case \"vec4\":\n    case \"ivec4\":\n    case \"uvec4\":\n      return 4;\n    default:\n      throw new Error(`Invalid vector type: ${s}`);\n  }\n}\nfunction R(s) {\n  return Math.trunc(s).toString();\n}\nfunction v(s) {\n  return `${Math.max(0, Math.trunc(s)).toString()}u`;\n}\nfunction m(s) {\n  return s === Number.POSITIVE_INFINITY ? \"INFINITY\" : s === Number.NEGATIVE_INFINITY ? \"-INFINITY\" : Number.isInteger(s) ? s.toFixed(1) : s.toString();\n}\nfunction xA(s) {\n  return s instanceof NA ? s.type : s.dynoOut().type;\n}\nclass NA {\n  constructor(A) {\n    this.__isDynoValue = !0, this.type = A;\n  }\n}\nclass P extends NA {\n  constructor(A, t) {\n    super(A.outTypes[t]), this.dyno = A, this.key = t;\n  }\n}\nclass it extends NA {\n  constructor(A, t) {\n    super(A), this.literal = t;\n  }\n  getLiteral() {\n    return this.literal;\n  }\n}\nclass Qs extends it {\n  constructor(A, t) {\n    super(A, \"\"), this.value = t;\n  }\n  getLiteral() {\n    const { type: A, value: t } = this;\n    switch (A) {\n      case \"bool\":\n        return t ? \"true\" : \"false\";\n      case \"uint\":\n        return v(t);\n      case \"int\":\n        return R(t);\n      case \"float\":\n        return m(t);\n      case \"bvec2\": {\n        const e = t;\n        return `bvec2(${e[0]}, ${e[1]})`;\n      }\n      case \"uvec2\": {\n        if (t instanceof B.Vector2)\n          return `uvec2(${v(t.x)}, ${v(t.y)})`;\n        const e = t;\n        return `uvec2(${v(e[0])}, ${v(e[1])})`;\n      }\n      case \"ivec2\": {\n        if (t instanceof B.Vector2)\n          return `ivec2(${R(t.x)}, ${R(t.y)})`;\n        const e = t;\n        return `ivec2(${R(e[0])}, ${R(e[1])})`;\n      }\n      case \"vec2\": {\n        if (t instanceof B.Vector2)\n          return `vec2(${m(t.x)}, ${m(t.y)})`;\n        const e = t;\n        return `vec2(${m(e[0])}, ${m(e[1])})`;\n      }\n      case \"bvec3\": {\n        const e = t;\n        return `bvec3(${e[0]}, ${e[1]}, ${e[2]})`;\n      }\n      case \"uvec3\": {\n        if (t instanceof B.Vector3)\n          return `uvec3(${v(t.x)}, ${v(t.y)}, ${v(t.z)})`;\n        const e = t;\n        return `uvec3(${v(e[0])}, ${v(e[1])}, ${v(e[2])})`;\n      }\n      case \"ivec3\": {\n        if (t instanceof B.Vector3)\n          return `ivec3(${R(t.x)}, ${R(t.y)}, ${R(t.z)})`;\n        const e = t;\n        return `ivec3(${R(e[0])}, ${R(e[1])}, ${R(e[2])})`;\n      }\n      case \"vec3\": {\n        if (t instanceof B.Vector3)\n          return `vec3(${m(t.x)}, ${m(t.y)}, ${m(t.z)})`;\n        const e = t;\n        return `vec3(${m(e[0])}, ${m(e[1])}, ${m(e[2])})`;\n      }\n      case \"bvec4\": {\n        const e = t;\n        return `bvec4(${e[0]}, ${e[1]}, ${e[2]}, ${e[3]})`;\n      }\n      case \"uvec4\": {\n        if (t instanceof B.Vector4)\n          return `uvec4(${v(t.x)}, ${v(t.y)}, ${v(t.z)}, ${v(t.w)})`;\n        const e = t;\n        return `uvec4(${v(e[0])}, ${v(e[1])}, ${v(e[2])}, ${v(e[3])})`;\n      }\n      case \"ivec4\": {\n        if (t instanceof B.Vector4)\n          return `ivec4(${R(t.x)}, ${R(t.y)}, ${R(t.z)}, ${R(t.w)})`;\n        const e = t;\n        return `ivec4(${R(e[0])}, ${R(e[1])}, ${R(e[2])}, ${R(e[3])})`;\n      }\n      case \"vec4\": {\n        if (t instanceof B.Vector4)\n          return `vec4(${m(t.x)}, ${m(t.y)}, ${m(t.z)}, ${m(t.w)})`;\n        if (t instanceof B.Quaternion)\n          return `vec4(${m(t.x)}, ${m(t.y)}, ${m(t.z)}, ${m(t.w)})`;\n        const e = t;\n        return `vec4(${m(e[0])}, ${m(e[1])}, ${m(e[2])}, ${m(e[3])})`;\n      }\n      case \"mat2\":\n      case \"mat2x2\": {\n        const e = t, i = e instanceof B.Matrix2 ? e.elements : t, a = new Array(4).fill(0).map((r, n) => m(i[n]));\n        return `${A}(${a.join(\", \")})`;\n      }\n      case \"mat2x3\": {\n        const e = t, i = new Array(6).fill(0).map((a, r) => m(e[r]));\n        return `${A}(${i.join(\", \")})`;\n      }\n      case \"mat2x4\": {\n        const e = t, i = new Array(8).fill(0).map((a, r) => m(e[r]));\n        return `${A}(${i.join(\", \")})`;\n      }\n      case \"mat3\":\n      case \"mat3x3\": {\n        const e = t, i = e instanceof B.Matrix3 ? e.elements : t, a = new Array(9).fill(0).map((r, n) => m(i[n]));\n        return `${A}(${a.join(\", \")})`;\n      }\n      case \"mat3x2\": {\n        const e = t, i = new Array(6).fill(0).map((a, r) => m(e[r]));\n        return `${A}(${i.join(\", \")})`;\n      }\n      case \"mat3x4\": {\n        const e = t, i = new Array(12).fill(0).map((a, r) => m(e[r]));\n        return `${A}(${i.join(\", \")})`;\n      }\n      case \"mat4\":\n      case \"mat4x4\": {\n        const e = t, i = e instanceof B.Matrix4 ? e.elements : t, a = new Array(16).fill(0).map((r, n) => m(i[n]));\n        return `${A}(${a.join(\", \")})`;\n      }\n      case \"mat4x2\": {\n        const e = t, i = new Array(8).fill(0).map((a, r) => m(e[r]));\n        return `${A}(${i.join(\", \")})`;\n      }\n      case \"mat4x3\": {\n        const e = t, i = new Array(12).fill(0).map((a, r) => m(e[r]));\n        return `${A}(${i.join(\", \")})`;\n      }\n      default:\n        throw new Error(`Type not implemented: ${String(A)}`);\n    }\n  }\n}\nfunction wt(s, A) {\n  return new Qs(s, A);\n}\nfunction XA(s) {\n  const A = String(s);\n  if (ns(s))\n    return `${A}(false)`;\n  if (VA(s))\n    return `${A}(0.0)`;\n  if (MA(s))\n    return `${A}(0)`;\n  if (FA(s))\n    return `${A}(0u)`;\n  throw new Error(`Type not implemented: ${A}`);\n}\nconst Jt = \"    \";\nclass cs {\n  constructor({ indent: A } = {}) {\n    this.globals = /* @__PURE__ */ new Set(), this.statements = [], this.uniforms = {}, this.declares = /* @__PURE__ */ new Set(), this.updaters = [], this.sequence = 0, this.indent = Jt, this.indent = A ?? Jt;\n  }\n  nextSequence() {\n    return this.sequence++;\n  }\n}\nclass Y {\n  constructor({\n    inTypes: A,\n    outTypes: t,\n    inputs: e,\n    update: i,\n    globals: a,\n    statements: r,\n    generate: n\n  }) {\n    this.inTypes = A ?? {}, this.outTypes = t ?? {}, this.inputs = e ?? {}, this.update = i, this.globals = a, this.statements = r, this.generate = n ?? (({ inputs: I, outputs: o, compile: Q }) => {\n      var g, c;\n      return {\n        globals: (g = this.globals) == null ? void 0 : g.call(this, { inputs: I, outputs: o, compile: Q }),\n        statements: (c = this.statements) == null ? void 0 : c.call(this, { inputs: I, outputs: o, compile: Q })\n      };\n    });\n  }\n  get outputs() {\n    const A = {};\n    for (const t in this.outTypes)\n      A[t] = new P(this, t);\n    return A;\n  }\n  apply(A) {\n    return Object.assign(this.inputs, A), this.outputs;\n  }\n  compile({\n    inputs: A,\n    outputs: t,\n    compile: e\n  }) {\n    const i = [\n      `// ${this.constructor.name}(${Object.values(A).join(\", \")}) => (${Object.values(t).join(\", \")})`\n    ], a = [];\n    for (const o in t) {\n      const Q = t[o];\n      Q && !e.declares.has(Q) && (e.declares.add(Q), a.push(o));\n    }\n    const { globals: r, statements: n, uniforms: I } = this.generate({\n      inputs: A,\n      outputs: t,\n      compile: e\n    });\n    for (const o of r ?? [])\n      e.globals.add(o);\n    for (const o in I)\n      e.uniforms[o] = I[o];\n    this.update && e.updaters.push(this.update);\n    for (const o of a) {\n      const Q = t[o];\n      Q && (e.uniforms[Q] || i.push(`${te(Q, this.outTypes[o])};`));\n    }\n    return n != null && n.length && (i.push(\"{\"), i.push(...n.map((o) => e.indent + o)), i.push(\"}\")), i;\n  }\n}\nclass Cs extends Y {\n  constructor({\n    inTypes: A,\n    outTypes: t,\n    inputs: e,\n    update: i,\n    globals: a,\n    construct: r\n  }) {\n    super({\n      inTypes: A,\n      outTypes: t,\n      inputs: e,\n      update: i,\n      globals: a,\n      generate: (n) => this.generateBlock(n)\n    }), this.construct = r;\n  }\n  generateBlock({\n    inputs: A,\n    outputs: t,\n    compile: e\n  }) {\n    var i, a;\n    const r = {}, n = {};\n    for (const C in A)\n      A[C] != null && (r[C] = new it(this.inTypes[C], A[C]));\n    for (const C in t)\n      t[C] != null && (n[C] = new NA(this.outTypes[C]));\n    const I = { roots: [] }, o = this.construct(r, n, I);\n    for (const C of ((i = this.globals) == null ? void 0 : i.call(this, { inputs: A, outputs: t, compile: e })) ?? [])\n      e.globals.add(C);\n    const Q = [], g = /* @__PURE__ */ new Map();\n    function c(C, u, y) {\n      let d = g.get(C);\n      if (!d) {\n        d = {\n          sequence: e.nextSequence(),\n          outNames: /* @__PURE__ */ new Map(),\n          newOuts: /* @__PURE__ */ new Set()\n        }, g.set(C, d);\n        for (const h in C.inputs) {\n          let p = C.inputs[h];\n          for (; p; ) {\n            if (p instanceof NA) {\n              p instanceof P && c(p.dyno, p.key);\n              break;\n            }\n            p = p.dynoOut();\n          }\n        }\n        Q.push(C);\n      }\n      u && (y || d.newOuts.add(u), d.outNames.set(u, y ?? `${u}_${d.sequence}`));\n    }\n    for (const C of I.roots)\n      c(C);\n    for (const C in n) {\n      let u = (o == null ? void 0 : o[C]) ?? n[C];\n      for (; u; ) {\n        if (u instanceof NA) {\n          u instanceof P && c(u.dyno, u.key, t[C]);\n          break;\n        }\n        u = u.dynoOut();\n      }\n      n[C] = u;\n    }\n    const E = [];\n    for (const C of Q) {\n      const u = {}, y = {};\n      for (const p in C.inputs) {\n        let f = C.inputs[p];\n        for (; f; ) {\n          if (f instanceof NA) {\n            if (f instanceof it)\n              u[p] = f.getLiteral();\n            else if (f instanceof P) {\n              const D = (a = g.get(f.dyno)) == null ? void 0 : a.outNames.get(f.key);\n              if (!D)\n                throw new Error(\n                  `Source not found for ${f.dyno.constructor.name}.${f.key}`\n                );\n              u[p] = D;\n            }\n            break;\n          }\n          f = f.dynoOut();\n        }\n      }\n      const d = g.get(C) ?? { outNames: /* @__PURE__ */ new Map() };\n      for (const [p, f] of d.outNames.entries())\n        y[p] = f;\n      const h = C.compile({ inputs: u, outputs: y, compile: e });\n      E.push(h);\n    }\n    const l = [];\n    for (const C in t)\n      n[C] instanceof it && l.push(\n        `${t[C]} = ${n[C].getLiteral()};`\n      );\n    return l.length > 0 && E.push(l), { statements: E.flatMap((C, u) => u === 0 ? C : [\"\", ...C]) };\n  }\n}\nfunction SA(s, A, t, { update: e, globals: i } = {}) {\n  return new Cs({ inTypes: s, outTypes: A, construct: t, update: e, globals: i });\n}\nfunction Qt({\n  inTypes: s,\n  outTypes: A,\n  inputs: t,\n  update: e,\n  globals: i,\n  statements: a,\n  generate: r\n}) {\n  return new Y({\n    inTypes: s,\n    outTypes: A,\n    inputs: t,\n    update: e,\n    globals: i,\n    statements: a,\n    generate: r\n  });\n}\nfunction te(s, A, t) {\n  const e = typeof A == \"string\" ? A : A.type;\n  if (!e)\n    throw new Error(`Invalid DynoType: ${String(A)}`);\n  return `${e} ${s}${t != null ? `[${t}]` : \"\"}`;\n}\nfunction BA(s) {\n  var A;\n  let t = !1;\n  const e = s.split(`\n`).map((r) => {\n    const n = r.trimEnd();\n    return t ? n : n.length > 0 ? (t = !0, n) : null;\n  }).filter((r) => r != null);\n  for (; e.length > 0 && e[e.length - 1].length === 0; )\n    e.pop();\n  if (e.length === 0)\n    return [];\n  const i = (A = e[0].match(/^\\s*/)) == null ? void 0 : A[0];\n  if (!i)\n    return e;\n  const a = new RegExp(`^${i}`);\n  return e.map((r) => r.replace(a, \"\"));\n}\nfunction O(s) {\n  return BA(s).join(`\n`);\n}\nclass Nt extends Y {\n  constructor({\n    a: A,\n    outKey: t,\n    outTypeFunc: e\n  }) {\n    const i = { a: xA(A) }, a = e(xA(A)), r = { [t]: a };\n    super({ inTypes: i, outTypes: r, inputs: { a: A } }), this.outKey = t;\n  }\n  dynoOut() {\n    return new P(this, this.outKey);\n  }\n}\nclass ct extends Y {\n  constructor({\n    a: A,\n    b: t,\n    outKey: e,\n    outTypeFunc: i\n  }) {\n    const a = { a: xA(A), b: xA(t) }, r = i(xA(A), xA(t)), n = { [e]: r };\n    super({ inTypes: a, outTypes: n, inputs: { a: A, b: t } }), this.outKey = e;\n  }\n  dynoOut() {\n    return new P(this, this.outKey);\n  }\n}\nconst G = { type: \"Gsplat\" }, Ct = { type: \"PackedSplats\" }, gt = (s, A) => new ls({ packedSplats: s, index: A }), Es = (s, A, t, e) => new hs({ packedSplats: s, index: A, base: t, count: e }), at = (s) => new us({ gsplat: s }), Et = ({\n  gsplat: s,\n  flags: A,\n  index: t,\n  center: e,\n  scales: i,\n  quaternion: a,\n  rgba: r,\n  rgb: n,\n  opacity: I,\n  x: o,\n  y: Q,\n  z: g,\n  r: c,\n  g: E,\n  b: l\n}) => new ds({\n  gsplat: s,\n  flags: A,\n  index: t,\n  center: e,\n  scales: i,\n  quaternion: a,\n  rgba: r,\n  rgb: n,\n  opacity: I,\n  x: o,\n  y: Q,\n  z: g,\n  r: c,\n  g: E,\n  b: l\n}), ee = (s, {\n  scale: A,\n  rotate: t,\n  translate: e,\n  recolor: i\n}) => new ps({ gsplat: s, scale: A, rotate: t, translate: e, recolor: i }), QA = O(`\n  struct Gsplat {\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n`), Rt = O(`\n  struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n  };\n`), se = O(`\n  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\n      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);\n      return true;\n    } else {\n      return false;\n    }\n  }\n`);\nclass ls extends Y {\n  constructor({\n    packedSplats: A,\n    index: t\n  }) {\n    super({\n      inTypes: { packedSplats: Ct, index: \"int\" },\n      outTypes: { gsplat: G },\n      inputs: { packedSplats: A, index: t },\n      globals: () => [QA, Rt, se],\n      statements: ({ inputs: e, outputs: i }) => {\n        const { gsplat: a } = i;\n        if (!a)\n          return [];\n        const { packedSplats: r, index: n } = e;\n        let I;\n        return r && n ? I = BA(`\n            if (readPackedSplat(${r}.texture, ${r}.numSplats, ${n}, ${a})) {\n              bool zeroSize = all(equal(${a}.scales, vec3(0.0, 0.0, 0.0)));\n              ${a}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } else {\n              ${a}.flags = 0u;\n            }\n          `) : I = [`${a}.flags = 0u;`], I.push(`${a}.index = ${n ?? \"0\"};`), I;\n      }\n    });\n  }\n  dynoOut() {\n    return new P(this, \"gsplat\");\n  }\n}\nclass hs extends Y {\n  constructor({\n    packedSplats: A,\n    index: t,\n    base: e,\n    count: i\n  }) {\n    super({\n      inTypes: {\n        packedSplats: Ct,\n        index: \"int\",\n        base: \"int\",\n        count: \"int\"\n      },\n      outTypes: { gsplat: G },\n      inputs: { packedSplats: A, index: t, base: e, count: i },\n      globals: () => [QA, Rt, se],\n      statements: ({ inputs: a, outputs: r }) => {\n        const { gsplat: n } = r;\n        if (!n)\n          return [];\n        const { packedSplats: I, index: o, base: Q, count: g } = a;\n        let c;\n        return I && o && Q && g ? c = BA(`\n            ${n}.flags = 0u;\n            if ((${o} >= ${Q}) && (${o} < (${Q} + ${g}))) {\n              if (readPackedSplat(${I}.texture, ${I}.numSplats, ${o}, ${n})) {\n                bool zeroSize = all(equal(${n}.scales, vec3(0.0, 0.0, 0.0)));\n                ${n}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          `) : c = [`${n}.flags = 0u;`], c.push(`${n}.index = ${o ?? \"0\"};`), c;\n      }\n    });\n  }\n  dynoOut() {\n    return new P(this, \"gsplat\");\n  }\n}\nclass us extends Y {\n  constructor({ gsplat: A }) {\n    super({\n      inTypes: { gsplat: G },\n      outTypes: {\n        flags: \"uint\",\n        active: \"bool\",\n        index: \"int\",\n        center: \"vec3\",\n        scales: \"vec3\",\n        quaternion: \"vec4\",\n        rgba: \"vec4\",\n        rgb: \"vec3\",\n        opacity: \"float\",\n        x: \"float\",\n        y: \"float\",\n        z: \"float\",\n        r: \"float\",\n        g: \"float\",\n        b: \"float\"\n      },\n      inputs: { gsplat: A },\n      globals: () => [QA],\n      statements: ({ inputs: t, outputs: e }) => {\n        const { gsplat: i } = t, {\n          flags: a,\n          active: r,\n          index: n,\n          center: I,\n          scales: o,\n          quaternion: Q,\n          rgba: g,\n          rgb: c,\n          opacity: E,\n          x: l,\n          y: C,\n          z: u,\n          r: y,\n          g: d,\n          b: h\n        } = e;\n        return [\n          a ? `${a} = ${i ? `${i}.flags` : \"0u\"};` : null,\n          r ? `${r} = isGsplatActive(${i ? `${i}.flags` : \"0u\"});` : null,\n          n ? `${n} = ${i ? `${i}.index` : \"0\"};` : null,\n          I ? `${I} = ${i ? `${i}.center` : \"vec3(0.0, 0.0, 0.0)\"};` : null,\n          o ? `${o} = ${i ? `${i}.scales` : \"vec3(0.0, 0.0, 0.0)\"};` : null,\n          Q ? `${Q} = ${i ? `${i}.quaternion` : \"vec4(0.0, 0.0, 0.0, 1.0)\"};` : null,\n          g ? `${g} = ${i ? `${i}.rgba` : \"vec4(0.0, 0.0, 0.0, 0.0)\"};` : null,\n          c ? `${c} = ${i ? `${i}.rgba.rgb` : \"vec3(0.0, 0.0, 0.0)\"};` : null,\n          E ? `${E} = ${i ? `${i}.rgba.a` : \"0.0\"};` : null,\n          l ? `${l} = ${i ? `${i}.center.x` : \"0.0\"};` : null,\n          C ? `${C} = ${i ? `${i}.center.y` : \"0.0\"};` : null,\n          u ? `${u} = ${i ? `${i}.center.z` : \"0.0\"};` : null,\n          y ? `${y} = ${i ? `${i}.rgba.r` : \"0.0\"};` : null,\n          d ? `${d} = ${i ? `${i}.rgba.g` : \"0.0\"};` : null,\n          h ? `${h} = ${i ? `${i}.rgba.b` : \"0.0\"};` : null\n        ].filter(Boolean);\n      }\n    });\n  }\n}\nclass ds extends Y {\n  constructor({\n    gsplat: A,\n    flags: t,\n    index: e,\n    center: i,\n    scales: a,\n    quaternion: r,\n    rgba: n,\n    rgb: I,\n    opacity: o,\n    x: Q,\n    y: g,\n    z: c,\n    r: E,\n    g: l,\n    b: C\n  }) {\n    super({\n      inTypes: {\n        gsplat: G,\n        flags: \"uint\",\n        index: \"int\",\n        center: \"vec3\",\n        scales: \"vec3\",\n        quaternion: \"vec4\",\n        rgba: \"vec4\",\n        rgb: \"vec3\",\n        opacity: \"float\",\n        x: \"float\",\n        y: \"float\",\n        z: \"float\",\n        r: \"float\",\n        g: \"float\",\n        b: \"float\"\n      },\n      outTypes: { gsplat: G },\n      inputs: {\n        gsplat: A,\n        flags: t,\n        index: e,\n        center: i,\n        scales: a,\n        quaternion: r,\n        rgba: n,\n        rgb: I,\n        opacity: o,\n        x: Q,\n        y: g,\n        z: c,\n        r: E,\n        g: l,\n        b: C\n      },\n      globals: () => [QA],\n      statements: ({ inputs: u, outputs: y }) => {\n        const { gsplat: d } = y;\n        if (!d)\n          return [];\n        const {\n          gsplat: h,\n          flags: p,\n          index: f,\n          center: D,\n          scales: k,\n          quaternion: b,\n          rgba: T,\n          rgb: J,\n          opacity: H,\n          x: U,\n          y: M,\n          z: F,\n          r: V,\n          g: z,\n          b: N\n        } = u;\n        return [\n          `${d}.flags = ${p ?? (h ? `${h}.flags` : \"0u\")};`,\n          `${d}.index = ${f ?? (h ? `${h}.index` : \"0\")};`,\n          `${d}.center = ${D ?? (h ? `${h}.center` : \"vec3(0.0, 0.0, 0.0)\")};`,\n          `${d}.scales = ${k ?? (h ? `${h}.scales` : \"vec3(0.0, 0.0, 0.0)\")};`,\n          `${d}.quaternion = ${b ?? (h ? `${h}.quaternion` : \"vec4(0.0, 0.0, 0.0, 1.0)\")};`,\n          `${d}.rgba = ${T ?? (h ? `${h}.rgba` : \"vec4(0.0, 0.0, 0.0, 0.0)\")};`,\n          J ? `${d}.rgba.rgb = ${J};` : null,\n          H ? `${d}.rgba.a = ${H};` : null,\n          U ? `${d}.center.x = ${U};` : null,\n          M ? `${d}.center.y = ${M};` : null,\n          F ? `${d}.center.z = ${F};` : null,\n          V ? `${d}.rgba.r = ${V};` : null,\n          z ? `${d}.rgba.g = ${z};` : null,\n          N ? `${d}.rgba.b = ${N};` : null\n        ].filter(Boolean);\n      }\n    });\n  }\n  dynoOut() {\n    return new P(this, \"gsplat\");\n  }\n}\nO(`\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if (scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if (scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n      normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, normal);\n  }\n`);\nclass ps extends Y {\n  constructor({\n    gsplat: A,\n    scale: t,\n    rotate: e,\n    translate: i,\n    recolor: a\n  }) {\n    super({\n      inTypes: {\n        gsplat: G,\n        scale: \"float\",\n        rotate: \"vec4\",\n        translate: \"vec3\",\n        recolor: \"vec4\"\n      },\n      outTypes: { gsplat: G },\n      inputs: { gsplat: A, scale: t, rotate: e, translate: i, recolor: a },\n      globals: () => [QA],\n      statements: ({ inputs: r, outputs: n, compile: I }) => {\n        const { gsplat: o } = n;\n        if (!o || !r.gsplat)\n          return [];\n        const { scale: Q, rotate: g, translate: c, recolor: E } = r, l = I.indent;\n        return [\n          `${o} = ${r.gsplat};`,\n          `if (isGsplatActive(${o}.flags)) {`,\n          Q ? `${l}${o}.center *= ${Q};` : null,\n          g ? `${l}${o}.center = quatVec(${g}, ${o}.center);` : null,\n          c ? `${l}${o}.center += ${c};` : null,\n          Q ? `${l}${o}.scales *= ${Q};` : null,\n          g ? `${l}${o}.quaternion = quatQuat(${g}, ${o}.quaternion);` : null,\n          E ? `${l}${o}.rgba *= ${E};` : null,\n          \"}\"\n        ].filter(Boolean);\n      }\n    });\n  }\n  dynoOut() {\n    return new P(this, \"gsplat\");\n  }\n}\nconst ys = (s) => new fs({ gsplat: s });\nclass fs extends Y {\n  constructor({ gsplat: A }) {\n    super({\n      inTypes: { gsplat: G },\n      inputs: { gsplat: A },\n      globals: () => [QA],\n      statements: ({ inputs: t, outputs: e }) => {\n        const { output: i } = e;\n        if (!i)\n          return [];\n        const { gsplat: a } = t;\n        return a ? BA(`\n            if (isGsplatActive(${a}.flags)) {\n              ${i} = packSplat(${a}.center, ${a}.scales, ${a}.quaternion, ${a}.rgba);\n            } else {\n              ${i} = uvec4(0u, 0u, 0u, 0u);\n            }\n          `) : [`${i} = uvec4(0u, 0u, 0u, 0u);`];\n      }\n    });\n  }\n  dynoOut() {\n    return new P(this, \"output\");\n  }\n}\nclass ms extends Y {\n  constructor({ rgba8: A }) {\n    super({\n      inTypes: { rgba8: \"vec4\" },\n      inputs: { rgba8: A },\n      statements: ({ inputs: t, outputs: e }) => [\n        `target = ${t.rgba8 ?? \"vec4(0.0, 0.0, 0.0, 0.0)\"};`\n      ]\n    });\n  }\n  dynoOut() {\n    return new P(this, \"rgba8\");\n  }\n}\nclass oA extends Y {\n  constructor({\n    key: A,\n    type: t,\n    count: e,\n    value: i,\n    update: a,\n    globals: r\n  }) {\n    A = A ?? \"value\", super({\n      outTypes: { [A]: t },\n      update: () => {\n        if (a) {\n          const n = a(this.value);\n          n !== void 0 && (this.value = n);\n        }\n        this.uniform.value = this.value;\n      },\n      generate: ({ inputs: n, outputs: I }) => {\n        const o = (r == null ? void 0 : r({ inputs: n, outputs: I })) ?? [], Q = {}, g = I[A];\n        return g && (o.push(`uniform ${te(g, t, e)};`), Q[g] = this.uniform), { globals: o, uniforms: Q };\n      }\n    }), this.type = t, this.count = e, this.value = i, this.uniform = { value: i }, this.outKey = A;\n  }\n  dynoOut() {\n    return new P(this, this.outKey);\n  }\n}\nclass Ht extends oA {\n  constructor({\n    key: A,\n    value: t,\n    update: e\n  }) {\n    super({ key: A, type: \"bool\", value: t, update: e });\n  }\n}\nclass Dt extends oA {\n  constructor({\n    key: A,\n    value: t,\n    update: e\n  }) {\n    super({ key: A, type: \"int\", value: t, update: e });\n  }\n}\nclass jA extends oA {\n  constructor({\n    key: A,\n    value: t,\n    update: e\n  }) {\n    super({ key: A, type: \"float\", value: t, update: e });\n  }\n}\nclass ot extends oA {\n  constructor({\n    key: A,\n    value: t,\n    update: e\n  }) {\n    super({ key: A, type: \"vec3\", value: t, update: e });\n  }\n}\nclass vt extends oA {\n  constructor({\n    key: A,\n    value: t,\n    update: e\n  }) {\n    super({ key: A, type: \"vec4\", value: t, update: e });\n  }\n}\nclass lt extends oA {\n  constructor({\n    key: A,\n    value: t,\n    update: e\n  }) {\n    super({ key: A, type: \"usampler2DArray\", value: t, update: e });\n  }\n}\nvar _ = Uint8Array, KA = Uint16Array, ws = Int32Array, ie = new _([\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  1,\n  1,\n  2,\n  2,\n  2,\n  2,\n  3,\n  3,\n  3,\n  3,\n  4,\n  4,\n  4,\n  4,\n  5,\n  5,\n  5,\n  5,\n  0,\n  /* unused */\n  0,\n  0,\n  /* impossible */\n  0\n]), ae = new _([\n  0,\n  0,\n  0,\n  0,\n  1,\n  1,\n  2,\n  2,\n  3,\n  3,\n  4,\n  4,\n  5,\n  5,\n  6,\n  6,\n  7,\n  7,\n  8,\n  8,\n  9,\n  9,\n  10,\n  10,\n  11,\n  11,\n  12,\n  12,\n  13,\n  13,\n  /* unused */\n  0,\n  0\n]), Ds = new _([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), re = function(s, A) {\n  for (var t = new KA(31), e = 0; e < 31; ++e)\n    t[e] = A += 1 << s[e - 1];\n  for (var i = new ws(t[30]), e = 1; e < 30; ++e)\n    for (var a = t[e]; a < t[e + 1]; ++a)\n      i[a] = a - t[e] << 5 | e;\n  return { b: t, r: i };\n}, ne = re(ie, 2), ge = ne.b, xs = ne.r;\nge[28] = 258, xs[258] = 28;\nvar Ss = re(ae, 0), bs = Ss.b, oe = new KA(32768);\nfor (var S = 0; S < 32768; ++S) {\n  var DA = (S & 43690) >> 1 | (S & 21845) << 1;\n  DA = (DA & 52428) >> 2 | (DA & 13107) << 2, DA = (DA & 61680) >> 4 | (DA & 3855) << 4, oe[S] = ((DA & 65280) >> 8 | (DA & 255) << 8) >> 1;\n}\nvar PA = function(s, A, t) {\n  for (var e = s.length, i = 0, a = new KA(A); i < e; ++i)\n    s[i] && ++a[s[i] - 1];\n  var r = new KA(A);\n  for (i = 1; i < A; ++i)\n    r[i] = r[i - 1] + a[i - 1] << 1;\n  var n;\n  {\n    n = new KA(1 << A);\n    var I = 15 - A;\n    for (i = 0; i < e; ++i)\n      if (s[i])\n        for (var o = i << 4 | s[i], Q = A - s[i], g = r[s[i] - 1]++ << Q, c = g | (1 << Q) - 1; g <= c; ++g)\n          n[oe[g] >> I] = o;\n  }\n  return n;\n}, WA = new _(288);\nfor (var S = 0; S < 144; ++S)\n  WA[S] = 8;\nfor (var S = 144; S < 256; ++S)\n  WA[S] = 9;\nfor (var S = 256; S < 280; ++S)\n  WA[S] = 7;\nfor (var S = 280; S < 288; ++S)\n  WA[S] = 8;\nvar Ie = new _(32);\nfor (var S = 0; S < 32; ++S)\n  Ie[S] = 5;\nvar ks = /* @__PURE__ */ PA(WA, 9), Ms = /* @__PURE__ */ PA(Ie, 5), ht = function(s) {\n  for (var A = s[0], t = 1; t < s.length; ++t)\n    s[t] > A && (A = s[t]);\n  return A;\n}, iA = function(s, A, t) {\n  var e = A / 8 | 0;\n  return (s[e] | s[e + 1] << 8) >> (A & 7) & t;\n}, ut = function(s, A) {\n  var t = A / 8 | 0;\n  return (s[t] | s[t + 1] << 8 | s[t + 2] << 16) >> (A & 7);\n}, Be = function(s) {\n  return (s + 7) / 8 | 0;\n}, rt = function(s, A, t) {\n  return (A == null || A < 0) && (A = 0), (t == null || t > s.length) && (t = s.length), new _(s.subarray(A, t));\n}, Fs = [\n  \"unexpected EOF\",\n  \"invalid block type\",\n  \"invalid length/literal\",\n  \"invalid distance\",\n  \"stream finished\",\n  \"no stream handler\",\n  ,\n  \"no callback\",\n  \"invalid UTF-8 data\",\n  \"extra field too long\",\n  \"date not in range 1980-2099\",\n  \"filename too long\",\n  \"stream finishing\",\n  \"invalid zip data\"\n  // determined by unknown compression method\n], X = function(s, A, t) {\n  var e = new Error(A || Fs[s]);\n  if (e.code = s, Error.captureStackTrace && Error.captureStackTrace(e, X), !t)\n    throw e;\n  return e;\n}, Ns = function(s, A, t, e) {\n  var i = s.length, a = 0;\n  if (!i || A.f && !A.l)\n    return t || new _(0);\n  var r = !t, n = r || A.i != 2, I = A.i;\n  r && (t = new _(i * 3));\n  var o = function(sA) {\n    var dA = t.length;\n    if (sA > dA) {\n      var pA = new _(Math.max(dA * 2, sA));\n      pA.set(t), t = pA;\n    }\n  }, Q = A.f || 0, g = A.p || 0, c = A.b || 0, E = A.l, l = A.d, C = A.m, u = A.n, y = i * 8;\n  do {\n    if (!E) {\n      Q = iA(s, g, 1);\n      var d = iA(s, g + 1, 3);\n      if (g += 3, d)\n        if (d == 1)\n          E = ks, l = Ms, C = 9, u = 5;\n        else if (d == 2) {\n          var h = iA(s, g, 31) + 257, p = iA(s, g + 10, 15) + 4, f = h + iA(s, g + 5, 31) + 1;\n          g += 14;\n          for (var D = new _(f), k = new _(19), b = 0; b < p; ++b)\n            k[Ds[b]] = iA(s, g + b * 3, 7);\n          g += p * 3;\n          for (var T = ht(k), J = (1 << T) - 1, H = PA(k, T), b = 0; b < f; ) {\n            var U = H[iA(s, g, J)];\n            g += U & 15;\n            var M = U >> 4;\n            if (M < 16)\n              D[b++] = M;\n            else {\n              var F = 0, V = 0;\n              for (M == 16 ? (V = 3 + iA(s, g, 3), g += 2, F = D[b - 1]) : M == 17 ? (V = 3 + iA(s, g, 7), g += 3) : M == 18 && (V = 11 + iA(s, g, 127), g += 7); V--; )\n                D[b++] = F;\n            }\n          }\n          var z = D.subarray(0, h), N = D.subarray(h);\n          C = ht(z), u = ht(N), E = PA(z, C), l = PA(N, u);\n        } else\n          X(1);\n      else {\n        var M = Be(g) + 4, W = s[M - 4] | s[M - 3] << 8, AA = M + W;\n        if (AA > i) {\n          I && X(0);\n          break;\n        }\n        n && o(c + W), t.set(s.subarray(M, AA), c), A.b = c += W, A.p = g = AA * 8, A.f = Q;\n        continue;\n      }\n      if (g > y) {\n        I && X(0);\n        break;\n      }\n    }\n    n && o(c + 131072);\n    for (var uA = (1 << C) - 1, aA = (1 << u) - 1, rA = g; ; rA = g) {\n      var F = E[ut(s, g) & uA], j = F >> 4;\n      if (g += F & 15, g > y) {\n        I && X(0);\n        break;\n      }\n      if (F || X(2), j < 256)\n        t[c++] = j;\n      else if (j == 256) {\n        rA = g, E = null;\n        break;\n      } else {\n        var cA = j - 254;\n        if (j > 264) {\n          var b = j - 257, tA = ie[b];\n          cA = iA(s, g, (1 << tA) - 1) + ge[b], g += tA;\n        }\n        var nA = l[ut(s, g) & aA], w = nA >> 4;\n        nA || X(3), g += nA & 15;\n        var N = bs[w];\n        if (w > 3) {\n          var tA = ae[w];\n          N += ut(s, g) & (1 << tA) - 1, g += tA;\n        }\n        if (g > y) {\n          I && X(0);\n          break;\n        }\n        n && o(c + 131072);\n        var gA = c + cA;\n        if (c < N) {\n          var eA = a - N, CA = Math.min(N, gA);\n          for (eA + c < 0 && X(3); c < CA; ++c)\n            t[c] = e[eA + c];\n        }\n        for (; c < gA; ++c)\n          t[c] = t[c - N];\n      }\n    }\n    A.l = E, A.p = rA, A.b = c, A.f = Q, E && (Q = 1, A.m = C, A.d = l, A.n = u);\n  } while (!Q);\n  return c != t.length && r ? rt(t, 0, c) : t.subarray(0, c);\n}, Rs = /* @__PURE__ */ new _(0), vs = function(s) {\n  (s[0] != 31 || s[1] != 139 || s[2] != 8) && X(6, \"invalid gzip data\");\n  var A = s[3], t = 10;\n  A & 4 && (t += (s[10] | s[11] << 8) + 2);\n  for (var e = (A >> 3 & 1) + (A >> 4 & 1); e > 0; e -= !s[t++])\n    ;\n  return t + (A & 2);\n}, dt = /* @__PURE__ */ function() {\n  function s(A, t) {\n    typeof A == \"function\" && (t = A, A = {}), this.ondata = t;\n    var e = A && A.dictionary && A.dictionary.subarray(-32768);\n    this.s = { i: 0, b: e ? e.length : 0 }, this.o = new _(32768), this.p = new _(0), e && this.o.set(e);\n  }\n  return s.prototype.e = function(A) {\n    if (this.ondata || X(5), this.d && X(4), !this.p.length)\n      this.p = A;\n    else if (A.length) {\n      var t = new _(this.p.length + A.length);\n      t.set(this.p), t.set(A, this.p.length), this.p = t;\n    }\n  }, s.prototype.c = function(A) {\n    this.s.i = +(this.d = A || !1);\n    var t = this.s.b, e = Ns(this.p, this.s, this.o);\n    this.ondata(rt(e, t, this.s.b), this.d), this.o = rt(e, this.s.b - 32768), this.s.b = this.o.length, this.p = rt(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n  }, s.prototype.push = function(A, t) {\n    this.e(A), this.c(t);\n  }, s;\n}(), Gs = /* @__PURE__ */ function() {\n  function s(A, t) {\n    this.v = 1, this.r = 0, dt.call(this, A, t);\n  }\n  return s.prototype.push = function(A, t) {\n    if (dt.prototype.e.call(this, A), this.r += A.length, this.v) {\n      var e = this.p.subarray(this.v - 1), i = e.length > 3 ? vs(e) : 4;\n      if (i > e.length) {\n        if (!t)\n          return;\n      } else this.v > 1 && this.onmember && this.onmember(this.r - e.length);\n      this.p = e.subarray(i), this.v = 0;\n    }\n    dt.prototype.c.call(this, t), this.s.f && !this.s.l && !t && (this.v = Be(this.s.p) + 9, this.s = { i: 0 }, this.o = new _(0), this.push(new _(0), t));\n  }, s;\n}(), Us = typeof TextDecoder < \"u\" && /* @__PURE__ */ new TextDecoder(), Ls = 0;\ntry {\n  Us.decode(Rs, { stream: !0 }), Ls = 1;\n} catch {\n}\nconst Gt = new Float32Array(1), Qe = new Uint32Array(Gt.buffer);\nfunction pt(s) {\n  Gt[0] = s;\n  const A = Qe[0], t = A >> 31 & 1, e = A >> 23 & 255, i = A & 8388607, a = t << 15;\n  if (e === 255)\n    return i !== 0 ? a | 32767 : a | 31744;\n  const r = e - 127 + 15;\n  if (r >= 31)\n    return a | 31744;\n  if (r <= 0) {\n    if (r < -10)\n      return a;\n    const I = (i | 8388608) >> 1 - r + 13;\n    return a | I;\n  }\n  const n = i >> 13;\n  return a | r << 10 | n;\n}\nfunction yt(s) {\n  const A = s >> 15 & 1, t = s >> 10 & 31, e = s & 1023;\n  let i;\n  if (t === 0)\n    if (e === 0)\n      i = A << 31;\n    else {\n      let a = e, r = -14;\n      for (; !(a & 1024); )\n        a <<= 1, r--;\n      a &= 1023;\n      const n = r + 127, I = a << 13;\n      i = A << 31 | n << 23 | I;\n    }\n  else if (t === 31)\n    e === 0 ? i = A << 31 | 2139095040 : i = A << 31 | 2143289344;\n  else {\n    const a = t - 15 + 127, r = e << 13;\n    i = A << 31 | a << 23 | r;\n  }\n  return Qe[0] = i, Gt[0];\n}\nfunction $A(s) {\n  return Math.max(0, Math.min(255, Math.round(s * 255)));\n}\nfunction _s(s) {\n  const A = [], t = /* @__PURE__ */ new Set();\n  function e(i) {\n    i && typeof i == \"object\" && !t.has(i) && (t.add(i), i instanceof ArrayBuffer ? A.push(i) : ArrayBuffer.isView(i) ? A.push(i.buffer) : Array.isArray(i) ? i.forEach(e) : Object.values(i).forEach(e));\n  }\n  return e(s), A;\n}\nclass Ys {\n  constructor({\n    // Allocate a new item with the given args\n    allocate: A,\n    // Dispose of an item (optional, if GC is enough)\n    dispose: t,\n    // Check if an existing item in the list is valid for the given args,\n    // allowing you to store heterogeneous items in the list.\n    valid: e\n  }) {\n    this.items = [], this.allocate = A, this.dispose = t, this.valid = e;\n  }\n  // Allocate a new item from the free list, first checking if a existing item\n  // on the freelist is valid for the given args.\n  alloc(A) {\n    for (; ; ) {\n      const t = this.items.pop();\n      if (!t)\n        break;\n      if (this.valid(t, A))\n        return t;\n      this.dispose && this.dispose(t);\n    }\n    return this.allocate(A);\n  }\n  free(A) {\n    this.items.push(A);\n  }\n  disposeAll() {\n    let A;\n    for (A = this.items.pop(); A; )\n      this.dispose && this.dispose(A), A = this.items.pop();\n  }\n}\nfunction qt(s, A, t, e, i, a, r, n, I, o, Q, g, c, E, l, C) {\n  const u = $A(E), y = $A(l), d = $A(C), h = $A(c), p = Zs(\n    new B.Quaternion(I, o, Q, g)\n  ), f = p & 255, D = p >>> 8 & 255, k = p >>> 16 & 255, b = a === 0 ? 0 : Math.min(\n    255,\n    Math.max(\n      0,\n      Math.round((Math.log(a) - RA) / YA) + 1\n    )\n  ), T = r === 0 ? 0 : Math.min(\n    255,\n    Math.max(\n      0,\n      Math.round((Math.log(r) - RA) / YA) + 1\n    )\n  ), J = n === 0 ? 0 : Math.min(\n    255,\n    Math.max(\n      0,\n      Math.round((Math.log(n) - RA) / YA) + 1\n    )\n  ), H = pt(t), U = pt(e), M = pt(i), F = A * 4;\n  s[F] = u | y << 8 | d << 16 | h << 24, s[F + 1] = H | U << 16, s[F + 2] = M | f << 16 | D << 24, s[F + 3] = b | T << 8 | J << 16 | k << 24;\n}\nconst Ts = new B.Vector3(), Js = new B.Vector3(), Hs = new B.Quaternion(), qs = new B.Color(), zs = {\n  center: Ts,\n  scales: Js,\n  quaternion: Hs,\n  color: qs,\n  opacity: 0\n};\nfunction zt(s, A) {\n  const t = zs, e = A * 4, i = s[e], a = s[e + 1], r = s[e + 2], n = s[e + 3];\n  t.color.set(\n    (i & 255) / 255,\n    (i >>> 8 & 255) / 255,\n    (i >>> 16 & 255) / 255\n  ), t.opacity = (i >>> 24 & 255) / 255, t.center.set(\n    yt(a & 65535),\n    yt(a >>> 16 & 65535),\n    yt(r & 65535)\n  );\n  const I = n & 255;\n  t.scales.x = I === 0 ? 0 : Math.exp(RA + (I - 1) * YA);\n  const o = n >>> 8 & 255;\n  t.scales.y = o === 0 ? 0 : Math.exp(RA + (o - 1) * YA);\n  const Q = n >>> 16 & 255;\n  t.scales.z = Q === 0 ? 0 : Math.exp(RA + (Q - 1) * YA);\n  const g = r >>> 16 & 65535 | n >>> 8 & 16711680;\n  return Ws(g, t.quaternion), t;\n}\nfunction $(s) {\n  const A = x, t = Math.max(\n    rs,\n    Math.min(kA, Math.ceil(s / A))\n  ), e = Math.ceil(s / (A * t)), i = A * t * e;\n  return { width: A, height: t, depth: e, maxSplats: i };\n}\nfunction Ks(s) {\n  const A = new B.Clock(s.autoStart);\n  return A.startTime = s.startTime, A.oldTime = s.oldTime, A.elapsedTime = s.elapsedTime, A.running = s.running, A;\n}\nconst Ps = O(`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n`);\nfunction Os(s) {\n  const A = new B.Vector3();\n  for (const t of s)\n    A.add(t);\n  return A.divideScalar(s.length);\n}\nfunction Vs(s) {\n  if (s.length === 0)\n    return new B.Quaternion();\n  const A = s[0].clone();\n  for (let t = 1; t < s.length; t++)\n    s[t].dot(s[0]) < 0 ? (A.x -= s[t].x, A.y -= s[t].y, A.z -= s[t].z, A.w -= s[t].w) : (A.x += s[t].x, A.y += s[t].y, A.z += s[t].z, A.w += s[t].w);\n  return A.normalize();\n}\nfunction js(s, A) {\n  const [t, e] = [new B.Vector3(), new B.Quaternion()], [i, a] = [new B.Vector3(), new B.Quaternion()];\n  s.decompose(t, e, new B.Vector3()), A.decompose(i, a, new B.Vector3());\n  const r = t.distanceTo(i), n = Math.abs(e.dot(a));\n  return { distance: r, coorient: n };\n}\nfunction xt({\n  matrix1: s,\n  matrix2: A,\n  maxDistance: t,\n  minCoorient: e\n}) {\n  const { distance: i, coorient: a } = js(s, A);\n  return i <= t && (e == null || a >= e);\n}\nfunction Zs(s) {\n  const A = s.clone().normalize();\n  A.w < 0 && A.set(-A.x, -A.y, -A.z, -A.w);\n  const t = 2 * Math.acos(A.w), e = Math.sqrt(\n    A.x * A.x + A.y * A.y + A.z * A.z\n  ), i = e < 1e-6 ? new B.Vector3(1, 0, 0) : new B.Vector3(A.x, A.y, A.z).divideScalar(e), a = Math.abs(i.x) + Math.abs(i.y) + Math.abs(i.z);\n  let r = i.x / a, n = i.y / a;\n  if (i.z < 0) {\n    const c = r;\n    r = (1 - Math.abs(n)) * (r >= 0 ? 1 : -1), n = (1 - Math.abs(c)) * (n >= 0 ? 1 : -1);\n  }\n  const I = r * 0.5 + 0.5, o = n * 0.5 + 0.5, Q = Math.round(I * 255), g = Math.round(o * 255);\n  return Math.round(t * (255 / Math.PI)) << 16 | g << 8 | Q;\n}\nfunction Ws(s, A) {\n  const t = s & 255, e = s >>> 8 & 255, i = s >>> 16 & 255, a = t / 255, r = e / 255;\n  let n = (a - 0.5) * 2, I = (r - 0.5) * 2;\n  const o = 1 - (Math.abs(n) + Math.abs(I)), Q = Math.max(-o, 0);\n  n += n >= 0 ? -Q : Q, I += I >= 0 ? -Q : Q;\n  const g = new B.Vector3(n, I, o).normalize(), c = i / 255 * Math.PI * 0.5, E = Math.sin(c), l = Math.cos(c);\n  return A.set(g.x * E, g.y * E, g.z * E, l), A;\n}\nfunction Xs(s, A) {\n  const t = [];\n  let e = 0, i = null;\n  const a = new Gs((I, o) => {\n    if (t.push(I), e += I.length, o || e >= A) {\n      const Q = new Uint8Array(e);\n      let g = 0;\n      for (const c of t)\n        Q.set(c, g), g += c.length;\n      i = Q.slice(0, A);\n    }\n  }), r = 1024;\n  let n = 0;\n  for (; i == null && n < s.length; ) {\n    const I = s.slice(n, n + r);\n    a.push(I, !1), n += r;\n  }\n  if (i == null && (a.push(new Uint8Array(), !0), i == null))\n    throw new Error(\"Failed to decompress partial gzip\");\n  return i;\n}\nclass ce {\n  constructor({\n    graph: A,\n    inputs: t,\n    outputs: e,\n    template: i\n  }) {\n    this.graph = A, this.template = i, this.inputs = t ?? {}, this.outputs = e ?? {};\n    const a = new cs({ indent: this.template.indent });\n    for (const n in this.outputs)\n      this.outputs[n] && a.declares.add(this.outputs[n]);\n    const r = A.compile({\n      inputs: this.inputs,\n      outputs: this.outputs,\n      compile: a\n    });\n    this.shader = i.generate({ globals: a.globals, statements: r }), this.uniforms = a.uniforms, this.updaters = a.updaters;\n  }\n  prepareMaterial() {\n    return $s(this);\n  }\n  update() {\n    for (const A of this.updaters)\n      A();\n  }\n}\nclass Ce {\n  constructor(A) {\n    const t = A.match(/^([ \\t]*)\\{\\{\\s*GLOBALS\\s*\\}\\}/m), e = A.match(/^([ \\t]*)\\{\\{\\s*STATEMENTS\\s*\\}\\}/m);\n    if (!t || !e)\n      throw new Error(\n        \"Template must contain {{ GLOBALS }} and {{ STATEMENTS }}\"\n      );\n    this.before = A.substring(0, t.index), this.between = A.substring(\n      t.index + t[0].length,\n      e.index\n    ), this.after = A.substring(\n      e.index + e[0].length\n    ), this.indent = e[1];\n  }\n  generate({\n    globals: A,\n    statements: t\n  }) {\n    return this.before + Array.from(A).join(`\n\n`) + this.between + t.map((e) => this.indent + e).join(`\n`) + this.after;\n  }\n}\nconst Kt = /* @__PURE__ */ new Map();\nfunction $s(s) {\n  let A = Kt.get(s);\n  return A || (A = new B.RawShaderMaterial({\n    glslVersion: B.GLSL3,\n    vertexShader: Ps,\n    fragmentShader: s.shader,\n    uniforms: s.uniforms\n  }), Kt.set(s, A), A);\n}\nfunction Ee(s, A, t = \"add\") {\n  const e = () => {\n    throw new Error(`Invalid ${t} types: ${s}, ${A}`);\n  };\n  if (s === A) return s;\n  if (s === \"int\") {\n    if (MA(A)) return A;\n    e();\n  }\n  if (A === \"int\") {\n    if (MA(s)) return s;\n    e();\n  }\n  if (s === \"uint\") {\n    if (FA(A)) return A;\n    e();\n  }\n  if (A === \"uint\") {\n    if (FA(s)) return s;\n    e();\n  }\n  if (s === \"float\") {\n    if (VA(A)) return A;\n    e();\n  }\n  if (A === \"float\") {\n    if (VA(s)) return s;\n    e();\n  }\n  throw new Error(`Invalid ${t} types: ${s}, ${A}`);\n}\nfunction Ai(s, A) {\n  return Ee(s, A, \"sub\");\n}\nfunction ti(s, A) {\n  const t = () => {\n    throw new Error(`Invalid mul types: ${s}, ${A}`);\n  }, e = (i) => i;\n  if (s === \"int\") {\n    if (MA(A)) return e(A);\n    t();\n  }\n  if (A === \"int\") {\n    if (MA(s)) return e(s);\n    t();\n  }\n  if (s === \"uint\") {\n    if (FA(A)) return e(A);\n    t();\n  }\n  if (A === \"uint\") {\n    if (FA(s)) return e(s);\n    t();\n  }\n  if (s === \"float\") {\n    if (VA(A)) return e(A);\n    t();\n  }\n  if (A === \"float\") {\n    if (VA(s)) return e(s);\n    t();\n  }\n  if (MA(s) || FA(s) || MA(A) || FA(A)) {\n    if (s === A) return e(s);\n    t();\n  }\n  if (s === \"vec2\") {\n    if (A === \"vec2\" || vA(A)) return e(\"vec2\");\n    if (A === \"mat3x2\") return e(\"vec3\");\n    if (A === \"mat4x2\") return e(\"vec4\");\n    t();\n  }\n  if (s === \"vec3\") {\n    if (A === \"mat2x3\") return e(\"vec2\");\n    if (A === \"vec3\" || GA(A)) return e(\"vec3\");\n    if (A === \"mat4x3\") return e(\"vec4\");\n    t();\n  }\n  if (s === \"vec4\") {\n    if (A === \"mat2x4\") return e(\"vec2\");\n    if (A === \"mat3x4\") return e(\"vec3\");\n    if (A === \"vec4\" || UA(A)) return e(\"vec4\");\n    t();\n  }\n  if (A === \"vec2\") {\n    if (vA(s)) return e(\"vec2\");\n    if (s === \"mat2x3\") return e(\"vec3\");\n    if (s === \"mat2x4\") return e(\"vec4\");\n    t();\n  }\n  if (A === \"vec3\") {\n    if (s === \"mat3x2\") return e(\"vec2\");\n    if (GA(s)) return e(\"vec3\");\n    if (s === \"mat3x4\") return e(\"vec4\");\n    t();\n  }\n  if (A === \"vec4\") {\n    if (s === \"mat4x2\") return e(\"vec2\");\n    if (s === \"mat4x3\") return e(\"vec3\");\n    if (UA(s)) return e(\"vec4\");\n    t();\n  }\n  if (vA(s)) {\n    if (vA(A)) return e(\"mat2\");\n    if (A === \"mat3x2\") return e(\"mat3x2\");\n    if (A === \"mat4x2\") return e(\"mat4x2\");\n    t();\n  }\n  if (s === \"mat2x3\") {\n    if (vA(A)) return e(\"mat2x3\");\n    if (A === \"mat3x2\") return e(\"mat3\");\n    if (A === \"mat4x2\") return e(\"mat4x3\");\n    t();\n  }\n  if (s === \"mat2x4\") {\n    if (vA(A)) return e(\"mat2x4\");\n    if (A === \"mat3x2\") return e(\"mat3x4\");\n    if (A === \"mat4x2\") return e(\"mat4\");\n    t();\n  }\n  if (s === \"mat3x2\") {\n    if (A === \"mat2x3\") return e(\"mat2\");\n    if (GA(A)) return e(\"mat3x2\");\n    if (A === \"mat4x3\") return e(\"mat4x2\");\n    t();\n  }\n  if (GA(s)) {\n    if (A === \"mat2x3\") return e(\"mat2x3\");\n    if (GA(A)) return e(\"mat3\");\n    if (A === \"mat4x3\") return e(\"mat4x3\");\n    t();\n  }\n  if (s === \"mat3x4\") {\n    if (A === \"mat2x3\") return e(\"mat2x4\");\n    if (GA(A)) return e(\"mat3x4\");\n    if (A === \"mat4x3\") return e(\"mat4\");\n    t();\n  }\n  if (s === \"mat4x2\") {\n    if (A === \"mat2x4\") return e(\"mat2\");\n    if (A === \"mat3x4\") return e(\"mat3x2\");\n    if (UA(A)) return e(\"mat4x2\");\n    t();\n  }\n  if (s === \"mat4x3\") {\n    if (A === \"mat2x4\") return e(\"mat2x3\");\n    if (A === \"mat3x4\") return e(\"mat3\");\n    if (UA(A)) return e(\"mat4x3\");\n    t();\n  }\n  if (UA(s)) {\n    if (A === \"mat2x4\") return e(\"mat2x4\");\n    if (A === \"mat3x4\") return e(\"mat3x4\");\n    if (UA(A)) return e(\"mat4\");\n    t();\n  }\n  throw new Error(`Invalid mul types: ${s}, ${A}`);\n}\nconst OA = (s, A) => new si({ a: s, b: A }), ei = (s, A) => new ii({ a: s, b: A }), le = (s, A) => new ai({ a: s, b: A });\nclass si extends ct {\n  constructor({ a: A, b: t }) {\n    super({ a: A, b: t, outKey: \"sum\", outTypeFunc: Ee }), this.statements = ({ inputs: e, outputs: i }) => [`${i.sum} = ${e.a} + ${e.b};`];\n  }\n}\nclass ii extends ct {\n  constructor({ a: A, b: t }) {\n    super({ a: A, b: t, outKey: \"difference\", outTypeFunc: Ai }), this.statements = ({ inputs: e, outputs: i }) => [`${i.difference} = ${e.a} - ${e.b};`];\n  }\n}\nclass ai extends ct {\n  constructor({ a: A, b: t }) {\n    super({ a: A, b: t, outKey: \"product\", outTypeFunc: ti }), this.statements = ({ inputs: e, outputs: i }) => [`${i.product} = ${e.a} * ${e.b};`];\n  }\n}\nconst ri = (s) => new gi({ value: s }), ni = (s) => new oi({ value: s });\nclass gi extends Nt {\n  constructor({ value: A }) {\n    super({ a: A, outKey: \"uint\", outTypeFunc: () => \"uint\" }), this.statements = ({ inputs: t, outputs: e }) => [`${e.uint} = packHalf2x16(${t.a});`];\n  }\n}\nclass oi extends Nt {\n  constructor({ value: A }) {\n    super({ a: A, outKey: \"rgba8\", outTypeFunc: () => \"vec4\" }), this.statements = ({ inputs: t, outputs: e }) => [\n      `uvec4 uRgba = uvec4(${t.a} & 0xffu, (${t.a} >> 8u) & 0xffu, (${t.a} >> 16u) & 0xffu, (${t.a} >> 24u) & 0xffu);`,\n      `${e.rgba8} = vec4(uRgba) / 255.0;`\n    ];\n  }\n}\nconst Ii = (s) => new ci({ a: s }), Bi = ({\n  vector: s,\n  vectorType: A,\n  x: t,\n  y: e,\n  z: i,\n  w: a,\n  r,\n  g: n,\n  b: I,\n  a: o\n}) => new li({ vector: s, vectorType: A, x: t, y: e, z: i, w: a, r, g: n, b: I, a: o }), Qi = (s, A) => new Ei({ a: s, b: A });\nclass ci extends Nt {\n  constructor({ a: A }) {\n    super({ a: A, outTypeFunc: (t) => t, outKey: \"normalize\" }), this.statements = ({ inputs: t, outputs: e }) => [\n      `${e.normalize} = normalize(${t.a});`\n    ];\n  }\n}\nfunction Ci(s) {\n  if (s === \"float\") return \"vec2\";\n  if (s === \"vec2\") return \"vec3\";\n  if (s === \"vec3\") return \"vec4\";\n  throw new Error(\"Invalid type\");\n}\nclass Ei extends ct {\n  constructor({ a: A, b: t }) {\n    const e = xA(A), i = Ci(e);\n    super({ a: A, b: t, outKey: \"extend\", outTypeFunc: () => i }), this.statements = ({ inputs: a, outputs: r }) => [\n      `${r.extend} = ${i}(${a.a}, ${a.b});`\n    ];\n  }\n}\nclass li extends Y {\n  constructor({\n    vector: A,\n    vectorType: t,\n    x: e,\n    y: i,\n    z: a,\n    w: r,\n    r: n,\n    g: I,\n    b: o,\n    a: Q\n  }) {\n    if (!A && !t)\n      throw new Error(\"Either vector or vectorType must be provided\");\n    const g = t ?? xA(A), c = Is(g), E = Bs(g), l = {\n      vector: g,\n      x: c,\n      y: c,\n      r: c,\n      g: c\n    }, C = { vector: A, x: e, y: i, r: n, g: I };\n    E >= 3 && (Object.assign(l, { z: c, b: c }), Object.assign(C, { z: a, b: o })), E >= 4 && (Object.assign(l, { w: c, a: c }), Object.assign(C, { w: r, a: Q })), super({ inTypes: l, outTypes: { vector: g }, inputs: C }), this.statements = ({ inputs: u, outputs: y }) => {\n      const { vector: d } = y, {\n        vector: h,\n        x: p,\n        y: f,\n        z: D,\n        w: k,\n        r: b,\n        g: T,\n        b: J,\n        a: H\n      } = u, U = [\n        `${d}.x = ${p ?? b ?? (h ? `${h}.x` : XA(c))};`,\n        `${d}.y = ${f ?? T ?? (h ? `${h}.y` : XA(c))};`\n      ];\n      return E >= 3 && U.push(\n        `${d}.z = ${D ?? J ?? (h ? `${h}.z` : XA(c))};`\n      ), E >= 4 && U.push(\n        `${d}.w = ${k ?? H ?? (h ? `${h}.w` : XA(c))};`\n      ), U;\n    };\n  }\n  dynoOut() {\n    return new P(\n      this,\n      \"vector\"\n    );\n  }\n}\nconst hi = (s, {\n  scale: A,\n  scales: t,\n  rotate: e,\n  translate: i\n}) => new di({ position: s, scale: A, scales: t, rotate: e, translate: i }).outputs.position, ui = (s, {\n  scale: A,\n  scales: t,\n  rotate: e\n}) => new pi({ dir: s, scale: A, scales: t, rotate: e }).outputs.dir;\nclass di extends Y {\n  constructor({\n    position: A,\n    scale: t,\n    scales: e,\n    rotate: i,\n    translate: a\n  }) {\n    super({\n      inTypes: {\n        position: \"vec3\",\n        scale: \"float\",\n        scales: \"vec3\",\n        rotate: \"vec4\",\n        translate: \"vec3\"\n      },\n      outTypes: { position: \"vec3\" },\n      inputs: { position: A, scale: t, scales: e, rotate: i, translate: a },\n      statements: ({ inputs: r, outputs: n }) => {\n        const { position: I } = n;\n        if (!I)\n          return [];\n        const { scale: o, scales: Q, rotate: g, translate: c } = r;\n        return [\n          `${I} = ${r.position ?? \"vec3(0.0, 0.0, 0.0)\"};`,\n          o ? `${I} *= ${o};` : null,\n          Q ? `${I} *= ${Q};` : null,\n          g ? `${I} = quatVec(${g}, ${I});` : null,\n          c ? `${I} += ${c};` : null\n        ].filter(Boolean);\n      }\n    });\n  }\n}\nclass pi extends Y {\n  constructor({\n    dir: A,\n    scale: t,\n    scales: e,\n    rotate: i\n  }) {\n    super({\n      inTypes: { dir: \"vec3\", scale: \"float\", scales: \"vec3\", rotate: \"vec4\" },\n      outTypes: { dir: \"vec3\" },\n      inputs: { dir: A, scale: t, scales: e, rotate: i },\n      statements: ({ inputs: a, outputs: r }) => {\n        const { dir: n } = r;\n        if (!n)\n          return [];\n        const { scale: I, scales: o, rotate: Q } = a;\n        return [\n          `${n} = ${a.dir ?? \"vec3(0.0, 0.0, 0.0)\"};`,\n          I ? `${n} *= ${I};` : null,\n          o ? `${n} *= ${o};` : null,\n          Q ? `${n} = quatVec(${Q}, ${n});` : null\n        ].filter(Boolean);\n      }\n    });\n  }\n}\nvar yi = `precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout vec4 target;\n\n{{ GLOBALS }}\n\nvoid computeReadback(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        computeReadback(index);\n    } else {\n        target = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}`;\nconst hA = class EA {\n  constructor({ renderer: A } = {}) {\n    this.renderer = A, this.capacity = 0, this.count = 0;\n  }\n  dispose() {\n    this.target && (this.target.dispose(), this.target = void 0);\n  }\n  // Ensure we have a buffer large enough for the readback of count indices.\n  // Pass in previous bufer of the desired type.\n  ensureBuffer(A, t) {\n    const e = Math.ceil(Math.max(1, A) / x) * x * 4;\n    if (t.byteLength >= e)\n      return t;\n    const i = new ArrayBuffer(e);\n    if (t instanceof ArrayBuffer)\n      return i;\n    const a = t.constructor;\n    return new a(i);\n  }\n  // Ensure our render target is large enough for the readback of capacity indices.\n  ensureCapacity(A) {\n    const { width: t, height: e, depth: i, maxSplats: a } = $(A);\n    (!this.target || a > this.capacity) && (this.dispose(), this.capacity = a, this.target = new B.WebGLArrayRenderTarget(t, e, i, {\n      depthBuffer: !1,\n      stencilBuffer: !1,\n      generateMipmaps: !1,\n      magFilter: B.NearestFilter,\n      minFilter: B.NearestFilter\n    }), this.target.texture.format = B.RGBAFormat, this.target.texture.type = B.UnsignedByteType, this.target.texture.internalFormat = \"RGBA8\");\n  }\n  // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,\n  // generating it if necessary and caching the result.\n  prepareProgramMaterial(A) {\n    let t = EA.readbackProgram.get(A);\n    if (!t) {\n      const i = SA(\n        { index: \"int\" },\n        { rgba8: \"vec4\" },\n        ({ index: a }) => (A.inputs.index = a, { rgba8: new ms({ rgba8: A.outputs.rgba8 }) })\n      );\n      EA.programTemplate || (EA.programTemplate = new Ce(yi)), t = new ce({\n        graph: i,\n        inputs: { index: \"index\" },\n        outputs: { rgba8: \"target\" },\n        template: EA.programTemplate\n      }), Object.assign(t.uniforms, {\n        targetLayer: { value: 0 },\n        targetBase: { value: 0 },\n        targetCount: { value: 0 }\n      }), EA.readbackProgram.set(A, t);\n    }\n    const e = t.prepareMaterial();\n    return EA.mesh.material = e, { program: t, material: e };\n  }\n  saveRenderState(A) {\n    return {\n      xrPresenting: A.xr.isPresenting,\n      autoClear: A.autoClear,\n      scissorTest: A.getScissorTest(),\n      pixelRatio: A.getPixelRatio()\n    };\n  }\n  resetRenderState(A, t) {\n    A.setRenderTarget(null), A.setPixelRatio(t.pixelRatio), A.xr.isPresenting = t.xrPresenting, A.autoClear = t.autoClear, A.setScissorTest(t.scissorTest);\n  }\n  process({\n    count: A,\n    material: t\n  }) {\n    const e = this.renderer;\n    if (!e)\n      throw new Error(\"No renderer\");\n    if (!this.target)\n      throw new Error(\"No target\");\n    const i = x * kA;\n    t.uniforms.targetBase.value = 0, t.uniforms.targetCount.value = A;\n    let a = 0;\n    for (; a < A; ) {\n      const r = Math.floor(a / i), n = r * i, I = Math.min(\n        kA,\n        Math.ceil((A - n) / x)\n      );\n      t.uniforms.targetLayer.value = r, e.setPixelRatio(1), e.setRenderTarget(this.target, r), e.xr.isPresenting = !1, e.autoClear = !1, e.setScissorTest(!0), e.setScissor(0, 0, x, I), e.render(EA.scene, EA.camera), a += x * I;\n    }\n    this.count = A;\n  }\n  async read({\n    readback: A\n  }) {\n    const t = this.renderer;\n    if (!t)\n      throw new Error(\"No renderer\");\n    if (!this.target)\n      throw new Error(\"No target\");\n    const e = Math.ceil(this.count / x) * x;\n    if (A.byteLength < e * 4)\n      throw new Error(\n        `Readback buffer too small: ${A.byteLength} < ${e * 4}`\n      );\n    const i = new Uint8Array(\n      A instanceof ArrayBuffer ? A : A.buffer\n    ), a = x * kA;\n    let r = 0;\n    const n = [];\n    for (; r < this.count; ) {\n      const I = Math.floor(r / a), o = I * a, Q = Math.min(\n        kA,\n        Math.ceil((this.count - o) / x)\n      );\n      t.setPixelRatio(1), t.setRenderTarget(this.target, I);\n      const g = x * Q * 4, c = i.subarray(\n        o * 4,\n        o * 4 + g\n      ), E = t == null ? void 0 : t.readRenderTargetPixelsAsync(\n        this.target,\n        0,\n        0,\n        x,\n        Q,\n        c\n      );\n      n.push(E), r += x * Q;\n    }\n    return Promise.all(n).then(() => A);\n  }\n  // Perform render operation to run the Rgba8Readback program\n  // but don't perform the readback yet.\n  render({\n    reader: A,\n    count: t,\n    renderer: e\n  }) {\n    if (this.renderer = e || this.renderer, !this.renderer)\n      throw new Error(\"No renderer\");\n    this.ensureCapacity(t);\n    const { program: i, material: a } = this.prepareProgramMaterial(A);\n    i.update();\n    const r = this.saveRenderState(this.renderer);\n    this.process({ count: t, material: a }), this.resetRenderState(this.renderer, r);\n  }\n  // Perform a readback of the render target, returning a buffer of the\n  // given type.\n  async readback({\n    readback: A\n  }) {\n    if (!this.renderer)\n      throw new Error(\"No renderer\");\n    const t = this.saveRenderState(this.renderer), e = this.read({ readback: A });\n    return this.resetRenderState(this.renderer, t), e;\n  }\n  // Perform a render and readback operation for the given Rgba8Readback,\n  // and readback buffer (call ensureBuffer first).\n  async renderReadback({\n    reader: A,\n    count: t,\n    renderer: e,\n    readback: i\n  }) {\n    if (this.renderer = e || this.renderer, !this.renderer)\n      throw new Error(\"No renderer\");\n    this.ensureCapacity(t);\n    const { program: a, material: r } = this.prepareProgramMaterial(A);\n    a.update();\n    const n = this.saveRenderState(this.renderer);\n    this.process({ count: t, material: r });\n    const I = this.read({ readback: i });\n    return this.resetRenderState(this.renderer, n), I;\n  }\n  getTexture() {\n    var A;\n    return (A = this.target) == null ? void 0 : A.texture;\n  }\n};\nhA.programTemplate = null;\nhA.readbackProgram = /* @__PURE__ */ new Map();\nhA.geometry = new B.PlaneGeometry(2, 2);\nhA.mesh = new B.Mesh(\n  hA.geometry,\n  new B.RawShaderMaterial({ visible: !1 })\n);\nhA.scene = new B.Scene().add(hA.mesh);\nhA.camera = new B.Camera();\nlet he = hA;\nconst Ut = class q {\n  constructor(A = {}) {\n    this.capacity = 0, this.count = 0, this.array = null, this.readback = null, this.source = null, this.needsUpdate = !0, this.dyno = new oA({\n      key: \"rgbaArray\",\n      type: ue,\n      globals: () => [de],\n      value: {\n        texture: q.getEmpty(),\n        count: 0\n      },\n      update: (t) => {\n        var e;\n        return t.texture = ((e = this.readback) == null ? void 0 : e.getTexture()) ?? this.source ?? q.getEmpty(), t.count = this.count, t;\n      }\n    }), A.array ? (this.array = A.array, this.capacity = Math.floor(this.array.length / 4), this.capacity = Math.floor(this.capacity / x) * x, this.count = Math.min(\n      this.capacity,\n      A.count ?? Number.POSITIVE_INFINITY\n    )) : (this.capacity = A.capacity ?? 0, this.count = 0);\n  }\n  // Free up resources\n  dispose() {\n    this.readback && (this.readback.dispose(), this.readback = null), this.source && (this.source.dispose(), this.source = null);\n  }\n  // Ensure that our array is large enough to hold capacity RGBA8 values.\n  ensureCapacity(A) {\n    var t;\n    if (!this.array || A > (((t = this.array) == null ? void 0 : t.length) ?? 0) / 4) {\n      this.capacity = $(A).maxSplats;\n      const e = new Uint8Array(this.capacity * 4);\n      this.array && e.set(this.array), this.array = e;\n    }\n    return this.array;\n  }\n  // Get the THREE.DataArrayTexture from either the readback or the source.\n  getTexture() {\n    var A;\n    let t = (A = this.readback) == null ? void 0 : A.getTexture();\n    return (this.source || this.array) && (t = this.maybeUpdateSource()), t ?? q.getEmpty();\n  }\n  // Create or get a THREE.DataArrayTexture from the data array.\n  maybeUpdateSource() {\n    if (!this.array)\n      throw new Error(\"No array\");\n    if (this.needsUpdate || !this.source) {\n      if (this.needsUpdate = !1, this.source) {\n        const { width: A, height: t, depth: e } = this.source.image;\n        this.capacity !== A * t * e && (this.source.dispose(), this.source = null);\n      }\n      if (this.source)\n        this.array.buffer !== this.source.image.data.buffer && (this.source.image.data = new Uint8Array(this.array.buffer));\n      else {\n        const { width: A, height: t, depth: e } = $(this.capacity);\n        this.source = new B.DataArrayTexture(\n          this.array,\n          A,\n          t,\n          e\n        ), this.source.format = B.RGBAFormat, this.source.type = B.UnsignedByteType, this.source.internalFormat = \"RGBA8\", this.source.needsUpdate = !0;\n      }\n      this.source.needsUpdate = !0;\n    }\n    return this.source;\n  }\n  // Generate the RGBA8 values from a Rgba8Readback dyno program.\n  render({\n    reader: A,\n    count: t,\n    renderer: e\n  }) {\n    this.readback || (this.readback = new he({ renderer: e })), this.readback.render({ reader: A, count: t, renderer: e }), this.capacity = this.readback.capacity, this.count = this.readback.count;\n  }\n  // Extract the RGBA8 values from a PackedSplats collection.\n  fromPackedSplats({\n    packedSplats: A,\n    base: t,\n    count: e,\n    renderer: i\n  }) {\n    const { dynoSplats: a, dynoBase: r, dynoCount: n, reader: I } = q.makeDynos();\n    return a.packedSplats = A, r.value = t, n.value = e, this.render({ reader: I, count: e, renderer: i }), this;\n  }\n  // Read back the RGBA8 values from the readback buffer.\n  async read() {\n    if (!this.readback)\n      throw new Error(\"No readback\");\n    return (!this.array || this.array.length < this.count * 4) && (this.array = new Uint8Array(this.capacity * 4)), (await this.readback.readback({ readback: this.array })).subarray(0, this.count * 4);\n  }\n  // Can be used where you need an uninitialized THREE.DataArrayTexture like\n  // a uniform you will update with the result of this.getTexture() later.\n  static getEmpty() {\n    if (!q.emptySource) {\n      const A = new Uint8Array(4);\n      q.emptySource = new B.DataArrayTexture(A, 1, 1, 1), q.emptySource.format = B.RGBAFormat, q.emptySource.type = B.UnsignedByteType, q.emptySource.internalFormat = \"RGBA8\", q.emptySource.needsUpdate = !0;\n    }\n    return q.emptySource;\n  }\n  // Create a dyno program that can extract RGBA8 values from a PackedSplats\n  static makeDynos() {\n    if (!q.dynos) {\n      const A = new Lt(), t = new Dt({ value: 0 }), e = new Dt({ value: 0 }), i = SA(\n        { index: \"int\" },\n        { rgba8: \"vec4\" },\n        ({ index: a }) => {\n          if (!a)\n            throw new Error(\"index is undefined\");\n          a = OA(a, t);\n          const r = Es(\n            A,\n            a,\n            t,\n            e\n          );\n          return { rgba8: at(r).outputs.rgba };\n        }\n      );\n      q.dynos = { dynoSplats: A, dynoBase: t, dynoCount: e, reader: i };\n    }\n    return q.dynos;\n  }\n};\nUt.emptySource = null;\nUt.dynos = null;\nlet fi = Ut;\nconst ue = { type: \"RgbaArray\" }, de = O(`\n  struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  };\n`);\nfunction mi(s, A) {\n  return new Y({\n    inTypes: { rgba: ue, index: \"int\" },\n    outTypes: { rgba: \"vec4\" },\n    inputs: { rgba: s, index: A },\n    globals: () => [de],\n    statements: ({ inputs: t, outputs: e }) => BA(`\n        if ((index >= 0) && (index < ${t.rgba}.count)) {\n          ${e.rgba} = texelFetch(${t.rgba}.texture, splatTexCoord(index), 0);\n        } else {\n          ${e.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      `)\n  }).outputs.rgba;\n}\nfunction wi(s) {\n  switch (s) {\n    case \"all\":\n      return 0;\n    case \"plane\":\n      return 1;\n    case \"sphere\":\n      return 2;\n    case \"box\":\n      return 3;\n    case \"ellipsoid\":\n      return 4;\n    case \"cylinder\":\n      return 5;\n    case \"capsule\":\n      return 6;\n    case \"infinite_cone\":\n      return 7;\n    default:\n      throw new Error(`Unknown SDF type: ${s}`);\n  }\n}\nfunction Di(s) {\n  switch (s) {\n    case \"multiply\":\n      return 0;\n    case \"set_rgb\":\n      return 1;\n    case \"add_rgba\":\n      return 2;\n    default:\n      throw new Error(`Unknown blend mode: ${s}`);\n  }\n}\nclass xi extends B.Object3D {\n  constructor(A = {}) {\n    super();\n    const { type: t, invert: e, opacity: i, color: a, displace: r, radius: n } = A;\n    this.type = t ?? \"sphere\", this.invert = e ?? !1, this.opacity = i ?? 1, this.color = a ?? new B.Color(1, 1, 1), this.displace = r ?? new B.Vector3(0, 0, 0), this.radius = n ?? 0;\n  }\n}\nconst pe = class ye extends B.Object3D {\n  constructor(A = {}) {\n    const {\n      name: t,\n      rgbaBlendMode: e = \"multiply\",\n      sdfSmooth: i = 0,\n      softEdge: a = 0,\n      invert: r = !1,\n      sdfs: n = null\n    } = A;\n    super(), this.rgbaBlendMode = e, this.sdfSmooth = i, this.softEdge = a, this.invert = r, this.sdfs = n, this.ordering = ye.nextOrdering++, this.name = t ?? `Edit ${this.ordering}`;\n  }\n  addSdf(A) {\n    this.sdfs == null && (this.sdfs = []), this.sdfs.push(A);\n  }\n  removeSdf(A) {\n    this.sdfs != null && (this.sdfs = this.sdfs.filter((t) => t !== A));\n  }\n};\npe.nextOrdering = 1;\nlet fe = pe;\nclass Si {\n  constructor({ maxSdfs: A, maxEdits: t }) {\n    this.maxSdfs = Math.max(16, A ?? 0), this.numSdfs = 0, this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4), this.sdfFloatData = new Float32Array(this.sdfData.buffer), this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs), this.dynoSdfArray = new oA({\n      key: \"sdfArray\",\n      type: me,\n      globals: () => [we],\n      value: {\n        numSdfs: 0,\n        sdfTexture: this.sdfTexture\n      },\n      update: (e) => (e.numSdfs = this.numSdfs, e.sdfTexture = this.sdfTexture, e)\n    }), this.maxEdits = Math.max(16, t ?? 0), this.numEdits = 0, this.editData = new Uint32Array(this.maxEdits * 4), this.editFloatData = new Float32Array(this.editData.buffer), this.dynoNumEdits = new Dt({ value: 0 }), this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n  }\n  newSdfTexture(A, t) {\n    const e = new B.DataTexture(\n      A,\n      8,\n      t,\n      B.RGBAIntegerFormat,\n      B.UnsignedIntType\n    );\n    return e.internalFormat = \"RGBA32UI\", e.needsUpdate = !0, e;\n  }\n  newEdits(A, t) {\n    return new oA({\n      key: \"edits\",\n      type: \"uvec4\",\n      count: t,\n      globals: () => [De],\n      value: A\n    });\n  }\n  // Ensure our SDF texture and edits uniform array have enough capacity.\n  // Reallocate if not.\n  ensureCapacity({\n    maxSdfs: A,\n    maxEdits: t\n  }) {\n    let e = !1;\n    return A > this.sdfTexture.image.height && (this.sdfTexture.dispose(), this.maxSdfs = Math.max(this.maxSdfs * 2, A), this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4), this.sdfFloatData = new Float32Array(this.sdfData.buffer), this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs)), t > (this.dynoEdits.count ?? 0) && (this.maxEdits = Math.max(this.maxEdits * 2, t), this.editData = new Uint32Array(this.maxEdits * 4), this.editFloatData = new Float32Array(this.editData.buffer), this.dynoEdits = this.newEdits(this.editData, this.maxEdits), e = !0), e;\n  }\n  updateEditData(A, t) {\n    const e = this.editData[A] !== t;\n    return this.editData[A] = t, e;\n  }\n  updateEditFloatData(A, t) {\n    LA[0] = t;\n    const e = this.editFloatData[A] !== LA[0];\n    return e && (this.editFloatData[A] = LA[0]), e;\n  }\n  encodeEdit(A, {\n    sdfFirst: t,\n    sdfCount: e,\n    invert: i,\n    rgbaBlendMode: a,\n    softEdge: r,\n    sdfSmooth: n\n  }) {\n    const I = A * 4;\n    let o = !1;\n    return o = this.updateEditData(I + 0, a | (i ? 256 : 0)) || o, o = this.updateEditData(I + 1, t | e << 16) || o, o = this.updateEditFloatData(I + 2, r) || o, o = this.updateEditFloatData(I + 3, n) || o, o;\n  }\n  updateSdfData(A, t) {\n    const e = this.sdfData[A] !== t;\n    return this.sdfData[A] = t, e;\n  }\n  updateSdfFloatData(A, t) {\n    LA[0] = t;\n    const e = this.sdfFloatData[A] !== LA[0];\n    return e && (this.sdfFloatData[A] = LA[0]), e;\n  }\n  encodeSdf(A, {\n    sdfType: t,\n    invert: e,\n    center: i,\n    quaternion: a,\n    scale: r,\n    sizes: n\n  }, I) {\n    const o = A * 32, Q = t | (e ? 256 : 0);\n    let g = !1;\n    g = this.updateSdfFloatData(o + 0, (i == null ? void 0 : i.x) ?? 0) || g, g = this.updateSdfFloatData(o + 1, (i == null ? void 0 : i.y) ?? 0) || g, g = this.updateSdfFloatData(o + 2, (i == null ? void 0 : i.z) ?? 0) || g, g = this.updateSdfData(o + 3, Q) || g, g = this.updateSdfFloatData(o + 4, (a == null ? void 0 : a.x) ?? 0) || g, g = this.updateSdfFloatData(o + 5, (a == null ? void 0 : a.y) ?? 0) || g, g = this.updateSdfFloatData(o + 6, (a == null ? void 0 : a.z) ?? 0) || g, g = this.updateSdfFloatData(o + 7, (a == null ? void 0 : a.w) ?? 0) || g, g = this.updateSdfFloatData(o + 8, (r == null ? void 0 : r.x) ?? 0) || g, g = this.updateSdfFloatData(o + 9, (r == null ? void 0 : r.y) ?? 0) || g, g = this.updateSdfFloatData(o + 10, (r == null ? void 0 : r.z) ?? 0) || g, g = this.updateSdfData(o + 11, 0) || g, g = this.updateSdfFloatData(o + 12, (n == null ? void 0 : n.x) ?? 0) || g, g = this.updateSdfFloatData(o + 13, (n == null ? void 0 : n.y) ?? 0) || g, g = this.updateSdfFloatData(o + 14, (n == null ? void 0 : n.z) ?? 0) || g, g = this.updateSdfFloatData(o + 15, (n == null ? void 0 : n.w) ?? 0) || g;\n    const c = Math.min(4, I.length);\n    for (let E = 0; E < c; ++E) {\n      const l = o + 16 + E * 4;\n      g = this.updateSdfFloatData(l + 0, I[E].x) || g, g = this.updateSdfFloatData(l + 1, I[E].y) || g, g = this.updateSdfFloatData(l + 2, I[E].z) || g, g = this.updateSdfFloatData(l + 3, I[E].w) || g;\n    }\n    return g;\n  }\n  // Update the SDFs and edits from an array of SplatEdits and their\n  // associated SplatEditSdfs, updating it for the dyno shader program.\n  update(A) {\n    const t = A.reduce((g, { sdfs: c }) => g + c.length, 0), e = this.ensureCapacity({\n      maxEdits: A.length,\n      maxSdfs: t\n    }), i = [new B.Vector4(), new B.Vector4()], a = new B.Vector3(), r = new B.Quaternion(), n = new B.Vector3(), I = new B.Vector4();\n    let o = 0, Q = e;\n    A.length !== this.dynoNumEdits.value && (this.dynoNumEdits.value = A.length, this.numEdits = A.length, Q = !0);\n    for (const [g, { edit: c, sdfs: E }] of A.entries()) {\n      Q = this.encodeEdit(g, {\n        sdfFirst: o,\n        sdfCount: E.length,\n        invert: c.invert,\n        rgbaBlendMode: Di(c.rgbaBlendMode),\n        softEdge: c.softEdge,\n        sdfSmooth: c.sdfSmooth\n      }) || Q;\n      let l = !1;\n      for (const C of E)\n        I.set(C.scale.x, C.scale.y, C.scale.z, C.radius), C.scale.setScalar(1), C.updateMatrixWorld(), C.matrixWorld.clone().invert().decompose(a, r, n), C.scale.set(I.x, I.y, I.z), C.updateMatrixWorld(), i[0].set(C.color.r, C.color.g, C.color.b, C.opacity), i[1].set(C.displace.x, C.displace.y, C.displace.z, 1), l = this.encodeSdf(\n          o,\n          {\n            sdfType: wi(C.type),\n            invert: C.invert,\n            center: a,\n            quaternion: r,\n            scale: n,\n            sizes: I\n          },\n          i\n        ) || l, o += 1;\n      this.numSdfs = o, l && (this.sdfTexture.needsUpdate = !0), Q || (Q = l);\n    }\n    return { updated: Q, dynoUpdated: e };\n  }\n  // Modify a Gsplat in a dyno shader program using the current edits and SDFs.\n  modify(A) {\n    return bi(\n      A,\n      this.dynoSdfArray,\n      this.dynoNumEdits,\n      this.dynoEdits\n    );\n  }\n}\nconst me = { type: \"SdfArray\" }, we = O(`\n  struct SdfArray {\n    int numSdfs;\n    usampler2D sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n    }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    }\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n    vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n    for (int index = sdfFirst; index < sdfLast; ++index) {\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n          distance = sdfPos.z;\n          break;\n        }\n        case SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n          float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n        case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n          float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        }\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance = -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < distanceAccum) {\n          distanceAccum = distance;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          }\n        }\n      } else {\n        float scaledDistance = -distance / smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n          }\n          maxExp = scaledDistance;\n        }\n\n        float weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n        for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      return distanceAccum;\n    } else {\n      // Very distant SDFs may result in 0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / 0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n      distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  }\n`), De = O(`\n  const uint EDIT_FLAG_BLEND = 0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = uintBitsToFloat(packedEdit.z);\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\n    // On Android, moving values[0] is necessary to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) {\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n        target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    }\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\n  }\n`);\nfunction bi(s, A, t, e) {\n  return new Y({\n    inTypes: {\n      gsplat: G,\n      sdfArray: me,\n      numEdits: \"int\",\n      rgbaDisplaceEdits: \"uvec4\"\n    },\n    outTypes: { gsplat: G },\n    globals: () => [we, De],\n    inputs: { gsplat: s, sdfArray: A, numEdits: t, rgbaDisplaceEdits: e },\n    statements: ({ inputs: i, outputs: a }) => {\n      const { sdfArray: r, numEdits: n, rgbaDisplaceEdits: I } = i, { gsplat: o } = a;\n      return BA(`\n        ${o} = ${i.gsplat};\n        if (isGsplatActive(${o}.flags)) {\n          for (int editIndex = 0; editIndex < ${n}; ++editIndex) {\n            applyPackedRgbaDisplaceEdit(\n              ${I}[editIndex], ${r}.sdfTexture, ${r}.numSdfs,\n              ${o}.center, ${o}.rgba\n            );\n          }\n        }\n      `);\n    }\n  }).outputs.gsplat;\n}\nconst LA = new Float32Array(1);\nclass ki {\n  constructor(A) {\n    this.modifier = A, this.cache = /* @__PURE__ */ new Map();\n  }\n  apply(A) {\n    let t = this.cache.get(A);\n    return t || (t = SA(\n      { index: \"int\" },\n      { gsplat: G },\n      ({ index: e }) => {\n        const { gsplat: i } = A.apply({ index: e });\n        return this.modifier.apply({ gsplat: i });\n      }\n    ), this.cache.set(A, t)), t;\n  }\n}\nclass At {\n  // Create the dyno uniforms that parameterize the transform, setting them\n  // to initial values that are different from any valid transform.\n  constructor() {\n    this.scale = new jA({ value: Number.NEGATIVE_INFINITY }), this.rotate = new vt({\n      value: new B.Quaternion(\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY\n      )\n    }), this.translate = new ot({\n      value: new B.Vector3(\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY,\n        Number.POSITIVE_INFINITY\n      )\n    });\n  }\n  // Apply the transform to a Vec3 position in a dyno program.\n  apply(A) {\n    return hi(A, {\n      scale: this.scale,\n      rotate: this.rotate,\n      translate: this.translate\n    });\n  }\n  applyDir(A) {\n    return ui(A, {\n      rotate: this.rotate\n    });\n  }\n  // Apply the transform to a Gsplat in a dyno program.\n  applyGsplat(A) {\n    return ee(A, {\n      scale: this.scale,\n      rotate: this.rotate,\n      translate: this.translate\n    });\n  }\n  // Update the uniforms to match the given transform matrix.\n  updateFromMatrix(A) {\n    const t = new B.Vector3(), e = new B.Quaternion(), i = new B.Vector3();\n    A.decompose(i, e, t);\n    const a = (t.x + t.y + t.z) / 3;\n    let r = !1;\n    return a !== this.scale.value && (this.scale.value = a, r = !0), i.equals(this.translate.value) || (this.translate.value.copy(i), r = !0), e.equals(this.rotate.value) || (this.rotate.value.copy(e), r = !0), r;\n  }\n  // Update this transform to match the object's to-world transform.\n  update(A) {\n    return A.updateMatrixWorld(), this.updateFromMatrix(A.matrixWorld);\n  }\n}\nclass xe extends B.Object3D {\n  constructor({\n    numSplats: A,\n    generator: t,\n    construct: e,\n    update: i\n  }) {\n    if (super(), this.numSplats = A ?? 0, this.generator = t, this.frameUpdate = i, this.version = 0, e) {\n      const a = e(this);\n      Object.assign(this, a);\n    }\n  }\n  updateVersion() {\n    this.version += 1;\n  }\n  set needsUpdate(A) {\n    A && this.updateVersion();\n  }\n}\nconst ZA = class St extends xe {\n  constructor(A = {}) {\n    const t = new At(), e = new At(), i = new At(), a = new At(), r = new vt({\n      value: new B.Vector4(\n        Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY,\n        Number.NEGATIVE_INFINITY\n      )\n    }), n = new jA({ value: 0 }), I = new jA({ value: 0 }), o = {\n      transform: t,\n      viewToWorld: e,\n      worldToView: i,\n      viewToObject: a,\n      recolor: r,\n      time: n,\n      deltaTime: I\n    };\n    if (super({\n      update: ({ time: Q, deltaTime: g, viewToWorld: c, globalEdits: E }) => this.update({ time: Q, deltaTime: g, viewToWorld: c, globalEdits: E })\n    }), this.isInitialized = !1, this.recolor = new B.Color(1, 1, 1), this.opacity = 1, this.enableViewToObject = !1, this.enableViewToWorld = !1, this.enableWorldToView = !1, this.skinning = null, this.edits = null, this.rgbaDisplaceEdits = null, this.splatRgba = null, this.maxSh = 3, this.packedSplats = A.packedSplats ?? new TA(), this.numSplats = this.packedSplats.numSplats, this.editable = A.editable ?? !0, this.onFrame = A.onFrame, this.context = o, this.objectModifier = A.objectModifier, this.worldModifier = A.worldModifier, this.updateGenerator(), A.url || A.fileBytes || A.constructSplats || A.packedSplats && !A.packedSplats.isInitialized)\n      this.initialized = this.asyncInitialize(A).then(async () => {\n        if (this.updateGenerator(), this.isInitialized = !0, A.onLoad) {\n          const Q = A.onLoad(this);\n          Q instanceof Promise && await Q;\n        }\n        return this;\n      });\n    else if (this.isInitialized = !0, this.initialized = Promise.resolve(this), A.onLoad) {\n      const Q = A.onLoad(this);\n      Q instanceof Promise && (this.initialized = Q.then(() => this));\n    }\n  }\n  async asyncInitialize(A) {\n    const { url: t, fileBytes: e, fileType: i, fileName: a, maxSplats: r, constructSplats: n } = A;\n    if (t || e || n) {\n      const I = {\n        url: t,\n        fileBytes: e,\n        fileType: i,\n        fileName: a,\n        maxSplats: r,\n        construct: n\n      };\n      this.packedSplats.reinitialize(I);\n    }\n    this.packedSplats && (await this.packedSplats.initialized, this.numSplats = this.packedSplats.numSplats, this.updateGenerator());\n  }\n  static async staticInitialize() {\n    await Ae(), St.isStaticInitialized = !0;\n  }\n  // Creates a new Gsplat with the provided parameters (all values in \"float\" space,\n  // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,\n  // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential\n  // doubling strategy to fit the new data, so it's fairly efficient to just\n  // pushSplat(...) each Gsplat you want to create in a loop.\n  pushSplat(A, t, e, i, a) {\n    this.packedSplats.pushSplat(A, t, e, i, a);\n  }\n  // This method iterates over all Gsplats in this instance's packedSplats,\n  // invoking the provided callback with index: number in 0..=(this.numSplats-1) and\n  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n  // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).\n  // Note that the objects passed in as center etc. are the same for every callback\n  // invocation: these objects are reused for efficiency. Changing these values has\n  // no effect as they are decoded/unpacked copies of the underlying data. To update\n  // the packedSplats, call .packedSplats.setSplat(index, center, scales,\n  // quaternion, opacity, color).\n  forEachSplat(A) {\n    this.packedSplats.forEachSplat(A);\n  }\n  // Call this when you are finished with the SplatMesh and want to free\n  // any buffers it holds (via packedSplats).\n  dispose() {\n    this.packedSplats.dispose();\n  }\n  constructGenerator(A) {\n    const { transform: t, viewToObject: e, recolor: i } = A, a = SA(\n      { index: \"int\" },\n      { gsplat: G },\n      ({ index: r }) => {\n        if (!r)\n          throw new Error(\"index is undefined\");\n        let n = gt(this.packedSplats.dyno, r);\n        if (this.maxSh >= 1) {\n          const { sh1Texture: o, sh2Texture: Q, sh3Texture: g } = this.ensureShTextures();\n          if (o) {\n            const c = e.translate, { center: E } = at(n).outputs, l = Ii(ei(E, c));\n            let C = Ri(n, o, l);\n            this.maxSh >= 2 && Q && (C = OA(C, vi(n, Q, l))), this.maxSh >= 3 && g && (C = OA(C, Gi(n, g, l)));\n            let { rgba: u } = at(n).outputs;\n            u = OA(u, Qi(C, wt(\"float\", 0))), n = Et({ gsplat: n, rgba: u });\n          }\n        }\n        if (this.splatRgba) {\n          const o = mi(this.splatRgba.dyno, r);\n          n = Et({ gsplat: n, rgba: o });\n        }\n        this.skinning && (n = this.skinning.modify(n)), this.objectModifier && (n = this.objectModifier.apply({ gsplat: n }).gsplat), n = t.applyGsplat(n);\n        const I = le(i, at(n).outputs.rgba);\n        return n = Et({ gsplat: n, rgba: I }), this.rgbaDisplaceEdits && (n = this.rgbaDisplaceEdits.modify(n)), this.worldModifier && (n = this.worldModifier.apply({ gsplat: n }).gsplat), { gsplat: n };\n      }\n    );\n    this.generator = a;\n  }\n  // Call this whenever something changes in the Gsplat processing pipeline,\n  // for example changing maxSh or updating objectModifier or worldModifier.\n  // Compiled generators are cached for efficiency and re-use when the same\n  // pipeline structure emerges after successive changes.\n  updateGenerator() {\n    this.constructGenerator(this.context);\n  }\n  // This is called automatically by SparkRenderer and you should not have to\n  // call it. It updates parameters for the generated pipeline and calls\n  // updateGenerator() if the pipeline needs to change.\n  update({\n    time: A,\n    viewToWorld: t,\n    deltaTime: e,\n    globalEdits: i\n  }) {\n    var a;\n    this.numSplats = this.packedSplats.numSplats, this.context.time.value = A, this.context.deltaTime.value = e, St.dynoTime.value = A;\n    const { transform: r, viewToObject: n, recolor: I } = this.context;\n    let o = r.update(this);\n    this.context.viewToWorld.updateFromMatrix(t) && this.enableViewToWorld && (o = !0);\n    const Q = t.clone().invert();\n    this.context.worldToView.updateFromMatrix(Q) && this.enableWorldToView && (o = !0);\n    const g = new B.Matrix4().compose(\n      r.translate.value,\n      r.rotate.value,\n      new B.Vector3().setScalar(r.scale.value)\n    ).invert().multiply(t);\n    n.updateFromMatrix(g) && (this.enableViewToObject || this.packedSplats.extra.sh1) && (o = !0);\n    const c = new B.Vector4(\n      this.recolor.r,\n      this.recolor.g,\n      this.recolor.b,\n      this.opacity\n    );\n    c.equals(I.value) || (I.value.copy(c), o = !0);\n    const E = this.editable ? (this.edits ?? []).concat(i) : [];\n    this.editable && !this.edits && this.traverseVisible((C) => {\n      C instanceof fe && E.push(C);\n    }), E.sort((C, u) => C.ordering - u.ordering);\n    const l = E.map((C) => {\n      if (C.sdfs != null)\n        return { edit: C, sdfs: C.sdfs };\n      const u = [];\n      return C.traverseVisible((y) => {\n        y instanceof xi && u.push(y);\n      }), { edit: C, sdfs: u };\n    });\n    if (l.length > 0 && !this.rgbaDisplaceEdits) {\n      const C = l.length, u = l.reduce(\n        (y, d) => y + d.sdfs.length,\n        0\n      );\n      this.rgbaDisplaceEdits = new Si({\n        maxEdits: C,\n        maxSdfs: u\n      }), this.updateGenerator();\n    }\n    if (this.rgbaDisplaceEdits) {\n      const C = this.rgbaDisplaceEdits.update(l);\n      o || (o = C.updated), C.dynoUpdated && this.updateGenerator();\n    }\n    o && this.updateVersion(), (a = this.onFrame) == null || a.call(this, { mesh: this, time: A, deltaTime: e });\n  }\n  // This method conforms to the standard THREE.Raycaster API, performing object-ray\n  // intersections using this method to populate the provided intersects[] array\n  // with each intersection point.\n  raycast(A, t) {\n    if (!this.packedSplats.packedArray || !this.packedSplats.numSplats)\n      return;\n    const { near: e, far: i, ray: a } = A, r = this.matrixWorld.clone().invert(), n = new B.Matrix3().setFromMatrix4(r), I = a.origin.clone().applyMatrix4(r), o = a.direction.clone().applyMatrix3(n), Q = new B.Vector3();\n    r.decompose(new B.Vector3(), new B.Quaternion(), Q), (Q.x * Q.y * Q.z) ** (1 / 3);\n    const g = $e(\n      I.x,\n      I.y,\n      I.z,\n      o.x,\n      o.y,\n      o.z,\n      e,\n      i,\n      this.packedSplats.numSplats,\n      this.packedSplats.packedArray,\n      !0\n    );\n    for (const c of g) {\n      const E = a.direction.clone().multiplyScalar(c).add(a.origin);\n      t.push({\n        distance: c,\n        point: E,\n        object: this\n      });\n    }\n  }\n  ensureShTextures() {\n    if (!this.packedSplats.extra.sh1)\n      return {};\n    let A = this.packedSplats.extra.sh1Texture;\n    if (!A) {\n      let i = this.packedSplats.extra.sh1;\n      const { width: a, height: r, depth: n, maxSplats: I } = $(\n        i.length / 2\n      );\n      if (i.length < I * 2) {\n        const Q = new Uint32Array(I * 2);\n        Q.set(i), this.packedSplats.extra.sh1 = Q, i = Q;\n      }\n      const o = new B.DataArrayTexture(i, a, r, n);\n      o.format = B.RGIntegerFormat, o.type = B.UnsignedIntType, o.internalFormat = \"RG32UI\", o.needsUpdate = !0, A = new lt({\n        value: o,\n        key: \"sh1\"\n      }), this.packedSplats.extra.sh1Texture = A;\n    }\n    if (!this.packedSplats.extra.sh2)\n      return { sh1Texture: A };\n    let t = this.packedSplats.extra.sh2Texture;\n    if (!t) {\n      let i = this.packedSplats.extra.sh2;\n      const { width: a, height: r, depth: n, maxSplats: I } = $(\n        i.length / 4\n      );\n      if (i.length < I * 4) {\n        const Q = new Uint32Array(I * 4);\n        Q.set(i), this.packedSplats.extra.sh2 = Q, i = Q;\n      }\n      const o = new B.DataArrayTexture(i, a, r, n);\n      o.format = B.RGBAIntegerFormat, o.type = B.UnsignedIntType, o.internalFormat = \"RGBA32UI\", o.needsUpdate = !0, t = new lt({\n        value: o,\n        key: \"sh2\"\n      }), this.packedSplats.extra.sh2Texture = t;\n    }\n    if (!this.packedSplats.extra.sh3)\n      return { sh1Texture: A, sh2Texture: t };\n    let e = this.packedSplats.extra.sh3Texture;\n    if (!e) {\n      let i = this.packedSplats.extra.sh3;\n      const { width: a, height: r, depth: n, maxSplats: I } = $(\n        i.length / 4\n      );\n      if (i.length < I * 4) {\n        const Q = new Uint32Array(I * 4);\n        Q.set(i), this.packedSplats.extra.sh3 = Q, i = Q;\n      }\n      const o = new B.DataArrayTexture(i, a, r, n);\n      o.format = B.RGBAIntegerFormat, o.type = B.UnsignedIntType, o.internalFormat = \"RGBA32UI\", o.needsUpdate = !0, e = new lt({\n        value: o,\n        key: \"sh3\"\n      }), this.packedSplats.extra.sh3Texture = e;\n    }\n    return { sh1Texture: A, sh2Texture: t, sh3Texture: e };\n  }\n};\nZA.staticInitialized = ZA.staticInitialize();\nZA.isStaticInitialized = !1;\nZA.dynoTime = new jA({ value: 0 });\nlet It = ZA;\nconst Mi = O(`\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n      int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> 25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * (-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + sh1_2 * (-0.4886025 * viewDir.x);\n  }\n`), Fi = O(`\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> 24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n      int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n      int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> 24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> 24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (1.0925484 * viewDir.y * viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (1.0925484 * viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\n  }\n`), Ni = O(`\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // Extract sint6 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> 26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> 26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n    vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / 31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) >> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << 18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> 26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> 26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    )) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n      int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / 31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n`);\nfunction Ri(s, A, t) {\n  return Qt({\n    inTypes: { gsplat: G, sh1: \"usampler2DArray\", viewDir: \"vec3\" },\n    outTypes: { rgb: \"vec3\" },\n    inputs: { gsplat: s, sh1: A, viewDir: t },\n    globals: () => [QA, Mi],\n    statements: ({ inputs: e, outputs: i }) => BA(`\n        if (isGsplatActive(${e.gsplat}.flags)) {\n          ${i.rgb} = evaluateSH1(${e.gsplat}, ${e.sh1}, ${e.viewDir});\n        } else {\n          ${i.rgb} = vec3(0.0);\n        }\n      `)\n  }).outputs.rgb;\n}\nfunction vi(s, A, t) {\n  return Qt({\n    inTypes: { gsplat: G, sh2: \"usampler2DArray\", viewDir: \"vec3\" },\n    outTypes: { rgb: \"vec3\" },\n    inputs: { gsplat: s, sh2: A, viewDir: t },\n    globals: () => [QA, Fi],\n    statements: ({ inputs: e, outputs: i }) => BA(`\n        if (isGsplatActive(${e.gsplat}.flags)) {\n          ${i.rgb} = evaluateSH2(${e.gsplat}, ${e.sh2}, ${e.viewDir});\n        } else {\n          ${i.rgb} = vec3(0.0);\n        }\n      `)\n  }).outputs.rgb;\n}\nfunction Gi(s, A, t) {\n  return Qt({\n    inTypes: { gsplat: G, sh3: \"usampler2DArray\", viewDir: \"vec3\" },\n    outTypes: { rgb: \"vec3\" },\n    inputs: { gsplat: s, sh3: A, viewDir: t },\n    globals: () => [QA, Ni],\n    statements: ({ inputs: e, outputs: i }) => BA(`\n        if (isGsplatActive(${e.gsplat}.flags)) {\n          ${i.rgb} = evaluateSH3(${e.gsplat}, ${e.sh3}, ${e.viewDir});\n        } else {\n          ${i.rgb} = vec3(0.0);\n        }\n      `)\n  }).outputs.rgb;\n}\nconst Se = class nt {\n  // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet\n  constructor({ fileBytes: A }) {\n    this.header = \"\", this.littleEndian = !0, this.elements = {}, this.comments = [], this.data = null, this.numSplats = 0, this.fileBytes = A instanceof ArrayBuffer ? new Uint8Array(A) : A;\n  }\n  // Identify and parse the PLY text header (assumed to be <64KB in size).\n  // this.elements will contain all the elements in the file, typically\n  // \"vertex\" contains the Gsplat data.\n  async parseHeader() {\n    const A = new ReadableStream({\n      start: (a) => {\n        a.enqueue(this.fileBytes.slice(0, 65536)), a.close();\n      }\n    }).pipeThrough(new TextDecoderStream()).getReader();\n    this.header = \"\";\n    const t = `end_header\n`;\n    for (; ; ) {\n      const { value: a, done: r } = await A.read();\n      if (r)\n        throw new Error(\"Failed to read header\");\n      this.header += a;\n      const n = this.header.indexOf(t);\n      if (n >= 0) {\n        this.header = this.header.slice(0, n + t.length);\n        break;\n      }\n    }\n    const e = new TextEncoder().encode(this.header).length;\n    this.data = new DataView(this.fileBytes.buffer, e), this.elements = {};\n    let i = null;\n    this.comments = [], this.header.trim().split(`\n`).forEach((a, r) => {\n      const n = a.trim();\n      if (r === 0) {\n        if (n !== \"ply\")\n          throw new Error(\"Invalid PLY header\");\n        return;\n      }\n      if (n.length === 0)\n        return;\n      const I = n.split(\" \");\n      switch (I[0]) {\n        case \"format\":\n          if (I[1] === \"binary_little_endian\")\n            this.littleEndian = !0;\n          else if (I[1] === \"binary_big_endian\")\n            this.littleEndian = !1;\n          else\n            throw new Error(`Unsupported PLY format: ${I[1]}`);\n          if (I[2] !== \"1.0\")\n            throw new Error(`Unsupported PLY version: ${I[2]}`);\n          break;\n        case \"end_header\":\n          break;\n        case \"comment\":\n          this.comments.push(n.slice(8));\n          break;\n        case \"element\": {\n          const o = I[1];\n          i = {\n            name: o,\n            count: Number.parseInt(I[2]),\n            properties: {}\n          }, this.elements[o] = i;\n          break;\n        }\n        case \"property\":\n          if (i == null)\n            throw new Error(\"Property must be inside an element\");\n          I[1] === \"list\" ? i.properties[I[4]] = {\n            isList: !0,\n            type: I[3],\n            countType: I[2]\n          } : i.properties[I[2]] = {\n            isList: !1,\n            type: I[1]\n          };\n          break;\n      }\n    }), this.elements.vertex && (this.numSplats = this.elements.vertex.count);\n  }\n  parseData(A) {\n    let t = 0;\n    const e = this.data;\n    if (e == null)\n      throw new Error(\"No data to parse\");\n    for (const i in this.elements) {\n      const a = this.elements[i], { count: r, properties: n } = a, I = {}, o = [];\n      for (const [g, c] of Object.entries(n))\n        c.isList ? (I[g] = [], o.push(() => {\n          const E = I[g];\n          E.length = et[c.countType](\n            e,\n            t,\n            this.littleEndian\n          ), t += _A[c.countType];\n          for (let l = 0; l < E.length; l++)\n            E[l] = et[c.type](\n              e,\n              t,\n              this.littleEndian\n            ), t += _A[c.type];\n        })) : (I[g] = 0, o.push(() => {\n          I[g] = et[c.type](\n            e,\n            t,\n            this.littleEndian\n          ), t += _A[c.type];\n        }));\n      const Q = A(a) ?? (() => {\n      });\n      for (let g = 0; g < r; g++) {\n        for (const c of o)\n          c();\n        Q(g, I);\n      }\n    }\n  }\n  // Parse all the Gsplat data in the PLY file in go, invoking the given\n  // callbacks for each Gsplat.\n  parseSplats(A, t) {\n    if (this.elements.vertex == null)\n      throw new Error(\"No vertex element found\");\n    let e = !1;\n    const i = [];\n    let a = 0, r = [], n = [], I = [], o, Q, g;\n    function c() {\n      const y = _i[a];\n      r = new Array(3).fill(null).flatMap(\n        (d, h) => [0, 1, 2].map((p, f) => `f_rest_${h + f * y / 3}`)\n      ), n = new Array(5).fill(null).flatMap(\n        (d, h) => [0, 1, 2].map((p, f) => `f_rest_${3 + h + f * y / 3}`)\n      ), I = new Array(7).fill(null).flatMap(\n        (d, h) => [0, 1, 2].map((p, f) => `f_rest_${8 + h + f * y / 3}`)\n      ), o = a >= 1 ? new Float32Array(3 * 3) : void 0, Q = a >= 2 ? new Float32Array(5 * 3) : void 0, g = a >= 3 ? new Float32Array(7 * 3) : void 0;\n    }\n    function E(y, d) {\n      if (!o)\n        throw new Error(\"Missing sh1\");\n      for (const [h, p] of r.entries())\n        o[h] = d[p] * 8 / 255 - 4;\n      if (Q)\n        for (const [h, p] of n.entries())\n          Q[h] = d[p] * 8 / 255 - 4;\n      if (g)\n        for (const [h, p] of I.entries())\n          g[h] = d[p] * 8 / 255 - 4;\n      t == null || t(y, o, Q, g);\n    }\n    function l(y) {\n      const {\n        min_x: d,\n        min_y: h,\n        min_z: p,\n        max_x: f,\n        max_y: D,\n        max_z: k,\n        min_scale_x: b,\n        min_scale_y: T,\n        min_scale_z: J,\n        max_scale_x: H,\n        max_scale_y: U,\n        max_scale_z: M,\n        min_r: F,\n        min_g: V,\n        min_b: z,\n        max_r: N,\n        max_g: W,\n        max_b: AA\n      } = y.properties;\n      if (!d || !h || !p || !f || !D || !k || !b || !T || !J || !H || !U || !M || !F || !V || !z || !N || !W || !AA)\n        throw new Error(\"Missing PLY chunk properties\");\n      return e = !0, (uA, aA) => {\n        const {\n          min_x: rA,\n          min_y: j,\n          min_z: cA,\n          max_x: tA,\n          max_y: nA,\n          max_z: w,\n          min_scale_x: gA,\n          min_scale_y: eA,\n          min_scale_z: CA,\n          max_scale_x: sA,\n          max_scale_y: dA,\n          max_scale_z: pA,\n          min_r: JA,\n          min_g: yA,\n          min_b: fA,\n          max_r: mA,\n          max_g: wA,\n          max_b: K\n        } = aA;\n        i.push({\n          min_x: rA,\n          min_y: j,\n          min_z: cA,\n          max_x: tA,\n          max_y: nA,\n          max_z: w,\n          min_scale_x: gA,\n          min_scale_y: eA,\n          min_scale_z: CA,\n          max_scale_x: sA,\n          max_scale_y: dA,\n          max_scale_z: pA,\n          min_r: JA,\n          min_g: yA,\n          min_b: fA,\n          max_r: mA,\n          max_g: wA,\n          max_b: K\n        });\n      };\n    }\n    function C(y) {\n      if (t && y.name === \"sh\")\n        return a = Ot(y.properties), c(), E;\n      if (y.name !== \"vertex\")\n        return null;\n      const { packed_position: d, packed_rotation: h, packed_scale: p, packed_color: f } = y.properties;\n      if (!d || !h || !p || !f)\n        throw new Error(\n          \"Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color\"\n        );\n      const D = Math.sqrt(2);\n      return (k, b) => {\n        const T = i[k >>> 8];\n        if (T == null)\n          throw new Error(\"Missing PLY chunk\");\n        const {\n          min_x: J,\n          min_y: H,\n          min_z: U,\n          max_x: M,\n          max_y: F,\n          max_z: V,\n          min_scale_x: z,\n          min_scale_y: N,\n          min_scale_z: W,\n          max_scale_x: AA,\n          max_scale_y: uA,\n          max_scale_z: aA,\n          min_r: rA,\n          min_g: j,\n          min_b: cA,\n          max_r: tA,\n          max_g: nA,\n          max_b: w\n        } = T, { packed_position: gA, packed_rotation: eA, packed_scale: CA, packed_color: sA } = b, dA = (gA >>> 21 & 2047) / 2047 * (M - J) + J, pA = (gA >>> 11 & 1023) / 1023 * (F - H) + H, JA = (gA & 2047) / 2047 * (V - U) + U, yA = ((eA >>> 20 & 1023) / 1023 - 0.5) * D, fA = ((eA >>> 10 & 1023) / 1023 - 0.5) * D, mA = ((eA & 1023) / 1023 - 0.5) * D, wA = Math.sqrt(Math.max(0, 1 - yA * yA - fA * fA - mA * mA)), K = eA >>> 30, bA = K === 0 ? yA : K === 1 ? wA : fA, Le = K <= 1 ? fA : K === 2 ? wA : mA, _e = K <= 2 ? mA : wA, Ye = K === 0 ? wA : yA, Te = Math.exp(\n          (CA >>> 21 & 2047) / 2047 * (AA - z) + z\n        ), Je = Math.exp(\n          (CA >>> 11 & 1023) / 1023 * (uA - N) + N\n        ), He = Math.exp(\n          (CA & 2047) / 2047 * (aA - W) + W\n        ), qe = (sA >>> 24 & 255) / 255 * (tA - rA) + rA, ze = (sA >>> 16 & 255) / 255 * (nA - j) + j, Ke = (sA >>> 8 & 255) / 255 * (w - cA) + cA, Pe = (sA & 255) / 255;\n        A(\n          k,\n          dA,\n          pA,\n          JA,\n          Te,\n          Je,\n          He,\n          bA,\n          Le,\n          _e,\n          Ye,\n          Pe,\n          qe,\n          ze,\n          Ke\n        );\n      };\n    }\n    const u = (y) => {\n      if (y.name === \"chunk\")\n        return l(y);\n      if (e)\n        return C(y);\n      if (y.name !== \"vertex\")\n        return null;\n      const {\n        x: d,\n        y: h,\n        z: p,\n        scale_0: f,\n        scale_1: D,\n        scale_2: k,\n        rot_0: b,\n        rot_1: T,\n        rot_2: J,\n        rot_3: H,\n        opacity: U,\n        f_dc_0: M,\n        f_dc_1: F,\n        f_dc_2: V,\n        red: z,\n        green: N,\n        blue: W,\n        alpha: AA\n      } = y.properties;\n      if (!d || !h || !p)\n        throw new Error(\"Missing PLY properties: x, y, z\");\n      const uA = f && D && k, aA = b && T && J && H, rA = AA != null ? st[AA.type] : 1, j = z != null ? st[z.type] : 1, cA = N != null ? st[N.type] : 1, tA = W != null ? st[W.type] : 1;\n      return a = Ot(y.properties), c(), (nA, w) => {\n        const gA = uA ? Math.exp(w.scale_0) : nt.defaultPointScale, eA = uA ? Math.exp(w.scale_1) : nt.defaultPointScale, CA = uA ? Math.exp(w.scale_2) : nt.defaultPointScale, sA = aA ? w.rot_1 : 0, dA = aA ? w.rot_2 : 0, pA = aA ? w.rot_3 : 0, JA = aA ? w.rot_0 : 1, yA = U != null ? 1 / (1 + Math.exp(-w.opacity)) : AA != null ? w.alpha / rA : 1, fA = M != null ? w.f_dc_0 * tt + 0.5 : z != null ? w.red / j : 1, mA = F != null ? w.f_dc_1 * tt + 0.5 : N != null ? w.green / cA : 1, wA = V != null ? w.f_dc_2 * tt + 0.5 : W != null ? w.blue / tA : 1;\n        if (A(\n          nA,\n          w.x,\n          w.y,\n          w.z,\n          gA,\n          eA,\n          CA,\n          sA,\n          dA,\n          pA,\n          JA,\n          yA,\n          fA,\n          mA,\n          wA\n        ), t && o) {\n          if (o)\n            for (const [K, bA] of r.entries())\n              o[K] = w[bA];\n          if (Q)\n            for (const [K, bA] of n.entries())\n              Q[K] = w[bA];\n          if (g)\n            for (const [K, bA] of I.entries())\n              g[K] = w[bA];\n          t(nA, o, Q, g);\n        }\n      };\n    };\n    this.parseData(u);\n  }\n  // Inject RGBA values into original PLY file, which can be used to modify\n  // the color/opacity of the Gsplats and write out the modified PLY file.\n  injectRgba(A) {\n    let t = 0;\n    const e = this.data;\n    if (e == null)\n      throw new Error(\"No parsed data\");\n    if (A.length !== this.numSplats * 4)\n      throw new Error(\"Invalid RGBA array length\");\n    for (const i in this.elements) {\n      const a = this.elements[i], { count: r, properties: n } = a, I = [];\n      let o = 0;\n      const Q = i === \"vertex\";\n      if (Q) {\n        for (const g of [\"opacity\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"])\n          if (!n[g] || n[g].type !== \"float\")\n            throw new Error(`Can't injectRgba due to property: ${g}`);\n      }\n      for (const [g, c] of Object.entries(n))\n        if (c.isList)\n          I.push(() => {\n            const E = et[c.countType](\n              e,\n              t,\n              this.littleEndian\n            );\n            t += _A[c.countType], t += E * _A[c.type];\n          });\n        else {\n          if (Q)\n            if (g === \"f_dc_0\" || g === \"f_dc_1\" || g === \"f_dc_2\") {\n              const E = Number.parseInt(\n                g.slice(5)\n              );\n              I.push(() => {\n                const l = (A[o + E] / 255 - 0.5) / tt;\n                Pt[c.type](\n                  e,\n                  t,\n                  this.littleEndian,\n                  l\n                );\n              });\n            } else g === \"opacity\" && I.push(() => {\n              const E = Math.max(\n                -100,\n                Math.min(\n                  100,\n                  -Math.log(1 / (A[o + 3] / 255) - 1)\n                )\n              );\n              Pt[c.type](\n                e,\n                t,\n                this.littleEndian,\n                E\n              );\n            });\n          I.push(() => {\n            t += _A[c.type];\n          });\n        }\n      for (let g = 0; g < r; g++) {\n        for (const c of I)\n          c();\n        Q && (o += 4);\n      }\n    }\n  }\n};\nSe.defaultPointScale = 1e-3;\nlet Ui = Se;\nconst tt = 0.28209479177387814, et = {\n  char: (s, A, t) => s.getInt8(A),\n  uchar: (s, A, t) => s.getUint8(A),\n  short: (s, A, t) => s.getInt16(A, t),\n  ushort: (s, A, t) => s.getUint16(A, t),\n  int: (s, A, t) => s.getInt32(A, t),\n  uint: (s, A, t) => s.getUint32(A, t),\n  float: (s, A, t) => s.getFloat32(A, t),\n  double: (s, A, t) => s.getFloat64(A, t)\n}, Pt = {\n  char: (s, A, t, e) => {\n    s.setInt8(A, e);\n  },\n  uchar: (s, A, t, e) => {\n    s.setUint8(A, e);\n  },\n  short: (s, A, t, e) => {\n    s.setInt16(A, e, t);\n  },\n  ushort: (s, A, t, e) => {\n    s.setUint16(A, e, t);\n  },\n  int: (s, A, t, e) => {\n    s.setInt32(A, e, t);\n  },\n  uint: (s, A, t, e) => {\n    s.setUint32(A, e, t);\n  },\n  float: (s, A, t, e) => {\n    s.setFloat32(A, e, t);\n  },\n  double: (s, A, t, e) => {\n    s.setFloat64(A, e, t);\n  }\n}, _A = {\n  char: 1,\n  uchar: 1,\n  short: 2,\n  ushort: 2,\n  int: 4,\n  uint: 4,\n  float: 4,\n  double: 8\n}, st = {\n  char: 127,\n  uchar: 255,\n  short: 32767,\n  ushort: 65535,\n  int: 2147483647,\n  uint: 4294967295,\n  float: 1,\n  double: 1\n}, Li = {\n  0: 0,\n  9: 1,\n  24: 2,\n  45: 3\n}, _i = {\n  0: 0,\n  1: 9,\n  2: 24,\n  3: 45\n};\nfunction Ot(s) {\n  let A = 0;\n  for (; s[`f_rest_${A}`]; )\n    A += 1;\n  const t = Li[A];\n  if (t == null)\n    throw new Error(`Unsupported number of SH coefficients: ${A}`);\n  return t;\n}\nconst be = `(function() {\n  \"use strict\";\n  let wasm;\n  const cachedTextDecoder = typeof TextDecoder !== \"undefined\" ? new TextDecoder(\"utf-8\", { ignoreBOM: true, fatal: true }) : { decode: () => {\n    throw Error(\"TextDecoder not available\");\n  } };\n  if (typeof TextDecoder !== \"undefined\") {\n    cachedTextDecoder.decode();\n  }\n  let cachedUint8ArrayMemory0 = null;\n  function getUint8ArrayMemory0() {\n    if (cachedUint8ArrayMemory0 === null || cachedUint8ArrayMemory0.byteLength === 0) {\n      cachedUint8ArrayMemory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8ArrayMemory0;\n  }\n  function getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8ArrayMemory0().subarray(ptr, ptr + len));\n  }\n  function sort_splats(num_splats, readback, ordering) {\n    const ret = wasm.sort_splats(num_splats, readback, ordering);\n    return ret >>> 0;\n  }\n  function raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid) {\n    const ret = wasm.raycast_splats(origin_x, origin_y, origin_z, dir_x, dir_y, dir_z, near, far, num_splats, packed_splats, raycast_ellipsoid);\n    return ret;\n  }\n  async function __wbg_load(module, imports) {\n    if (typeof Response === \"function\" && module instanceof Response) {\n      if (typeof WebAssembly.instantiateStreaming === \"function\") {\n        try {\n          return await WebAssembly.instantiateStreaming(module, imports);\n        } catch (e) {\n          if (module.headers.get(\"Content-Type\") != \"application/wasm\") {\n            console.warn(\"\\`WebAssembly.instantiateStreaming\\` failed because your server does not serve Wasm with \\`application/wasm\\` MIME type. Falling back to \\`WebAssembly.instantiate\\` which is slower. Original error:\\\\n\", e);\n          } else {\n            throw e;\n          }\n        }\n      }\n      const bytes = await module.arrayBuffer();\n      return await WebAssembly.instantiate(bytes, imports);\n    } else {\n      const instance = await WebAssembly.instantiate(module, imports);\n      if (instance instanceof WebAssembly.Instance) {\n        return { instance, module };\n      } else {\n        return instance;\n      }\n    }\n  }\n  function __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbg_buffer_609cc3eee51ed158 = function(arg0) {\n      const ret = arg0.buffer;\n      return ret;\n    };\n    imports.wbg.__wbg_length_3b4f022188ae8db6 = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_6ca527665d89694d = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_length_8cfd2c6409af88ad = function(arg0) {\n      const ret = arg0.length;\n      return ret;\n    };\n    imports.wbg.__wbg_new_9fee97a409b32b68 = function(arg0) {\n      const ret = new Uint16Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_new_e3b321dcfef89fc7 = function(arg0) {\n      const ret = new Uint32Array(arg0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_e6b7e69acd4c7354 = function(arg0, arg1, arg2) {\n      const ret = new Float32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_f1dead44d1fc7212 = function(arg0, arg1, arg2) {\n      const ret = new Uint32Array(arg0, arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_newwithlength_5a5efe313cfd59f1 = function(arg0) {\n      const ret = new Float32Array(arg0 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_set_10bad9bee0e9c58b = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_d23661d19148b229 = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_set_f4f1f0daa30696fc = function(arg0, arg1, arg2) {\n      arg0.set(arg1, arg2 >>> 0);\n    };\n    imports.wbg.__wbg_subarray_3aaeec89bb2544f0 = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbg_subarray_769e1e0f81bb259b = function(arg0, arg1, arg2) {\n      const ret = arg0.subarray(arg1 >>> 0, arg2 >>> 0);\n      return ret;\n    };\n    imports.wbg.__wbindgen_init_externref_table = function() {\n      const table = wasm.__wbindgen_export_0;\n      const offset = table.grow(4);\n      table.set(0, void 0);\n      table.set(offset + 0, void 0);\n      table.set(offset + 1, null);\n      table.set(offset + 2, true);\n      table.set(offset + 3, false);\n    };\n    imports.wbg.__wbindgen_memory = function() {\n      const ret = wasm.memory;\n      return ret;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n      throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    return imports;\n  }\n  function __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n    cachedUint8ArrayMemory0 = null;\n    wasm.__wbindgen_start();\n    return wasm;\n  }\n  async function __wbg_init(module_or_path) {\n    if (wasm !== void 0) return wasm;\n    if (typeof module_or_path !== \"undefined\") {\n      if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n        ({ module_or_path } = module_or_path);\n      } else {\n        console.warn(\"using deprecated parameters for the initialization function; pass a single object instead\");\n      }\n    }\n    if (typeof module_or_path === \"undefined\") {\n      module_or_path = new URL(\"data:application/wasm;base64,AGFzbQEAAAAB9wEkYAJ/fwF/YAN/f38Bf2ACf38AYAN/f38AYAF/AGABfwF/YAV/f39/fwBgA29/fwFvYAV/f39/fwF/YAR/f39/AGABbwFvYANvb38AYAFvAX9gAAF/YAAAYAd/f39/f39/AX9gAX0BfWAGf39/f39/AGAEf39/fwF/YAF/AW9gAAFvYAd/f39/f39/AGACf34Bf2ADf35+AGACf34AYAt9fX19fX19fX9vfwFvYAZ/f39/f38Bf2AFf398f38AYAR/fH9/AGAFf399f38AYAR/fX9/AGAFf39+f38AYAR/fn9/AGADf35+AX9gA39vbwF/YAJ9fQF9AvIEEQN3YmcdX193YmdfYnVmZmVyXzYwOWNjM2VlZTUxZWQxNTgACgN3YmcaX193YmdfbmV3XzlmZWU5N2E0MDliMzJiNjgACgN3YmcaX193Ymdfc2V0X2Y0ZjFmMGRhYTMwNjk2ZmMACwN3YmcdX193YmdfbGVuZ3RoXzhjZmQyYzY0MDlhZjg4YWQADAN3YmcxX193YmdfbmV3d2l0aGJ5dGVvZmZzZXRhbmRsZW5ndGhfZjFkZWFkNDRkMWZjNzIxMgAHA3diZxpfX3diZ19uZXdfZTNiMzIxZGNmZWY4OWZjNwAKA3diZxpfX3diZ19zZXRfZDIzNjYxZDE5MTQ4YjIyOQALA3diZx1fX3diZ19sZW5ndGhfNmNhNTI3NjY1ZDg5Njk0ZAAMA3diZzFfX3diZ19uZXd3aXRoYnl0ZW9mZnNldGFuZGxlbmd0aF9lNmI3ZTY5YWNkNGM3MzU0AAcDd2JnGl9fd2JnX3NldF8xMGJhZDliZWUwZTljNThiAAsDd2JnHV9fd2JnX2xlbmd0aF8zYjRmMDIyMTg4YWU4ZGI2AAwDd2JnH19fd2JnX3N1YmFycmF5Xzc2OWUxZTBmODFiYjI1OWIABwN3YmcfX193Ymdfc3ViYXJyYXlfM2FhZWVjODliYjI1NDRmMAAHA3diZyRfX3diZ19uZXd3aXRobGVuZ3RoXzVhNWVmZTMxM2NmZDU5ZjEAEwN3YmcQX193YmluZGdlbl90aHJvdwACA3diZxFfX3diaW5kZ2VuX21lbW9yeQAUA3diZx9fX3diaW5kZ2VuX2luaXRfZXh0ZXJucmVmX3RhYmxlAA4DwAG+AQUAAAYPAAUF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BSADOgAcIAUgAjYCGCAFIAUpAwA3AhBBlM/AACgCACAFQRBqQZjPwAAoAgAoAhQRAgBBkM/AACgCAEEBawUgBgs2AgBB6NLAAEEAOgAAIANFDQAACwALsgEBBn8CQAJAIABBhAFJDQAgANBvJgEQRSIBKAIMIQUgASgCECECIAFCADcCDCABKAIIIQMgASgCBCEEIAFCBDcCBCABKAIAIQYgAUEANgIAIAAgAkkNASAAIAJrIgAgA08NASAEIABBAnRqIAU2AgAgASACNgIQIAEgADYCDCABIAM2AgggASgCBCABIAQ2AgQgASgCACEAIAEgBjYCACAARQ0AIABBAnRBBBCwAQsPCwALqQEBAX8jAEEQayIGJAACQCABBEAgBkEEaiABIAMgBCAFIAIoAhARBgACQCAGKAIEIgIgBigCDCIBTQRAIAYoAgghBQwBCyACQQJ0IQIgBigCCCEDIAFFBEBBBCEFIAMgAkEEELABDAELIAMgAkEEIAFBAnQiAhCXASIFRQ0CCyAAIAE2AgQgACAFNgIAIAZBEGokAA8LQZiPwABBMhC5AQALQQQgAhCUAQALowEBAn8jAEEgayIDJAACQCABRQRAQQFBACACEMYBIQAMAQsgAyABNgIMIAMgADYCCCADQRBqIANBCGoQLSADKAIQIgEEQANAIAMoAhQhBCADKAIcRQRAIAEgBCACEMYBIQAMAwtBASEAIAIgASAEEJkBDQIgAkH9/wMQnAENAiADQRBqIANBCGoQLSADKAIQIgENAAsLQQAhAAsgA0EgaiQAIAALiwEBAX8CQCACQQBOBEACfyADKAIEBEACQCADKAIIIgRFBEAMAQsgAygCACAEIAEgAhCXAQwCCwsgASACRQ0AGkH9zsAALQAAGiACIAEQpgELIgMEQCAAIAI2AgggACADNgIEIABBADYCAA8LIAAgAjYCCCAAIAE2AgQMAQsgAEEANgIECyAAQQE2AgALqwEBAn8jAEEgayIBJAACQCAAKAIEIgJBA0YgAkECSXINAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIABBKEEEELABIAFBIGokAAuaAQECfyMAQSBrIgEkAAJAIAAoAgRBAkcNAAJAAkAgAC0AGEEBaw4CAgABCyABQQE2AgggAUGshcAANgIEIAFCADcCECABIAFBHGo2AgwgAUEEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiAkUNACAAKAIMIAJBDGxBBBCwAQsgACgCHCICBEAgACgCICACQQEQsAELIAFBIGokAAuSAQEEfyMAQRBrIgIkAEEBIQQCQCABKAIUIgNBJyABKAIYIgUoAhAiAREAAA0AIAJBBGogACgCAEGBAhAiAkAgAi0ABEGAAUYEQCADIAIoAgggAREAAEUNAQwCCyADIAItAA4iACACQQRqaiACLQAPIABrIAUoAgwRAQANAQsgA0EnIAERAAAhBAsgAkEQaiQAIAQLlQEBAn8jAEEgayIDJAACQCAAKAIEIgRBA0YgBEECSXINAAJAAkAgAC0AGEEBaw4CAgABCyADQQE2AgggA0GshcAANgIEIANCADcCECADIANBHGo2AgwgA0EEakGQhsAAEIQBAAsgAEEIahBOIAAoAggiBEUNACAAKAIMIARBDGxBBBCwAQsgAEEoQQQQsAEgA0EgaiQAC4QBAQN/An8CQCAAKAIAIgFFDQADQAJAIAAoAggiAyAAKAIETw0AIAEgA2otAABBxQBHDQAgACADQQFqNgIIDAILAkAgAkUNACAAKAIQIgFFDQBB+aTAAEECIAEQxgFFDQBBAQ8LQQEgAEEBEBMNAhogAkEBayECIAAoAgAiAQ0ACwtBAAsLegEBfyMAQSBrIgIkAAJ/IAAoAgBBgICAgHhHBEAgASAAKAIEIAAoAggQmQEMAQsgAkEQaiAAKAIMKAIAIgBBCGopAgA3AwAgAkEYaiAAQRBqKQIANwMAIAIgACkCADcDCCABKAIUIAEoAhggAkEIahApCyACQSBqJAALSQEDfiAAIAFC/////w+DIgJCPn4iA0IAIgIgAUIgiEI+fnwiAUIghnwiBDcDACAAIAMgBFatIAEgAlStQiCGIAFCIIiEfDcDCAt8AQF/IwBBQGoiBSQAIAUgATYCDCAFIAA2AgggBSADNgIUIAUgAjYCECAFQQI2AhwgBUG8rsAANgIYIAVCAjcCJCAFIAVBEGqtQoCAgICADIQ3AzggBSAFQQhqrUKAgICAkAyENwMwIAUgBUEwajYCICAFQRhqIAQQhAEAC3gBA38CQCAAKAIAIgFBgICAgHhHBEAgAUUNASAAKAIEIAFBARCwAQ8LIAAtAARBA0cNACAAKAIIIgAoAgAhASAAQQRqKAIAIgMoAgAiAgRAIAEgAhEEAAsgAygCBCICBEAgASACIAMoAggQsAELIABBDEEEELABCwvzAwIIfwF+IwBBEGsiAyQAIAAoAgQhBSAAKAIAIQAgASgCFEG4rMAAQQEgASgCGCgCDBEBACEEIANBBGoiAkEAOgAFIAIgBDoABCACIAE2AgAgBQRAA0AgAyAANgIMIANBDGohCCMAQUBqIgEkAEEBIQYCQCADQQRqIgQtAAQNACAELQAFIQkCQCAEKAIAIgIoAhwiB0EEcUUEQCAJQQFxRQ0BIAIoAhRB667AAEECIAIoAhgoAgwRAQBFDQEMAgsgCUEBcUUEQCACKAIUQfWuwABBASACKAIYKAIMEQEADQIgAigCHCEHCyABQQE6ABsgASACKQIUNwIMIAFBzK7AADYCNCABIAFBG2o2AhQgASACKQIINwIkIAIpAgAhCiABIAc2AjggASACKAIQNgIsIAEgAi0AIDoAPCABIAo3AhwgASABQQxqNgIwIAggAUEcakGAmcAAKAIAEQAADQEgASgCMEHwrsAAQQIgASgCNCgCDBEBACEGDAELIAggAkGAmcAAKAIAEQAAIQYLIARBAToABSAEIAY6AAQgAUFAayQAIABBAWohACAFQQFrIgUNAAsLQQEhACADQQRqIgEtAARFBEAgASgCACIAKAIUQfauwABBASAAKAIYKAIMEQEAIQALIAEgADoABCADQRBqJAAgAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0HYscAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2oCAX8BfiMAQTBrIgMkACADIAE2AgQgAyAANgIAIANBAjYCDCADQZitwAA2AgggA0ICNwIUIANCgICAgPACIgQgA62ENwMoIAMgBCADQQRqrYQ3AyAgAyADQSBqNgIQIANBCGogAhCEAQALagIBfwF+IwBBMGsiAyQAIAMgADYCACADIAE2AgQgA0ECNgIMIANB+LHAADYCCCADQgI3AhQgA0KAgICA8AIiBCADQQRqrYQ3AyggAyAEIAOthDcDICADIANBIGo2AhAgA0EIaiACEIQBAAtqAgF/AX4jAEEwayIDJAAgAyAANgIAIAMgATYCBCADQQI2AgwgA0GsssAANgIIIANCAjcCFCADQoCAgIDwAiIEIANBBGqthDcDKCADIAQgA62ENwMgIAMgA0EgajYCECADQQhqIAIQhAEAC2MBAX8jAEEQayIAJAACfyACKAIABEBBwJXAACEDQQkMAQsgAEEEaiACKAIEIAIoAggQJEHAlcAAIAAoAgggACgCBCICGyEDQQkgACgCDCACGwshAiADIAIgARBcIABBEGokAAtnACMAQTBrIgAkAEH8zsAALQAABEAgAEECNgIMIABB8JXAADYCCCAAQgE3AhQgACABNgIsIAAgAEEsaq1CgICAgPAChDcDICAAIABBIGo2AhAgAEEIakGQlsAAEIQBAAsgAEEwaiQAC+caAhJ/AX4jAEEgayIPJAACfyAAKAIAIgAoAgAEQAJ/IAEhDCMAQTBrIgYkACAAKAIIIREgACgCBCEIIAAoAgAhDgJAAkACQAJAAkADQAJAIBEgECIJRgRAQQAhAgwBCyAIRQ0GIAkgEUchEiAJQQFqIRAgCEEBayEHIA4iBC0AACEBQQAhAAJAAkACQAJAA0ACQCABwEEASARAIAFBH3EhAiAAIARqIgVBAWotAABBP3EhAyABQf8BcSIOQd8BTQRAIAJBBnQgA3IhAQwCCyAFQQJqLQAAQT9xIANBBnRyIQEgDkHwAUkEQCABIAJBDHRyIQEMAgsgAkESdEGAgPAAcSAFQQNqLQAAQT9xIAFBBnRyciIBQYCAxABHDQEMDQsgAUH/AXEhAQsCQAJAIAFBMGtBCU0EQCAAIAdGDQ4gACAEaiICQQFqLAAAIgFBv39KDQEgAiAIIABrIgBBASAAQcCdwAAQnQEACyAABEAgACAEaiwAAEG/f0wNAgsgBkEUaiEHIAQhAkEAIQMCQAJAAkACQAJAAkACQCAAIgEOAgQAAQtBASEDIAItAABBK2sOAwMBAwELIAItAABBK0YEQCACQQFqIQIgAUEKSSABQQFrIgMhAQ0BDAILIAEhAyABQQhLDQELQQAhBQNAIAItAABBMGsiAUEJSwRAQQEhAwwDCyACQQFqIQIgASAFQQpsaiEFIANBAWsiAw0ACwwCC0EAIQUDQCABRQ0CIAItAABBMGsiDkEJSwRAQQEhAwwCC0ECIQMgBa1CCn4iFEIgiKcNASACQQFqIQIgAUEBayEBIA4gFKciCmoiBSAKTw0ACwsgByADOgABIAdBAToAAAwBCyAHIAU2AgQgB0EAOgAACyAGLQAUDQMgCCAGKAIYIgVrIQoCQCAFRQ0AIAggAGsiASAFSwRAIAQgBWogAGoiAiwAAEG/f0wNBiACLAAAQb9/Sg0BIAAgBGogAUEAIAVB8J3AABCdAQALIAAgCkcNBQsgACAEaiIBIQcgBCAFaiAAaiEOIAVFIBAgEUdyDQYgDCgCHEEEcUUNBiAHLQAAQegARw0GIAVBAUcEQCABQQFqLAAAQb9/TA0GCyAAIARqQQFqIQEDQEEAIQIgASAORg0IAn8gASwAACIDQQBOBEAgA0H/AXEhCCABQQFqDAELIAEtAAFBP3EhDSADQR9xIQggA0FfTQRAIAhBBnQgDXIhCCABQQJqDAELIAEtAAJBP3EgDUEGdHIhDSADQXBJBEAgDSAIQQx0ciEIIAFBA2oMAQsgCEESdEGAgPAAcSABLQADQT9xIA1BBnRyciIIQYCAxABGDQkgAUEEagshASAIQTBrQQpJIAhBIHJB4QBrQQZJcg0ACwwGCyAAQQFqIQAMAQsLIAQgCEEAIABB0J3AABCdAQALIAYgBi0AFToACEGEm8AAQSsgBkEIakG0n8AAQcSfwAAQZQALIAAgBGogASAFIAFB4J3AABCdAQALIAEgBUEBIAVBoJ3AABCdAQALAkAgCUUNACAMQYCewABBAhCZAUUNACASIQIMAQsCQCAFQQJJDQAgBy8AAEHfyABHDQAgACAEaiIBQQFqIgcsAABBv39MDQMgBUEBayEFCyAKIABrIQgDQCAHIQQCQAJAAkACQAJAAkACQAJAAkACQCAFIgNFDQACQCAELQAAQSRrDgsCAQEBAQEBAQEBAAELIANBAUYNBSAELAABQb9/Sg0EIAQgA0EBIANBgJ/AABCdAQALIAMgBGohCUEAIQAgBCEBA0AgACECIAEiACAJRg0IAn8gACwAACIFQQBOBEAgBUH/AXEhBSAAQQFqDAELIAAtAAFBP3EhByAFQR9xIQEgBUFfTQRAIAFBBnQgB3IhBSAAQQJqDAELIAAtAAJBP3EgB0EGdHIhByAFQXBJBEAgByABQQx0ciEFIABBA2oMAQsgAUESdEGAgPAAcSAALQADQT9xIAdBBnRyciEFIABBBGoLIgEgAiAAa2ohACAFQSRrDgsCAAAAAAAAAAAAAgALAAsgA0EBRg0BIAQsAAFBv39KDQEgBCADQQEgA0G0nsAAEJ0BAAsCQAJAAkAgAgRAAkAgAiADTyIARQRAIAIgBGosAABBv39MDQEgDCAEIAIQmQFFDQRBASECDA4LIAIgA0YNAgsgBCADQQAgAkGUnsAAEJ0BAAsgDCAEIAIQmQFFDQJBASECDAsLIAwgBCACEJkBRQ0AQQEhAgwKCyAARQRAIAIgBGosAABBv39KDQEMDwsgAiADRw0OCyACIARqIQcgAyACayEFDAcLIAYgA0EBayIANgIkIAZBADYCICAGIAA2AhwgBkEkNgIUIAZBJDYCKCAGQQE6ACwgBiAEQQFqIgA2AhggBkEIaiAGQRRqEC4gBigCCEEBRw0EAkAgBigCDCICQX9HBEAgAkEBaiEBIANBAUcNAQwFCyMAQSBrIgAkACAAQQA2AhggAEEBNgIMIABB2LPAADYCCCAAQgQ3AhAgAEEIakHEnsAAEIQBAAsgACwAAEG/f0oNAwwLCwJAAn8gBCwAASIAQQBOBEAgAEH/AXEMAQsgBC0AAkE/cSICIABBH3EiAUEGdHIgAEFfTQ0AGiAELQADQT9xIAJBBnRyIgIgAUEMdHIgAEFwSQ0AGiABQRJ0QYCA8ABxIAQtAARBP3EgAkEGdHJyC0EuRwRAQQEhAiAMQaCfwABBARCZAQ0IIAQsAAFBQEgNAQwDCyAMQYCewABBAhCZAQRAQQEhAgwICwJAIANBA08EQCAELAACQUBIDQELIARBAmohByADQQJrIQUMBwsgBCADQQIgA0GQn8AAEJ0BAAsgBCADQQEgA0Gkn8AAEJ0BAAtBASECIAxBoJ/AAEEBEJkBDQULIARBAWohByADQQFrIQUMAwsCQAJAAkACQCABIANJBEAgASAEaiwAAEFASA0MIAJBAmohAQwBCyABIANHDQsgAkECaiIBRQ0BCwJAIAEgA0kEQCABIARqLAAAQb9/Sg0BDAsLIAEgA0cNCgsgASAEaiEHIAMgAWshBQJAAkAgAg4DBQEAAgsgAC8AAEHToAFGBEBB/57AACEADAYLIAAvAABBwqABRgRAQf6ewAAhAAwGCyAALwAAQdKMAUYEQEH9nsAAIQAMBgsgAC8AAEHMqAFGBEBB/J7AACEADAYLIAAvAABBx6gBRgRAQfuewAAhAAwGCyAALwAAQcygAUYEQEH6nsAAIQAMBgsgAC8AAEHSoAFHDQFB+Z7AACEADAULIAAtAABBwwBGBEBB+J7AACEADAULIAAtAABB9QBGDQEMAwsgBC0AAUH1AEcNAiACQQJJDQEgBCwAAkG/f0wNAQsgACACaiETIAJBAWshCSAEQQJqIgIhAAJAA0BBASENIAAgE0YNAQJ/IAAsAAAiAUEATgRAIAFB/wFxIQEgAEEBagwBCyAALQABQT9xIQsgAUEfcSEKIAFBX00EQCAKQQZ0IAtyIQEgAEECagwBCyAALQACQT9xIAtBBnRyIQsgAUFwSQRAIAsgCkEMdHIhASAAQQNqDAELIApBEnRBgIDwAHEgAC0AA0E/cSALQQZ0cnIiAUGAgMQARg0CIABBBGoLIQAgAUEwa0EKSSABQeEAa0EGSXINAAtBACENCyAGQRRqIQoCQAJAAkACQAJAAkACQCAJIgAOAgABAgsgCkEAOgABDAQLIAItAAAiAUEraw4DAgECAQsgAi0AACEBCwJAAkACQCABQf8BcUErRgRAIABBAWshASACQQFqIQIgAEEJSwRAIAEhAAwCCyABIgANAkEAIQEMAwsgAEEISw0ADAELQQAhAQJAA0AgAEUNAyACLQAAIgtBMGsiCUEKTwRAQX8gC0EgciIJQdcAayILIAsgCUHhAGtJGyIJQRBPDQULIAGtQgSGIhRCIIinDQEgAkEBaiECIABBAWshACAJIBSnIgtqIgEgC08NAAsgCkECOgABDAQLIApBAjoAAQwDC0EAIQEDQCACLQAAIgtBMGsiCUEKTwRAQX8gC0EgciIJQdcAayILIAsgCUHhAGtJGyIJQRBPDQMLIAJBAWohAiAJIAFBBHRqIQEgAEEBayIADQALCyAKIAE2AgQgCkEAOgAADAILIApBAToAASAKQQE6AAAMAQsgCkEBOgAACyAGLQAUDQEgDUVBgIDEACAGKAIYIgAgAEGAsANzQYCAxABrQYCQvH9JGyIAQYCAxABGcg0BIAYgADYCBCAAQSBJIABB/wBrQSFJcg0BIAZBBGogDBBGRQ0DQQEhAgwECyAAIAJBASACQeiewAAQnQEACyASIQIgDCAEIAMQmQFFDQMMAgtBASECIAwgAEEBEJkBRQ0ACwsLIAZBMGokACACDAULIAEgBUEBIAVBhJ7AABCdAQALIAQgAyABIANB1J7AABCdAQALIAQgA0EBIAFBxJ7AABCdAQALIAQgAyACIANBpJ7AABCdAQALQbCdwAAQswEACwwBCyAPQQA2AhwgDyABNgIYIA9CADcCECAPIAApAgQ3AgggD0EIakEBEBILIA9BIGokAAuYAQIDfwFvIwBBIGsiAyQAIAMgACgCABDLASIENgIAIAMgAjYCBCACIARHBEAgA0EANgIIIAMgA0EEaiADQQhqEH4ACxCeASIEEJUBIgUlARAFIQYQMyICIAYmASAFQYQBTwRAIAUQWgsgAiAAKAIAIAFBAnYQrwEgAkGEAU8EQCACEFoLIARBhAFPBEAgBBBaCyADQSBqJAALUAEBfyMAQTBrIgAkACAAQQE2AgwgAEGorMAANgIIIABCATcCFCAAIABBL2qtQoCAgIDwC4Q3AyAgACAAQSBqNgIQIABBCGpB/IPAABCEAQALQwEDfwJAIAJFDQADQCAALQAAIgQgAS0AACIFRgRAIABBAWohACABQQFqIQEgAkEBayICDQEMAgsLIAQgBWshAwsgAwtBAQF/IAIgACgCACAAKAIIIgNrSwRAIAAgAyACEEQgACgCCCEDCyAAKAIEIANqIAEgAhA8GiAAIAIgA2o2AghBAAtBAQF/IAIgACgCACAAKAIIIgNrSwRAIAAgAyACEEogACgCCCEDCyAAKAIEIANqIAEgAhA8GiAAIAIgA2o2AghBAAtPAQJ/IAAoAgQhAiAAKAIAIQMCQCAAKAIIIgAtAABFDQAgA0HkrsAAQQQgAigCDBEBAEUNAEEBDwsgACABQQpGOgAAIAMgASACKAIQEQAAC0cBAX8jAEEQayICJAAgAkEIaiABEHogAiACKAIIIAIoAgwoAhgRAgAgAigCBCEBIAAgAigCADYCACAAIAE2AgQgAkEQaiQAC08BAn9B/c7AAC0AABogASgCBCECIAEoAgAhA0EIQQQQpgEiAUUEQEEEQQgQxAEACyABIAI2AgQgASADNgIAIABBtJbAADYCBCAAIAE2AgALQQEBfyACIAAoAgAgACgCCCIDa0sEQCAAIAMgAhBVIAAoAgghAwsgACgCBCADaiABIAIQPBogACACIANqNgIIQQALQgEBfyMAQSBrIgMkACADQQA2AhAgA0EBNgIEIANCBDcCCCADIAE2AhwgAyAANgIYIAMgA0EYajYCACADIAIQhAEACz0BAn8gACAAKAIEIgMgAms2AgQgACAAKAIAIAIgA0tyIgQ2AgBBASEDIAQEfyADBSAAKAIIIAEgAhCZAQsLPgEBfyMAQRBrIgIkACACQQhqIAEgASgCACgCBBECACACKAIMIQEgACACKAIINgIAIAAgATYCBCACQRBqJAALxAIBA38gACgCACECIAEoAhwiAEEQcUUEQCAAQSBxRQRAIAIgARCyAQ8LQQAhACMAQYABayIEJAAgAigCACECA0AgACAEakH/AGogAkEPcSIDQTByIANBN2ogA0EKSRs6AAAgAEEBayEAIAJBEEkgAkEEdiECRQ0ACyAAQYABaiICQYEBTwRAIAJBgAFBjK/AABBoAAsgAUGcr8AAQQIgACAEakGAAWpBACAAaxAhIARBgAFqJAAPC0EAIQAjAEGAAWsiBCQAIAIoAgAhAgNAIAAgBGpB/wBqIAJBD3EiA0EwciADQdcAaiADQQpJGzoAACAAQQFrIQAgAkEQSSACQQR2IQJFDQALIABBgAFqIgJBgQFPBEAgAkGAAUGMr8AAEGgACyABQZyvwABBAiAAIARqQYABakEAIABrECEgBEGAAWokAAvNAwEDfyAAKAIAIQAgASgCHCIDQRBxRQRAIANBIHFFBEAjAEEQayIDJAACQAJAAkAgAC0AACIAQeQATwRAIAMgACAAQeQAbiIAQeQAbGtB/wFxQQF0QZ6vwABqLwAAOwAODAELQQIhAiAAQQpPDQELIANBDWogAmogAEEwcjoAAAwBC0EBIQIgAyAAQQF0QZ6vwABqLwAAOwAOCyABQQFBACADQQ1qIAJqIAJBA3MQISADQRBqJAAPCyMAQYABayIEJAAgAC0AACEAA0AgAiAEakH/AGogAEEPcSIDQTByIANBN2ogA0EKSRs6AAAgAkEBayECIAAiA0EEdiEAIANBEE8NAAsgAkGAAWoiAEGBAU8EQCAAQYABQYyvwAAQaAALIAFBnK/AAEECIAIgBGpBgAFqQQAgAmsQISAEQYABaiQADwsjAEGAAWsiBCQAIAAtAAAhAANAIAIgBGpB/wBqIABBD3EiA0EwciADQdcAaiADQQpJGzoAACACQQFrIQIgACIDQQR2IQAgA0EQTw0ACyACQYABaiIAQYEBTwRAIABBgAFBjK/AABBoAAsgAUGcr8AAQQIgAiAEakGAAWpBACACaxAhIARBgAFqJAALOAACQCACQYCAxABGDQAgACACIAEoAhARAABFDQBBAQ8LIANFBEBBAA8LIAAgAyAEIAEoAgwRAQALOQEBfyMAQRBrIgMkACADIAE2AgwgAyAANgIIIANBCGpBiI/AACADQQxqQYiPwAAgAkH4jsAAEDgACzwBAX8jAEEQayICJAAgAkGUkcAANgIMIAIgADYCCCACQQhqQZiRwAAgAkEMakGYkcAAIAFBjJXAABA4AAvcBAIHfwF+IwBBEGsiBiQAIAYgADYCDCAGQQxqIQgjAEEQayICJAAgASgCFEHwm8AAQQ0gASgCGCgCDBEBACEAIAJBADoADSACIAA6AAwgAiABNgIIIwBBQGoiACQAQQEhAwJAIAJBCGoiBC0ABA0AIAQtAAUhBSAEKAIAIgEoAhwiB0EEcUUEQCABKAIUQeuuwABB6K7AACAFQQFxIgUbQQJBAyAFGyABKAIYKAIMEQEADQEgASgCFEH9m8AAQQQgASgCGCgCDBEBAA0BIAEoAhRBuK7AAEECIAEoAhgoAgwRAQANASAIIAFB7JvAACgCABEAACEDDAELIAVBAXFFBEAgASgCFEHtrsAAQQMgASgCGCgCDBEBAA0BIAEoAhwhBwsgAEEBOgAbIAAgASkCFDcCDCAAQcyuwAA2AjQgACAAQRtqNgIUIAAgASkCCDcCJCABKQIAIQkgACAHNgI4IAAgASgCEDYCLCAAIAEtACA6ADwgACAJNwIcIAAgAEEMaiIBNgIwIAFB/ZvAAEEEECoNACABQbiuwABBAhAqDQAgCCAAQRxqQeybwAAoAgARAAANACAAKAIwQfCuwABBAiAAKAI0KAIMEQEAIQMLIARBAToABSAEIAM6AAQgAEFAayQAIAItAA0iASACLQAMIgNyIQACQCADQQFxIAFBAUdyDQAgBCgCACIALQAcQQRxRQRAIAAoAhRB867AAEECIAAoAhgoAgwRAQAhAAwBCyAAKAIUQfKuwABBASAAKAIYKAIMEQEAIQALIAJBEGokACAAQQFxIAZBEGokAAsvAQF/IwBBEGsiAiQAIAJBCGogABB6IAIoAgggASACKAIMKAIQEQAAIAJBEGokAAs5AQF/QQEhAgJAIAAgARA/DQAgASgCFEH0q8AAQQIgASgCGCgCDBEBAA0AIABBBGogARA/IQILIAIL1hMCF30LfxAzIiMgCSYBAn8gCCEqIwBBMGsiIiQAICIgIzYCBCAiQoCAgIDAADcCCCAiQQA2AhBB7M7AACErQejOwAAoAgBFBEACf0H9zsAALQAAGgJAQYCAwAAQESIIRQ0AIAhBBGstAABBA3FFDQAgCEGAgMAAEFcaCyAIBEBB+M7AAEGAgBA2AgBB7M7AAEEANgIAQfTOwAAoAgAhI0H0zsAAIAg2AgBB8M7AACgCACEmQfDOwABBgIAQNgIAQejOwAAoAgBB6M7AAEEBNgIARSAmRXJFBEAgIyAmQQJ0QQQQsAELQezOwAAMAQtBBEGAgMAAEJQBAAshKwsgKygCAEUEQCArQX82AgACQCArAn8gKkUEQEEAISNBAAwBCyArQQxqKAIAISwgK0EIaigCACEIAkAgCgRAQQAhIwNAICIgIkEEaiAjQQJ0ICNBgIAEICogI2siCiAKQYCABE8bIgpqIiZBAnQQsQE2AhQgCkECdCIjICxLDQQgIkEUaiAIICMQbyAiIAI4AiAgIiABOAIcICIgADgCGCAiIAU4AiwgIiAEOAIoICIgAzgCJCAIIQojAEEQayInJAAgIwRAICJBCGohKCAiQSRqIiQqAgAhFSAkKgIEIRggJCoCCCEZICJBGGoiJCoCCCEfICQqAgQhICAkKgIAISEDQCAjQQQgI0EESSIkGyEpAkAgCi0AA7NDAAB/Q5VDzczMPV0NACAnQQRqIAogKRAmAn0CQCAkRQRAICcqAgwhDiAnKgIIIQwgJyoCBCELQwAAAAAhFkMAAAAAIRcgCigCDCIlQf8BcQRAICVBAWtB/wFxs0NFIpE9lEMAABDBkhAsIRcLICVBCHYiJEH/AXEEQCAkQQFrQf8BcbNDRSKRPZRDAAAQwZIQLCEWCyAfIA6TIQ8gICAMkyESICEgC5MhESAlQRB2IiRB/wFxDQFDAAAAAAwCC0EDIClBnIPAABBpAAsgJEEBa0H/AXGzQ0UikT2UQwAAEMGSECwLIRogGSAKKAIIIiRBGHWyQwAA/kKVIhMgGCAlQRh1skMAAP5ClSIUlCAZIBOUkyIQlCAkQRB2wLJDAAD+QpUiDSAZIA2UIBUgFJSTIg6UkyAVIBOUIBggDZSTIgxDAACAPyANIA2UkyATIBOUkyAUIBSUk0MAAAAAEJIBkSIblJIiCyALkpIhHCAYIA0gDJQgFCAQlJMgDiAblJIiCyALkpIhHSAVIBQgDpQgEyAMlJMgECAblJIiCyALkpIhHiAPIBMgEiAUlCAPIBOUkyIQlCANIA8gDZQgESAUlJMiDpSTIBEgE5QgEiANlJMiDCAblJIiCyALkpIhDyASIA0gDJQgFCAQlJMgDiAblJIiCyALkpIhDSARIBQgDpQgEyAMlJMgECAblJIiCyALkpIhDAJAIBogFyAWEJIBIBoQkgFDCtcjPJQiC11FBEAgCyAWXkUEQCALIBdeRQRAQwAAgD8gGpUiCyAPlCIPIAsgHJQiEpRDAACAPyAXlSILIAyUIhEgCyAelCIMlEMAAIA/IBaVIgsgDZQiECALIB2UIguUkpIiDiAOlCASIBKUIAwgDJQgCyALlJKSIgwgDyAPlCARIBGUIBAgEJSSkkMAAIC/kpSTIgtDAAAAAF0NBCAOjCALkZMgDJUhDAwDCyAei0O9N4Y1XQ0DIA0gHSAMjCAelSIMlJIgFpUiCyALlCAPIBwgDJSSIBqVIgsgC5SSQwAAgD9eRQ0CDAMLIB2LQ703hjVdDQIgDCAeIA2MIB2VIgyUkiAXlSILIAuUIA8gHCAMlJIgGpUiCyALlJJDAACAP14NAgwBCyAci0O9N4Y1XQ0BIAwgHiAPjCAclSIMlJIgF5UiCyALlCANIB0gDJSSIBaVIgsgC5SSQwAAgD9eDQELIAYgDF9FIAcgDGBFcg0AICgoAggiJCAoKAIARgRAICgQTwsgKCgCBCAkQQJ0aiAMOAIAICggJEEBajYCCAsgCiApQQJ0aiEKICMgKWsiIw0ACwsgJ0EQaiQAICIoAhQiCkGEAU8EQCAKEFoLICYiIyAqSQ0ACwwBC0EAISMDQCAiICJBBGogI0ECdCAjQYCABCAqICNrIgogCkGAgARPGyIKaiImQQJ0ELEBNgIUIApBAnQiIyAsSw0DICJBFGogCCAjEG8gIiACOAIgICIgATgCHCAiIAA4AhggIiAFOAIsICIgBDgCKCAiIAM4AiQgCCEKIwBBEGsiJyQAICMEQCAiQQhqISggIkEkaiIkKgIAIhggGJQgJCoCBCIZIBmUkiAkKgIIIg8gD5SSIRIgIkEYaiIkKgIIIR8gJCoCBCEgICQqAgAhIQNAICNBBCAjQQRJIiQbISkCQCAKLQADs0MAAH9DlUPNzMw9XQ0AICdBBGogCiApECYCfQJAICRFBEAgJyoCDCEOICcqAgghDCAnKgIEIQtDAAAAACERQwAAAAAhECAKKAIMIiVB/wFxBEAgJUEBa0H/AXGzQ0UikT2UQwAAEMGSEMwBIRALICVBCHYiJEH/AXEEQCAkQQFrQf8BcbNDRSKRPZRDAAAQwZIQzAEhEQsgHyAOkyENICAgDJMhFSAhIAuTIQ4gJUEQdiIkQf8BcQ0BQwAAAAAMAgtBAyApQZyDwAAQaQALICRBAWtB/wFxs0NFIpE9lEMAABDBkhDMAQshCyAYIA6UIBkgFZSSIA8gDZSSIgwgDJQgEiAOIA6UIBUgFZSSIA0gDZSSIBAgEZIgC5JDAABAQJUiCyALlJOUkyILQwAAAABdDQAgDIwgC5GTIBKVIgsgBmBFIAcgC2BFcg0AICgoAggiJCAoKAIARgRAICgQTwsgKCgCBCAkQQJ0aiALOAIAICggJEEBajYCCAsgCiApQQJ0aiEKICMgKWsiIw0ACwsgJ0EQaiQAICIoAhQiCkGEAU8EQCAKEFoLICYiIyAqSQ0ACwsgIigCECEjICsoAgBBAWoLNgIAICMQDSEJEDMiCCAJJgEgIiAINgIkICIoAgwhIyAiKAIQISQjAEEgayIlJAAgIkEkaigCACIKJQEQCiEmICUgJDYCBCAlICY2AgACQCAkICZGBEAQngEiKhCVASImJQEgIyAkEAghCRAzIiMgCSYBICpBhAFPBEAgKhBaCyAmQYQBTwRAICYQWgsgCiUBICMlAUEAEAkgI0GEAU8EQCAjEFoLICVBIGokAAwBCyAlQQA2AgggJSAlQQRqICVBCGoQfgALICIoAggiCgRAICIoAgwgCkECdEEEELABCyAiKAIEIgpBhAFPBEAgChBaCyAiQTBqJAAgCAwCCyAjICxB5IbAABBqAAsQcAALIgglASAIEFoL+gECAn8BfiMAQRBrIgIkACACQQE7AQwgAiABNgIIIAIgADYCBCMAQRBrIgEkACACQQRqIgApAgAhBCABIAA2AgwgASAENwIEIwBBEGsiACQAIAFBBGoiASgCACICKAIMIQMCQAJAAkACQCACKAIEDgIAAQILIAMNAUEBIQJBACEDDAILIAMNACACKAIAIgIoAgQhAyACKAIAIQIMAQsgAEGAgICAeDYCACAAIAE2AgwgAEHglsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALIAAgAzYCBCAAIAI2AgAgAEHElsAAIAEoAgQgASgCCCIALQAIIAAtAAkQWQALJQAgAEUEQEGYj8AAQTIQuQEACyAAIAIgAyAEIAUgASgCEBEIAAsoACABIAAoAgAtAABBAnQiAEHkp8AAaigCACAAQdCnwABqKAIAEJkBCyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQEQkACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERIACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQERwACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQER4ACyMAIABFBEBBmI/AAEEyELkBAAsgACACIAMgBCABKAIQESAACygBAX8gACgCACIBQYCAgIB4ckGAgICAeEcEQCAAKAIEIAFBARCwAQsLJwAgAEEcakEAIAJC2KGkg7Hi0d18URtBACABQpXX3ZjDl4qMC1EbCyEAIABFBEBBmI/AAEEyELkBAAsgACACIAMgASgCEBEDAAsfACAARQRAQZiPwABBMhC5AQALIAAgAiABKAIQEQAAC+MVAQx/EDMiBCABJgECfyAAIQYQMyIAIAImASMAQdAAayIIJAAgCCAANgIYIAggBDYCFCAIQRRqKAIAEMoBIQtBvM7AACgCAEUEQEHkzsAAQQA2AgBB2M7AAEEANgIAQczOwABBADYCAEHAzsAAQQA2AgBB4M7AACgCACEFQeDOwABBBDYCAEHczsAAKAIAIQ1B3M7AAEEANgIAQdTOwAAoAgAhA0HUzsAAQQQ2AgBB0M7AACgCACEJQdDOwABBADYCAEHIzsAAKAIAIQRByM7AAEECNgIAQcTOwAAoAgAhB0HEzsAAQQA2AgBBvM7AACgCACEAQbzOwABBATYCAAJAIABFDQAgBwRAIAQgB0EBdEECELABCyAJBEAgAyAJQQJ0QQQQsAELIA1FDQAgBSAN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IABBAWshACACQRBJIAJBBHYhAkUNAAsgAEGAAWoiAkGBAUkEQCABQZyvwABBAiAAIARqQYABakEAIABrECEgASAFNgIcIAEgBzYCBCABIAY2AgAgBEGAAWokAAwBCyACQYABQYyvwAAQaAALCwwAIAAgASkCADcDAAsNACABQfCYwABBAhAeCw0AIABBhJzAACABECkLDgAgAUGvm8AAQQUQmQELDgAgAUG8p8AAQRIQmQELDQAgAEHQqcAAIAEQKQsOACABQcipwABBBRCZAQsZACAAIAFBjM/AACgCACIAQTogABsRAgAACw0AIABBzK7AACABECkLCgAgAiAAIAEQHguQBQEHfwJAAn8CQCACIgUgACABa0sEQCABIAJqIQMgACACaiECIAAgBUEQSQ0CGiACQXxxIQRBACACQQNxIgZrIQcgBgRAIANBAWshAANAIAJBAWsiAiAALQAAOgAAIABBAWshACACIARLDQALCyAEIAUgBmsiBkF8cSIFayECIAMgB2oiA0EDcQRAIAVBAEwNAiADQQN0IgBBGHEhByADQXxxIghBBGshAUEAIABrQRhxIQkgCCgCACEAA0AgBEEEayIEIAAgCXQgASgCACIAIAd2cjYCACABQQRrIQEgAiAESQ0ACwwCCyAFQQBMDQEgASAGakEEayEBA0AgBEEEayIEIAEoAgA2AgAgAUEEayEBIAIgBEkNAAsMAQsCQCAFQRBJBEAgACECDAELIABBACAAa0EDcSIDaiEEIAMEQCAAIQIgASEAA0AgAiAALQAAOgAAIABBAWohACACQQFqIgIgBEkNAAsLIAQgBSADayIFQXxxIgZqIQICQCABIANqIgNBA3EEQCAGQQBMDQEgA0EDdCIAQRhxIQcgA0F8cSIIQQRqIQFBACAAa0EYcSEJIAgoAgAhAANAIAQgACAHdiABKAIAIgAgCXRyNgIAIAFBBGohASAEQQRqIgQgAkkNAAsMAQsgBkEATA0AIAMhAQNAIAQgASgCADYCACABQQRqIQEgBEEEaiIEIAJJDQALCyAFQQNxIQUgAyAGaiEBCyAFRQ0CIAIgBWohAANAIAIgAS0AADoAACABQQFqIQEgAkEBaiICIABJDQALDAILIAZBA3EiAEUNASADIAVrIQMgAiAAawshACADQQFrIQEDQCACQQFrIgIgAS0AADoA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YTBhYWYvbGlicmFyeS9jb3JlL3NyYy9zbGljZS9pbmRleC5ycwB0AxAATwAAAGgDAAA0AAAAdAMQAE8AAABvAwAAMgAAAGFzc2VydGlvbiBmYWlsZWQ6IHNlbGYuaXNfY2hhcl9ib3VuZGFyeShuKS9ydXN0Yy85MGIzNWE2MjM5YzNkOGJkYWJjNTMwYTZhMDgxNmY3ZmY4OWEwYWFmL2xpYnJhcnkvYWxsb2Mvc3JjL3N0cmluZy5ycwAAAA4EEABLAAAAxAcAAB0AAAAOBBAASwAAAMwHAAAdAAAAHAAAAAwAAAAEAAAAHQAAAB4AAAAfAAAARXJyb3Jhc3NlcnRpb24gZmFpbGVkOiBzZWxmLmlzX2NoYXJfYm91bmRhcnkobmV3X2xlbikvcnVzdGMvOTBiMzVhNjIzOWMzZDhiZGFiYzUzMGE2YTA4MTZmN2ZmODlhMGFhZi9saWJyYXJ5L2FsbG9jL3NyYy9zdHJpbmcucnPJBBAASwAAAMAFAAANAAAAAAAAABAAAAAEAAAAIgAAACMAAAAkAAAAYmFja3RyYWNlIGNhcHR1cmUgZmFpbGVkL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9hbnlob3ctMS4wLjk4L3NyYy9lcnJvci5ycwAAVAUQAF4AAABnBAAADgAAAAEAAAAAAAAAOiAAAMwFEAACAAAACgpDYXVzZWQgYnk6CgAAACUAAAAMAAAABAAAACYAAAAnAAAAHwAAAAoKc3RhY2sgYmFja3RyYWNlOlN0YWNrIGJhY2t0cmFjZToKABIGEAARAAAAUwBBuIzAAAvZBAEAAAAoAAAAYSBEaXNwbGF5IGltcGxlbWVudGF0aW9uIHJldHVybmVkIGFuIGVycm9yIHVuZXhwZWN0ZWRseQDJBBAASwAAAHsKAAAOAAAAL3J1c3RjLzkwYjM1YTYyMzljM2Q4YmRhYmM1MzBhNmEwODE2ZjdmZjg5YTBhYWYvbGlicmFyeS9hbGxvYy9zcmMvdmVjL21vZC5yc4gGEABMAAAALQoAACQAAAAAAAAAEAAAAAQAAAAiAAAAIwAAACQAAAAgICAgOiAAAAEAAAAAAAAAAAcQAAIAAAAgICAgICAgL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9qcy1zeXMtMC4zLjc3L3NyYy9saWIucnMAGwcQAFwAAAD7GAAAAQAAAAAAAAAEAAAABAAAADUAAABjbG9zdXJlIGludm9rZWQgcmVjdXJzaXZlbHkgb3IgYWZ0ZXIgYmVpbmcgZHJvcHBlZExhenkgaW5zdGFuY2UgaGFzIHByZXZpb3VzbHkgYmVlbiBwb2lzb25lZMoHEAAqAAAAL1VzZXJzL2RtYXJjb3MvLmNhcmdvL3JlZ2lzdHJ5L3NyYy9pbmRleC5jcmF0ZXMuaW8tNmYxN2QyMmJiYTE1MDAxZi9vbmNlX2NlbGwtMS4yMS4zL3NyYy9saWIucnMA/AcQAF8AAAAIAwAAGQAAAHJlZW50cmFudCBpbml0AABsCBAADgAAAPwHEABfAAAAegIAAA0AQZyRwAALlQ8EAAAABAAAADsAAAA6AAAAPAAAAAwAAAAEAAAAPQAAAD4AAAA/AAAAL3J1c3QvZGVwcy9kbG1hbGxvYy0wLjIuNi9zcmMvZGxtYWxsb2MucnNhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA+PSBzaXplICsgbWluX292ZXJoZWFkAMQIEAApAAAAqAQAAAkAAABhc3NlcnRpb24gZmFpbGVkOiBwc2l6ZSA8PSBzaXplICsgbWF4X292ZXJoZWFkAADECBAAKQAAAK4EAAANAAAAc3RkL3NyYy9iYWNrdHJhY2UucnNvcGVyYXRpb24gbm90IHN1cHBvcnRlZCBvbiB0aGlzIHBsYXRmb3JtgAkQACgAAAAkAAAAAAAAAAIAAACoCRAAdW5zdXBwb3J0ZWQgYmFja3RyYWNlZGlzYWJsZWQgYmFja3RyYWNlAGwJEAAUAAAAigEAAB0AAABAAAAAEAAAAAQAAABBAAAAQgAAAAEAAAAAAAAAOiBzdGQvc3JjL3N5bmMvbGF6eV9sb2NrLnJzABYKEAAZAAAA0AAAABMAAABjYW5ub3QgcmVjdXJzaXZlbHkgYWNxdWlyZSBtdXRleEAKEAAgAAAAc3RkL3NyYy9zeXMvc3luYy9tdXRleC9ub190aHJlYWRzLnJzaAoQACQAAAAUAAAACQAAAHN0ZC9zcmMvc3luYy9v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Zm9ybWF0dGluZyB0cmFpdCBpbXBsZW1lbnRhdGlvbiByZXR1cm5lZCBhbiBlcnJvciB3aGVuIHRoZSB1bmRlcmx5aW5nIHN0cmVhbSBkaWQgbm90YWxsb2Mvc3JjL2ZtdC5ycwAAjhUQABAAAAB+AgAADgAAAGZyb21fc3RyX3JhZGl4X2ludDogbXVzdCBsaWUgaW4gdGhlIHJhbmdlIGBbMiwgMzZdYCAtIGZvdW5kILAVEAA8AAAALi4wMTIzNDU2Nzg5YWJjZGVmQm9ycm93TXV0RXJyb3JhbHJlYWR5IGJvcnJvd2VkOiAAABQWEAASAAAAAQAAAAAAAABbY2FsbGVkIGBPcHRpb246OnVud3JhcCgpYCBvbiBhIGBOb25lYCB2YWx1ZWluZGV4IG91dCBvZiBib3VuZHM6IHRoZSBsZW4gaXMgIGJ1dCB0aGUgaW5kZXggaXMgAABkFhAAIAAAAIQWEAASAAAAPT0hPW1hdGNoZXNhc3NlcnRpb24gYGxlZnQgIHJpZ2h0YCBmYWlsZWQKICBsZWZ0OiAKIHJpZ2h0OiAAsxYQABAAAADDFhAAFwAAANoWEAAJAAAAIHJpZ2h0YCBmYWlsZWQ6IAogIGxlZnQ6IAAAALMWEAAQAAAA/BYQABAAAAAMFxAACQAAANoWEAAJAAAAOiAAAAEAAAAAAAAAOBcQAAIAAAAAAAAADAAAAAQAAABlAAAAZgAAAGcAAAAgICAgIHsgLCAgewosCn0gfQpdY29yZS9zcmMvZm10L251bS5ycwAAdxcQABMAAABmAAAAFwAAADB4MDAwMTAyMDMwNDA1MDYwNzA4MDkxMDExMTIxMzE0MTUxNjE3MTgxOTIwMjEyMjIzMjQyNTI2MjcyODI5MzAzMTMyMzMzNDM1MzYzNzM4Mzk0MDQxNDI0MzQ0NDU0NjQ3NDg0OTUwNTE1MjUzNTQ1NTU2NTc1ODU5NjA2MTYyNjM2NDY1NjY2NzY4Njk3MDcxNzI3Mzc0NzU3Njc3Nzg3OTgwODE4MjgzODQ4NTg2ODc4ODg5OTA5MTkyOTM5NDk1OTY5Nzk4OTljb3JlL3NyYy9mbXQvbW9kLnJzZmFsc2V0cnVlAABmGBAAEwAAAKMJAAAmAAAAZhgQABMAAACsCQAAGgAAAHJhbmdlIHN0YXJ0IGluZGV4ICBvdXQgb2Yg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\", self.location.href);\n    }\n    const imports = __wbg_get_imports();\n    if (typeof module_or_path === \"string\" || typeof Request === \"function\" && module_or_path instanceof Request || typeof URL === \"function\" && module_or_path instanceof URL) {\n      module_or_path = fetch(module_or_path);\n    }\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n    return __wbg_finalize_init(instance, module);\n  }\n  var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array;\n  var fleb = new u8([\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    2,\n    2,\n    2,\n    2,\n    3,\n    3,\n    3,\n    3,\n    4,\n    4,\n    4,\n    4,\n    5,\n    5,\n    5,\n    5,\n    0,\n    /* unused */\n    0,\n    0,\n    /* impossible */\n    0\n  ]);\n  var fdeb = new u8([\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    2,\n    2,\n    3,\n    3,\n    4,\n    4,\n    5,\n    5,\n    6,\n    6,\n    7,\n    7,\n    8,\n    8,\n    9,\n    9,\n    10,\n    10,\n    11,\n    11,\n    12,\n    12,\n    13,\n    13,\n    /* unused */\n    0,\n    0\n  ]);\n  var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n  var freb = function(eb, start) {\n    var b = new u16(31);\n    for (var i2 = 0; i2 < 31; ++i2) {\n      b[i2] = start += 1 << eb[i2 - 1];\n    }\n    var r = new i32(b[30]);\n    for (var i2 = 1; i2 < 30; ++i2) {\n      for (var j = b[i2]; j < b[i2 + 1]; ++j) {\n        r[j] = j - b[i2] << 5 | i2;\n      }\n    }\n    return { b, r };\n  };\n  var _a = freb(fleb, 2), fl = _a.b, revfl = _a.r;\n  fl[28] = 258, revfl[258] = 28;\n  var _b = freb(fdeb, 0), fd = _b.b;\n  var rev = new u16(32768);\n  for (var i = 0; i < 32768; ++i) {\n    var x = (i & 43690) >> 1 | (i & 21845) << 1;\n    x = (x & 52428) >> 2 | (x & 13107) << 2;\n    x = (x & 61680) >> 4 | (x & 3855) << 4;\n    rev[i] = ((x & 65280) >> 8 | (x & 255) << 8) >> 1;\n  }\n  var hMap = function(cd, mb, r) {\n    var s = cd.length;\n    var i2 = 0;\n    var l = new u16(mb);\n    for (; i2 < s; ++i2) {\n      if (cd[i2])\n        ++l[cd[i2] - 1];\n    }\n    var le = new u16(mb);\n    for (i2 = 1; i2 < mb; ++i2) {\n      le[i2] = le[i2 - 1] + l[i2 - 1] << 1;\n    }\n    var co;\n    if (r) {\n      co = new u16(1 << mb);\n      var rvb = 15 - mb;\n      for (i2 = 0; i2 < s; ++i2) {\n        if (cd[i2]) {\n          var sv = i2 << 4 | cd[i2];\n          var r_1 = mb - cd[i2];\n          var v = le[cd[i2] - 1]++ << r_1;\n          for (var m = v | (1 << r_1) - 1; v <= m; ++v) {\n            co[rev[v] >> rvb] = sv;\n          }\n        }\n      }\n    } else {\n      co = new u16(s);\n      for (i2 = 0; i2 < s; ++i2) {\n        if (cd[i2]) {\n          co[i2] = rev[le[cd[i2] - 1]++] >> 15 - cd[i2];\n        }\n      }\n    }\n    return co;\n  };\n  var flt = new u8(288);\n  for (var i = 0; i < 144; ++i)\n    flt[i] = 8;\n  for (var i = 144; i < 256; ++i)\n    flt[i] = 9;\n  for (var i = 256; i < 280; ++i)\n    flt[i] = 7;\n  for (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n  var fdt = new u8(32);\n  for (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n  var flrm = /* @__PURE__ */ hMap(flt, 9, 1);\n  var fdrm = /* @__PURE__ */ hMap(fdt, 5, 1);\n  var max = function(a) {\n    var m = a[0];\n    for (var i2 = 1; i2 < a.length; ++i2) {\n      if (a[i2] > m)\n        m = a[i2];\n    }\n    return m;\n  };\n  var bits = function(d, p, m) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8) >> (p & 7) & m;\n  };\n  var bits16 = function(d, p) {\n    var o = p / 8 | 0;\n    return (d[o] | d[o + 1] << 8 | d[o + 2] << 16) >> (p & 7);\n  };\n  var shft = function(p) {\n    return (p + 7) / 8 | 0;\n  };\n  var slc = function(v, s, e) {\n    if (s == null || s < 0)\n      s = 0;\n    if (e == null || e > v.length)\n      e = v.length;\n    return new u8(v.subarray(s, e));\n  };\n  var ec = [\n    \"unexpected EOF\",\n    \"invalid block type\",\n    \"invalid length/literal\",\n    \"invalid distance\",\n    \"stream finished\",\n    \"no stream handler\",\n    ,\n    \"no callback\",\n    \"invalid UTF-8 data\",\n    \"extra field too long\",\n    \"date not in range 1980-2099\",\n    \"filename too long\",\n    \"stream finishing\",\n    \"invalid zip data\"\n    // determined by unknown compression method\n  ];\n  var err = function(ind, msg, nt) {\n    var e = new Error(msg || ec[ind]);\n    e.code = ind;\n    if (Error.captureStackTrace)\n      Error.captureStackTrace(e, err);\n    if (!nt)\n      throw e;\n    return e;\n  };\n  var inflt = function(dat, st, buf, dict) {\n    var sl = dat.length, dl = 0;\n    if (!sl || st.f && !st.l)\n      return buf || new u8(0);\n    var noBuf = !buf;\n    var resize = noBuf || st.i != 2;\n    var noSt = st.i;\n    if (noBuf)\n      buf = new u8(sl * 3);\n    var cbuf = function(l2) {\n      var bl = buf.length;\n      if (l2 > bl) {\n        var nbuf = new u8(Math.max(bl * 2, l2));\n        nbuf.set(buf);\n        buf = nbuf;\n      }\n    };\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    var tbts = sl * 8;\n    do {\n      if (!lm) {\n        final = bits(dat, pos, 1);\n        var type = bits(dat, pos + 1, 3);\n        pos += 3;\n        if (!type) {\n          var s = shft(pos) + 4, l = dat[s - 4] | dat[s - 3] << 8, t = s + l;\n          if (t > sl) {\n            if (noSt)\n              err(0);\n            break;\n          }\n          if (resize)\n            cbuf(bt + l);\n          buf.set(dat.subarray(s, t), bt);\n          st.b = bt += l, st.p = pos = t * 8, st.f = final;\n          continue;\n        } else if (type == 1)\n          lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n        else if (type == 2) {\n          var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n          var tl = hLit + bits(dat, pos + 5, 31) + 1;\n          pos += 14;\n          var ldt = new u8(tl);\n          var clt = new u8(19);\n          for (var i2 = 0; i2 < hcLen; ++i2) {\n            clt[clim[i2]] = bits(dat, pos + i2 * 3, 7);\n          }\n          pos += hcLen * 3;\n          var clb = max(clt), clbmsk = (1 << clb) - 1;\n          var clm = hMap(clt, clb, 1);\n          for (var i2 = 0; i2 < tl; ) {\n            var r = clm[bits(dat, pos, clbmsk)];\n            pos += r & 15;\n            var s = r >> 4;\n            if (s < 16) {\n              ldt[i2++] = s;\n            } else {\n              var c = 0, n = 0;\n              if (s == 16)\n                n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i2 - 1];\n              else if (s == 17)\n                n = 3 + bits(dat, pos, 7), pos += 3;\n              else if (s == 18)\n                n = 11 + bits(dat, pos, 127), pos += 7;\n              while (n--)\n                ldt[i2++] = c;\n            }\n          }\n          var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n          lbt = max(lt);\n          dbt = max(dt);\n          lm = hMap(lt, lbt, 1);\n          dm = hMap(dt, dbt, 1);\n        } else\n          err(1);\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n      }\n      if (resize)\n        cbuf(bt + 131072);\n      var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n      var lpos = pos;\n      for (; ; lpos = pos) {\n        var c = lm[bits16(dat, pos) & lms], sym = c >> 4;\n        pos += c & 15;\n        if (pos > tbts) {\n          if (noSt)\n            err(0);\n          break;\n        }\n        if (!c)\n          err(2);\n        if (sym < 256)\n          buf[bt++] = sym;\n        else if (sym == 256) {\n          lpos = pos, lm = null;\n          break;\n        } else {\n          var add2 = sym - 254;\n          if (sym > 264) {\n            var i2 = sym - 257, b = fleb[i2];\n            add2 = bits(dat, pos, (1 << b) - 1) + fl[i2];\n            pos += b;\n          }\n          var d = dm[bits16(dat, pos) & dms], dsym = d >> 4;\n          if (!d)\n            err(3);\n          pos += d & 15;\n          var dt = fd[dsym];\n          if (dsym > 3) {\n            var b = fdeb[dsym];\n            dt += bits16(dat, pos) & (1 << b) - 1, pos += b;\n          }\n          if (pos > tbts) {\n            if (noSt)\n              err(0);\n            break;\n          }\n          if (resize)\n            cbuf(bt + 131072);\n          var end = bt + add2;\n          if (bt < dt) {\n            var shift = dl - dt, dend = Math.min(dt, end);\n            if (shift + bt < 0)\n              err(3);\n            for (; bt < dend; ++bt)\n              buf[bt] = dict[shift + bt];\n          }\n          for (; bt < end; ++bt)\n            buf[bt] = buf[bt - dt];\n        }\n      }\n      st.l = lm, st.p = lpos, st.b = bt, st.f = final;\n      if (lm)\n        final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt != buf.length && noBuf ? slc(buf, 0, bt) : buf.subarray(0, bt);\n  };\n  var et = /* @__PURE__ */ new u8(0);\n  var gzs = function(d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n      err(6, \"invalid gzip data\");\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n      st += (d[10] | d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n      ;\n    return st + (flg & 2);\n  };\n  var Inflate = /* @__PURE__ */ function() {\n    function Inflate2(opts, cb) {\n      if (typeof opts == \"function\")\n        cb = opts, opts = {};\n      this.ondata = cb;\n      var dict = opts && opts.dictionary && opts.dictionary.subarray(-32768);\n      this.s = { i: 0, b: dict ? dict.length : 0 };\n      this.o = new u8(32768);\n      this.p = new u8(0);\n      if (dict)\n        this.o.set(dict);\n    }\n    Inflate2.prototype.e = function(c) {\n      if (!this.ondata)\n        err(5);\n      if (this.d)\n        err(4);\n      if (!this.p.length)\n        this.p = c;\n      else if (c.length) {\n        var n = new u8(this.p.length + c.length);\n        n.set(this.p), n.set(c, this.p.length), this.p = n;\n      }\n    };\n    Inflate2.prototype.c = function(final) {\n      this.s.i = +(this.d = final || false);\n      var bts = this.s.b;\n      var dt = inflt(this.p, this.s, this.o);\n      this.ondata(slc(dt, bts, this.s.b), this.d);\n      this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n      this.p = slc(this.p, this.s.p / 8 | 0), this.s.p &= 7;\n    };\n    Inflate2.prototype.push = function(chunk, final) {\n      this.e(chunk), this.c(final);\n    };\n    return Inflate2;\n  }();\n  var Gunzip = /* @__PURE__ */ function() {\n    function Gunzip2(opts, cb) {\n      this.v = 1;\n      this.r = 0;\n      Inflate.call(this, opts, cb);\n    }\n    Gunzip2.prototype.push = function(chunk, final) {\n      Inflate.prototype.e.call(this, chunk);\n      this.r += chunk.length;\n      if (this.v) {\n        var p = this.p.subarray(this.v - 1);\n        var s = p.length > 3 ? gzs(p) : 4;\n        if (s > p.length) {\n          if (!final)\n            return;\n        } else if (this.v > 1 && this.onmember) {\n          this.onmember(this.r - p.length);\n        }\n        this.p = p.subarray(s), this.v = 0;\n      }\n      Inflate.prototype.c.call(this, final);\n      if (this.s.f && !this.s.l && !final) {\n        this.v = shft(this.s.p) + 9;\n        this.s = { i: 0 };\n        this.o = new u8(0);\n        this.push(new u8(0), final);\n      }\n    };\n    return Gunzip2;\n  }();\n  var td = typeof TextDecoder != \"undefined\" && /* @__PURE__ */ new TextDecoder();\n  var tds = 0;\n  try {\n    td.decode(et, { stream: true });\n    tds = 1;\n  } catch (e) {\n  }\n  /**\n   * @license\n   * Copyright 2010-2024 Three.js Authors\n   * SPDX-License-Identifier: MIT\n   */\n  const REVISION = \"172\";\n  const FrontSide = 0;\n  const BackSide = 1;\n  const NormalBlending = 1;\n  const AddEquation = 100;\n  const SrcAlphaFactor = 204;\n  const OneMinusSrcAlphaFactor = 205;\n  const LessEqualDepth = 3;\n  const MultiplyOperation = 0;\n  const UVMapping = 300;\n  const RepeatWrapping = 1e3;\n  const ClampToEdgeWrapping = 1001;\n  const MirroredRepeatWrapping = 1002;\n  const NearestFilter = 1003;\n  const LinearFilter = 1006;\n  const LinearMipmapLinearFilter = 1008;\n  const UnsignedByteType = 1009;\n  const UnsignedIntType = 1014;\n  const FloatType = 1015;\n  const RGBAFormat = 1023;\n  const RGIntegerFormat = 1031;\n  const RGBAIntegerFormat = 1033;\n  const NoColorSpace = \"\";\n  const SRGBColorSpace = \"srgb\";\n  const LinearSRGBColorSpace = \"srgb-linear\";\n  const LinearTransfer = \"linear\";\n  const SRGBTransfer = \"srgb\";\n  const KeepStencilOp = 7680;\n  const AlwaysStencilFunc = 519;\n  const StaticDrawUsage = 35044;\n  const GLSL3 = \"300 es\";\n  const WebGLCoordinateSystem = 2e3;\n  const WebGPUCoordinateSystem = 2001;\n  class EventDispatcher {\n    addEventListener(type, listener) {\n      if (this._listeners === void 0) this._listeners = {};\n      const listeners = this._listeners;\n      if (listeners[type] === void 0) {\n        listeners[type] = [];\n      }\n      if (listeners[type].indexOf(listener) === -1) {\n        listeners[type].push(listener);\n      }\n    }\n    hasEventListener(type, listener) {\n      if (this._listeners === void 0) return false;\n      const listeners = this._listeners;\n      return listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1;\n    }\n    removeEventListener(type, listener) {\n      if (this._listeners === void 0) return;\n      const listeners = this._listeners;\n      const listenerArray = listeners[type];\n      if (listenerArray !== void 0) {\n        const index = listenerArray.indexOf(listener);\n        if (index !== -1) {\n          listenerArray.splice(index, 1);\n        }\n      }\n    }\n    dispatchEvent(event) {\n      if (this._listeners === void 0) return;\n      const listeners = this._listeners;\n      const listenerArray = listeners[event.type];\n      if (listenerArray !== void 0) {\n        event.target = this;\n        const array = listenerArray.slice(0);\n        for (let i2 = 0, l = array.length; i2 < l; i2++) {\n          array[i2].call(this, event);\n        }\n        event.target = null;\n      }\n    }\n  }\n  const _lut = [\"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\", \"0a\", \"0b\", \"0c\", \"0d\", \"0e\", \"0f\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\", \"1a\", \"1b\", \"1c\", \"1d\", \"1e\", \"1f\", \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"2a\", \"2b\", \"2c\", \"2d\", \"2e\", \"2f\", \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\", \"3a\", \"3b\", \"3c\", \"3d\", \"3e\", \"3f\", \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\", \"4a\", \"4b\", \"4c\", \"4d\", \"4e\", \"4f\", \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\", \"5a\", \"5b\", \"5c\", \"5d\", \"5e\", \"5f\", \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\", \"6a\", \"6b\", \"6c\", \"6d\", \"6e\", \"6f\", \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\", \"7a\", \"7b\", \"7c\", \"7d\", \"7e\", \"7f\", \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\", \"8a\", \"8b\", \"8c\", \"8d\", \"8e\", \"8f\", \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\", \"9a\", \"9b\", \"9c\", \"9d\", \"9e\", \"9f\", \"a0\", \"a1\", \"a2\", \"a3\", \"a4\", \"a5\", \"a6\", \"a7\", \"a8\", \"a9\", \"aa\", \"ab\", \"ac\", \"ad\", \"ae\", \"af\", \"b0\", \"b1\", \"b2\", \"b3\", \"b4\", \"b5\", \"b6\", \"b7\", \"b8\", \"b9\", \"ba\", \"bb\", \"bc\", \"bd\", \"be\", \"bf\", \"c0\", \"c1\", \"c2\", \"c3\", \"c4\", \"c5\", \"c6\", \"c7\", \"c8\", \"c9\", \"ca\", \"cb\", \"cc\", \"cd\", \"ce\", \"cf\", \"d0\", \"d1\", \"d2\", \"d3\", \"d4\", \"d5\", \"d6\", \"d7\", \"d8\", \"d9\", \"da\", \"db\", \"dc\", \"dd\", \"de\", \"df\", \"e0\", \"e1\", \"e2\", \"e3\", \"e4\", \"e5\", \"e6\", \"e7\", \"e8\", \"e9\", \"ea\", \"eb\", \"ec\", \"ed\", \"ee\", \"ef\", \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \"f8\", \"f9\", \"fa\", \"fb\", \"fc\", \"fd\", \"fe\", \"ff\"];\n  function generateUUID() {\n    const d0 = Math.random() * 4294967295 | 0;\n    const d1 = Math.random() * 4294967295 | 0;\n    const d2 = Math.random() * 4294967295 | 0;\n    const d3 = Math.random() * 4294967295 | 0;\n    const uuid = _lut[d0 & 255] + _lut[d0 >> 8 & 255] + _lut[d0 >> 16 & 255] + _lut[d0 >> 24 & 255] + \"-\" + _lut[d1 & 255] + _lut[d1 >> 8 & 255] + \"-\" + _lut[d1 >> 16 & 15 | 64] + _lut[d1 >> 24 & 255] + \"-\" + _lut[d2 & 63 | 128] + _lut[d2 >> 8 & 255] + \"-\" + _lut[d2 >> 16 & 255] + _lut[d2 >> 24 & 255] + _lut[d3 & 255] + _lut[d3 >> 8 & 255] + _lut[d3 >> 16 & 255] + _lut[d3 >> 24 & 255];\n    return uuid.toLowerCase();\n  }\n  function clamp(value, min, max2) {\n    return Math.max(min, Math.min(max2, value));\n  }\n  function euclideanModulo(n, m) {\n    return (n % m + m) % m;\n  }\n  function lerp(x2, y, t) {\n    return (1 - t) * x2 + t * y;\n  }\n  function denormalize(value, array) {\n    switch (array.constructor) {\n      case Float32Array:\n        return value;\n      case Uint32Array:\n        return value / 4294967295;\n      case Uint16Array:\n        return value / 65535;\n      case Uint8Array:\n        return value / 255;\n      case Int32Array:\n        return Math.max(value / 2147483647, -1);\n      case Int16Array:\n        return Math.max(value / 32767, -1);\n      case Int8Array:\n        return Math.max(value / 127, -1);\n      default:\n        throw new Error(\"Invalid component type.\");\n    }\n  }\n  function normalize$1(value, array) {\n    switch (array.constructor) {\n      case Float32Array:\n        return value;\n      case Uint32Array:\n        return Math.round(value * 4294967295);\n      case Uint16Array:\n        return Math.round(value * 65535);\n      case Uint8Array:\n        return Math.round(value * 255);\n      case Int32Array:\n        return Math.round(value * 2147483647);\n      case Int16Array:\n        return Math.round(value * 32767);\n      case Int8Array:\n        return Math.round(value * 127);\n      default:\n        throw new Error(\"Invalid component type.\");\n    }\n  }\n  class Vector2 {\n    constructor(x2 = 0, y = 0) {\n      Vector2.prototype.isVector2 = true;\n      this.x = x2;\n      this.y = y;\n    }\n    get width() {\n      return this.x;\n    }\n    set width(value) {\n      this.x = value;\n    }\n    get height() {\n      return this.y;\n    }\n    set height(value) {\n      this.y = value;\n    }\n    set(x2, y) {\n      this.x = x2;\n      this.y = y;\n      return this;\n    }\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      return this;\n    }\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        default:\n          throw new Error(\"index is out of range: \" + index);\n      }\n      return this;\n    }\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        default:\n          throw new Error(\"index is out of range: \" + index);\n      }\n    }\n    clone() {\n      return new this.constructor(this.x, this.y);\n    }\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      return this;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      return this;\n    }\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      return this;\n    }\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      return this;\n    }\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      return this;\n    }\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      return this;\n    }\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      return this;\n    }\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      return this;\n    }\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      return this;\n    }\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      return this;\n    }\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      return this;\n    }\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    applyMatrix3(m) {\n      const x2 = this.x, y = this.y;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[3] * y + e[6];\n      this.y = e[1] * x2 + e[4] * y + e[7];\n      return this;\n    }\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      return this;\n    }\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      return this;\n    }\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      return this;\n    }\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      return this;\n    }\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      return this;\n    }\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      return this;\n    }\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      return this;\n    }\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      return this;\n    }\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      return this;\n    }\n    dot(v) {\n      return this.x * v.x + this.y * v.y;\n    }\n    cross(v) {\n      return this.x * v.y - this.y * v.x;\n    }\n    lengthSq() {\n      return this.x * this.x + this.y * this.y;\n    }\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y);\n    }\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    angle() {\n      const angle = Math.atan2(-this.y, -this.x) + Math.PI;\n      return angle;\n    }\n    angleTo(v) {\n      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n      if (denominator === 0) return Math.PI / 2;\n      const theta = this.dot(v) / denominator;\n      return Math.acos(clamp(theta, -1, 1));\n    }\n    distanceTo(v) {\n      return Math.sqrt(this.distanceToSquared(v));\n    }\n    distanceToSquared(v) {\n      const dx = this.x - v.x, dy = this.y - v.y;\n      return dx * dx + dy * dy;\n    }\n    manhattanDistanceTo(v) {\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);\n    }\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      return this;\n    }\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      return this;\n    }\n    equals(v) {\n      return v.x === this.x && v.y === this.y;\n    }\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      return this;\n    }\n    rotateAround(center, angle) {\n      const c = Math.cos(angle), s = Math.sin(angle);\n      const x2 = this.x - center.x;\n      const y = this.y - center.y;\n      this.x = x2 * c - y * s + center.x;\n      this.y = x2 * s + y * c + center.y;\n      return this;\n    }\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n    }\n  }\n  class Matrix3 {\n    constructor(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      Matrix3.prototype.isMatrix3 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);\n      }\n    }\n    set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {\n      const te = this.elements;\n      te[0] = n11;\n      te[1] = n21;\n      te[2] = n31;\n      te[3] = n12;\n      te[4] = n22;\n      te[5] = n32;\n      te[6] = n13;\n      te[7] = n23;\n      te[8] = n33;\n      return this;\n    }\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    copy(m) {\n      const te = this.elements;\n      const me = m.elements;\n      te[0] = me[0];\n      te[1] = me[1];\n      te[2] = me[2];\n      te[3] = me[3];\n      te[4] = me[4];\n      te[5] = me[5];\n      te[6] = me[6];\n      te[7] = me[7];\n      te[8] = me[8];\n      return this;\n    }\n    extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.setFromMatrix3Column(this, 0);\n      yAxis.setFromMatrix3Column(this, 1);\n      zAxis.setFromMatrix3Column(this, 2);\n      return this;\n    }\n    setFromMatrix4(m) {\n      const me = m.elements;\n      this.set(\n        me[0],\n        me[4],\n        me[8],\n        me[1],\n        me[5],\n        me[9],\n        me[2],\n        me[6],\n        me[10]\n      );\n      return this;\n    }\n    multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n    premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n    multiplyMatrices(a, b) {\n      const ae = a.elements;\n      const be = b.elements;\n      const te = this.elements;\n      const a11 = ae[0], a12 = ae[3], a13 = ae[6];\n      const a21 = ae[1], a22 = ae[4], a23 = ae[7];\n      const a31 = ae[2], a32 = ae[5], a33 = ae[8];\n      const b11 = be[0], b12 = be[3], b13 = be[6];\n      const b21 = be[1], b22 = be[4], b23 = be[7];\n      const b31 = be[2], b32 = be[5], b33 = be[8];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31;\n      te[3] = a11 * b12 + a12 * b22 + a13 * b32;\n      te[6] = a11 * b13 + a12 * b23 + a13 * b33;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31;\n      te[4] = a21 * b12 + a22 * b22 + a23 * b32;\n      te[7] = a21 * b13 + a22 * b23 + a23 * b33;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31;\n      te[5] = a31 * b12 + a32 * b22 + a33 * b32;\n      te[8] = a31 * b13 + a32 * b23 + a33 * b33;\n      return this;\n    }\n    multiplyScalar(s) {\n      const te = this.elements;\n      te[0] *= s;\n      te[3] *= s;\n      te[6] *= s;\n      te[1] *= s;\n      te[4] *= s;\n      te[7] *= s;\n      te[2] *= s;\n      te[5] *= s;\n      te[8] *= s;\n      return this;\n    }\n    determinant() {\n      const te = this.elements;\n      const a = te[0], b = te[1], c = te[2], d = te[3], e = te[4], f = te[5], g = te[6], h = te[7], i2 = te[8];\n      return a * e * i2 - a * f * h - b * d * i2 + b * f * g + c * d * h - c * e * g;\n    }\n    invert() {\n      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n12 = te[3], n22 = te[4], n32 = te[5], n13 = te[6], n23 = te[7], n33 = te[8], t11 = n33 * n22 - n32 * n23, t12 = n32 * n13 - n33 * n12, t13 = n23 * n12 - n22 * n13, det = n11 * t11 + n21 * t12 + n31 * t13;\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);\n      const detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n31 * n23 - n33 * n21) * detInv;\n      te[2] = (n32 * n21 - n31 * n22) * detInv;\n      te[3] = t12 * detInv;\n      te[4] = (n33 * n11 - n31 * n13) * detInv;\n      te[5] = (n31 * n12 - n32 * n11) * detInv;\n      te[6] = t13 * detInv;\n      te[7] = (n21 * n13 - n23 * n11) * detInv;\n      te[8] = (n22 * n11 - n21 * n12) * detInv;\n      return this;\n    }\n    transpose() {\n      let tmp;\n      const m = this.elements;\n      tmp = m[1];\n      m[1] = m[3];\n      m[3] = tmp;\n      tmp = m[2];\n      m[2] = m[6];\n      m[6] = tmp;\n      tmp = m[5];\n      m[5] = m[7];\n      m[7] = tmp;\n      return this;\n    }\n    getNormalMatrix(matrix4) {\n      return this.setFromMatrix4(matrix4).invert().transpose();\n    }\n    transposeIntoArray(r) {\n      const m = this.elements;\n      r[0] = m[0];\n      r[1] = m[3];\n      r[2] = m[6];\n      r[3] = m[1];\n      r[4] = m[4];\n      r[5] = m[7];\n      r[6] = m[2];\n      r[7] = m[5];\n      r[8] = m[8];\n      return this;\n    }\n    setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {\n      const c = Math.cos(rotation);\n      const s = Math.sin(rotation);\n      this.set(\n        sx * c,\n        sx * s,\n        -sx * (c * cx + s * cy) + cx + tx,\n        -sy * s,\n        sy * c,\n        -sy * (-s * cx + c * cy) + cy + ty,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    //\n    scale(sx, sy) {\n      this.premultiply(_m3.makeScale(sx, sy));\n      return this;\n    }\n    rotate(theta) {\n      this.premultiply(_m3.makeRotation(-theta));\n      return this;\n    }\n    translate(tx, ty) {\n      this.premultiply(_m3.makeTranslation(tx, ty));\n      return this;\n    }\n    // for 2D Transforms\n    makeTranslation(x2, y) {\n      if (x2.isVector2) {\n        this.set(\n          1,\n          0,\n          x2.x,\n          0,\n          1,\n          x2.y,\n          0,\n          0,\n          1\n        );\n      } else {\n        this.set(\n          1,\n          0,\n          x2,\n          0,\n          1,\n          y,\n          0,\n          0,\n          1\n        );\n      }\n      return this;\n    }\n    makeRotation(theta) {\n      const c = Math.cos(theta);\n      const s = Math.sin(theta);\n      this.set(\n        c,\n        -s,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeScale(x2, y) {\n      this.set(\n        x2,\n        0,\n        0,\n        0,\n        y,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    //\n    equals(matrix) {\n      const te = this.elements;\n      const me = matrix.elements;\n      for (let i2 = 0; i2 < 9; i2++) {\n        if (te[i2] !== me[i2]) return false;\n      }\n      return true;\n    }\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 9; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      const te = this.elements;\n      array[offset] = te[0];\n      array[offset + 1] = te[1];\n      array[offset + 2] = te[2];\n      array[offset + 3] = te[3];\n      array[offset + 4] = te[4];\n      array[offset + 5] = te[5];\n      array[offset + 6] = te[6];\n      array[offset + 7] = te[7];\n      array[offset + 8] = te[8];\n      return array;\n    }\n    clone() {\n      return new this.constructor().fromArray(this.elements);\n    }\n  }\n  const _m3 = /* @__PURE__ */ new Matrix3();\n  function arrayNeedsUint32(array) {\n    for (let i2 = array.length - 1; i2 >= 0; --i2) {\n      if (array[i2] >= 65535) return true;\n    }\n    return false;\n  }\n  function createElementNS(name) {\n    return document.createElementNS(\"http://www.w3.org/1999/xhtml\", name);\n  }\n  const LINEAR_REC709_TO_XYZ = /* @__PURE__ */ new Matrix3().set(\n    0.4123908,\n    0.3575843,\n    0.1804808,\n    0.212639,\n    0.7151687,\n    0.0721923,\n    0.0193308,\n    0.1191948,\n    0.9505322\n  );\n  const XYZ_TO_LINEAR_REC709 = /* @__PURE__ */ new Matrix3().set(\n    3.2409699,\n    -1.5373832,\n    -0.4986108,\n    -0.9692436,\n    1.8759675,\n    0.0415551,\n    0.0556301,\n    -0.203977,\n    1.0569715\n  );\n  function createColorManagement() {\n    const ColorManagement2 = {\n      enabled: true,\n      workingColorSpace: LinearSRGBColorSpace,\n      /**\n       * Implementations of supported color spaces.\n       *\n       * Required:\n       *\t- primaries: chromaticity coordinates [ rx ry gx gy bx by ]\n       *\t- whitePoint: reference white [ x y ]\n       *\t- transfer: transfer function (pre-defined)\n       *\t- toXYZ: Matrix3 RGB to XYZ transform\n       *\t- fromXYZ: Matrix3 XYZ to RGB transform\n       *\t- luminanceCoefficients: RGB luminance coefficients\n       *\n       * Optional:\n       *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }\n       *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }\n       *\n       * Reference:\n       * - https://www.russellcottrell.com/photo/matrixCalculator.htm\n       */\n      spaces: {},\n      convert: function(color, sourceColorSpace, targetColorSpace) {\n        if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {\n          return color;\n        }\n        if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {\n          color.r = SRGBToLinear(color.r);\n          color.g = SRGBToLinear(color.g);\n          color.b = SRGBToLinear(color.b);\n        }\n        if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {\n          color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);\n          color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);\n        }\n        if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {\n          color.r = LinearToSRGB(color.r);\n          color.g = LinearToSRGB(color.g);\n          color.b = LinearToSRGB(color.b);\n        }\n        return color;\n      },\n      fromWorkingColorSpace: function(color, targetColorSpace) {\n        return this.convert(color, this.workingColorSpace, targetColorSpace);\n      },\n      toWorkingColorSpace: function(color, sourceColorSpace) {\n        return this.convert(color, sourceColorSpace, this.workingColorSpace);\n      },\n      getPrimaries: function(colorSpace) {\n        return this.spaces[colorSpace].primaries;\n      },\n      getTransfer: function(colorSpace) {\n        if (colorSpace === NoColorSpace) return LinearTransfer;\n        return this.spaces[colorSpace].transfer;\n      },\n      getLuminanceCoefficients: function(target, colorSpace = this.workingColorSpace) {\n        return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);\n      },\n      define: function(colorSpaces) {\n        Object.assign(this.spaces, colorSpaces);\n      },\n      // Internal APIs\n      _getMatrix: function(targetMatrix, sourceColorSpace, targetColorSpace) {\n        return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);\n      },\n      _getDrawingBufferColorSpace: function(colorSpace) {\n        return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;\n      },\n      _getUnpackColorSpace: function(colorSpace = this.workingColorSpace) {\n        return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;\n      }\n    };\n    const REC709_PRIMARIES = [0.64, 0.33, 0.3, 0.6, 0.15, 0.06];\n    const REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];\n    const D65 = [0.3127, 0.329];\n    ColorManagement2.define({\n      [LinearSRGBColorSpace]: {\n        primaries: REC709_PRIMARIES,\n        whitePoint: D65,\n        transfer: LinearTransfer,\n        toXYZ: LINEAR_REC709_TO_XYZ,\n        fromXYZ: XYZ_TO_LINEAR_REC709,\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n        workingColorSpaceConfig: { unpackColorSpace: SRGBColorSpace },\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n      },\n      [SRGBColorSpace]: {\n        primaries: REC709_PRIMARIES,\n        whitePoint: D65,\n        transfer: SRGBTransfer,\n        toXYZ: LINEAR_REC709_TO_XYZ,\n        fromXYZ: XYZ_TO_LINEAR_REC709,\n        luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,\n        outputColorSpaceConfig: { drawingBufferColorSpace: SRGBColorSpace }\n      }\n    });\n    return ColorManagement2;\n  }\n  const ColorManagement = /* @__PURE__ */ createColorManagement();\n  function SRGBToLinear(c) {\n    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);\n  }\n  function LinearToSRGB(c) {\n    return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;\n  }\n  let _canvas;\n  class ImageUtils {\n    static getDataURL(image) {\n      if (/^data:/i.test(image.src)) {\n        return image.src;\n      }\n      if (typeof HTMLCanvasElement === \"undefined\") {\n        return image.src;\n      }\n      let canvas;\n      if (image instanceof HTMLCanvasElement) {\n        canvas = image;\n      } else {\n        if (_canvas === void 0) _canvas = createElementNS(\"canvas\");\n        _canvas.width = image.width;\n        _canvas.height = image.height;\n        const context = _canvas.getContext(\"2d\");\n        if (image instanceof ImageData) {\n          context.putImageData(image, 0, 0);\n        } else {\n          context.drawImage(image, 0, 0, image.width, image.height);\n        }\n        canvas = _canvas;\n      }\n      if (canvas.width > 2048 || canvas.height > 2048) {\n        console.warn(\"THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons\", image);\n        return canvas.toDataURL(\"image/jpeg\", 0.6);\n      } else {\n        return canvas.toDataURL(\"image/png\");\n      }\n    }\n    static sRGBToLinear(image) {\n      if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap) {\n        const canvas = createElementNS(\"canvas\");\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const context = canvas.getContext(\"2d\");\n        context.drawImage(image, 0, 0, image.width, image.height);\n        const imageData = context.getImageData(0, 0, image.width, image.height);\n        const data = imageData.data;\n        for (let i2 = 0; i2 < data.length; i2++) {\n          data[i2] = SRGBToLinear(data[i2] / 255) * 255;\n        }\n        context.putImageData(imageData, 0, 0);\n        return canvas;\n      } else if (image.data) {\n        const data = image.data.slice(0);\n        for (let i2 = 0; i2 < data.length; i2++) {\n          if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {\n            data[i2] = Math.floor(SRGBToLinear(data[i2] / 255) * 255);\n          } else {\n            data[i2] = SRGBToLinear(data[i2]);\n          }\n        }\n        return {\n          data,\n          width: image.width,\n          height: image.height\n        };\n      } else {\n        console.warn(\"THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.\");\n        return image;\n      }\n    }\n  }\n  let _sourceId = 0;\n  class Source {\n    constructor(data = null) {\n      this.isSource = true;\n      Object.defineProperty(this, \"id\", { value: _sourceId++ });\n      this.uuid = generateUUID();\n      this.data = data;\n      this.dataReady = true;\n      this.version = 0;\n    }\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === \"string\";\n      if (!isRootObject && meta.images[this.uuid] !== void 0) {\n        return meta.images[this.uuid];\n      }\n      const output = {\n        uuid: this.uuid,\n        url: \"\"\n      };\n      const data = this.data;\n      if (data !== null) {\n        let url;\n        if (Array.isArray(data)) {\n          url = [];\n          for (let i2 = 0, l = data.length; i2 < l; i2++) {\n            if (data[i2].isDataTexture) {\n              url.push(serializeImage(data[i2].image));\n            } else {\n              url.push(serializeImage(data[i2]));\n            }\n          }\n        } else {\n          url = serializeImage(data);\n        }\n        output.url = url;\n      }\n      if (!isRootObject) {\n        meta.images[this.uuid] = output;\n      }\n      return output;\n    }\n  }\n  function serializeImage(image) {\n    if (typeof HTMLImageElement !== \"undefined\" && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== \"undefined\" && image instanceof HTMLCanvasElement || typeof ImageBitmap !== \"undefined\" && image instanceof ImageBitmap) {\n      return ImageUtils.getDataURL(image);\n    } else {\n      if (image.data) {\n        return {\n          data: Array.from(image.data),\n          width: image.width,\n          height: image.height,\n          type: image.data.constructor.name\n        };\n      } else {\n        console.warn(\"THREE.Texture: Unable to serialize Texture.\");\n        return {};\n      }\n    }\n  }\n  let _textureId = 0;\n  class Texture extends EventDispatcher {\n    constructor(image = Texture.DEFAULT_IMAGE, mapping = Texture.DEFAULT_MAPPING, wrapS = ClampToEdgeWrapping, wrapT = ClampToEdgeWrapping, magFilter = LinearFilter, minFilter = LinearMipmapLinearFilter, format = RGBAFormat, type = UnsignedByteType, anisotropy = Texture.DEFAULT_ANISOTROPY, colorSpace = NoColorSpace) {\n      super();\n      this.isTexture = true;\n      Object.defineProperty(this, \"id\", { value: _textureId++ });\n      this.uuid = generateUUID();\n      this.name = \"\";\n      this.source = new Source(image);\n      this.mipmaps = [];\n      this.mapping = mapping;\n      this.channel = 0;\n      this.wrapS = wrapS;\n      this.wrapT = wrapT;\n      this.magFilter = magFilter;\n      this.minFilter = minFilter;\n      this.anisotropy = anisotropy;\n      this.format = format;\n      this.internalFormat = null;\n      this.type = type;\n      this.offset = new Vector2(0, 0);\n      this.repeat = new Vector2(1, 1);\n      this.center = new Vector2(0, 0);\n      this.rotation = 0;\n      this.matrixAutoUpdate = true;\n      this.matrix = new Matrix3();\n      this.generateMipmaps = true;\n      this.premultiplyAlpha = false;\n      this.flipY = true;\n      this.unpackAlignment = 4;\n      this.colorSpace = colorSpace;\n      this.userData = {};\n      this.version = 0;\n      this.onUpdate = null;\n      this.renderTarget = null;\n      this.isRenderTargetTexture = false;\n      this.pmremVersion = 0;\n    }\n    get image() {\n      return this.source.data;\n    }\n    set image(value = null) {\n      this.source.data = value;\n    }\n    updateMatrix() {\n      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.name = source.name;\n      this.source = source.source;\n      this.mipmaps = source.mipmaps.slice(0);\n      this.mapping = source.mapping;\n      this.channel = source.channel;\n      this.wrapS = source.wrapS;\n      this.wrapT = source.wrapT;\n      this.magFilter = source.magFilter;\n      this.minFilter = source.minFilter;\n      this.anisotropy = source.anisotropy;\n      this.format = source.format;\n      this.internalFormat = source.internalFormat;\n      this.type = source.type;\n      this.offset.copy(source.offset);\n      this.repeat.copy(source.repeat);\n      this.center.copy(source.center);\n      this.rotation = source.rotation;\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      this.matrix.copy(source.matrix);\n      this.generateMipmaps = source.generateMipmaps;\n      this.premultiplyAlpha = source.premultiplyAlpha;\n      this.flipY = source.flipY;\n      this.unpackAlignment = source.unpackAlignment;\n      this.colorSpace = source.colorSpace;\n      this.renderTarget = source.renderTarget;\n      this.isRenderTargetTexture = source.isRenderTargetTexture;\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      this.needsUpdate = true;\n      return this;\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === \"string\";\n      if (!isRootObject && meta.textures[this.uuid] !== void 0) {\n        return meta.textures[this.uuid];\n      }\n      const output = {\n        metadata: {\n          version: 4.6,\n          type: \"Texture\",\n          generator: \"Texture.toJSON\"\n        },\n        uuid: this.uuid,\n        name: this.name,\n        image: this.source.toJSON(meta).uuid,\n        mapping: this.mapping,\n        channel: this.channel,\n        repeat: [this.repeat.x, this.repeat.y],\n        offset: [this.offset.x, this.offset.y],\n        center: [this.center.x, this.center.y],\n        rotation: this.rotation,\n        wrap: [this.wrapS, this.wrapT],\n        format: this.format,\n        internalFormat: this.internalFormat,\n        type: this.type,\n        colorSpace: this.colorSpace,\n        minFilter: this.minFilter,\n        magFilter: this.magFilter,\n        anisotropy: this.anisotropy,\n        flipY: this.flipY,\n        generateMipmaps: this.generateMipmaps,\n        premultiplyAlpha: this.premultiplyAlpha,\n        unpackAlignment: this.unpackAlignment\n      };\n      if (Object.keys(this.userData).length > 0) output.userData = this.userData;\n      if (!isRootObject) {\n        meta.textures[this.uuid] = output;\n      }\n      return output;\n    }\n    dispose() {\n      this.dispatchEvent({ type: \"dispose\" });\n    }\n    transformUv(uv) {\n      if (this.mapping !== UVMapping) return uv;\n      uv.applyMatrix3(this.matrix);\n      if (uv.x < 0 || uv.x > 1) {\n        switch (this.wrapS) {\n          case RepeatWrapping:\n            uv.x = uv.x - Math.floor(uv.x);\n            break;\n          case ClampToEdgeWrapping:\n            uv.x = uv.x < 0 ? 0 : 1;\n            break;\n          case MirroredRepeatWrapping:\n            if (Math.abs(Math.floor(uv.x) % 2) === 1) {\n              uv.x = Math.ceil(uv.x) - uv.x;\n            } else {\n              uv.x = uv.x - Math.floor(uv.x);\n            }\n            break;\n        }\n      }\n      if (uv.y < 0 || uv.y > 1) {\n        switch (this.wrapT) {\n          case RepeatWrapping:\n            uv.y = uv.y - Math.floor(uv.y);\n            break;\n          case ClampToEdgeWrapping:\n            uv.y = uv.y < 0 ? 0 : 1;\n            break;\n          case MirroredRepeatWrapping:\n            if (Math.abs(Math.floor(uv.y) % 2) === 1) {\n              uv.y = Math.ceil(uv.y) - uv.y;\n            } else {\n              uv.y = uv.y - Math.floor(uv.y);\n            }\n            break;\n        }\n      }\n      if (this.flipY) {\n        uv.y = 1 - uv.y;\n      }\n      return uv;\n    }\n    set needsUpdate(value) {\n      if (value === true) {\n        this.version++;\n        this.source.needsUpdate = true;\n      }\n    }\n    set needsPMREMUpdate(value) {\n      if (value === true) {\n        this.pmremVersion++;\n      }\n    }\n  }\n  Texture.DEFAULT_IMAGE = null;\n  Texture.DEFAULT_MAPPING = UVMapping;\n  Texture.DEFAULT_ANISOTROPY = 1;\n  class Vector4 {\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\n      Vector4.prototype.isVector4 = true;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n    }\n    get width() {\n      return this.z;\n    }\n    set width(value) {\n      this.z = value;\n    }\n    get height() {\n      return this.w;\n    }\n    set height(value) {\n      this.w = value;\n    }\n    set(x2, y, z, w) {\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      this.w = w;\n      return this;\n    }\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      this.w = scalar;\n      return this;\n    }\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    setZ(z) {\n      this.z = z;\n      return this;\n    }\n    setW(w) {\n      this.w = w;\n      return this;\n    }\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        case 2:\n          this.z = value;\n          break;\n        case 3:\n          this.w = value;\n          break;\n        default:\n          throw new Error(\"index is out of range: \" + index);\n      }\n      return this;\n    }\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        case 2:\n          return this.z;\n        case 3:\n          return this.w;\n        default:\n          throw new Error(\"index is out of range: \" + index);\n      }\n    }\n    clone() {\n      return new this.constructor(this.x, this.y, this.z, this.w);\n    }\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      this.w = v.w !== void 0 ? v.w : 1;\n      return this;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      this.w += v.w;\n      return this;\n    }\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      this.w += s;\n      return this;\n    }\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      this.w = a.w + b.w;\n      return this;\n    }\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      this.w += v.w * s;\n      return this;\n    }\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      this.w -= v.w;\n      return this;\n    }\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      this.w -= s;\n      return this;\n    }\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      this.w = a.w - b.w;\n      return this;\n    }\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      this.w *= v.w;\n      return this;\n    }\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      this.w *= scalar;\n      return this;\n    }\n    applyMatrix4(m) {\n      const x2 = this.x, y = this.y, z = this.z, w = this.w;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[4] * y + e[8] * z + e[12] * w;\n      this.y = e[1] * x2 + e[5] * y + e[9] * z + e[13] * w;\n      this.z = e[2] * x2 + e[6] * y + e[10] * z + e[14] * w;\n      this.w = e[3] * x2 + e[7] * y + e[11] * z + e[15] * w;\n      return this;\n    }\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n      this.w /= v.w;\n      return this;\n    }\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    setAxisAngleFromQuaternion(q) {\n      this.w = 2 * Math.acos(q.w);\n      const s = Math.sqrt(1 - q.w * q.w);\n      if (s < 1e-4) {\n        this.x = 1;\n        this.y = 0;\n        this.z = 0;\n      } else {\n        this.x = q.x / s;\n        this.y = q.y / s;\n        this.z = q.z / s;\n      }\n      return this;\n    }\n    setAxisAngleFromRotationMatrix(m) {\n      let angle, x2, y, z;\n      const epsilon = 0.01, epsilon2 = 0.1, te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10];\n      if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {\n        if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {\n          this.set(1, 0, 0, 0);\n          return this;\n        }\n        angle = Math.PI;\n        const xx = (m11 + 1) / 2;\n        const yy = (m22 + 1) / 2;\n        const zz = (m33 + 1) / 2;\n        const xy = (m12 + m21) / 4;\n        const xz = (m13 + m31) / 4;\n        const yz = (m23 + m32) / 4;\n        if (xx > yy && xx > zz) {\n          if (xx < epsilon) {\n            x2 = 0;\n            y = 0.707106781;\n            z = 0.707106781;\n          } else {\n            x2 = Math.sqrt(xx);\n            y = xy / x2;\n            z = xz / x2;\n          }\n        } else if (yy > zz) {\n          if (yy < epsilon) {\n            x2 = 0.707106781;\n            y = 0;\n            z = 0.707106781;\n          } else {\n            y = Math.sqrt(yy);\n            x2 = xy / y;\n            z = yz / y;\n          }\n        } else {\n          if (zz < epsilon) {\n            x2 = 0.707106781;\n            y = 0.707106781;\n            z = 0;\n          } else {\n            z = Math.sqrt(zz);\n            x2 = xz / z;\n            y = yz / z;\n          }\n        }\n        this.set(x2, y, z, angle);\n        return this;\n      }\n      let s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12));\n      if (Math.abs(s) < 1e-3) s = 1;\n      this.x = (m32 - m23) / s;\n      this.y = (m13 - m31) / s;\n      this.z = (m21 - m12) / s;\n      this.w = Math.acos((m11 + m22 + m33 - 1) / 2);\n      return this;\n    }\n    setFromMatrixPosition(m) {\n      const e = m.elements;\n      this.x = e[12];\n      this.y = e[13];\n      this.z = e[14];\n      this.w = e[15];\n      return this;\n    }\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      this.w = Math.min(this.w, v.w);\n      return this;\n    }\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      this.w = Math.max(this.w, v.w);\n      return this;\n    }\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      this.z = clamp(this.z, min.z, max2.z);\n      this.w = clamp(this.w, min.w, max2.w);\n      return this;\n    }\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      this.z = clamp(this.z, minVal, maxVal);\n      this.w = clamp(this.w, minVal, maxVal);\n      return this;\n    }\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      this.z = Math.floor(this.z);\n      this.w = Math.floor(this.w);\n      return this;\n    }\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      this.z = Math.ceil(this.z);\n      this.w = Math.ceil(this.w);\n      return this;\n    }\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      this.z = Math.round(this.z);\n      this.w = Math.round(this.w);\n      return this;\n    }\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      this.z = Math.trunc(this.z);\n      this.w = Math.trunc(this.w);\n      return this;\n    }\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      this.w = -this.w;\n      return this;\n    }\n    dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\n    }\n    lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    }\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    }\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);\n    }\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      this.z += (v.z - this.z) * alpha;\n      this.w += (v.w - this.w) * alpha;\n      return this;\n    }\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      this.z = v1.z + (v2.z - v1.z) * alpha;\n      this.w = v1.w + (v2.w - v1.w) * alpha;\n      return this;\n    }\n    equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;\n    }\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      this.w = array[offset + 3];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      array[offset + 3] = this.w;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      this.z = attribute.getZ(index);\n      this.w = attribute.getW(index);\n      return this;\n    }\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      this.z = Math.random();\n      this.w = Math.random();\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n      yield this.z;\n      yield this.w;\n    }\n  }\n  class RenderTarget extends EventDispatcher {\n    constructor(width = 1, height = 1, options = {}) {\n      super();\n      this.isRenderTarget = true;\n      this.width = width;\n      this.height = height;\n      this.depth = 1;\n      this.scissor = new Vector4(0, 0, width, height);\n      this.scissorTest = false;\n      this.viewport = new Vector4(0, 0, width, height);\n      const image = { width, height, depth: 1 };\n      options = Object.assign({\n        generateMipmaps: false,\n        internalFormat: null,\n        minFilter: LinearFilter,\n        depthBuffer: true,\n        stencilBuffer: false,\n        resolveDepthBuffer: true,\n        resolveStencilBuffer: true,\n        depthTexture: null,\n        samples: 0,\n        count: 1\n      }, options);\n      const texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);\n      texture.flipY = false;\n      texture.generateMipmaps = options.generateMipmaps;\n      texture.internalFormat = options.internalFormat;\n      this.textures = [];\n      const count = options.count;\n      for (let i2 = 0; i2 < count; i2++) {\n        this.textures[i2] = texture.clone();\n        this.textures[i2].isRenderTargetTexture = true;\n        this.textures[i2].renderTarget = this;\n      }\n      this.depthBuffer = options.depthBuffer;\n      this.stencilBuffer = options.stencilBuffer;\n      this.resolveDepthBuffer = options.resolveDepthBuffer;\n      this.resolveStencilBuffer = options.resolveStencilBuffer;\n      this._depthTexture = null;\n      this.depthTexture = options.depthTexture;\n      this.samples = options.samples;\n    }\n    get texture() {\n      return this.textures[0];\n    }\n    set texture(value) {\n      this.textures[0] = value;\n    }\n    set depthTexture(current) {\n      if (this._depthTexture !== null) this._depthTexture.renderTarget = null;\n      if (current !== null) current.renderTarget = this;\n      this._depthTexture = current;\n    }\n    get depthTexture() {\n      return this._depthTexture;\n    }\n    setSize(width, height, depth = 1) {\n      if (this.width !== width || this.height !== height || this.depth !== depth) {\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        for (let i2 = 0, il = this.textures.length; i2 < il; i2++) {\n          this.textures[i2].image.width = width;\n          this.textures[i2].image.height = height;\n          this.textures[i2].image.depth = depth;\n        }\n        this.dispose();\n      }\n      this.viewport.set(0, 0, width, height);\n      this.scissor.set(0, 0, width, height);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.width = source.width;\n      this.height = source.height;\n      this.depth = source.depth;\n      this.scissor.copy(source.scissor);\n      this.scissorTest = source.scissorTest;\n      this.viewport.copy(source.viewport);\n      this.textures.length = 0;\n      for (let i2 = 0, il = source.textures.length; i2 < il; i2++) {\n        this.textures[i2] = source.textures[i2].clone();\n        this.textures[i2].isRenderTargetTexture = true;\n        this.textures[i2].renderTarget = this;\n      }\n      const image = Object.assign({}, source.texture.image);\n      this.texture.source = new Source(image);\n      this.depthBuffer = source.depthBuffer;\n      this.stencilBuffer = source.stencilBuffer;\n      this.resolveDepthBuffer = source.resolveDepthBuffer;\n      this.resolveStencilBuffer = source.resolveStencilBuffer;\n      if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();\n      this.samples = source.samples;\n      return this;\n    }\n    dispose() {\n      this.dispatchEvent({ type: \"dispose\" });\n    }\n  }\n  class WebGLRenderTarget extends RenderTarget {\n    constructor(width = 1, height = 1, options = {}) {\n      super(width, height, options);\n      this.isWebGLRenderTarget = true;\n    }\n  }\n  class DataArrayTexture extends Texture {\n    constructor(data = null, width = 1, height = 1, depth = 1) {\n      super(null);\n      this.isDataArrayTexture = true;\n      this.image = { data, width, height, depth };\n      this.magFilter = NearestFilter;\n      this.minFilter = NearestFilter;\n      this.wrapR = ClampToEdgeWrapping;\n      this.generateMipmaps = false;\n      this.flipY = false;\n      this.unpackAlignment = 1;\n      this.layerUpdates = /* @__PURE__ */ new Set();\n    }\n    addLayerUpdate(layerIndex) {\n      this.layerUpdates.add(layerIndex);\n    }\n    clearLayerUpdates() {\n      this.layerUpdates.clear();\n    }\n  }\n  class WebGLArrayRenderTarget extends WebGLRenderTarget {\n    constructor(width = 1, height = 1, depth = 1, options = {}) {\n      super(width, height, options);\n      this.isWebGLArrayRenderTarget = true;\n      this.depth = depth;\n      this.texture = new DataArrayTexture(null, width, height, depth);\n      this.texture.isRenderTargetTexture = true;\n    }\n  }\n  class Quaternion {\n    constructor(x2 = 0, y = 0, z = 0, w = 1) {\n      this.isQuaternion = true;\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n    }\n    static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {\n      let x0 = src0[srcOffset0 + 0], y0 = src0[srcOffset0 + 1], z0 = src0[srcOffset0 + 2], w0 = src0[srcOffset0 + 3];\n      const x1 = src1[srcOffset1 + 0], y1 = src1[srcOffset1 + 1], z1 = src1[srcOffset1 + 2], w1 = src1[srcOffset1 + 3];\n      if (t === 0) {\n        dst[dstOffset + 0] = x0;\n        dst[dstOffset + 1] = y0;\n        dst[dstOffset + 2] = z0;\n        dst[dstOffset + 3] = w0;\n        return;\n      }\n      if (t === 1) {\n        dst[dstOffset + 0] = x1;\n        dst[dstOffset + 1] = y1;\n        dst[dstOffset + 2] = z1;\n        dst[dstOffset + 3] = w1;\n        return;\n      }\n      if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {\n        let s = 1 - t;\n        const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1, dir = cos >= 0 ? 1 : -1, sqrSin = 1 - cos * cos;\n        if (sqrSin > Number.EPSILON) {\n          const sin = Math.sqrt(sqrSin), len = Math.atan2(sin, cos * dir);\n          s = Math.sin(s * len) / sin;\n          t = Math.sin(t * len) / sin;\n        }\n        const tDir = t * dir;\n        x0 = x0 * s + x1 * tDir;\n        y0 = y0 * s + y1 * tDir;\n        z0 = z0 * s + z1 * tDir;\n        w0 = w0 * s + w1 * tDir;\n        if (s === 1 - t) {\n          const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);\n          x0 *= f;\n          y0 *= f;\n          z0 *= f;\n          w0 *= f;\n        }\n      }\n      dst[dstOffset] = x0;\n      dst[dstOffset + 1] = y0;\n      dst[dstOffset + 2] = z0;\n      dst[dstOffset + 3] = w0;\n    }\n    static multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {\n      const x0 = src0[srcOffset0];\n      const y0 = src0[srcOffset0 + 1];\n      const z0 = src0[srcOffset0 + 2];\n      const w0 = src0[srcOffset0 + 3];\n      const x1 = src1[srcOffset1];\n      const y1 = src1[srcOffset1 + 1];\n      const z1 = src1[srcOffset1 + 2];\n      const w1 = src1[srcOffset1 + 3];\n      dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;\n      dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;\n      dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;\n      dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;\n      return dst;\n    }\n    get x() {\n      return this._x;\n    }\n    set x(value) {\n      this._x = value;\n      this._onChangeCallback();\n    }\n    get y() {\n      return this._y;\n    }\n    set y(value) {\n      this._y = value;\n      this._onChangeCallback();\n    }\n    get z() {\n      return this._z;\n    }\n    set z(value) {\n      this._z = value;\n      this._onChangeCallback();\n    }\n    get w() {\n      return this._w;\n    }\n    set w(value) {\n      this._w = value;\n      this._onChangeCallback();\n    }\n    set(x2, y, z, w) {\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._w = w;\n      this._onChangeCallback();\n      return this;\n    }\n    clone() {\n      return new this.constructor(this._x, this._y, this._z, this._w);\n    }\n    copy(quaternion) {\n      this._x = quaternion.x;\n      this._y = quaternion.y;\n      this._z = quaternion.z;\n      this._w = quaternion.w;\n      this._onChangeCallback();\n      return this;\n    }\n    setFromEuler(euler, update = true) {\n      const x2 = euler._x, y = euler._y, z = euler._z, order = euler._order;\n      const cos = Math.cos;\n      const sin = Math.sin;\n      const c1 = cos(x2 / 2);\n      const c2 = cos(y / 2);\n      const c3 = cos(z / 2);\n      const s1 = sin(x2 / 2);\n      const s2 = sin(y / 2);\n      const s3 = sin(z / 2);\n      switch (order) {\n        case \"XYZ\":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case \"YXZ\":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        case \"ZXY\":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case \"ZYX\":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        case \"YZX\":\n          this._x = s1 * c2 * c3 + c1 * s2 * s3;\n          this._y = c1 * s2 * c3 + s1 * c2 * s3;\n          this._z = c1 * c2 * s3 - s1 * s2 * c3;\n          this._w = c1 * c2 * c3 - s1 * s2 * s3;\n          break;\n        case \"XZY\":\n          this._x = s1 * c2 * c3 - c1 * s2 * s3;\n          this._y = c1 * s2 * c3 - s1 * c2 * s3;\n          this._z = c1 * c2 * s3 + s1 * s2 * c3;\n          this._w = c1 * c2 * c3 + s1 * s2 * s3;\n          break;\n        default:\n          console.warn(\"THREE.Quaternion: .setFromEuler() encountered an unknown order: \" + order);\n      }\n      if (update === true) this._onChangeCallback();\n      return this;\n    }\n    setFromAxisAngle(axis, angle) {\n      const halfAngle = angle / 2, s = Math.sin(halfAngle);\n      this._x = axis.x * s;\n      this._y = axis.y * s;\n      this._z = axis.z * s;\n      this._w = Math.cos(halfAngle);\n      this._onChangeCallback();\n      return this;\n    }\n    setFromRotationMatrix(m) {\n      const te = m.elements, m11 = te[0], m12 = te[4], m13 = te[8], m21 = te[1], m22 = te[5], m23 = te[9], m31 = te[2], m32 = te[6], m33 = te[10], trace = m11 + m22 + m33;\n      if (trace > 0) {\n        const s = 0.5 / Math.sqrt(trace + 1);\n        this._w = 0.25 / s;\n        this._x = (m32 - m23) * s;\n        this._y = (m13 - m31) * s;\n        this._z = (m21 - m12) * s;\n      } else if (m11 > m22 && m11 > m33) {\n        const s = 2 * Math.sqrt(1 + m11 - m22 - m33);\n        this._w = (m32 - m23) / s;\n        this._x = 0.25 * s;\n        this._y = (m12 + m21) / s;\n        this._z = (m13 + m31) / s;\n      } else if (m22 > m33) {\n        const s = 2 * Math.sqrt(1 + m22 - m11 - m33);\n        this._w = (m13 - m31) / s;\n        this._x = (m12 + m21) / s;\n        this._y = 0.25 * s;\n        this._z = (m23 + m32) / s;\n      } else {\n        const s = 2 * Math.sqrt(1 + m33 - m11 - m22);\n        this._w = (m21 - m12) / s;\n        this._x = (m13 + m31) / s;\n        this._y = (m23 + m32) / s;\n        this._z = 0.25 * s;\n      }\n      this._onChangeCallback();\n      return this;\n    }\n    setFromUnitVectors(vFrom, vTo) {\n      let r = vFrom.dot(vTo) + 1;\n      if (r < Number.EPSILON) {\n        r = 0;\n        if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {\n          this._x = -vFrom.y;\n          this._y = vFrom.x;\n          this._z = 0;\n          this._w = r;\n        } else {\n          this._x = 0;\n          this._y = -vFrom.z;\n          this._z = vFrom.y;\n          this._w = r;\n        }\n      } else {\n        this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;\n        this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;\n        this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;\n        this._w = r;\n      }\n      return this.normalize();\n    }\n    angleTo(q) {\n      return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)));\n    }\n    rotateTowards(q, step) {\n      const angle = this.angleTo(q);\n      if (angle === 0) return this;\n      const t = Math.min(1, step / angle);\n      this.slerp(q, t);\n      return this;\n    }\n    identity() {\n      return this.set(0, 0, 0, 1);\n    }\n    invert() {\n      return this.conjugate();\n    }\n    conjugate() {\n      this._x *= -1;\n      this._y *= -1;\n      this._z *= -1;\n      this._onChangeCallback();\n      return this;\n    }\n    dot(v) {\n      return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;\n    }\n    lengthSq() {\n      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;\n    }\n    length() {\n      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);\n    }\n    normalize() {\n      let l = this.length();\n      if (l === 0) {\n        this._x = 0;\n        this._y = 0;\n        this._z = 0;\n        this._w = 1;\n      } else {\n        l = 1 / l;\n        this._x = this._x * l;\n        this._y = this._y * l;\n        this._z = this._z * l;\n        this._w = this._w * l;\n      }\n      this._onChangeCallback();\n      return this;\n    }\n    multiply(q) {\n      return this.multiplyQuaternions(this, q);\n    }\n    premultiply(q) {\n      return this.multiplyQuaternions(q, this);\n    }\n    multiplyQuaternions(a, b) {\n      const qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;\n      const qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;\n      this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;\n      this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;\n      this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;\n      this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;\n      this._onChangeCallback();\n      return this;\n    }\n    slerp(qb, t) {\n      if (t === 0) return this;\n      if (t === 1) return this.copy(qb);\n      const x2 = this._x, y = this._y, z = this._z, w = this._w;\n      let cosHalfTheta = w * qb._w + x2 * qb._x + y * qb._y + z * qb._z;\n      if (cosHalfTheta < 0) {\n        this._w = -qb._w;\n        this._x = -qb._x;\n        this._y = -qb._y;\n        this._z = -qb._z;\n        cosHalfTheta = -cosHalfTheta;\n      } else {\n        this.copy(qb);\n      }\n      if (cosHalfTheta >= 1) {\n        this._w = w;\n        this._x = x2;\n        this._y = y;\n        this._z = z;\n        return this;\n      }\n      const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta;\n      if (sqrSinHalfTheta <= Number.EPSILON) {\n        const s = 1 - t;\n        this._w = s * w + t * this._w;\n        this._x = s * x2 + t * this._x;\n        this._y = s * y + t * this._y;\n        this._z = s * z + t * this._z;\n        this.normalize();\n        return this;\n      }\n      const sinHalfTheta = Math.sqrt(sqrSinHalfTheta);\n      const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);\n      const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta, ratioB = Math.sin(t * halfTheta) / sinHalfTheta;\n      this._w = w * ratioA + this._w * ratioB;\n      this._x = x2 * ratioA + this._x * ratioB;\n      this._y = y * ratioA + this._y * ratioB;\n      this._z = z * ratioA + this._z * ratioB;\n      this._onChangeCallback();\n      return this;\n    }\n    slerpQuaternions(qa, qb, t) {\n      return this.copy(qa).slerp(qb, t);\n    }\n    random() {\n      const theta1 = 2 * Math.PI * Math.random();\n      const theta2 = 2 * Math.PI * Math.random();\n      const x0 = Math.random();\n      const r1 = Math.sqrt(1 - x0);\n      const r2 = Math.sqrt(x0);\n      return this.set(\n        r1 * Math.sin(theta1),\n        r1 * Math.cos(theta1),\n        r2 * Math.sin(theta2),\n        r2 * Math.cos(theta2)\n      );\n    }\n    equals(quaternion) {\n      return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;\n    }\n    fromArray(array, offset = 0) {\n      this._x = array[offset];\n      this._y = array[offset + 1];\n      this._z = array[offset + 2];\n      this._w = array[offset + 3];\n      this._onChangeCallback();\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._w;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this._x = attribute.getX(index);\n      this._y = attribute.getY(index);\n      this._z = attribute.getZ(index);\n      this._w = attribute.getW(index);\n      this._onChangeCallback();\n      return this;\n    }\n    toJSON() {\n      return this.toArray();\n    }\n    _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n    _onChangeCallback() {\n    }\n    *[Symbol.iterator]() {\n      yield this._x;\n      yield this._y;\n      yield this._z;\n      yield this._w;\n    }\n  }\n  class Vector3 {\n    constructor(x2 = 0, y = 0, z = 0) {\n      Vector3.prototype.isVector3 = true;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n    }\n    set(x2, y, z) {\n      if (z === void 0) z = this.z;\n      this.x = x2;\n      this.y = y;\n      this.z = z;\n      return this;\n    }\n    setScalar(scalar) {\n      this.x = scalar;\n      this.y = scalar;\n      this.z = scalar;\n      return this;\n    }\n    setX(x2) {\n      this.x = x2;\n      return this;\n    }\n    setY(y) {\n      this.y = y;\n      return this;\n    }\n    setZ(z) {\n      this.z = z;\n      return this;\n    }\n    setComponent(index, value) {\n      switch (index) {\n        case 0:\n          this.x = value;\n          break;\n        case 1:\n          this.y = value;\n          break;\n        case 2:\n          this.z = value;\n          break;\n        default:\n          throw new Error(\"index is out of range: \" + index);\n      }\n      return this;\n    }\n    getComponent(index) {\n      switch (index) {\n        case 0:\n          return this.x;\n        case 1:\n          return this.y;\n        case 2:\n          return this.z;\n        default:\n          throw new Error(\"index is out of range: \" + index);\n      }\n    }\n    clone() {\n      return new this.constructor(this.x, this.y, this.z);\n    }\n    copy(v) {\n      this.x = v.x;\n      this.y = v.y;\n      this.z = v.z;\n      return this;\n    }\n    add(v) {\n      this.x += v.x;\n      this.y += v.y;\n      this.z += v.z;\n      return this;\n    }\n    addScalar(s) {\n      this.x += s;\n      this.y += s;\n      this.z += s;\n      return this;\n    }\n    addVectors(a, b) {\n      this.x = a.x + b.x;\n      this.y = a.y + b.y;\n      this.z = a.z + b.z;\n      return this;\n    }\n    addScaledVector(v, s) {\n      this.x += v.x * s;\n      this.y += v.y * s;\n      this.z += v.z * s;\n      return this;\n    }\n    sub(v) {\n      this.x -= v.x;\n      this.y -= v.y;\n      this.z -= v.z;\n      return this;\n    }\n    subScalar(s) {\n      this.x -= s;\n      this.y -= s;\n      this.z -= s;\n      return this;\n    }\n    subVectors(a, b) {\n      this.x = a.x - b.x;\n      this.y = a.y - b.y;\n      this.z = a.z - b.z;\n      return this;\n    }\n    multiply(v) {\n      this.x *= v.x;\n      this.y *= v.y;\n      this.z *= v.z;\n      return this;\n    }\n    multiplyScalar(scalar) {\n      this.x *= scalar;\n      this.y *= scalar;\n      this.z *= scalar;\n      return this;\n    }\n    multiplyVectors(a, b) {\n      this.x = a.x * b.x;\n      this.y = a.y * b.y;\n      this.z = a.z * b.z;\n      return this;\n    }\n    applyEuler(euler) {\n      return this.applyQuaternion(_quaternion$4.setFromEuler(euler));\n    }\n    applyAxisAngle(axis, angle) {\n      return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));\n    }\n    applyMatrix3(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[3] * y + e[6] * z;\n      this.y = e[1] * x2 + e[4] * y + e[7] * z;\n      this.z = e[2] * x2 + e[5] * y + e[8] * z;\n      return this;\n    }\n    applyNormalMatrix(m) {\n      return this.applyMatrix3(m).normalize();\n    }\n    applyMatrix4(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      const w = 1 / (e[3] * x2 + e[7] * y + e[11] * z + e[15]);\n      this.x = (e[0] * x2 + e[4] * y + e[8] * z + e[12]) * w;\n      this.y = (e[1] * x2 + e[5] * y + e[9] * z + e[13]) * w;\n      this.z = (e[2] * x2 + e[6] * y + e[10] * z + e[14]) * w;\n      return this;\n    }\n    applyQuaternion(q) {\n      const vx = this.x, vy = this.y, vz = this.z;\n      const qx = q.x, qy = q.y, qz = q.z, qw = q.w;\n      const tx = 2 * (qy * vz - qz * vy);\n      const ty = 2 * (qz * vx - qx * vz);\n      const tz = 2 * (qx * vy - qy * vx);\n      this.x = vx + qw * tx + qy * tz - qz * ty;\n      this.y = vy + qw * ty + qz * tx - qx * tz;\n      this.z = vz + qw * tz + qx * ty - qy * tx;\n      return this;\n    }\n    project(camera) {\n      return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);\n    }\n    unproject(camera) {\n      return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);\n    }\n    transformDirection(m) {\n      const x2 = this.x, y = this.y, z = this.z;\n      const e = m.elements;\n      this.x = e[0] * x2 + e[4] * y + e[8] * z;\n      this.y = e[1] * x2 + e[5] * y + e[9] * z;\n      this.z = e[2] * x2 + e[6] * y + e[10] * z;\n      return this.normalize();\n    }\n    divide(v) {\n      this.x /= v.x;\n      this.y /= v.y;\n      this.z /= v.z;\n      return this;\n    }\n    divideScalar(scalar) {\n      return this.multiplyScalar(1 / scalar);\n    }\n    min(v) {\n      this.x = Math.min(this.x, v.x);\n      this.y = Math.min(this.y, v.y);\n      this.z = Math.min(this.z, v.z);\n      return this;\n    }\n    max(v) {\n      this.x = Math.max(this.x, v.x);\n      this.y = Math.max(this.y, v.y);\n      this.z = Math.max(this.z, v.z);\n      return this;\n    }\n    clamp(min, max2) {\n      this.x = clamp(this.x, min.x, max2.x);\n      this.y = clamp(this.y, min.y, max2.y);\n      this.z = clamp(this.z, min.z, max2.z);\n      return this;\n    }\n    clampScalar(minVal, maxVal) {\n      this.x = clamp(this.x, minVal, maxVal);\n      this.y = clamp(this.y, minVal, maxVal);\n      this.z = clamp(this.z, minVal, maxVal);\n      return this;\n    }\n    clampLength(min, max2) {\n      const length = this.length();\n      return this.divideScalar(length || 1).multiplyScalar(clamp(length, min, max2));\n    }\n    floor() {\n      this.x = Math.floor(this.x);\n      this.y = Math.floor(this.y);\n      this.z = Math.floor(this.z);\n      return this;\n    }\n    ceil() {\n      this.x = Math.ceil(this.x);\n      this.y = Math.ceil(this.y);\n      this.z = Math.ceil(this.z);\n      return this;\n    }\n    round() {\n      this.x = Math.round(this.x);\n      this.y = Math.round(this.y);\n      this.z = Math.round(this.z);\n      return this;\n    }\n    roundToZero() {\n      this.x = Math.trunc(this.x);\n      this.y = Math.trunc(this.y);\n      this.z = Math.trunc(this.z);\n      return this;\n    }\n    negate() {\n      this.x = -this.x;\n      this.y = -this.y;\n      this.z = -this.z;\n      return this;\n    }\n    dot(v) {\n      return this.x * v.x + this.y * v.y + this.z * v.z;\n    }\n    // TODO lengthSquared?\n    lengthSq() {\n      return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    length() {\n      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    manhattanLength() {\n      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);\n    }\n    normalize() {\n      return this.divideScalar(this.length() || 1);\n    }\n    setLength(length) {\n      return this.normalize().multiplyScalar(length);\n    }\n    lerp(v, alpha) {\n      this.x += (v.x - this.x) * alpha;\n      this.y += (v.y - this.y) * alpha;\n      this.z += (v.z - this.z) * alpha;\n      return this;\n    }\n    lerpVectors(v1, v2, alpha) {\n      this.x = v1.x + (v2.x - v1.x) * alpha;\n      this.y = v1.y + (v2.y - v1.y) * alpha;\n      this.z = v1.z + (v2.z - v1.z) * alpha;\n      return this;\n    }\n    cross(v) {\n      return this.crossVectors(this, v);\n    }\n    crossVectors(a, b) {\n      const ax = a.x, ay = a.y, az = a.z;\n      const bx = b.x, by = b.y, bz = b.z;\n      this.x = ay * bz - az * by;\n      this.y = az * bx - ax * bz;\n      this.z = ax * by - ay * bx;\n      return this;\n    }\n    projectOnVector(v) {\n      const denominator = v.lengthSq();\n      if (denominator === 0) return this.set(0, 0, 0);\n      const scalar = v.dot(this) / denominator;\n      return this.copy(v).multiplyScalar(scalar);\n    }\n    projectOnPlane(planeNormal) {\n      _vector$c.copy(this).projectOnVector(planeNormal);\n      return this.sub(_vector$c);\n    }\n    reflect(normal) {\n      return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));\n    }\n    angleTo(v) {\n      const denominator = Math.sqrt(this.lengthSq() * v.lengthSq());\n      if (denominator === 0) return Math.PI / 2;\n      const theta = this.dot(v) / denominator;\n      return Math.acos(clamp(theta, -1, 1));\n    }\n    distanceTo(v) {\n      return Math.sqrt(this.distanceToSquared(v));\n    }\n    distanceToSquared(v) {\n      const dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;\n      return dx * dx + dy * dy + dz * dz;\n    }\n    manhattanDistanceTo(v) {\n      return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);\n    }\n    setFromSpherical(s) {\n      return this.setFromSphericalCoords(s.radius, s.phi, s.theta);\n    }\n    setFromSphericalCoords(radius, phi, theta) {\n      const sinPhiRadius = Math.sin(phi) * radius;\n      this.x = sinPhiRadius * Math.sin(theta);\n      this.y = Math.cos(phi) * radius;\n      this.z = sinPhiRadius * Math.cos(theta);\n      return this;\n    }\n    setFromCylindrical(c) {\n      return this.setFromCylindricalCoords(c.radius, c.theta, c.y);\n    }\n    setFromCylindricalCoords(radius, theta, y) {\n      this.x = radius * Math.sin(theta);\n      this.y = y;\n      this.z = radius * Math.cos(theta);\n      return this;\n    }\n    setFromMatrixPosition(m) {\n      const e = m.elements;\n      this.x = e[12];\n      this.y = e[13];\n      this.z = e[14];\n      return this;\n    }\n    setFromMatrixScale(m) {\n      const sx = this.setFromMatrixColumn(m, 0).length();\n      const sy = this.setFromMatrixColumn(m, 1).length();\n      const sz = this.setFromMatrixColumn(m, 2).length();\n      this.x = sx;\n      this.y = sy;\n      this.z = sz;\n      return this;\n    }\n    setFromMatrixColumn(m, index) {\n      return this.fromArray(m.elements, index * 4);\n    }\n    setFromMatrix3Column(m, index) {\n      return this.fromArray(m.elements, index * 3);\n    }\n    setFromEuler(e) {\n      this.x = e._x;\n      this.y = e._y;\n      this.z = e._z;\n      return this;\n    }\n    setFromColor(c) {\n      this.x = c.r;\n      this.y = c.g;\n      this.z = c.b;\n      return this;\n    }\n    equals(v) {\n      return v.x === this.x && v.y === this.y && v.z === this.z;\n    }\n    fromArray(array, offset = 0) {\n      this.x = array[offset];\n      this.y = array[offset + 1];\n      this.z = array[offset + 2];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.x;\n      array[offset + 1] = this.y;\n      array[offset + 2] = this.z;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.x = attribute.getX(index);\n      this.y = attribute.getY(index);\n      this.z = attribute.getZ(index);\n      return this;\n    }\n    random() {\n      this.x = Math.random();\n      this.y = Math.random();\n      this.z = Math.random();\n      return this;\n    }\n    randomDirection() {\n      const theta = Math.random() * Math.PI * 2;\n      const u = Math.random() * 2 - 1;\n      const c = Math.sqrt(1 - u * u);\n      this.x = c * Math.cos(theta);\n      this.y = u;\n      this.z = c * Math.sin(theta);\n      return this;\n    }\n    *[Symbol.iterator]() {\n      yield this.x;\n      yield this.y;\n      yield this.z;\n    }\n  }\n  const _vector$c = /* @__PURE__ */ new Vector3();\n  const _quaternion$4 = /* @__PURE__ */ new Quaternion();\n  class Box3 {\n    constructor(min = new Vector3(Infinity, Infinity, Infinity), max2 = new Vector3(-Infinity, -Infinity, -Infinity)) {\n      this.isBox3 = true;\n      this.min = min;\n      this.max = max2;\n    }\n    set(min, max2) {\n      this.min.copy(min);\n      this.max.copy(max2);\n      return this;\n    }\n    setFromArray(array) {\n      this.makeEmpty();\n      for (let i2 = 0, il = array.length; i2 < il; i2 += 3) {\n        this.expandByPoint(_vector$b.fromArray(array, i2));\n      }\n      return this;\n    }\n    setFromBufferAttribute(attribute) {\n      this.makeEmpty();\n      for (let i2 = 0, il = attribute.count; i2 < il; i2++) {\n        this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i2));\n      }\n      return this;\n    }\n    setFromPoints(points) {\n      this.makeEmpty();\n      for (let i2 = 0, il = points.length; i2 < il; i2++) {\n        this.expandByPoint(points[i2]);\n      }\n      return this;\n    }\n    setFromCenterAndSize(center, size) {\n      const halfSize = _vector$b.copy(size).multiplyScalar(0.5);\n      this.min.copy(center).sub(halfSize);\n      this.max.copy(center).add(halfSize);\n      return this;\n    }\n    setFromObject(object, precise = false) {\n      this.makeEmpty();\n      return this.expandByObject(object, precise);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(box) {\n      this.min.copy(box.min);\n      this.max.copy(box.max);\n      return this;\n    }\n    makeEmpty() {\n      this.min.x = this.min.y = this.min.z = Infinity;\n      this.max.x = this.max.y = this.max.z = -Infinity;\n      return this;\n    }\n    isEmpty() {\n      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;\n    }\n    getCenter(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);\n    }\n    getSize(target) {\n      return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);\n    }\n    expandByPoint(point) {\n      this.min.min(point);\n      this.max.max(point);\n      return this;\n    }\n    expandByVector(vector) {\n      this.min.sub(vector);\n      this.max.add(vector);\n      return this;\n    }\n    expandByScalar(scalar) {\n      this.min.addScalar(-scalar);\n      this.max.addScalar(scalar);\n      return this;\n    }\n    expandByObject(object, precise = false) {\n      object.updateWorldMatrix(false, false);\n      const geometry = object.geometry;\n      if (geometry !== void 0) {\n        const positionAttribute = geometry.getAttribute(\"position\");\n        if (precise === true && positionAttribute !== void 0 && object.isInstancedMesh !== true) {\n          for (let i2 = 0, l = positionAttribute.count; i2 < l; i2++) {\n            if (object.isMesh === true) {\n              object.getVertexPosition(i2, _vector$b);\n            } else {\n              _vector$b.fromBufferAttribute(positionAttribute, i2);\n            }\n            _vector$b.applyMatrix4(object.matrixWorld);\n            this.expandByPoint(_vector$b);\n          }\n        } else {\n          if (object.boundingBox !== void 0) {\n            if (object.boundingBox === null) {\n              object.computeBoundingBox();\n            }\n            _box$4.copy(object.boundingBox);\n          } else {\n            if (geometry.boundingBox === null) {\n              geometry.computeBoundingBox();\n            }\n            _box$4.copy(geometry.boundingBox);\n          }\n          _box$4.applyMatrix4(object.matrixWorld);\n          this.union(_box$4);\n        }\n      }\n      const children = object.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        this.expandByObject(children[i2], precise);\n      }\n      return this;\n    }\n    containsPoint(point) {\n      return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;\n    }\n    containsBox(box) {\n      return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;\n    }\n    getParameter(point, target) {\n      return target.set(\n        (point.x - this.min.x) / (this.max.x - this.min.x),\n        (point.y - this.min.y) / (this.max.y - this.min.y),\n        (point.z - this.min.z) / (this.max.z - this.min.z)\n      );\n    }\n    intersectsBox(box) {\n      return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;\n    }\n    intersectsSphere(sphere) {\n      this.clampPoint(sphere.center, _vector$b);\n      return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    intersectsPlane(plane) {\n      let min, max2;\n      if (plane.normal.x > 0) {\n        min = plane.normal.x * this.min.x;\n        max2 = plane.normal.x * this.max.x;\n      } else {\n        min = plane.normal.x * this.max.x;\n        max2 = plane.normal.x * this.min.x;\n      }\n      if (plane.normal.y > 0) {\n        min += plane.normal.y * this.min.y;\n        max2 += plane.normal.y * this.max.y;\n      } else {\n        min += plane.normal.y * this.max.y;\n        max2 += plane.normal.y * this.min.y;\n      }\n      if (plane.normal.z > 0) {\n        min += plane.normal.z * this.min.z;\n        max2 += plane.normal.z * this.max.z;\n      } else {\n        min += plane.normal.z * this.max.z;\n        max2 += plane.normal.z * this.min.z;\n      }\n      return min <= -plane.constant && max2 >= -plane.constant;\n    }\n    intersectsTriangle(triangle) {\n      if (this.isEmpty()) {\n        return false;\n      }\n      this.getCenter(_center);\n      _extents.subVectors(this.max, _center);\n      _v0$2.subVectors(triangle.a, _center);\n      _v1$7.subVectors(triangle.b, _center);\n      _v2$4.subVectors(triangle.c, _center);\n      _f0.subVectors(_v1$7, _v0$2);\n      _f1.subVectors(_v2$4, _v1$7);\n      _f2.subVectors(_v0$2, _v2$4);\n      let axes = [\n        0,\n        -_f0.z,\n        _f0.y,\n        0,\n        -_f1.z,\n        _f1.y,\n        0,\n        -_f2.z,\n        _f2.y,\n        _f0.z,\n        0,\n        -_f0.x,\n        _f1.z,\n        0,\n        -_f1.x,\n        _f2.z,\n        0,\n        -_f2.x,\n        -_f0.y,\n        _f0.x,\n        0,\n        -_f1.y,\n        _f1.x,\n        0,\n        -_f2.y,\n        _f2.x,\n        0\n      ];\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n        return false;\n      }\n      axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {\n        return false;\n      }\n      _triangleNormal.crossVectors(_f0, _f1);\n      axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];\n      return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);\n    }\n    clampPoint(point, target) {\n      return target.copy(point).clamp(this.min, this.max);\n    }\n    distanceToPoint(point) {\n      return this.clampPoint(point, _vector$b).distanceTo(point);\n    }\n    getBoundingSphere(target) {\n      if (this.isEmpty()) {\n        target.makeEmpty();\n      } else {\n        this.getCenter(target.center);\n        target.radius = this.getSize(_vector$b).length() * 0.5;\n      }\n      return target;\n    }\n    intersect(box) {\n      this.min.max(box.min);\n      this.max.min(box.max);\n      if (this.isEmpty()) this.makeEmpty();\n      return this;\n    }\n    union(box) {\n      this.min.min(box.min);\n      this.max.max(box.max);\n      return this;\n    }\n    applyMatrix4(matrix) {\n      if (this.isEmpty()) return this;\n      _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix);\n      _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix);\n      _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix);\n      _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix);\n      _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix);\n      _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix);\n      _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix);\n      _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix);\n      this.setFromPoints(_points);\n      return this;\n    }\n    translate(offset) {\n      this.min.add(offset);\n      this.max.add(offset);\n      return this;\n    }\n    equals(box) {\n      return box.min.equals(this.min) && box.max.equals(this.max);\n    }\n  }\n  const _points = [\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3(),\n    /* @__PURE__ */ new Vector3()\n  ];\n  const _vector$b = /* @__PURE__ */ new Vector3();\n  const _box$4 = /* @__PURE__ */ new Box3();\n  const _v0$2 = /* @__PURE__ */ new Vector3();\n  const _v1$7 = /* @__PURE__ */ new Vector3();\n  const _v2$4 = /* @__PURE__ */ new Vector3();\n  const _f0 = /* @__PURE__ */ new Vector3();\n  const _f1 = /* @__PURE__ */ new Vector3();\n  const _f2 = /* @__PURE__ */ new Vector3();\n  const _center = /* @__PURE__ */ new Vector3();\n  const _extents = /* @__PURE__ */ new Vector3();\n  const _triangleNormal = /* @__PURE__ */ new Vector3();\n  const _testAxis = /* @__PURE__ */ new Vector3();\n  function satForAxes(axes, v0, v1, v2, extents) {\n    for (let i2 = 0, j = axes.length - 3; i2 <= j; i2 += 3) {\n      _testAxis.fromArray(axes, i2);\n      const r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);\n      const p0 = v0.dot(_testAxis);\n      const p1 = v1.dot(_testAxis);\n      const p2 = v2.dot(_testAxis);\n      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {\n        return false;\n      }\n    }\n    return true;\n  }\n  const _box$3 = /* @__PURE__ */ new Box3();\n  const _v1$6 = /* @__PURE__ */ new Vector3();\n  const _v2$3 = /* @__PURE__ */ new Vector3();\n  class Sphere {\n    constructor(center = new Vector3(), radius = -1) {\n      this.isSphere = true;\n      this.center = center;\n      this.radius = radius;\n    }\n    set(center, radius) {\n      this.center.copy(center);\n      this.radius = radius;\n      return this;\n    }\n    setFromPoints(points, optionalCenter) {\n      const center = this.center;\n      if (optionalCenter !== void 0) {\n        center.copy(optionalCenter);\n      } else {\n        _box$3.setFromPoints(points).getCenter(center);\n      }\n      let maxRadiusSq = 0;\n      for (let i2 = 0, il = points.length; i2 < il; i2++) {\n        maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i2]));\n      }\n      this.radius = Math.sqrt(maxRadiusSq);\n      return this;\n    }\n    copy(sphere) {\n      this.center.copy(sphere.center);\n      this.radius = sphere.radius;\n      return this;\n    }\n    isEmpty() {\n      return this.radius < 0;\n    }\n    makeEmpty() {\n      this.center.set(0, 0, 0);\n      this.radius = -1;\n      return this;\n    }\n    containsPoint(point) {\n      return point.distanceToSquared(this.center) <= this.radius * this.radius;\n    }\n    distanceToPoint(point) {\n      return point.distanceTo(this.center) - this.radius;\n    }\n    intersectsSphere(sphere) {\n      const radiusSum = this.radius + sphere.radius;\n      return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;\n    }\n    intersectsBox(box) {\n      return box.intersectsSphere(this);\n    }\n    intersectsPlane(plane) {\n      return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;\n    }\n    clampPoint(point, target) {\n      const deltaLengthSq = this.center.distanceToSquared(point);\n      target.copy(point);\n      if (deltaLengthSq > this.radius * this.radius) {\n        target.sub(this.center).normalize();\n        target.multiplyScalar(this.radius).add(this.center);\n      }\n      return target;\n    }\n    getBoundingBox(target) {\n      if (this.isEmpty()) {\n        target.makeEmpty();\n        return target;\n      }\n      target.set(this.center, this.center);\n      target.expandByScalar(this.radius);\n      return target;\n    }\n    applyMatrix4(matrix) {\n      this.center.applyMatrix4(matrix);\n      this.radius = this.radius * matrix.getMaxScaleOnAxis();\n      return this;\n    }\n    translate(offset) {\n      this.center.add(offset);\n      return this;\n    }\n    expandByPoint(point) {\n      if (this.isEmpty()) {\n        this.center.copy(point);\n        this.radius = 0;\n        return this;\n      }\n      _v1$6.subVectors(point, this.center);\n      const lengthSq = _v1$6.lengthSq();\n      if (lengthSq > this.radius * this.radius) {\n        const length = Math.sqrt(lengthSq);\n        const delta = (length - this.radius) * 0.5;\n        this.center.addScaledVector(_v1$6, delta / length);\n        this.radius += delta;\n      }\n      return this;\n    }\n    union(sphere) {\n      if (sphere.isEmpty()) {\n        return this;\n      }\n      if (this.isEmpty()) {\n        this.copy(sphere);\n        return this;\n      }\n      if (this.center.equals(sphere.center) === true) {\n        this.radius = Math.max(this.radius, sphere.radius);\n      } else {\n        _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);\n        this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));\n        this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));\n      }\n      return this;\n    }\n    equals(sphere) {\n      return sphere.center.equals(this.center) && sphere.radius === this.radius;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  const _vector$a = /* @__PURE__ */ new Vector3();\n  const _segCenter = /* @__PURE__ */ new Vector3();\n  const _segDir = /* @__PURE__ */ new Vector3();\n  const _diff = /* @__PURE__ */ new Vector3();\n  const _edge1 = /* @__PURE__ */ new Vector3();\n  const _edge2 = /* @__PURE__ */ new Vector3();\n  const _normal$1 = /* @__PURE__ */ new Vector3();\n  class Ray {\n    constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {\n      this.origin = origin;\n      this.direction = direction;\n    }\n    set(origin, direction) {\n      this.origin.copy(origin);\n      this.direction.copy(direction);\n      return this;\n    }\n    copy(ray) {\n      this.origin.copy(ray.origin);\n      this.direction.copy(ray.direction);\n      return this;\n    }\n    at(t, target) {\n      return target.copy(this.origin).addScaledVector(this.direction, t);\n    }\n    lookAt(v) {\n      this.direction.copy(v).sub(this.origin).normalize();\n      return this;\n    }\n    recast(t) {\n      this.origin.copy(this.at(t, _vector$a));\n      return this;\n    }\n    closestPointToPoint(point, target) {\n      target.subVectors(point, this.origin);\n      const directionDistance = target.dot(this.direction);\n      if (directionDistance < 0) {\n        return target.copy(this.origin);\n      }\n      return target.copy(this.origin).addScaledVector(this.direction, directionDistance);\n    }\n    distanceToPoint(point) {\n      return Math.sqrt(this.distanceSqToPoint(point));\n    }\n    distanceSqToPoint(point) {\n      const directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);\n      if (directionDistance < 0) {\n        return this.origin.distanceToSquared(point);\n      }\n      _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);\n      return _vector$a.distanceToSquared(point);\n    }\n    distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {\n      _segCenter.copy(v0).add(v1).multiplyScalar(0.5);\n      _segDir.copy(v1).sub(v0).normalize();\n      _diff.copy(this.origin).sub(_segCenter);\n      const segExtent = v0.distanceTo(v1) * 0.5;\n      const a01 = -this.direction.dot(_segDir);\n      const b0 = _diff.dot(this.direction);\n      const b1 = -_diff.dot(_segDir);\n      const c = _diff.lengthSq();\n      const det = Math.abs(1 - a01 * a01);\n      let s0, s1, sqrDist, extDet;\n      if (det > 0) {\n        s0 = a01 * b1 - b0;\n        s1 = a01 * b0 - b1;\n        extDet = segExtent * det;\n        if (s0 >= 0) {\n          if (s1 >= -extDet) {\n            if (s1 <= extDet) {\n              const invDet = 1 / det;\n              s0 *= invDet;\n              s1 *= invDet;\n              sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;\n            } else {\n              s1 = segExtent;\n              s0 = Math.max(0, -(a01 * s1 + b0));\n              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n            }\n          } else {\n            s1 = -segExtent;\n            s0 = Math.max(0, -(a01 * s1 + b0));\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        } else {\n          if (s1 <= -extDet) {\n            s0 = Math.max(0, -(-a01 * segExtent + b0));\n            s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          } else if (s1 <= extDet) {\n            s0 = 0;\n            s1 = Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = s1 * (s1 + 2 * b1) + c;\n          } else {\n            s0 = Math.max(0, -(a01 * segExtent + b0));\n            s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);\n            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n          }\n        }\n      } else {\n        s1 = a01 > 0 ? -segExtent : segExtent;\n        s0 = Math.max(0, -(a01 * s1 + b0));\n        sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;\n      }\n      if (optionalPointOnRay) {\n        optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);\n      }\n      if (optionalPointOnSegment) {\n        optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);\n      }\n      return sqrDist;\n    }\n    intersectSphere(sphere, target) {\n      _vector$a.subVectors(sphere.center, this.origin);\n      const tca = _vector$a.dot(this.direction);\n      const d2 = _vector$a.dot(_vector$a) - tca * tca;\n      const radius2 = sphere.radius * sphere.radius;\n      if (d2 > radius2) return null;\n      const thc = Math.sqrt(radius2 - d2);\n      const t0 = tca - thc;\n      const t1 = tca + thc;\n      if (t1 < 0) return null;\n      if (t0 < 0) return this.at(t1, target);\n      return this.at(t0, target);\n    }\n    intersectsSphere(sphere) {\n      return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;\n    }\n    distanceToPlane(plane) {\n      const denominator = plane.normal.dot(this.direction);\n      if (denominator === 0) {\n        if (plane.distanceToPoint(this.origin) === 0) {\n          return 0;\n        }\n        return null;\n      }\n      const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;\n      return t >= 0 ? t : null;\n    }\n    intersectPlane(plane, target) {\n      const t = this.distanceToPlane(plane);\n      if (t === null) {\n        return null;\n      }\n      return this.at(t, target);\n    }\n    intersectsPlane(plane) {\n      const distToPoint = plane.distanceToPoint(this.origin);\n      if (distToPoint === 0) {\n        return true;\n      }\n      const denominator = plane.normal.dot(this.direction);\n      if (denominator * distToPoint < 0) {\n        return true;\n      }\n      return false;\n    }\n    intersectBox(box, target) {\n      let tmin, tmax, tymin, tymax, tzmin, tzmax;\n      const invdirx = 1 / this.direction.x, invdiry = 1 / this.direction.y, invdirz = 1 / this.direction.z;\n      const origin = this.origin;\n      if (invdirx >= 0) {\n        tmin = (box.min.x - origin.x) * invdirx;\n        tmax = (box.max.x - origin.x) * invdirx;\n      } else {\n        tmin = (box.max.x - origin.x) * invdirx;\n        tmax = (box.min.x - origin.x) * invdirx;\n      }\n      if (invdiry >= 0) {\n        tymin = (box.min.y - origin.y) * invdiry;\n        tymax = (box.max.y - origin.y) * invdiry;\n      } else {\n        tymin = (box.max.y - origin.y) * invdiry;\n        tymax = (box.min.y - origin.y) * invdiry;\n      }\n      if (tmin > tymax || tymin > tmax) return null;\n      if (tymin > tmin || isNaN(tmin)) tmin = tymin;\n      if (tymax < tmax || isNaN(tmax)) tmax = tymax;\n      if (invdirz >= 0) {\n        tzmin = (box.min.z - origin.z) * invdirz;\n        tzmax = (box.max.z - origin.z) * invdirz;\n      } else {\n        tzmin = (box.max.z - origin.z) * invdirz;\n        tzmax = (box.min.z - origin.z) * invdirz;\n      }\n      if (tmin > tzmax || tzmin > tmax) return null;\n      if (tzmin > tmin || tmin !== tmin) tmin = tzmin;\n      if (tzmax < tmax || tmax !== tmax) tmax = tzmax;\n      if (tmax < 0) return null;\n      return this.at(tmin >= 0 ? tmin : tmax, target);\n    }\n    intersectsBox(box) {\n      return this.intersectBox(box, _vector$a) !== null;\n    }\n    intersectTriangle(a, b, c, backfaceCulling, target) {\n      _edge1.subVectors(b, a);\n      _edge2.subVectors(c, a);\n      _normal$1.crossVectors(_edge1, _edge2);\n      let DdN = this.direction.dot(_normal$1);\n      let sign;\n      if (DdN > 0) {\n        if (backfaceCulling) return null;\n        sign = 1;\n      } else if (DdN < 0) {\n        sign = -1;\n        DdN = -DdN;\n      } else {\n        return null;\n      }\n      _diff.subVectors(this.origin, a);\n      const DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));\n      if (DdQxE2 < 0) {\n        return null;\n      }\n      const DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));\n      if (DdE1xQ < 0) {\n        return null;\n      }\n      if (DdQxE2 + DdE1xQ > DdN) {\n        return null;\n      }\n      const QdN = -sign * _diff.dot(_normal$1);\n      if (QdN < 0) {\n        return null;\n      }\n      return this.at(QdN / DdN, target);\n    }\n    applyMatrix4(matrix4) {\n      this.origin.applyMatrix4(matrix4);\n      this.direction.transformDirection(matrix4);\n      return this;\n    }\n    equals(ray) {\n      return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  class Matrix4 {\n    constructor(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n      Matrix4.prototype.isMatrix4 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);\n      }\n    }\n    set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {\n      const te = this.elements;\n      te[0] = n11;\n      te[4] = n12;\n      te[8] = n13;\n      te[12] = n14;\n      te[1] = n21;\n      te[5] = n22;\n      te[9] = n23;\n      te[13] = n24;\n      te[2] = n31;\n      te[6] = n32;\n      te[10] = n33;\n      te[14] = n34;\n      te[3] = n41;\n      te[7] = n42;\n      te[11] = n43;\n      te[15] = n44;\n      return this;\n    }\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    clone() {\n      return new Matrix4().fromArray(this.elements);\n    }\n    copy(m) {\n      const te = this.elements;\n      const me = m.elements;\n      te[0] = me[0];\n      te[1] = me[1];\n      te[2] = me[2];\n      te[3] = me[3];\n      te[4] = me[4];\n      te[5] = me[5];\n      te[6] = me[6];\n      te[7] = me[7];\n      te[8] = me[8];\n      te[9] = me[9];\n      te[10] = me[10];\n      te[11] = me[11];\n      te[12] = me[12];\n      te[13] = me[13];\n      te[14] = me[14];\n      te[15] = me[15];\n      return this;\n    }\n    copyPosition(m) {\n      const te = this.elements, me = m.elements;\n      te[12] = me[12];\n      te[13] = me[13];\n      te[14] = me[14];\n      return this;\n    }\n    setFromMatrix3(m) {\n      const me = m.elements;\n      this.set(\n        me[0],\n        me[3],\n        me[6],\n        0,\n        me[1],\n        me[4],\n        me[7],\n        0,\n        me[2],\n        me[5],\n        me[8],\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    extractBasis(xAxis, yAxis, zAxis) {\n      xAxis.setFromMatrixColumn(this, 0);\n      yAxis.setFromMatrixColumn(this, 1);\n      zAxis.setFromMatrixColumn(this, 2);\n      return this;\n    }\n    makeBasis(xAxis, yAxis, zAxis) {\n      this.set(\n        xAxis.x,\n        yAxis.x,\n        zAxis.x,\n        0,\n        xAxis.y,\n        yAxis.y,\n        zAxis.y,\n        0,\n        xAxis.z,\n        yAxis.z,\n        zAxis.z,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    extractRotation(m) {\n      const te = this.elements;\n      const me = m.elements;\n      const scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();\n      const scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();\n      const scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();\n      te[0] = me[0] * scaleX;\n      te[1] = me[1] * scaleX;\n      te[2] = me[2] * scaleX;\n      te[3] = 0;\n      te[4] = me[4] * scaleY;\n      te[5] = me[5] * scaleY;\n      te[6] = me[6] * scaleY;\n      te[7] = 0;\n      te[8] = me[8] * scaleZ;\n      te[9] = me[9] * scaleZ;\n      te[10] = me[10] * scaleZ;\n      te[11] = 0;\n      te[12] = 0;\n      te[13] = 0;\n      te[14] = 0;\n      te[15] = 1;\n      return this;\n    }\n    makeRotationFromEuler(euler) {\n      const te = this.elements;\n      const x2 = euler.x, y = euler.y, z = euler.z;\n      const a = Math.cos(x2), b = Math.sin(x2);\n      const c = Math.cos(y), d = Math.sin(y);\n      const e = Math.cos(z), f = Math.sin(z);\n      if (euler.order === \"XYZ\") {\n        const ae = a * e, af = a * f, be = b * e, bf = b * f;\n        te[0] = c * e;\n        te[4] = -c * f;\n        te[8] = d;\n        te[1] = af + be * d;\n        te[5] = ae - bf * d;\n        te[9] = -b * c;\n        te[2] = bf - ae * d;\n        te[6] = be + af * d;\n        te[10] = a * c;\n      } else if (euler.order === \"YXZ\") {\n        const ce = c * e, cf = c * f, de = d * e, df = d * f;\n        te[0] = ce + df * b;\n        te[4] = de * b - cf;\n        te[8] = a * d;\n        te[1] = a * f;\n        te[5] = a * e;\n        te[9] = -b;\n        te[2] = cf * b - de;\n        te[6] = df + ce * b;\n        te[10] = a * c;\n      } else if (euler.order === \"ZXY\") {\n        const ce = c * e, cf = c * f, de = d * e, df = d * f;\n        te[0] = ce - df * b;\n        te[4] = -a * f;\n        te[8] = de + cf * b;\n        te[1] = cf + de * b;\n        te[5] = a * e;\n        te[9] = df - ce * b;\n        te[2] = -a * d;\n        te[6] = b;\n        te[10] = a * c;\n      } else if (euler.order === \"ZYX\") {\n        const ae = a * e, af = a * f, be = b * e, bf = b * f;\n        te[0] = c * e;\n        te[4] = be * d - af;\n        te[8] = ae * d + bf;\n        te[1] = c * f;\n        te[5] = bf * d + ae;\n        te[9] = af * d - be;\n        te[2] = -d;\n        te[6] = b * c;\n        te[10] = a * c;\n      } else if (euler.order === \"YZX\") {\n        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n        te[0] = c * e;\n        te[4] = bd - ac * f;\n        te[8] = bc * f + ad;\n        te[1] = f;\n        te[5] = a * e;\n        te[9] = -b * e;\n        te[2] = -d * e;\n        te[6] = ad * f + bc;\n        te[10] = ac - bd * f;\n      } else if (euler.order === \"XZY\") {\n        const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\n        te[0] = c * e;\n        te[4] = -f;\n        te[8] = d * e;\n        te[1] = ac * f + bd;\n        te[5] = a * e;\n        te[9] = ad * f - bc;\n        te[2] = bc * f - ad;\n        te[6] = b * e;\n        te[10] = bd * f + ac;\n      }\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = 0;\n      te[12] = 0;\n      te[13] = 0;\n      te[14] = 0;\n      te[15] = 1;\n      return this;\n    }\n    makeRotationFromQuaternion(q) {\n      return this.compose(_zero, q, _one);\n    }\n    lookAt(eye, target, up) {\n      const te = this.elements;\n      _z.subVectors(eye, target);\n      if (_z.lengthSq() === 0) {\n        _z.z = 1;\n      }\n      _z.normalize();\n      _x.crossVectors(up, _z);\n      if (_x.lengthSq() === 0) {\n        if (Math.abs(up.z) === 1) {\n          _z.x += 1e-4;\n        } else {\n          _z.z += 1e-4;\n        }\n        _z.normalize();\n        _x.crossVectors(up, _z);\n      }\n      _x.normalize();\n      _y.crossVectors(_z, _x);\n      te[0] = _x.x;\n      te[4] = _y.x;\n      te[8] = _z.x;\n      te[1] = _x.y;\n      te[5] = _y.y;\n      te[9] = _z.y;\n      te[2] = _x.z;\n      te[6] = _y.z;\n      te[10] = _z.z;\n      return this;\n    }\n    multiply(m) {\n      return this.multiplyMatrices(this, m);\n    }\n    premultiply(m) {\n      return this.multiplyMatrices(m, this);\n    }\n    multiplyMatrices(a, b) {\n      const ae = a.elements;\n      const be = b.elements;\n      const te = this.elements;\n      const a11 = ae[0], a12 = ae[4], a13 = ae[8], a14 = ae[12];\n      const a21 = ae[1], a22 = ae[5], a23 = ae[9], a24 = ae[13];\n      const a31 = ae[2], a32 = ae[6], a33 = ae[10], a34 = ae[14];\n      const a41 = ae[3], a42 = ae[7], a43 = ae[11], a44 = ae[15];\n      const b11 = be[0], b12 = be[4], b13 = be[8], b14 = be[12];\n      const b21 = be[1], b22 = be[5], b23 = be[9], b24 = be[13];\n      const b31 = be[2], b32 = be[6], b33 = be[10], b34 = be[14];\n      const b41 = be[3], b42 = be[7], b43 = be[11], b44 = be[15];\n      te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;\n      te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;\n      te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;\n      te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;\n      te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;\n      te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;\n      te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;\n      te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;\n      te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;\n      te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;\n      te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;\n      te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;\n      te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;\n      te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;\n      te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;\n      te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;\n      return this;\n    }\n    multiplyScalar(s) {\n      const te = this.elements;\n      te[0] *= s;\n      te[4] *= s;\n      te[8] *= s;\n      te[12] *= s;\n      te[1] *= s;\n      te[5] *= s;\n      te[9] *= s;\n      te[13] *= s;\n      te[2] *= s;\n      te[6] *= s;\n      te[10] *= s;\n      te[14] *= s;\n      te[3] *= s;\n      te[7] *= s;\n      te[11] *= s;\n      te[15] *= s;\n      return this;\n    }\n    determinant() {\n      const te = this.elements;\n      const n11 = te[0], n12 = te[4], n13 = te[8], n14 = te[12];\n      const n21 = te[1], n22 = te[5], n23 = te[9], n24 = te[13];\n      const n31 = te[2], n32 = te[6], n33 = te[10], n34 = te[14];\n      const n41 = te[3], n42 = te[7], n43 = te[11], n44 = te[15];\n      return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);\n    }\n    transpose() {\n      const te = this.elements;\n      let tmp;\n      tmp = te[1];\n      te[1] = te[4];\n      te[4] = tmp;\n      tmp = te[2];\n      te[2] = te[8];\n      te[8] = tmp;\n      tmp = te[6];\n      te[6] = te[9];\n      te[9] = tmp;\n      tmp = te[3];\n      te[3] = te[12];\n      te[12] = tmp;\n      tmp = te[7];\n      te[7] = te[13];\n      te[13] = tmp;\n      tmp = te[11];\n      te[11] = te[14];\n      te[14] = tmp;\n      return this;\n    }\n    setPosition(x2, y, z) {\n      const te = this.elements;\n      if (x2.isVector3) {\n        te[12] = x2.x;\n        te[13] = x2.y;\n        te[14] = x2.z;\n      } else {\n        te[12] = x2;\n        te[13] = y;\n        te[14] = z;\n      }\n      return this;\n    }\n    invert() {\n      const te = this.elements, n11 = te[0], n21 = te[1], n31 = te[2], n41 = te[3], n12 = te[4], n22 = te[5], n32 = te[6], n42 = te[7], n13 = te[8], n23 = te[9], n33 = te[10], n43 = te[11], n14 = te[12], n24 = te[13], n34 = te[14], n44 = te[15], t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44, t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44, t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44, t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;\n      const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;\n      if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n      const detInv = 1 / det;\n      te[0] = t11 * detInv;\n      te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;\n      te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;\n      te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;\n      te[4] = t12 * detInv;\n      te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;\n      te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;\n      te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;\n      te[8] = t13 * detInv;\n      te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;\n      te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;\n      te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;\n      te[12] = t14 * detInv;\n      te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;\n      te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;\n      te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;\n      return this;\n    }\n    scale(v) {\n      const te = this.elements;\n      const x2 = v.x, y = v.y, z = v.z;\n      te[0] *= x2;\n      te[4] *= y;\n      te[8] *= z;\n      te[1] *= x2;\n      te[5] *= y;\n      te[9] *= z;\n      te[2] *= x2;\n      te[6] *= y;\n      te[10] *= z;\n      te[3] *= x2;\n      te[7] *= y;\n      te[11] *= z;\n      return this;\n    }\n    getMaxScaleOnAxis() {\n      const te = this.elements;\n      const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];\n      const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];\n      const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];\n      return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));\n    }\n    makeTranslation(x2, y, z) {\n      if (x2.isVector3) {\n        this.set(\n          1,\n          0,\n          0,\n          x2.x,\n          0,\n          1,\n          0,\n          x2.y,\n          0,\n          0,\n          1,\n          x2.z,\n          0,\n          0,\n          0,\n          1\n        );\n      } else {\n        this.set(\n          1,\n          0,\n          0,\n          x2,\n          0,\n          1,\n          0,\n          y,\n          0,\n          0,\n          1,\n          z,\n          0,\n          0,\n          0,\n          1\n        );\n      }\n      return this;\n    }\n    makeRotationX(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        1,\n        0,\n        0,\n        0,\n        0,\n        c,\n        -s,\n        0,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeRotationY(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        c,\n        0,\n        s,\n        0,\n        0,\n        1,\n        0,\n        0,\n        -s,\n        0,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeRotationZ(theta) {\n      const c = Math.cos(theta), s = Math.sin(theta);\n      this.set(\n        c,\n        -s,\n        0,\n        0,\n        s,\n        c,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeRotationAxis(axis, angle) {\n      const c = Math.cos(angle);\n      const s = Math.sin(angle);\n      const t = 1 - c;\n      const x2 = axis.x, y = axis.y, z = axis.z;\n      const tx = t * x2, ty = t * y;\n      this.set(\n        tx * x2 + c,\n        tx * y - s * z,\n        tx * z + s * y,\n        0,\n        tx * y + s * z,\n        ty * y + c,\n        ty * z - s * x2,\n        0,\n        tx * z - s * y,\n        ty * z + s * x2,\n        t * z * z + c,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeScale(x2, y, z) {\n      this.set(\n        x2,\n        0,\n        0,\n        0,\n        0,\n        y,\n        0,\n        0,\n        0,\n        0,\n        z,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    makeShear(xy, xz, yx, yz, zx, zy) {\n      this.set(\n        1,\n        yx,\n        zx,\n        0,\n        xy,\n        1,\n        zy,\n        0,\n        xz,\n        yz,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    compose(position, quaternion, scale) {\n      const te = this.elements;\n      const x2 = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;\n      const x22 = x2 + x2, y2 = y + y, z2 = z + z;\n      const xx = x2 * x22, xy = x2 * y2, xz = x2 * z2;\n      const yy = y * y2, yz = y * z2, zz = z * z2;\n      const wx = w * x22, wy = w * y2, wz = w * z2;\n      const sx = scale.x, sy = scale.y, sz = scale.z;\n      te[0] = (1 - (yy + zz)) * sx;\n      te[1] = (xy + wz) * sx;\n      te[2] = (xz - wy) * sx;\n      te[3] = 0;\n      te[4] = (xy - wz) * sy;\n      te[5] = (1 - (xx + zz)) * sy;\n      te[6] = (yz + wx) * sy;\n      te[7] = 0;\n      te[8] = (xz + wy) * sz;\n      te[9] = (yz - wx) * sz;\n      te[10] = (1 - (xx + yy)) * sz;\n      te[11] = 0;\n      te[12] = position.x;\n      te[13] = position.y;\n      te[14] = position.z;\n      te[15] = 1;\n      return this;\n    }\n    decompose(position, quaternion, scale) {\n      const te = this.elements;\n      let sx = _v1$5.set(te[0], te[1], te[2]).length();\n      const sy = _v1$5.set(te[4], te[5], te[6]).length();\n      const sz = _v1$5.set(te[8], te[9], te[10]).length();\n      const det = this.determinant();\n      if (det < 0) sx = -sx;\n      position.x = te[12];\n      position.y = te[13];\n      position.z = te[14];\n      _m1$2.copy(this);\n      const invSX = 1 / sx;\n      const invSY = 1 / sy;\n      const invSZ = 1 / sz;\n      _m1$2.elements[0] *= invSX;\n      _m1$2.elements[1] *= invSX;\n      _m1$2.elements[2] *= invSX;\n      _m1$2.elements[4] *= invSY;\n      _m1$2.elements[5] *= invSY;\n      _m1$2.elements[6] *= invSY;\n      _m1$2.elements[8] *= invSZ;\n      _m1$2.elements[9] *= invSZ;\n      _m1$2.elements[10] *= invSZ;\n      quaternion.setFromRotationMatrix(_m1$2);\n      scale.x = sx;\n      scale.y = sy;\n      scale.z = sz;\n      return this;\n    }\n    makePerspective(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {\n      const te = this.elements;\n      const x2 = 2 * near / (right - left);\n      const y = 2 * near / (top - bottom);\n      const a = (right + left) / (right - left);\n      const b = (top + bottom) / (top - bottom);\n      let c, d;\n      if (coordinateSystem === WebGLCoordinateSystem) {\n        c = -(far + near) / (far - near);\n        d = -2 * far * near / (far - near);\n      } else if (coordinateSystem === WebGPUCoordinateSystem) {\n        c = -far / (far - near);\n        d = -far * near / (far - near);\n      } else {\n        throw new Error(\"THREE.Matrix4.makePerspective(): Invalid coordinate system: \" + coordinateSystem);\n      }\n      te[0] = x2;\n      te[4] = 0;\n      te[8] = a;\n      te[12] = 0;\n      te[1] = 0;\n      te[5] = y;\n      te[9] = b;\n      te[13] = 0;\n      te[2] = 0;\n      te[6] = 0;\n      te[10] = c;\n      te[14] = d;\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = -1;\n      te[15] = 0;\n      return this;\n    }\n    makeOrthographic(left, right, top, bottom, near, far, coordinateSystem = WebGLCoordinateSystem) {\n      const te = this.elements;\n      const w = 1 / (right - left);\n      const h = 1 / (top - bottom);\n      const p = 1 / (far - near);\n      const x2 = (right + left) * w;\n      const y = (top + bottom) * h;\n      let z, zInv;\n      if (coordinateSystem === WebGLCoordinateSystem) {\n        z = (far + near) * p;\n        zInv = -2 * p;\n      } else if (coordinateSystem === WebGPUCoordinateSystem) {\n        z = near * p;\n        zInv = -1 * p;\n      } else {\n        throw new Error(\"THREE.Matrix4.makeOrthographic(): Invalid coordinate system: \" + coordinateSystem);\n      }\n      te[0] = 2 * w;\n      te[4] = 0;\n      te[8] = 0;\n      te[12] = -x2;\n      te[1] = 0;\n      te[5] = 2 * h;\n      te[9] = 0;\n      te[13] = -y;\n      te[2] = 0;\n      te[6] = 0;\n      te[10] = zInv;\n      te[14] = -z;\n      te[3] = 0;\n      te[7] = 0;\n      te[11] = 0;\n      te[15] = 1;\n      return this;\n    }\n    equals(matrix) {\n      const te = this.elements;\n      const me = matrix.elements;\n      for (let i2 = 0; i2 < 16; i2++) {\n        if (te[i2] !== me[i2]) return false;\n      }\n      return true;\n    }\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 16; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      const te = this.elements;\n      array[offset] = te[0];\n      array[offset + 1] = te[1];\n      array[offset + 2] = te[2];\n      array[offset + 3] = te[3];\n      array[offset + 4] = te[4];\n      array[offset + 5] = te[5];\n      array[offset + 6] = te[6];\n      array[offset + 7] = te[7];\n      array[offset + 8] = te[8];\n      array[offset + 9] = te[9];\n      array[offset + 10] = te[10];\n      array[offset + 11] = te[11];\n      array[offset + 12] = te[12];\n      array[offset + 13] = te[13];\n      array[offset + 14] = te[14];\n      array[offset + 15] = te[15];\n      return array;\n    }\n  }\n  const _v1$5 = /* @__PURE__ */ new Vector3();\n  const _m1$2 = /* @__PURE__ */ new Matrix4();\n  const _zero = /* @__PURE__ */ new Vector3(0, 0, 0);\n  const _one = /* @__PURE__ */ new Vector3(1, 1, 1);\n  const _x = /* @__PURE__ */ new Vector3();\n  const _y = /* @__PURE__ */ new Vector3();\n  const _z = /* @__PURE__ */ new Vector3();\n  const _matrix$2 = /* @__PURE__ */ new Matrix4();\n  const _quaternion$3 = /* @__PURE__ */ new Quaternion();\n  class Euler {\n    constructor(x2 = 0, y = 0, z = 0, order = Euler.DEFAULT_ORDER) {\n      this.isEuler = true;\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._order = order;\n    }\n    get x() {\n      return this._x;\n    }\n    set x(value) {\n      this._x = value;\n      this._onChangeCallback();\n    }\n    get y() {\n      return this._y;\n    }\n    set y(value) {\n      this._y = value;\n      this._onChangeCallback();\n    }\n    get z() {\n      return this._z;\n    }\n    set z(value) {\n      this._z = value;\n      this._onChangeCallback();\n    }\n    get order() {\n      return this._order;\n    }\n    set order(value) {\n      this._order = value;\n      this._onChangeCallback();\n    }\n    set(x2, y, z, order = this._order) {\n      this._x = x2;\n      this._y = y;\n      this._z = z;\n      this._order = order;\n      this._onChangeCallback();\n      return this;\n    }\n    clone() {\n      return new this.constructor(this._x, this._y, this._z, this._order);\n    }\n    copy(euler) {\n      this._x = euler._x;\n      this._y = euler._y;\n      this._z = euler._z;\n      this._order = euler._order;\n      this._onChangeCallback();\n      return this;\n    }\n    setFromRotationMatrix(m, order = this._order, update = true) {\n      const te = m.elements;\n      const m11 = te[0], m12 = te[4], m13 = te[8];\n      const m21 = te[1], m22 = te[5], m23 = te[9];\n      const m31 = te[2], m32 = te[6], m33 = te[10];\n      switch (order) {\n        case \"XYZ\":\n          this._y = Math.asin(clamp(m13, -1, 1));\n          if (Math.abs(m13) < 0.9999999) {\n            this._x = Math.atan2(-m23, m33);\n            this._z = Math.atan2(-m12, m11);\n          } else {\n            this._x = Math.atan2(m32, m22);\n            this._z = 0;\n          }\n          break;\n        case \"YXZ\":\n          this._x = Math.asin(-clamp(m23, -1, 1));\n          if (Math.abs(m23) < 0.9999999) {\n            this._y = Math.atan2(m13, m33);\n            this._z = Math.atan2(m21, m22);\n          } else {\n            this._y = Math.atan2(-m31, m11);\n            this._z = 0;\n          }\n          break;\n        case \"ZXY\":\n          this._x = Math.asin(clamp(m32, -1, 1));\n          if (Math.abs(m32) < 0.9999999) {\n            this._y = Math.atan2(-m31, m33);\n            this._z = Math.atan2(-m12, m22);\n          } else {\n            this._y = 0;\n            this._z = Math.atan2(m21, m11);\n          }\n          break;\n        case \"ZYX\":\n          this._y = Math.asin(-clamp(m31, -1, 1));\n          if (Math.abs(m31) < 0.9999999) {\n            this._x = Math.atan2(m32, m33);\n            this._z = Math.atan2(m21, m11);\n          } else {\n            this._x = 0;\n            this._z = Math.atan2(-m12, m22);\n          }\n          break;\n        case \"YZX\":\n          this._z = Math.asin(clamp(m21, -1, 1));\n          if (Math.abs(m21) < 0.9999999) {\n            this._x = Math.atan2(-m23, m22);\n            this._y = Math.atan2(-m31, m11);\n          } else {\n            this._x = 0;\n            this._y = Math.atan2(m13, m33);\n          }\n          break;\n        case \"XZY\":\n          this._z = Math.asin(-clamp(m12, -1, 1));\n          if (Math.abs(m12) < 0.9999999) {\n            this._x = Math.atan2(m32, m22);\n            this._y = Math.atan2(m13, m11);\n          } else {\n            this._x = Math.atan2(-m23, m33);\n            this._y = 0;\n          }\n          break;\n        default:\n          console.warn(\"THREE.Euler: .setFromRotationMatrix() encountered an unknown order: \" + order);\n      }\n      this._order = order;\n      if (update === true) this._onChangeCallback();\n      return this;\n    }\n    setFromQuaternion(q, order, update) {\n      _matrix$2.makeRotationFromQuaternion(q);\n      return this.setFromRotationMatrix(_matrix$2, order, update);\n    }\n    setFromVector3(v, order = this._order) {\n      return this.set(v.x, v.y, v.z, order);\n    }\n    reorder(newOrder) {\n      _quaternion$3.setFromEuler(this);\n      return this.setFromQuaternion(_quaternion$3, newOrder);\n    }\n    equals(euler) {\n      return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;\n    }\n    fromArray(array) {\n      this._x = array[0];\n      this._y = array[1];\n      this._z = array[2];\n      if (array[3] !== void 0) this._order = array[3];\n      this._onChangeCallback();\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this._x;\n      array[offset + 1] = this._y;\n      array[offset + 2] = this._z;\n      array[offset + 3] = this._order;\n      return array;\n    }\n    _onChange(callback) {\n      this._onChangeCallback = callback;\n      return this;\n    }\n    _onChangeCallback() {\n    }\n    *[Symbol.iterator]() {\n      yield this._x;\n      yield this._y;\n      yield this._z;\n      yield this._order;\n    }\n  }\n  Euler.DEFAULT_ORDER = \"XYZ\";\n  class Layers {\n    constructor() {\n      this.mask = 1 | 0;\n    }\n    set(channel) {\n      this.mask = (1 << channel | 0) >>> 0;\n    }\n    enable(channel) {\n      this.mask |= 1 << channel | 0;\n    }\n    enableAll() {\n      this.mask = 4294967295 | 0;\n    }\n    toggle(channel) {\n      this.mask ^= 1 << channel | 0;\n    }\n    disable(channel) {\n      this.mask &= ~(1 << channel | 0);\n    }\n    disableAll() {\n      this.mask = 0;\n    }\n    test(layers) {\n      return (this.mask & layers.mask) !== 0;\n    }\n    isEnabled(channel) {\n      return (this.mask & (1 << channel | 0)) !== 0;\n    }\n  }\n  let _object3DId = 0;\n  const _v1$4 = /* @__PURE__ */ new Vector3();\n  const _q1 = /* @__PURE__ */ new Quaternion();\n  const _m1$1 = /* @__PURE__ */ new Matrix4();\n  const _target = /* @__PURE__ */ new Vector3();\n  const _position$3 = /* @__PURE__ */ new Vector3();\n  const _scale$2 = /* @__PURE__ */ new Vector3();\n  const _quaternion$2 = /* @__PURE__ */ new Quaternion();\n  const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0);\n  const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0);\n  const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1);\n  const _addedEvent = { type: \"added\" };\n  const _removedEvent = { type: \"removed\" };\n  const _childaddedEvent = { type: \"childadded\", child: null };\n  const _childremovedEvent = { type: \"childremoved\", child: null };\n  class Object3D extends EventDispatcher {\n    constructor() {\n      super();\n      this.isObject3D = true;\n      Object.defineProperty(this, \"id\", { value: _object3DId++ });\n      this.uuid = generateUUID();\n      this.name = \"\";\n      this.type = \"Object3D\";\n      this.parent = null;\n      this.children = [];\n      this.up = Object3D.DEFAULT_UP.clone();\n      const position = new Vector3();\n      const rotation = new Euler();\n      const quaternion = new Quaternion();\n      const scale = new Vector3(1, 1, 1);\n      function onRotationChange() {\n        quaternion.setFromEuler(rotation, false);\n      }\n      function onQuaternionChange() {\n        rotation.setFromQuaternion(quaternion, void 0, false);\n      }\n      rotation._onChange(onRotationChange);\n      quaternion._onChange(onQuaternionChange);\n      Object.defineProperties(this, {\n        position: {\n          configurable: true,\n          enumerable: true,\n          value: position\n        },\n        rotation: {\n          configurable: true,\n          enumerable: true,\n          value: rotation\n        },\n        quaternion: {\n          configurable: true,\n          enumerable: true,\n          value: quaternion\n        },\n        scale: {\n          configurable: true,\n          enumerable: true,\n          value: scale\n        },\n        modelViewMatrix: {\n          value: new Matrix4()\n        },\n        normalMatrix: {\n          value: new Matrix3()\n        }\n      });\n      this.matrix = new Matrix4();\n      this.matrixWorld = new Matrix4();\n      this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;\n      this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE;\n      this.matrixWorldNeedsUpdate = false;\n      this.layers = new Layers();\n      this.visible = true;\n      this.castShadow = false;\n      this.receiveShadow = false;\n      this.frustumCulled = true;\n      this.renderOrder = 0;\n      this.animations = [];\n      this.userData = {};\n    }\n    onBeforeShadow() {\n    }\n    onAfterShadow() {\n    }\n    onBeforeRender() {\n    }\n    onAfterRender() {\n    }\n    applyMatrix4(matrix) {\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      this.matrix.premultiply(matrix);\n      this.matrix.decompose(this.position, this.quaternion, this.scale);\n    }\n    applyQuaternion(q) {\n      this.quaternion.premultiply(q);\n      return this;\n    }\n    setRotationFromAxisAngle(axis, angle) {\n      this.quaternion.setFromAxisAngle(axis, angle);\n    }\n    setRotationFromEuler(euler) {\n      this.quaternion.setFromEuler(euler, true);\n    }\n    setRotationFromMatrix(m) {\n      this.quaternion.setFromRotationMatrix(m);\n    }\n    setRotationFromQuaternion(q) {\n      this.quaternion.copy(q);\n    }\n    rotateOnAxis(axis, angle) {\n      _q1.setFromAxisAngle(axis, angle);\n      this.quaternion.multiply(_q1);\n      return this;\n    }\n    rotateOnWorldAxis(axis, angle) {\n      _q1.setFromAxisAngle(axis, angle);\n      this.quaternion.premultiply(_q1);\n      return this;\n    }\n    rotateX(angle) {\n      return this.rotateOnAxis(_xAxis, angle);\n    }\n    rotateY(angle) {\n      return this.rotateOnAxis(_yAxis, angle);\n    }\n    rotateZ(angle) {\n      return this.rotateOnAxis(_zAxis, angle);\n    }\n    translateOnAxis(axis, distance) {\n      _v1$4.copy(axis).applyQuaternion(this.quaternion);\n      this.position.add(_v1$4.multiplyScalar(distance));\n      return this;\n    }\n    translateX(distance) {\n      return this.translateOnAxis(_xAxis, distance);\n    }\n    translateY(distance) {\n      return this.translateOnAxis(_yAxis, distance);\n    }\n    translateZ(distance) {\n      return this.translateOnAxis(_zAxis, distance);\n    }\n    localToWorld(vector) {\n      this.updateWorldMatrix(true, false);\n      return vector.applyMatrix4(this.matrixWorld);\n    }\n    worldToLocal(vector) {\n      this.updateWorldMatrix(true, false);\n      return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());\n    }\n    lookAt(x2, y, z) {\n      if (x2.isVector3) {\n        _target.copy(x2);\n      } else {\n        _target.set(x2, y, z);\n      }\n      const parent = this.parent;\n      this.updateWorldMatrix(true, false);\n      _position$3.setFromMatrixPosition(this.matrixWorld);\n      if (this.isCamera || this.isLight) {\n        _m1$1.lookAt(_position$3, _target, this.up);\n      } else {\n        _m1$1.lookAt(_target, _position$3, this.up);\n      }\n      this.quaternion.setFromRotationMatrix(_m1$1);\n      if (parent) {\n        _m1$1.extractRotation(parent.matrixWorld);\n        _q1.setFromRotationMatrix(_m1$1);\n        this.quaternion.premultiply(_q1.invert());\n      }\n    }\n    add(object) {\n      if (arguments.length > 1) {\n        for (let i2 = 0; i2 < arguments.length; i2++) {\n          this.add(arguments[i2]);\n        }\n        return this;\n      }\n      if (object === this) {\n        console.error(\"THREE.Object3D.add: object can't be added as a child of itself.\", object);\n        return this;\n      }\n      if (object && object.isObject3D) {\n        object.removeFromParent();\n        object.parent = this;\n        this.children.push(object);\n        object.dispatchEvent(_addedEvent);\n        _childaddedEvent.child = object;\n        this.dispatchEvent(_childaddedEvent);\n        _childaddedEvent.child = null;\n      } else {\n        console.error(\"THREE.Object3D.add: object not an instance of THREE.Object3D.\", object);\n      }\n      return this;\n    }\n    remove(object) {\n      if (arguments.length > 1) {\n        for (let i2 = 0; i2 < arguments.length; i2++) {\n          this.remove(arguments[i2]);\n        }\n        return this;\n      }\n      const index = this.children.indexOf(object);\n      if (index !== -1) {\n        object.parent = null;\n        this.children.splice(index, 1);\n        object.dispatchEvent(_removedEvent);\n        _childremovedEvent.child = object;\n        this.dispatchEvent(_childremovedEvent);\n        _childremovedEvent.child = null;\n      }\n      return this;\n    }\n    removeFromParent() {\n      const parent = this.parent;\n      if (parent !== null) {\n        parent.remove(this);\n      }\n      return this;\n    }\n    clear() {\n      return this.remove(...this.children);\n    }\n    attach(object) {\n      this.updateWorldMatrix(true, false);\n      _m1$1.copy(this.matrixWorld).invert();\n      if (object.parent !== null) {\n        object.parent.updateWorldMatrix(true, false);\n        _m1$1.multiply(object.parent.matrixWorld);\n      }\n      object.applyMatrix4(_m1$1);\n      object.removeFromParent();\n      object.parent = this;\n      this.children.push(object);\n      object.updateWorldMatrix(false, true);\n      object.dispatchEvent(_addedEvent);\n      _childaddedEvent.child = object;\n      this.dispatchEvent(_childaddedEvent);\n      _childaddedEvent.child = null;\n      return this;\n    }\n    getObjectById(id) {\n      return this.getObjectByProperty(\"id\", id);\n    }\n    getObjectByName(name) {\n      return this.getObjectByProperty(\"name\", name);\n    }\n    getObjectByProperty(name, value) {\n      if (this[name] === value) return this;\n      for (let i2 = 0, l = this.children.length; i2 < l; i2++) {\n        const child = this.children[i2];\n        const object = child.getObjectByProperty(name, value);\n        if (object !== void 0) {\n          return object;\n        }\n      }\n      return void 0;\n    }\n    getObjectsByProperty(name, value, result = []) {\n      if (this[name] === value) result.push(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].getObjectsByProperty(name, value, result);\n      }\n      return result;\n    }\n    getWorldPosition(target) {\n      this.updateWorldMatrix(true, false);\n      return target.setFromMatrixPosition(this.matrixWorld);\n    }\n    getWorldQuaternion(target) {\n      this.updateWorldMatrix(true, false);\n      this.matrixWorld.decompose(_position$3, target, _scale$2);\n      return target;\n    }\n    getWorldScale(target) {\n      this.updateWorldMatrix(true, false);\n      this.matrixWorld.decompose(_position$3, _quaternion$2, target);\n      return target;\n    }\n    getWorldDirection(target) {\n      this.updateWorldMatrix(true, false);\n      const e = this.matrixWorld.elements;\n      return target.set(e[8], e[9], e[10]).normalize();\n    }\n    raycast() {\n    }\n    traverse(callback) {\n      callback(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].traverse(callback);\n      }\n    }\n    traverseVisible(callback) {\n      if (this.visible === false) return;\n      callback(this);\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        children[i2].traverseVisible(callback);\n      }\n    }\n    traverseAncestors(callback) {\n      const parent = this.parent;\n      if (parent !== null) {\n        callback(parent);\n        parent.traverseAncestors(callback);\n      }\n    }\n    updateMatrix() {\n      this.matrix.compose(this.position, this.quaternion, this.scale);\n      this.matrixWorldNeedsUpdate = true;\n    }\n    updateMatrixWorld(force) {\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      if (this.matrixWorldNeedsUpdate || force) {\n        if (this.matrixWorldAutoUpdate === true) {\n          if (this.parent === null) {\n            this.matrixWorld.copy(this.matrix);\n          } else {\n            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n          }\n        }\n        this.matrixWorldNeedsUpdate = false;\n        force = true;\n      }\n      const children = this.children;\n      for (let i2 = 0, l = children.length; i2 < l; i2++) {\n        const child = children[i2];\n        child.updateMatrixWorld(force);\n      }\n    }\n    updateWorldMatrix(updateParents, updateChildren) {\n      const parent = this.parent;\n      if (updateParents === true && parent !== null) {\n        parent.updateWorldMatrix(true, false);\n      }\n      if (this.matrixAutoUpdate) this.updateMatrix();\n      if (this.matrixWorldAutoUpdate === true) {\n        if (this.parent === null) {\n          this.matrixWorld.copy(this.matrix);\n        } else {\n          this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);\n        }\n      }\n      if (updateChildren === true) {\n        const children = this.children;\n        for (let i2 = 0, l = children.length; i2 < l; i2++) {\n          const child = children[i2];\n          child.updateWorldMatrix(false, true);\n        }\n      }\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === \"string\";\n      const output = {};\n      if (isRootObject) {\n        meta = {\n          geometries: {},\n          materials: {},\n          textures: {},\n          images: {},\n          shapes: {},\n          skeletons: {},\n          animations: {},\n          nodes: {}\n        };\n        output.metadata = {\n          version: 4.6,\n          type: \"Object\",\n          generator: \"Object3D.toJSON\"\n        };\n      }\n      const object = {};\n      object.uuid = this.uuid;\n      object.type = this.type;\n      if (this.name !== \"\") object.name = this.name;\n      if (this.castShadow === true) object.castShadow = true;\n      if (this.receiveShadow === true) object.receiveShadow = true;\n      if (this.visible === false) object.visible = false;\n      if (this.frustumCulled === false) object.frustumCulled = false;\n      if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;\n      if (Object.keys(this.userData).length > 0) object.userData = this.userData;\n      object.layers = this.layers.mask;\n      object.matrix = this.matrix.toArray();\n      object.up = this.up.toArray();\n      if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;\n      if (this.isInstancedMesh) {\n        object.type = \"InstancedMesh\";\n        object.count = this.count;\n        object.instanceMatrix = this.instanceMatrix.toJSON();\n        if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();\n      }\n      if (this.isBatchedMesh) {\n        object.type = \"BatchedMesh\";\n        object.perObjectFrustumCulled = this.perObjectFrustumCulled;\n        object.sortObjects = this.sortObjects;\n        object.drawRanges = this._drawRanges;\n        object.reservedRanges = this._reservedRanges;\n        object.visibility = this._visibility;\n        object.active = this._active;\n        object.bounds = this._bounds.map((bound) => ({\n          boxInitialized: bound.boxInitialized,\n          boxMin: bound.box.min.toArray(),\n          boxMax: bound.box.max.toArray(),\n          sphereInitialized: bound.sphereInitialized,\n          sphereRadius: bound.sphere.radius,\n          sphereCenter: bound.sphere.center.toArray()\n        }));\n        object.maxInstanceCount = this._maxInstanceCount;\n        object.maxVertexCount = this._maxVertexCount;\n        object.maxIndexCount = this._maxIndexCount;\n        object.geometryInitialized = this._geometryInitialized;\n        object.geometryCount = this._geometryCount;\n        object.matricesTexture = this._matricesTexture.toJSON(meta);\n        if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);\n        if (this.boundingSphere !== null) {\n          object.boundingSphere = {\n            center: object.boundingSphere.center.toArray(),\n            radius: object.boundingSphere.radius\n          };\n        }\n        if (this.boundingBox !== null) {\n          object.boundingBox = {\n            min: object.boundingBox.min.toArray(),\n            max: object.boundingBox.max.toArray()\n          };\n        }\n      }\n      function serialize(library, element) {\n        if (library[element.uuid] === void 0) {\n          library[element.uuid] = element.toJSON(meta);\n        }\n        return element.uuid;\n      }\n      if (this.isScene) {\n        if (this.background) {\n          if (this.background.isColor) {\n            object.background = this.background.toJSON();\n          } else if (this.background.isTexture) {\n            object.background = this.background.toJSON(meta).uuid;\n          }\n        }\n        if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {\n          object.environment = this.environment.toJSON(meta).uuid;\n        }\n      } else if (this.isMesh || this.isLine || this.isPoints) {\n        object.geometry = serialize(meta.geometries, this.geometry);\n        const parameters = this.geometry.parameters;\n        if (parameters !== void 0 && parameters.shapes !== void 0) {\n          const shapes = parameters.shapes;\n          if (Array.isArray(shapes)) {\n            for (let i2 = 0, l = shapes.length; i2 < l; i2++) {\n              const shape = shapes[i2];\n              serialize(meta.shapes, shape);\n            }\n          } else {\n            serialize(meta.shapes, shapes);\n          }\n        }\n      }\n      if (this.isSkinnedMesh) {\n        object.bindMode = this.bindMode;\n        object.bindMatrix = this.bindMatrix.toArray();\n        if (this.skeleton !== void 0) {\n          serialize(meta.skeletons, this.skeleton);\n          object.skeleton = this.skeleton.uuid;\n        }\n      }\n      if (this.material !== void 0) {\n        if (Array.isArray(this.material)) {\n          const uuids = [];\n          for (let i2 = 0, l = this.material.length; i2 < l; i2++) {\n            uuids.push(serialize(meta.materials, this.material[i2]));\n          }\n          object.material = uuids;\n        } else {\n          object.material = serialize(meta.materials, this.material);\n        }\n      }\n      if (this.children.length > 0) {\n        object.children = [];\n        for (let i2 = 0; i2 < this.children.length; i2++) {\n          object.children.push(this.children[i2].toJSON(meta).object);\n        }\n      }\n      if (this.animations.length > 0) {\n        object.animations = [];\n        for (let i2 = 0; i2 < this.animations.length; i2++) {\n          const animation = this.animations[i2];\n          object.animations.push(serialize(meta.animations, animation));\n        }\n      }\n      if (isRootObject) {\n        const geometries = extractFromCache(meta.geometries);\n        const materials = extractFromCache(meta.materials);\n        const textures = extractFromCache(meta.textures);\n        const images = extractFromCache(meta.images);\n        const shapes = extractFromCache(meta.shapes);\n        const skeletons = extractFromCache(meta.skeletons);\n        const animations = extractFromCache(meta.animations);\n        const nodes = extractFromCache(meta.nodes);\n        if (geometries.length > 0) output.geometries = geometries;\n        if (materials.length > 0) output.materials = materials;\n        if (textures.length > 0) output.textures = textures;\n        if (images.length > 0) output.images = images;\n        if (shapes.length > 0) output.shapes = shapes;\n        if (skeletons.length > 0) output.skeletons = skeletons;\n        if (animations.length > 0) output.animations = animations;\n        if (nodes.length > 0) output.nodes = nodes;\n      }\n      output.object = object;\n      return output;\n      function extractFromCache(cache) {\n        const values = [];\n        for (const key in cache) {\n          const data = cache[key];\n          delete data.metadata;\n          values.push(data);\n        }\n        return values;\n      }\n    }\n    clone(recursive) {\n      return new this.constructor().copy(this, recursive);\n    }\n    copy(source, recursive = true) {\n      this.name = source.name;\n      this.up.copy(source.up);\n      this.position.copy(source.position);\n      this.rotation.order = source.rotation.order;\n      this.quaternion.copy(source.quaternion);\n      this.scale.copy(source.scale);\n      this.matrix.copy(source.matrix);\n      this.matrixWorld.copy(source.matrixWorld);\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;\n      this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;\n      this.layers.mask = source.layers.mask;\n      this.visible = source.visible;\n      this.castShadow = source.castShadow;\n      this.receiveShadow = source.receiveShadow;\n      this.frustumCulled = source.frustumCulled;\n      this.renderOrder = source.renderOrder;\n      this.animations = source.animations.slice();\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      if (recursive === true) {\n        for (let i2 = 0; i2 < source.children.length; i2++) {\n          const child = source.children[i2];\n          this.add(child.clone());\n        }\n      }\n      return this;\n    }\n  }\n  Object3D.DEFAULT_UP = /* @__PURE__ */ new Vector3(0, 1, 0);\n  Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;\n  Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;\n  const _v0$1 = /* @__PURE__ */ new Vector3();\n  const _v1$3 = /* @__PURE__ */ new Vector3();\n  const _v2$2 = /* @__PURE__ */ new Vector3();\n  const _v3$2 = /* @__PURE__ */ new Vector3();\n  const _vab = /* @__PURE__ */ new Vector3();\n  const _vac = /* @__PURE__ */ new Vector3();\n  const _vbc = /* @__PURE__ */ new Vector3();\n  const _vap = /* @__PURE__ */ new Vector3();\n  const _vbp = /* @__PURE__ */ new Vector3();\n  const _vcp = /* @__PURE__ */ new Vector3();\n  const _v40 = /* @__PURE__ */ new Vector4();\n  const _v41 = /* @__PURE__ */ new Vector4();\n  const _v42 = /* @__PURE__ */ new Vector4();\n  class Triangle {\n    constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {\n      this.a = a;\n      this.b = b;\n      this.c = c;\n    }\n    static getNormal(a, b, c, target) {\n      target.subVectors(c, b);\n      _v0$1.subVectors(a, b);\n      target.cross(_v0$1);\n      const targetLengthSq = target.lengthSq();\n      if (targetLengthSq > 0) {\n        return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));\n      }\n      return target.set(0, 0, 0);\n    }\n    // static/instance method to calculate barycentric coordinates\n    // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n    static getBarycoord(point, a, b, c, target) {\n      _v0$1.subVectors(c, a);\n      _v1$3.subVectors(b, a);\n      _v2$2.subVectors(point, a);\n      const dot00 = _v0$1.dot(_v0$1);\n      const dot01 = _v0$1.dot(_v1$3);\n      const dot02 = _v0$1.dot(_v2$2);\n      const dot11 = _v1$3.dot(_v1$3);\n      const dot12 = _v1$3.dot(_v2$2);\n      const denom = dot00 * dot11 - dot01 * dot01;\n      if (denom === 0) {\n        target.set(0, 0, 0);\n        return null;\n      }\n      const invDenom = 1 / denom;\n      const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n      const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n      return target.set(1 - u - v, v, u);\n    }\n    static containsPoint(point, a, b, c) {\n      if (this.getBarycoord(point, a, b, c, _v3$2) === null) {\n        return false;\n      }\n      return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;\n    }\n    static getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {\n      if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {\n        target.x = 0;\n        target.y = 0;\n        if (\"z\" in target) target.z = 0;\n        if (\"w\" in target) target.w = 0;\n        return null;\n      }\n      target.setScalar(0);\n      target.addScaledVector(v1, _v3$2.x);\n      target.addScaledVector(v2, _v3$2.y);\n      target.addScaledVector(v3, _v3$2.z);\n      return target;\n    }\n    static getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {\n      _v40.setScalar(0);\n      _v41.setScalar(0);\n      _v42.setScalar(0);\n      _v40.fromBufferAttribute(attr, i1);\n      _v41.fromBufferAttribute(attr, i2);\n      _v42.fromBufferAttribute(attr, i3);\n      target.setScalar(0);\n      target.addScaledVector(_v40, barycoord.x);\n      target.addScaledVector(_v41, barycoord.y);\n      target.addScaledVector(_v42, barycoord.z);\n      return target;\n    }\n    static isFrontFacing(a, b, c, direction) {\n      _v0$1.subVectors(c, b);\n      _v1$3.subVectors(a, b);\n      return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;\n    }\n    set(a, b, c) {\n      this.a.copy(a);\n      this.b.copy(b);\n      this.c.copy(c);\n      return this;\n    }\n    setFromPointsAndIndices(points, i0, i1, i2) {\n      this.a.copy(points[i0]);\n      this.b.copy(points[i1]);\n      this.c.copy(points[i2]);\n      return this;\n    }\n    setFromAttributeAndIndices(attribute, i0, i1, i2) {\n      this.a.fromBufferAttribute(attribute, i0);\n      this.b.fromBufferAttribute(attribute, i1);\n      this.c.fromBufferAttribute(attribute, i2);\n      return this;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(triangle) {\n      this.a.copy(triangle.a);\n      this.b.copy(triangle.b);\n      this.c.copy(triangle.c);\n      return this;\n    }\n    getArea() {\n      _v0$1.subVectors(this.c, this.b);\n      _v1$3.subVectors(this.a, this.b);\n      return _v0$1.cross(_v1$3).length() * 0.5;\n    }\n    getMidpoint(target) {\n      return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);\n    }\n    getNormal(target) {\n      return Triangle.getNormal(this.a, this.b, this.c, target);\n    }\n    getPlane(target) {\n      return target.setFromCoplanarPoints(this.a, this.b, this.c);\n    }\n    getBarycoord(point, target) {\n      return Triangle.getBarycoord(point, this.a, this.b, this.c, target);\n    }\n    getInterpolation(point, v1, v2, v3, target) {\n      return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);\n    }\n    containsPoint(point) {\n      return Triangle.containsPoint(point, this.a, this.b, this.c);\n    }\n    isFrontFacing(direction) {\n      return Triangle.isFrontFacing(this.a, this.b, this.c, direction);\n    }\n    intersectsBox(box) {\n      return box.intersectsTriangle(this);\n    }\n    closestPointToPoint(p, target) {\n      const a = this.a, b = this.b, c = this.c;\n      let v, w;\n      _vab.subVectors(b, a);\n      _vac.subVectors(c, a);\n      _vap.subVectors(p, a);\n      const d1 = _vab.dot(_vap);\n      const d2 = _vac.dot(_vap);\n      if (d1 <= 0 && d2 <= 0) {\n        return target.copy(a);\n      }\n      _vbp.subVectors(p, b);\n      const d3 = _vab.dot(_vbp);\n      const d4 = _vac.dot(_vbp);\n      if (d3 >= 0 && d4 <= d3) {\n        return target.copy(b);\n      }\n      const vc = d1 * d4 - d3 * d2;\n      if (vc <= 0 && d1 >= 0 && d3 <= 0) {\n        v = d1 / (d1 - d3);\n        return target.copy(a).addScaledVector(_vab, v);\n      }\n      _vcp.subVectors(p, c);\n      const d5 = _vab.dot(_vcp);\n      const d6 = _vac.dot(_vcp);\n      if (d6 >= 0 && d5 <= d6) {\n        return target.copy(c);\n      }\n      const vb = d5 * d2 - d1 * d6;\n      if (vb <= 0 && d2 >= 0 && d6 <= 0) {\n        w = d2 / (d2 - d6);\n        return target.copy(a).addScaledVector(_vac, w);\n      }\n      const va = d3 * d6 - d5 * d4;\n      if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {\n        _vbc.subVectors(c, b);\n        w = (d4 - d3) / (d4 - d3 + (d5 - d6));\n        return target.copy(b).addScaledVector(_vbc, w);\n      }\n      const denom = 1 / (va + vb + vc);\n      v = vb * denom;\n      w = vc * denom;\n      return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);\n    }\n    equals(triangle) {\n      return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);\n    }\n  }\n  const _colorKeywords = {\n    \"aliceblue\": 15792383,\n    \"antiquewhite\": 16444375,\n    \"aqua\": 65535,\n    \"aquamarine\": 8388564,\n    \"azure\": 15794175,\n    \"beige\": 16119260,\n    \"bisque\": 16770244,\n    \"black\": 0,\n    \"blanchedalmond\": 16772045,\n    \"blue\": 255,\n    \"blueviolet\": 9055202,\n    \"brown\": 10824234,\n    \"burlywood\": 14596231,\n    \"cadetblue\": 6266528,\n    \"chartreuse\": 8388352,\n    \"chocolate\": 13789470,\n    \"coral\": 16744272,\n    \"cornflowerblue\": 6591981,\n    \"cornsilk\": 16775388,\n    \"crimson\": 14423100,\n    \"cyan\": 65535,\n    \"darkblue\": 139,\n    \"darkcyan\": 35723,\n    \"darkgoldenrod\": 12092939,\n    \"darkgray\": 11119017,\n    \"darkgreen\": 25600,\n    \"darkgrey\": 11119017,\n    \"darkkhaki\": 12433259,\n    \"darkmagenta\": 9109643,\n    \"darkolivegreen\": 5597999,\n    \"darkorange\": 16747520,\n    \"darkorchid\": 10040012,\n    \"darkred\": 9109504,\n    \"darksalmon\": 15308410,\n    \"darkseagreen\": 9419919,\n    \"darkslateblue\": 4734347,\n    \"darkslategray\": 3100495,\n    \"darkslategrey\": 3100495,\n    \"darkturquoise\": 52945,\n    \"darkviolet\": 9699539,\n    \"deeppink\": 16716947,\n    \"deepskyblue\": 49151,\n    \"dimgray\": 6908265,\n    \"dimgrey\": 6908265,\n    \"dodgerblue\": 2003199,\n    \"firebrick\": 11674146,\n    \"floralwhite\": 16775920,\n    \"forestgreen\": 2263842,\n    \"fuchsia\": 16711935,\n    \"gainsboro\": 14474460,\n    \"ghostwhite\": 16316671,\n    \"gold\": 16766720,\n    \"goldenrod\": 14329120,\n    \"gray\": 8421504,\n    \"green\": 32768,\n    \"greenyellow\": 11403055,\n    \"grey\": 8421504,\n    \"honeydew\": 15794160,\n    \"hotpink\": 16738740,\n    \"indianred\": 13458524,\n    \"indigo\": 4915330,\n    \"ivory\": 16777200,\n    \"khaki\": 15787660,\n    \"lavender\": 15132410,\n    \"lavenderblush\": 16773365,\n    \"lawngreen\": 8190976,\n    \"lemonchiffon\": 16775885,\n    \"lightblue\": 11393254,\n    \"lightcoral\": 15761536,\n    \"lightcyan\": 14745599,\n    \"lightgoldenrodyellow\": 16448210,\n    \"lightgray\": 13882323,\n    \"lightgreen\": 9498256,\n    \"lightgrey\": 13882323,\n    \"lightpink\": 16758465,\n    \"lightsalmon\": 16752762,\n    \"lightseagreen\": 2142890,\n    \"lightskyblue\": 8900346,\n    \"lightslategray\": 7833753,\n    \"lightslategrey\": 7833753,\n    \"lightsteelblue\": 11584734,\n    \"lightyellow\": 16777184,\n    \"lime\": 65280,\n    \"limegreen\": 3329330,\n    \"linen\": 16445670,\n    \"magenta\": 16711935,\n    \"maroon\": 8388608,\n    \"mediumaquamarine\": 6737322,\n    \"mediumblue\": 205,\n    \"mediumorchid\": 12211667,\n    \"mediumpurple\": 9662683,\n    \"mediumseagreen\": 3978097,\n    \"mediumslateblue\": 8087790,\n    \"mediumspringgreen\": 64154,\n    \"mediumturquoise\": 4772300,\n    \"mediumvioletred\": 13047173,\n    \"midnightblue\": 1644912,\n    \"mintcream\": 16121850,\n    \"mistyrose\": 16770273,\n    \"moccasin\": 16770229,\n    \"navajowhite\": 16768685,\n    \"navy\": 128,\n    \"oldlace\": 16643558,\n    \"olive\": 8421376,\n    \"olivedrab\": 7048739,\n    \"orange\": 16753920,\n    \"orangered\": 16729344,\n    \"orchid\": 14315734,\n    \"palegoldenrod\": 15657130,\n    \"palegreen\": 10025880,\n    \"paleturquoise\": 11529966,\n    \"palevioletred\": 14381203,\n    \"papayawhip\": 16773077,\n    \"peachpuff\": 16767673,\n    \"peru\": 13468991,\n    \"pink\": 16761035,\n    \"plum\": 14524637,\n    \"powderblue\": 11591910,\n    \"purple\": 8388736,\n    \"rebeccapurple\": 6697881,\n    \"red\": 16711680,\n    \"rosybrown\": 12357519,\n    \"royalblue\": 4286945,\n    \"saddlebrown\": 9127187,\n    \"salmon\": 16416882,\n    \"sandybrown\": 16032864,\n    \"seagreen\": 3050327,\n    \"seashell\": 16774638,\n    \"sienna\": 10506797,\n    \"silver\": 12632256,\n    \"skyblue\": 8900331,\n    \"slateblue\": 6970061,\n    \"slategray\": 7372944,\n    \"slategrey\": 7372944,\n    \"snow\": 16775930,\n    \"springgreen\": 65407,\n    \"steelblue\": 4620980,\n    \"tan\": 13808780,\n    \"teal\": 32896,\n    \"thistle\": 14204888,\n    \"tomato\": 16737095,\n    \"turquoise\": 4251856,\n    \"violet\": 15631086,\n    \"wheat\": 16113331,\n    \"white\": 16777215,\n    \"whitesmoke\": 16119285,\n    \"yellow\": 16776960,\n    \"yellowgreen\": 10145074\n  };\n  const _hslA = { h: 0, s: 0, l: 0 };\n  const _hslB = { h: 0, s: 0, l: 0 };\n  function hue2rgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);\n    return p;\n  }\n  class Color {\n    constructor(r, g, b) {\n      this.isColor = true;\n      this.r = 1;\n      this.g = 1;\n      this.b = 1;\n      return this.set(r, g, b);\n    }\n    set(r, g, b) {\n      if (g === void 0 && b === void 0) {\n        const value = r;\n        if (value && value.isColor) {\n          this.copy(value);\n        } else if (typeof value === \"number\") {\n          this.setHex(value);\n        } else if (typeof value === \"string\") {\n          this.setStyle(value);\n        }\n      } else {\n        this.setRGB(r, g, b);\n      }\n      return this;\n    }\n    setScalar(scalar) {\n      this.r = scalar;\n      this.g = scalar;\n      this.b = scalar;\n      return this;\n    }\n    setHex(hex, colorSpace = SRGBColorSpace) {\n      hex = Math.floor(hex);\n      this.r = (hex >> 16 & 255) / 255;\n      this.g = (hex >> 8 & 255) / 255;\n      this.b = (hex & 255) / 255;\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n    setRGB(r, g, b, colorSpace = ColorManagement.workingColorSpace) {\n      this.r = r;\n      this.g = g;\n      this.b = b;\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n    setHSL(h, s, l, colorSpace = ColorManagement.workingColorSpace) {\n      h = euclideanModulo(h, 1);\n      s = clamp(s, 0, 1);\n      l = clamp(l, 0, 1);\n      if (s === 0) {\n        this.r = this.g = this.b = l;\n      } else {\n        const p = l <= 0.5 ? l * (1 + s) : l + s - l * s;\n        const q = 2 * l - p;\n        this.r = hue2rgb(q, p, h + 1 / 3);\n        this.g = hue2rgb(q, p, h);\n        this.b = hue2rgb(q, p, h - 1 / 3);\n      }\n      ColorManagement.toWorkingColorSpace(this, colorSpace);\n      return this;\n    }\n    setStyle(style, colorSpace = SRGBColorSpace) {\n      function handleAlpha(string) {\n        if (string === void 0) return;\n        if (parseFloat(string) < 1) {\n          console.warn(\"THREE.Color: Alpha component of \" + style + \" will be ignored.\");\n        }\n      }\n      let m;\n      if (m = /^(\\\\w+)\\\\(([^\\\\)]*)\\\\)/.exec(style)) {\n        let color;\n        const name = m[1];\n        const components = m[2];\n        switch (name) {\n          case \"rgb\":\n          case \"rgba\":\n            if (color = /^\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*,\\\\s*(\\\\d+)\\\\s*(?:,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setRGB(\n                Math.min(255, parseInt(color[1], 10)) / 255,\n                Math.min(255, parseInt(color[2], 10)) / 255,\n                Math.min(255, parseInt(color[3], 10)) / 255,\n                colorSpace\n              );\n            }\n            if (color = /^\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d+)\\\\%\\\\s*(?:,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setRGB(\n                Math.min(100, parseInt(color[1], 10)) / 100,\n                Math.min(100, parseInt(color[2], 10)) / 100,\n                Math.min(100, parseInt(color[3], 10)) / 100,\n                colorSpace\n              );\n            }\n            break;\n          case \"hsl\":\n          case \"hsla\":\n            if (color = /^\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\%\\\\s*,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\%\\\\s*(?:,\\\\s*(\\\\d*\\\\.?\\\\d+)\\\\s*)?$/.exec(components)) {\n              handleAlpha(color[4]);\n              return this.setHSL(\n                parseFloat(color[1]) / 360,\n                parseFloat(color[2]) / 100,\n                parseFloat(color[3]) / 100,\n                colorSpace\n              );\n            }\n            break;\n          default:\n            console.warn(\"THREE.Color: Unknown color model \" + style);\n        }\n      } else if (m = /^\\\\#([A-Fa-f\\\\d]+)$/.exec(style)) {\n        const hex = m[1];\n        const size = hex.length;\n        if (size === 3) {\n          return this.setRGB(\n            parseInt(hex.charAt(0), 16) / 15,\n            parseInt(hex.charAt(1), 16) / 15,\n            parseInt(hex.charAt(2), 16) / 15,\n            colorSpace\n          );\n        } else if (size === 6) {\n          return this.setHex(parseInt(hex, 16), colorSpace);\n        } else {\n          console.warn(\"THREE.Color: Invalid hex color \" + style);\n        }\n      } else if (style && style.length > 0) {\n        return this.setColorName(style, colorSpace);\n      }\n      return this;\n    }\n    setColorName(style, colorSpace = SRGBColorSpace) {\n      const hex = _colorKeywords[style.toLowerCase()];\n      if (hex !== void 0) {\n        this.setHex(hex, colorSpace);\n      } else {\n        console.warn(\"THREE.Color: Unknown color \" + style);\n      }\n      return this;\n    }\n    clone() {\n      return new this.constructor(this.r, this.g, this.b);\n    }\n    copy(color) {\n      this.r = color.r;\n      this.g = color.g;\n      this.b = color.b;\n      return this;\n    }\n    copySRGBToLinear(color) {\n      this.r = SRGBToLinear(color.r);\n      this.g = SRGBToLinear(color.g);\n      this.b = SRGBToLinear(color.b);\n      return this;\n    }\n    copyLinearToSRGB(color) {\n      this.r = LinearToSRGB(color.r);\n      this.g = LinearToSRGB(color.g);\n      this.b = LinearToSRGB(color.b);\n      return this;\n    }\n    convertSRGBToLinear() {\n      this.copySRGBToLinear(this);\n      return this;\n    }\n    convertLinearToSRGB() {\n      this.copyLinearToSRGB(this);\n      return this;\n    }\n    getHex(colorSpace = SRGBColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      return Math.round(clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(clamp(_color.g * 255, 0, 255)) * 256 + Math.round(clamp(_color.b * 255, 0, 255));\n    }\n    getHexString(colorSpace = SRGBColorSpace) {\n      return (\"000000\" + this.getHex(colorSpace).toString(16)).slice(-6);\n    }\n    getHSL(target, colorSpace = ColorManagement.workingColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      const r = _color.r, g = _color.g, b = _color.b;\n      const max2 = Math.max(r, g, b);\n      const min = Math.min(r, g, b);\n      let hue, saturation;\n      const lightness = (min + max2) / 2;\n      if (min === max2) {\n        hue = 0;\n        saturation = 0;\n      } else {\n        const delta = max2 - min;\n        saturation = lightness <= 0.5 ? delta / (max2 + min) : delta / (2 - max2 - min);\n        switch (max2) {\n          case r:\n            hue = (g - b) / delta + (g < b ? 6 : 0);\n            break;\n          case g:\n            hue = (b - r) / delta + 2;\n            break;\n          case b:\n            hue = (r - g) / delta + 4;\n            break;\n        }\n        hue /= 6;\n      }\n      target.h = hue;\n      target.s = saturation;\n      target.l = lightness;\n      return target;\n    }\n    getRGB(target, colorSpace = ColorManagement.workingColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      target.r = _color.r;\n      target.g = _color.g;\n      target.b = _color.b;\n      return target;\n    }\n    getStyle(colorSpace = SRGBColorSpace) {\n      ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);\n      const r = _color.r, g = _color.g, b = _color.b;\n      if (colorSpace !== SRGBColorSpace) {\n        return \\`color(\\${colorSpace} \\${r.toFixed(3)} \\${g.toFixed(3)} \\${b.toFixed(3)})\\`;\n      }\n      return \\`rgb(\\${Math.round(r * 255)},\\${Math.round(g * 255)},\\${Math.round(b * 255)})\\`;\n    }\n    offsetHSL(h, s, l) {\n      this.getHSL(_hslA);\n      return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);\n    }\n    add(color) {\n      this.r += color.r;\n      this.g += color.g;\n      this.b += color.b;\n      return this;\n    }\n    addColors(color1, color2) {\n      this.r = color1.r + color2.r;\n      this.g = color1.g + color2.g;\n      this.b = color1.b + color2.b;\n      return this;\n    }\n    addScalar(s) {\n      this.r += s;\n      this.g += s;\n      this.b += s;\n      return this;\n    }\n    sub(color) {\n      this.r = Math.max(0, this.r - color.r);\n      this.g = Math.max(0, this.g - color.g);\n      this.b = Math.max(0, this.b - color.b);\n      return this;\n    }\n    multiply(color) {\n      this.r *= color.r;\n      this.g *= color.g;\n      this.b *= color.b;\n      return this;\n    }\n    multiplyScalar(s) {\n      this.r *= s;\n      this.g *= s;\n      this.b *= s;\n      return this;\n    }\n    lerp(color, alpha) {\n      this.r += (color.r - this.r) * alpha;\n      this.g += (color.g - this.g) * alpha;\n      this.b += (color.b - this.b) * alpha;\n      return this;\n    }\n    lerpColors(color1, color2, alpha) {\n      this.r = color1.r + (color2.r - color1.r) * alpha;\n      this.g = color1.g + (color2.g - color1.g) * alpha;\n      this.b = color1.b + (color2.b - color1.b) * alpha;\n      return this;\n    }\n    lerpHSL(color, alpha) {\n      this.getHSL(_hslA);\n      color.getHSL(_hslB);\n      const h = lerp(_hslA.h, _hslB.h, alpha);\n      const s = lerp(_hslA.s, _hslB.s, alpha);\n      const l = lerp(_hslA.l, _hslB.l, alpha);\n      this.setHSL(h, s, l);\n      return this;\n    }\n    setFromVector3(v) {\n      this.r = v.x;\n      this.g = v.y;\n      this.b = v.z;\n      return this;\n    }\n    applyMatrix3(m) {\n      const r = this.r, g = this.g, b = this.b;\n      const e = m.elements;\n      this.r = e[0] * r + e[3] * g + e[6] * b;\n      this.g = e[1] * r + e[4] * g + e[7] * b;\n      this.b = e[2] * r + e[5] * g + e[8] * b;\n      return this;\n    }\n    equals(c) {\n      return c.r === this.r && c.g === this.g && c.b === this.b;\n    }\n    fromArray(array, offset = 0) {\n      this.r = array[offset];\n      this.g = array[offset + 1];\n      this.b = array[offset + 2];\n      return this;\n    }\n    toArray(array = [], offset = 0) {\n      array[offset] = this.r;\n      array[offset + 1] = this.g;\n      array[offset + 2] = this.b;\n      return array;\n    }\n    fromBufferAttribute(attribute, index) {\n      this.r = attribute.getX(index);\n      this.g = attribute.getY(index);\n      this.b = attribute.getZ(index);\n      return this;\n    }\n    toJSON() {\n      return this.getHex();\n    }\n    *[Symbol.iterator]() {\n      yield this.r;\n      yield this.g;\n      yield this.b;\n    }\n  }\n  const _color = /* @__PURE__ */ new Color();\n  Color.NAMES = _colorKeywords;\n  let _materialId = 0;\n  class Material extends EventDispatcher {\n    constructor() {\n      super();\n      this.isMaterial = true;\n      Object.defineProperty(this, \"id\", { value: _materialId++ });\n      this.uuid = generateUUID();\n      this.name = \"\";\n      this.type = \"Material\";\n      this.blending = NormalBlending;\n      this.side = FrontSide;\n      this.vertexColors = false;\n      this.opacity = 1;\n      this.transparent = false;\n      this.alphaHash = false;\n      this.blendSrc = SrcAlphaFactor;\n      this.blendDst = OneMinusSrcAlphaFactor;\n      this.blendEquation = AddEquation;\n      this.blendSrcAlpha = null;\n      this.blendDstAlpha = null;\n      this.blendEquationAlpha = null;\n      this.blendColor = new Color(0, 0, 0);\n      this.blendAlpha = 0;\n      this.depthFunc = LessEqualDepth;\n      this.depthTest = true;\n      this.depthWrite = true;\n      this.stencilWriteMask = 255;\n      this.stencilFunc = AlwaysStencilFunc;\n      this.stencilRef = 0;\n      this.stencilFuncMask = 255;\n      this.stencilFail = KeepStencilOp;\n      this.stencilZFail = KeepStencilOp;\n      this.stencilZPass = KeepStencilOp;\n      this.stencilWrite = false;\n      this.clippingPlanes = null;\n      this.clipIntersection = false;\n      this.clipShadows = false;\n      this.shadowSide = null;\n      this.colorWrite = true;\n      this.precision = null;\n      this.polygonOffset = false;\n      this.polygonOffsetFactor = 0;\n      this.polygonOffsetUnits = 0;\n      this.dithering = false;\n      this.alphaToCoverage = false;\n      this.premultipliedAlpha = false;\n      this.forceSinglePass = false;\n      this.visible = true;\n      this.toneMapped = true;\n      this.userData = {};\n      this.version = 0;\n      this._alphaTest = 0;\n    }\n    get alphaTest() {\n      return this._alphaTest;\n    }\n    set alphaTest(value) {\n      if (this._alphaTest > 0 !== value > 0) {\n        this.version++;\n      }\n      this._alphaTest = value;\n    }\n    // onBeforeRender and onBeforeCompile only supported in WebGLRenderer\n    onBeforeRender() {\n    }\n    onBeforeCompile() {\n    }\n    customProgramCacheKey() {\n      return this.onBeforeCompile.toString();\n    }\n    setValues(values) {\n      if (values === void 0) return;\n      for (const key in values) {\n        const newValue = values[key];\n        if (newValue === void 0) {\n          console.warn(\\`THREE.Material: parameter '\\${key}' has value of undefined.\\`);\n          continue;\n        }\n        const currentValue = this[key];\n        if (currentValue === void 0) {\n          console.warn(\\`THREE.Material: '\\${key}' is not a property of THREE.\\${this.type}.\\`);\n          continue;\n        }\n        if (currentValue && currentValue.isColor) {\n          currentValue.set(newValue);\n        } else if (currentValue && currentValue.isVector3 && (newValue && newValue.isVector3)) {\n          currentValue.copy(newValue);\n        } else {\n          this[key] = newValue;\n        }\n      }\n    }\n    toJSON(meta) {\n      const isRootObject = meta === void 0 || typeof meta === \"string\";\n      if (isRootObject) {\n        meta = {\n          textures: {},\n          images: {}\n        };\n      }\n      const data = {\n        metadata: {\n          version: 4.6,\n          type: \"Material\",\n          generator: \"Material.toJSON\"\n        }\n      };\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== \"\") data.name = this.name;\n      if (this.color && this.color.isColor) data.color = this.color.getHex();\n      if (this.roughness !== void 0) data.roughness = this.roughness;\n      if (this.metalness !== void 0) data.metalness = this.metalness;\n      if (this.sheen !== void 0) data.sheen = this.sheen;\n      if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();\n      if (this.sheenRoughness !== void 0) data.sheenRoughness = this.sheenRoughness;\n      if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();\n      if (this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;\n      if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();\n      if (this.specularIntensity !== void 0) data.specularIntensity = this.specularIntensity;\n      if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();\n      if (this.shininess !== void 0) data.shininess = this.shininess;\n      if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat;\n      if (this.clearcoatRoughness !== void 0) data.clearcoatRoughness = this.clearcoatRoughness;\n      if (this.clearcoatMap && this.clearcoatMap.isTexture) {\n        data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;\n      }\n      if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {\n        data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;\n      }\n      if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {\n        data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;\n        data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();\n      }\n      if (this.dispersion !== void 0) data.dispersion = this.dispersion;\n      if (this.iridescence !== void 0) data.iridescence = this.iridescence;\n      if (this.iridescenceIOR !== void 0) data.iridescenceIOR = this.iridescenceIOR;\n      if (this.iridescenceThicknessRange !== void 0) data.iridescenceThicknessRange = this.iridescenceThicknessRange;\n      if (this.iridescenceMap && this.iridescenceMap.isTexture) {\n        data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;\n      }\n      if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {\n        data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;\n      }\n      if (this.anisotropy !== void 0) data.anisotropy = this.anisotropy;\n      if (this.anisotropyRotation !== void 0) data.anisotropyRotation = this.anisotropyRotation;\n      if (this.anisotropyMap && this.anisotropyMap.isTexture) {\n        data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;\n      }\n      if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;\n      if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;\n      if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;\n      if (this.lightMap && this.lightMap.isTexture) {\n        data.lightMap = this.lightMap.toJSON(meta).uuid;\n        data.lightMapIntensity = this.lightMapIntensity;\n      }\n      if (this.aoMap && this.aoMap.isTexture) {\n        data.aoMap = this.aoMap.toJSON(meta).uuid;\n        data.aoMapIntensity = this.aoMapIntensity;\n      }\n      if (this.bumpMap && this.bumpMap.isTexture) {\n        data.bumpMap = this.bumpMap.toJSON(meta).uuid;\n        data.bumpScale = this.bumpScale;\n      }\n      if (this.normalMap && this.normalMap.isTexture) {\n        data.normalMap = this.normalMap.toJSON(meta).uuid;\n        data.normalMapType = this.normalMapType;\n        data.normalScale = this.normalScale.toArray();\n      }\n      if (this.displacementMap && this.displacementMap.isTexture) {\n        data.displacementMap = this.displacementMap.toJSON(meta).uuid;\n        data.displacementScale = this.displacementScale;\n        data.displacementBias = this.displacementBias;\n      }\n      if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;\n      if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;\n      if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;\n      if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;\n      if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;\n      if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;\n      if (this.envMap && this.envMap.isTexture) {\n        data.envMap = this.envMap.toJSON(meta).uuid;\n        if (this.combine !== void 0) data.combine = this.combine;\n      }\n      if (this.envMapRotation !== void 0) data.envMapRotation = this.envMapRotation.toArray();\n      if (this.envMapIntensity !== void 0) data.envMapIntensity = this.envMapIntensity;\n      if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity;\n      if (this.refractionRatio !== void 0) data.refractionRatio = this.refractionRatio;\n      if (this.gradientMap && this.gradientMap.isTexture) {\n        data.gradientMap = this.gradientMap.toJSON(meta).uuid;\n      }\n      if (this.transmission !== void 0) data.transmission = this.transmission;\n      if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;\n      if (this.thickness !== void 0) data.thickness = this.thickness;\n      if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;\n      if (this.attenuationDistance !== void 0 && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;\n      if (this.attenuationColor !== void 0) data.attenuationColor = this.attenuationColor.getHex();\n      if (this.size !== void 0) data.size = this.size;\n      if (this.shadowSide !== null) data.shadowSide = this.shadowSide;\n      if (this.sizeAttenuation !== void 0) data.sizeAttenuation = this.sizeAttenuation;\n      if (this.blending !== NormalBlending) data.blending = this.blending;\n      if (this.side !== FrontSide) data.side = this.side;\n      if (this.vertexColors === true) data.vertexColors = true;\n      if (this.opacity < 1) data.opacity = this.opacity;\n      if (this.transparent === true) data.transparent = true;\n      if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;\n      if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;\n      if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;\n      if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;\n      if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;\n      if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;\n      if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();\n      if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;\n      if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;\n      if (this.depthTest === false) data.depthTest = this.depthTest;\n      if (this.depthWrite === false) data.depthWrite = this.depthWrite;\n      if (this.colorWrite === false) data.colorWrite = this.colorWrite;\n      if (this.stencilWriteMask !== 255) data.stencilWriteMask = this.stencilWriteMask;\n      if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;\n      if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;\n      if (this.stencilFuncMask !== 255) data.stencilFuncMask = this.stencilFuncMask;\n      if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;\n      if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;\n      if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;\n      if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;\n      if (this.rotation !== void 0 && this.rotation !== 0) data.rotation = this.rotation;\n      if (this.polygonOffset === true) data.polygonOffset = true;\n      if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;\n      if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;\n      if (this.linewidth !== void 0 && this.linewidth !== 1) data.linewidth = this.linewidth;\n      if (this.dashSize !== void 0) data.dashSize = this.dashSize;\n      if (this.gapSize !== void 0) data.gapSize = this.gapSize;\n      if (this.scale !== void 0) data.scale = this.scale;\n      if (this.dithering === true) data.dithering = true;\n      if (this.alphaTest > 0) data.alphaTest = this.alphaTest;\n      if (this.alphaHash === true) data.alphaHash = true;\n      if (this.alphaToCoverage === true) data.alphaToCoverage = true;\n      if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;\n      if (this.forceSinglePass === true) data.forceSinglePass = true;\n      if (this.wireframe === true) data.wireframe = true;\n      if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;\n      if (this.wireframeLinecap !== \"round\") data.wireframeLinecap = this.wireframeLinecap;\n      if (this.wireframeLinejoin !== \"round\") data.wireframeLinejoin = this.wireframeLinejoin;\n      if (this.flatShading === true) data.flatShading = true;\n      if (this.visible === false) data.visible = false;\n      if (this.toneMapped === false) data.toneMapped = false;\n      if (this.fog === false) data.fog = false;\n      if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n      function extractFromCache(cache) {\n        const values = [];\n        for (const key in cache) {\n          const data2 = cache[key];\n          delete data2.metadata;\n          values.push(data2);\n        }\n        return values;\n      }\n      if (isRootObject) {\n        const textures = extractFromCache(meta.textures);\n        const images = extractFromCache(meta.images);\n        if (textures.length > 0) data.textures = textures;\n        if (images.length > 0) data.images = images;\n      }\n      return data;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.name = source.name;\n      this.blending = source.blending;\n      this.side = source.side;\n      this.vertexColors = source.vertexColors;\n      this.opacity = source.opacity;\n      this.transparent = source.transparent;\n      this.blendSrc = source.blendSrc;\n      this.blendDst = source.blendDst;\n      this.blendEquation = source.blendEquation;\n      this.blendSrcAlpha = source.blendSrcAlpha;\n      this.blendDstAlpha = source.blendDstAlpha;\n      this.blendEquationAlpha = source.blendEquationAlpha;\n      this.blendColor.copy(source.blendColor);\n      this.blendAlpha = source.blendAlpha;\n      this.depthFunc = source.depthFunc;\n      this.depthTest = source.depthTest;\n      this.depthWrite = source.depthWrite;\n      this.stencilWriteMask = source.stencilWriteMask;\n      this.stencilFunc = source.stencilFunc;\n      this.stencilRef = source.stencilRef;\n      this.stencilFuncMask = source.stencilFuncMask;\n      this.stencilFail = source.stencilFail;\n      this.stencilZFail = source.stencilZFail;\n      this.stencilZPass = source.stencilZPass;\n      this.stencilWrite = source.stencilWrite;\n      const srcPlanes = source.clippingPlanes;\n      let dstPlanes = null;\n      if (srcPlanes !== null) {\n        const n = srcPlanes.length;\n        dstPlanes = new Array(n);\n        for (let i2 = 0; i2 !== n; ++i2) {\n          dstPlanes[i2] = srcPlanes[i2].clone();\n        }\n      }\n      this.clippingPlanes = dstPlanes;\n      this.clipIntersection = source.clipIntersection;\n      this.clipShadows = source.clipShadows;\n      this.shadowSide = source.shadowSide;\n      this.colorWrite = source.colorWrite;\n      this.precision = source.precision;\n      this.polygonOffset = source.polygonOffset;\n      this.polygonOffsetFactor = source.polygonOffsetFactor;\n      this.polygonOffsetUnits = source.polygonOffsetUnits;\n      this.dithering = source.dithering;\n      this.alphaTest = source.alphaTest;\n      this.alphaHash = source.alphaHash;\n      this.alphaToCoverage = source.alphaToCoverage;\n      this.premultipliedAlpha = source.premultipliedAlpha;\n      this.forceSinglePass = source.forceSinglePass;\n      this.visible = source.visible;\n      this.toneMapped = source.toneMapped;\n      this.userData = JSON.parse(JSON.stringify(source.userData));\n      return this;\n    }\n    dispose() {\n      this.dispatchEvent({ type: \"dispose\" });\n    }\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    onBuild() {\n      console.warn(\"Material: onBuild() has been removed.\");\n    }\n  }\n  class MeshBasicMaterial extends Material {\n    constructor(parameters) {\n      super();\n      this.isMeshBasicMaterial = true;\n      this.type = \"MeshBasicMaterial\";\n      this.color = new Color(16777215);\n      this.map = null;\n      this.lightMap = null;\n      this.lightMapIntensity = 1;\n      this.aoMap = null;\n      this.aoMapIntensity = 1;\n      this.specularMap = null;\n      this.alphaMap = null;\n      this.envMap = null;\n      this.envMapRotation = new Euler();\n      this.combine = MultiplyOperation;\n      this.reflectivity = 1;\n      this.refractionRatio = 0.98;\n      this.wireframe = false;\n      this.wireframeLinewidth = 1;\n      this.wireframeLinecap = \"round\";\n      this.wireframeLinejoin = \"round\";\n      this.fog = true;\n      this.setValues(parameters);\n    }\n    copy(source) {\n      super.copy(source);\n      this.color.copy(source.color);\n      this.map = source.map;\n      this.lightMap = source.lightMap;\n      this.lightMapIntensity = source.lightMapIntensity;\n      this.aoMap = source.aoMap;\n      this.aoMapIntensity = source.aoMapIntensity;\n      this.specularMap = source.specularMap;\n      this.alphaMap = source.alphaMap;\n      this.envMap = source.envMap;\n      this.envMapRotation.copy(source.envMapRotation);\n      this.combine = source.combine;\n      this.reflectivity = source.reflectivity;\n      this.refractionRatio = source.refractionRatio;\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.wireframeLinecap = source.wireframeLinecap;\n      this.wireframeLinejoin = source.wireframeLinejoin;\n      this.fog = source.fog;\n      return this;\n    }\n  }\n  const _vector$9 = /* @__PURE__ */ new Vector3();\n  const _vector2$1 = /* @__PURE__ */ new Vector2();\n  class BufferAttribute {\n    constructor(array, itemSize, normalized = false) {\n      if (Array.isArray(array)) {\n        throw new TypeError(\"THREE.BufferAttribute: array should be a Typed Array.\");\n      }\n      this.isBufferAttribute = true;\n      this.name = \"\";\n      this.array = array;\n      this.itemSize = itemSize;\n      this.count = array !== void 0 ? array.length / itemSize : 0;\n      this.normalized = normalized;\n      this.usage = StaticDrawUsage;\n      this.updateRanges = [];\n      this.gpuType = FloatType;\n      this.version = 0;\n    }\n    onUploadCallback() {\n    }\n    set needsUpdate(value) {\n      if (value === true) this.version++;\n    }\n    setUsage(value) {\n      this.usage = value;\n      return this;\n    }\n    addUpdateRange(start, count) {\n      this.updateRanges.push({ start, count });\n    }\n    clearUpdateRanges() {\n      this.updateRanges.length = 0;\n    }\n    copy(source) {\n      this.name = source.name;\n      this.array = new source.array.constructor(source.array);\n      this.itemSize = source.itemSize;\n      this.count = source.count;\n      this.normalized = source.normalized;\n      this.usage = source.usage;\n      this.gpuType = source.gpuType;\n      return this;\n    }\n    copyAt(index1, attribute, index2) {\n      index1 *= this.itemSize;\n      index2 *= attribute.itemSize;\n      for (let i2 = 0, l = this.itemSize; i2 < l; i2++) {\n        this.array[index1 + i2] = attribute.array[index2 + i2];\n      }\n      return this;\n    }\n    copyArray(array) {\n      this.array.set(array);\n      return this;\n    }\n    applyMatrix3(m) {\n      if (this.itemSize === 2) {\n        for (let i2 = 0, l = this.count; i2 < l; i2++) {\n          _vector2$1.fromBufferAttribute(this, i2);\n          _vector2$1.applyMatrix3(m);\n          this.setXY(i2, _vector2$1.x, _vector2$1.y);\n        }\n      } else if (this.itemSize === 3) {\n        for (let i2 = 0, l = this.count; i2 < l; i2++) {\n          _vector$9.fromBufferAttribute(this, i2);\n          _vector$9.applyMatrix3(m);\n          this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n        }\n      }\n      return this;\n    }\n    applyMatrix4(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.applyMatrix4(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    applyNormalMatrix(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.applyNormalMatrix(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    transformDirection(m) {\n      for (let i2 = 0, l = this.count; i2 < l; i2++) {\n        _vector$9.fromBufferAttribute(this, i2);\n        _vector$9.transformDirection(m);\n        this.setXYZ(i2, _vector$9.x, _vector$9.y, _vector$9.z);\n      }\n      return this;\n    }\n    set(value, offset = 0) {\n      this.array.set(value, offset);\n      return this;\n    }\n    getComponent(index, component) {\n      let value = this.array[index * this.itemSize + component];\n      if (this.normalized) value = denormalize(value, this.array);\n      return value;\n    }\n    setComponent(index, component, value) {\n      if (this.normalized) value = normalize$1(value, this.array);\n      this.array[index * this.itemSize + component] = value;\n      return this;\n    }\n    getX(index) {\n      let x2 = this.array[index * this.itemSize];\n      if (this.normalized) x2 = denormalize(x2, this.array);\n      return x2;\n    }\n    setX(index, x2) {\n      if (this.normalized) x2 = normalize$1(x2, this.array);\n      this.array[index * this.itemSize] = x2;\n      return this;\n    }\n    getY(index) {\n      let y = this.array[index * this.itemSize + 1];\n      if (this.normalized) y = denormalize(y, this.array);\n      return y;\n    }\n    setY(index, y) {\n      if (this.normalized) y = normalize$1(y, this.array);\n      this.array[index * this.itemSize + 1] = y;\n      return this;\n    }\n    getZ(index) {\n      let z = this.array[index * this.itemSize + 2];\n      if (this.normalized) z = denormalize(z, this.array);\n      return z;\n    }\n    setZ(index, z) {\n      if (this.normalized) z = normalize$1(z, this.array);\n      this.array[index * this.itemSize + 2] = z;\n      return this;\n    }\n    getW(index) {\n      let w = this.array[index * this.itemSize + 3];\n      if (this.normalized) w = denormalize(w, this.array);\n      return w;\n    }\n    setW(index, w) {\n      if (this.normalized) w = normalize$1(w, this.array);\n      this.array[index * this.itemSize + 3] = w;\n      return this;\n    }\n    setXY(index, x2, y) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$1(x2, this.array);\n        y = normalize$1(y, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      return this;\n    }\n    setXYZ(index, x2, y, z) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$1(x2, this.array);\n        y = normalize$1(y, this.array);\n        z = normalize$1(z, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      this.array[index + 2] = z;\n      return this;\n    }\n    setXYZW(index, x2, y, z, w) {\n      index *= this.itemSize;\n      if (this.normalized) {\n        x2 = normalize$1(x2, this.array);\n        y = normalize$1(y, this.array);\n        z = normalize$1(z, this.array);\n        w = normalize$1(w, this.array);\n      }\n      this.array[index + 0] = x2;\n      this.array[index + 1] = y;\n      this.array[index + 2] = z;\n      this.array[index + 3] = w;\n      return this;\n    }\n    onUpload(callback) {\n      this.onUploadCallback = callback;\n      return this;\n    }\n    clone() {\n      return new this.constructor(this.array, this.itemSize).copy(this);\n    }\n    toJSON() {\n      const data = {\n        itemSize: this.itemSize,\n        type: this.array.constructor.name,\n        array: Array.from(this.array),\n        normalized: this.normalized\n      };\n      if (this.name !== \"\") data.name = this.name;\n      if (this.usage !== StaticDrawUsage) data.usage = this.usage;\n      return data;\n    }\n  }\n  class Uint16BufferAttribute extends BufferAttribute {\n    constructor(array, itemSize, normalized) {\n      super(new Uint16Array(array), itemSize, normalized);\n    }\n  }\n  class Uint32BufferAttribute extends BufferAttribute {\n    constructor(array, itemSize, normalized) {\n      super(new Uint32Array(array), itemSize, normalized);\n    }\n  }\n  class Float32BufferAttribute extends BufferAttribute {\n    constructor(array, itemSize, normalized) {\n      super(new Float32Array(array), itemSize, normalized);\n    }\n  }\n  let _id$1 = 0;\n  const _m1 = /* @__PURE__ */ new Matrix4();\n  const _obj = /* @__PURE__ */ new Object3D();\n  const _offset = /* @__PURE__ */ new Vector3();\n  const _box$2 = /* @__PURE__ */ new Box3();\n  const _boxMorphTargets = /* @__PURE__ */ new Box3();\n  const _vector$8 = /* @__PURE__ */ new Vector3();\n  class BufferGeometry extends EventDispatcher {\n    constructor() {\n      super();\n      this.isBufferGeometry = true;\n      Object.defineProperty(this, \"id\", { value: _id$1++ });\n      this.uuid = generateUUID();\n      this.name = \"\";\n      this.type = \"BufferGeometry\";\n      this.index = null;\n      this.indirect = null;\n      this.attributes = {};\n      this.morphAttributes = {};\n      this.morphTargetsRelative = false;\n      this.groups = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n      this.drawRange = { start: 0, count: Infinity };\n      this.userData = {};\n    }\n    getIndex() {\n      return this.index;\n    }\n    setIndex(index) {\n      if (Array.isArray(index)) {\n        this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);\n      } else {\n        this.index = index;\n      }\n      return this;\n    }\n    setIndirect(indirect) {\n      this.indirect = indirect;\n      return this;\n    }\n    getIndirect() {\n      return this.indirect;\n    }\n    getAttribute(name) {\n      return this.attributes[name];\n    }\n    setAttribute(name, attribute) {\n      this.attributes[name] = attribute;\n      return this;\n    }\n    deleteAttribute(name) {\n      delete this.attributes[name];\n      return this;\n    }\n    hasAttribute(name) {\n      return this.attributes[name] !== void 0;\n    }\n    addGroup(start, count, materialIndex = 0) {\n      this.groups.push({\n        start,\n        count,\n        materialIndex\n      });\n    }\n    clearGroups() {\n      this.groups = [];\n    }\n    setDrawRange(start, count) {\n      this.drawRange.start = start;\n      this.drawRange.count = count;\n    }\n    applyMatrix4(matrix) {\n      const position = this.attributes.position;\n      if (position !== void 0) {\n        position.applyMatrix4(matrix);\n        position.needsUpdate = true;\n      }\n      const normal = this.attributes.normal;\n      if (normal !== void 0) {\n        const normalMatrix = new Matrix3().getNormalMatrix(matrix);\n        normal.applyNormalMatrix(normalMatrix);\n        normal.needsUpdate = true;\n      }\n      const tangent = this.attributes.tangent;\n      if (tangent !== void 0) {\n        tangent.transformDirection(matrix);\n        tangent.needsUpdate = true;\n      }\n      if (this.boundingBox !== null) {\n        this.computeBoundingBox();\n      }\n      if (this.boundingSphere !== null) {\n        this.computeBoundingSphere();\n      }\n      return this;\n    }\n    applyQuaternion(q) {\n      _m1.makeRotationFromQuaternion(q);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateX(angle) {\n      _m1.makeRotationX(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateY(angle) {\n      _m1.makeRotationY(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    rotateZ(angle) {\n      _m1.makeRotationZ(angle);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    translate(x2, y, z) {\n      _m1.makeTranslation(x2, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    scale(x2, y, z) {\n      _m1.makeScale(x2, y, z);\n      this.applyMatrix4(_m1);\n      return this;\n    }\n    lookAt(vector) {\n      _obj.lookAt(vector);\n      _obj.updateMatrix();\n      this.applyMatrix4(_obj.matrix);\n      return this;\n    }\n    center() {\n      this.computeBoundingBox();\n      this.boundingBox.getCenter(_offset).negate();\n      this.translate(_offset.x, _offset.y, _offset.z);\n      return this;\n    }\n    setFromPoints(points) {\n      const positionAttribute = this.getAttribute(\"position\");\n      if (positionAttribute === void 0) {\n        const position = [];\n        for (let i2 = 0, l = points.length; i2 < l; i2++) {\n          const point = points[i2];\n          position.push(point.x, point.y, point.z || 0);\n        }\n        this.setAttribute(\"position\", new Float32BufferAttribute(position, 3));\n      } else {\n        const l = Math.min(points.length, positionAttribute.count);\n        for (let i2 = 0; i2 < l; i2++) {\n          const point = points[i2];\n          positionAttribute.setXYZ(i2, point.x, point.y, point.z || 0);\n        }\n        if (points.length > positionAttribute.count) {\n          console.warn(\"THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.\");\n        }\n        positionAttribute.needsUpdate = true;\n      }\n      return this;\n    }\n    computeBoundingBox() {\n      if (this.boundingBox === null) {\n        this.boundingBox = new Box3();\n      }\n      const position = this.attributes.position;\n      const morphAttributesPosition = this.morphAttributes.position;\n      if (position && position.isGLBufferAttribute) {\n        console.error(\"THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.\", this);\n        this.boundingBox.set(\n          new Vector3(-Infinity, -Infinity, -Infinity),\n          new Vector3(Infinity, Infinity, Infinity)\n        );\n        return;\n      }\n      if (position !== void 0) {\n        this.boundingBox.setFromBufferAttribute(position);\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            _box$2.setFromBufferAttribute(morphAttribute);\n            if (this.morphTargetsRelative) {\n              _vector$8.addVectors(this.boundingBox.min, _box$2.min);\n              this.boundingBox.expandByPoint(_vector$8);\n              _vector$8.addVectors(this.boundingBox.max, _box$2.max);\n              this.boundingBox.expandByPoint(_vector$8);\n            } else {\n              this.boundingBox.expandByPoint(_box$2.min);\n              this.boundingBox.expandByPoint(_box$2.max);\n            }\n          }\n        }\n      } else {\n        this.boundingBox.makeEmpty();\n      }\n      if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {\n        console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The \"position\" attribute is likely to have NaN values.', this);\n      }\n    }\n    computeBoundingSphere() {\n      if (this.boundingSphere === null) {\n        this.boundingSphere = new Sphere();\n      }\n      const position = this.attributes.position;\n      const morphAttributesPosition = this.morphAttributes.position;\n      if (position && position.isGLBufferAttribute) {\n        console.error(\"THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.\", this);\n        this.boundingSphere.set(new Vector3(), Infinity);\n        return;\n      }\n      if (position) {\n        const center = this.boundingSphere.center;\n        _box$2.setFromBufferAttribute(position);\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            _boxMorphTargets.setFromBufferAttribute(morphAttribute);\n            if (this.morphTargetsRelative) {\n              _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);\n              _box$2.expandByPoint(_vector$8);\n              _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);\n              _box$2.expandByPoint(_vector$8);\n            } else {\n              _box$2.expandByPoint(_boxMorphTargets.min);\n              _box$2.expandByPoint(_boxMorphTargets.max);\n            }\n          }\n        }\n        _box$2.getCenter(center);\n        let maxRadiusSq = 0;\n        for (let i2 = 0, il = position.count; i2 < il; i2++) {\n          _vector$8.fromBufferAttribute(position, i2);\n          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n        }\n        if (morphAttributesPosition) {\n          for (let i2 = 0, il = morphAttributesPosition.length; i2 < il; i2++) {\n            const morphAttribute = morphAttributesPosition[i2];\n            const morphTargetsRelative = this.morphTargetsRelative;\n            for (let j = 0, jl = morphAttribute.count; j < jl; j++) {\n              _vector$8.fromBufferAttribute(morphAttribute, j);\n              if (morphTargetsRelative) {\n                _offset.fromBufferAttribute(position, j);\n                _vector$8.add(_offset);\n              }\n              maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));\n            }\n          }\n        }\n        this.boundingSphere.radius = Math.sqrt(maxRadiusSq);\n        if (isNaN(this.boundingSphere.radius)) {\n          console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The \"position\" attribute is likely to have NaN values.', this);\n        }\n      }\n    }\n    computeTangents() {\n      const index = this.index;\n      const attributes = this.attributes;\n      if (index === null || attributes.position === void 0 || attributes.normal === void 0 || attributes.uv === void 0) {\n        console.error(\"THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)\");\n        return;\n      }\n      const positionAttribute = attributes.position;\n      const normalAttribute = attributes.normal;\n      const uvAttribute = attributes.uv;\n      if (this.hasAttribute(\"tangent\") === false) {\n        this.setAttribute(\"tangent\", new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));\n      }\n      const tangentAttribute = this.getAttribute(\"tangent\");\n      const tan1 = [], tan2 = [];\n      for (let i2 = 0; i2 < positionAttribute.count; i2++) {\n        tan1[i2] = new Vector3();\n        tan2[i2] = new Vector3();\n      }\n      const vA = new Vector3(), vB = new Vector3(), vC = new Vector3(), uvA = new Vector2(), uvB = new Vector2(), uvC = new Vector2(), sdir = new Vector3(), tdir = new Vector3();\n      function handleTriangle(a, b, c) {\n        vA.fromBufferAttribute(positionAttribute, a);\n        vB.fromBufferAttribute(positionAttribute, b);\n        vC.fromBufferAttribute(positionAttribute, c);\n        uvA.fromBufferAttribute(uvAttribute, a);\n        uvB.fromBufferAttribute(uvAttribute, b);\n        uvC.fromBufferAttribute(uvAttribute, c);\n        vB.sub(vA);\n        vC.sub(vA);\n        uvB.sub(uvA);\n        uvC.sub(uvA);\n        const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y);\n        if (!isFinite(r)) return;\n        sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);\n        tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);\n        tan1[a].add(sdir);\n        tan1[b].add(sdir);\n        tan1[c].add(sdir);\n        tan2[a].add(tdir);\n        tan2[b].add(tdir);\n        tan2[c].add(tdir);\n      }\n      let groups = this.groups;\n      if (groups.length === 0) {\n        groups = [{\n          start: 0,\n          count: index.count\n        }];\n      }\n      for (let i2 = 0, il = groups.length; i2 < il; ++i2) {\n        const group = groups[i2];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          handleTriangle(\n            index.getX(j + 0),\n            index.getX(j + 1),\n            index.getX(j + 2)\n          );\n        }\n      }\n      const tmp = new Vector3(), tmp2 = new Vector3();\n      const n = new Vector3(), n2 = new Vector3();\n      function handleVertex(v) {\n        n.fromBufferAttribute(normalAttribute, v);\n        n2.copy(n);\n        const t = tan1[v];\n        tmp.copy(t);\n        tmp.sub(n.multiplyScalar(n.dot(t))).normalize();\n        tmp2.crossVectors(n2, t);\n        const test = tmp2.dot(tan2[v]);\n        const w = test < 0 ? -1 : 1;\n        tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);\n      }\n      for (let i2 = 0, il = groups.length; i2 < il; ++i2) {\n        const group = groups[i2];\n        const start = group.start;\n        const count = group.count;\n        for (let j = start, jl = start + count; j < jl; j += 3) {\n          handleVertex(index.getX(j + 0));\n          handleVertex(index.getX(j + 1));\n          handleVertex(index.getX(j + 2));\n        }\n      }\n    }\n    computeVertexNormals() {\n      const index = this.index;\n      const positionAttribute = this.getAttribute(\"position\");\n      if (positionAttribute !== void 0) {\n        let normalAttribute = this.getAttribute(\"normal\");\n        if (normalAttribute === void 0) {\n          normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);\n          this.setAttribute(\"normal\", normalAttribute);\n        } else {\n          for (let i2 = 0, il = normalAttribute.count; i2 < il; i2++) {\n            normalAttribute.setXYZ(i2, 0, 0, 0);\n          }\n        }\n        const pA = new Vector3(), pB = new Vector3(), pC = new Vector3();\n        const nA = new Vector3(), nB = new Vector3(), nC = new Vector3();\n        const cb = new Vector3(), ab = new Vector3();\n        if (index) {\n          for (let i2 = 0, il = index.count; i2 < il; i2 += 3) {\n            const vA = index.getX(i2 + 0);\n            const vB = index.getX(i2 + 1);\n            const vC = index.getX(i2 + 2);\n            pA.fromBufferAttribute(positionAttribute, vA);\n            pB.fromBufferAttribute(positionAttribute, vB);\n            pC.fromBufferAttribute(positionAttribute, vC);\n            cb.subVectors(pC, pB);\n            ab.subVectors(pA, pB);\n            cb.cross(ab);\n            nA.fromBufferAttribute(normalAttribute, vA);\n            nB.fromBufferAttribute(normalAttribute, vB);\n            nC.fromBufferAttribute(normalAttribute, vC);\n            nA.add(cb);\n            nB.add(cb);\n            nC.add(cb);\n            normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);\n            normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);\n            normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);\n          }\n        } else {\n          for (let i2 = 0, il = positionAttribute.count; i2 < il; i2 += 3) {\n            pA.fromBufferAttribute(positionAttribute, i2 + 0);\n            pB.fromBufferAttribute(positionAttribute, i2 + 1);\n            pC.fromBufferAttribute(positionAttribute, i2 + 2);\n            cb.subVectors(pC, pB);\n            ab.subVectors(pA, pB);\n            cb.cross(ab);\n            normalAttribute.setXYZ(i2 + 0, cb.x, cb.y, cb.z);\n            normalAttribute.setXYZ(i2 + 1, cb.x, cb.y, cb.z);\n            normalAttribute.setXYZ(i2 + 2, cb.x, cb.y, cb.z);\n          }\n        }\n        this.normalizeNormals();\n        normalAttribute.needsUpdate = true;\n      }\n    }\n    normalizeNormals() {\n      const normals = this.attributes.normal;\n      for (let i2 = 0, il = normals.count; i2 < il; i2++) {\n        _vector$8.fromBufferAttribute(normals, i2);\n        _vector$8.normalize();\n        normals.setXYZ(i2, _vector$8.x, _vector$8.y, _vector$8.z);\n      }\n    }\n    toNonIndexed() {\n      function convertBufferAttribute(attribute, indices2) {\n        const array = attribute.array;\n        const itemSize = attribute.itemSize;\n        const normalized = attribute.normalized;\n        const array2 = new array.constructor(indices2.length * itemSize);\n        let index = 0, index2 = 0;\n        for (let i2 = 0, l = indices2.length; i2 < l; i2++) {\n          if (attribute.isInterleavedBufferAttribute) {\n            index = indices2[i2] * attribute.data.stride + attribute.offset;\n          } else {\n            index = indices2[i2] * itemSize;\n          }\n          for (let j = 0; j < itemSize; j++) {\n            array2[index2++] = array[index++];\n          }\n        }\n        return new BufferAttribute(array2, itemSize, normalized);\n      }\n      if (this.index === null) {\n        console.warn(\"THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.\");\n        return this;\n      }\n      const geometry2 = new BufferGeometry();\n      const indices = this.index.array;\n      const attributes = this.attributes;\n      for (const name in attributes) {\n        const attribute = attributes[name];\n        const newAttribute = convertBufferAttribute(attribute, indices);\n        geometry2.setAttribute(name, newAttribute);\n      }\n      const morphAttributes = this.morphAttributes;\n      for (const name in morphAttributes) {\n        const morphArray = [];\n        const morphAttribute = morphAttributes[name];\n        for (let i2 = 0, il = morphAttribute.length; i2 < il; i2++) {\n          const attribute = morphAttribute[i2];\n          const newAttribute = convertBufferAttribute(attribute, indices);\n          morphArray.push(newAttribute);\n        }\n        geometry2.morphAttributes[name] = morphArray;\n      }\n      geometry2.morphTargetsRelative = this.morphTargetsRelative;\n      const groups = this.groups;\n      for (let i2 = 0, l = groups.length; i2 < l; i2++) {\n        const group = groups[i2];\n        geometry2.addGroup(group.start, group.count, group.materialIndex);\n      }\n      return geometry2;\n    }\n    toJSON() {\n      const data = {\n        metadata: {\n          version: 4.6,\n          type: \"BufferGeometry\",\n          generator: \"BufferGeometry.toJSON\"\n        }\n      };\n      data.uuid = this.uuid;\n      data.type = this.type;\n      if (this.name !== \"\") data.name = this.name;\n      if (Object.keys(this.userData).length > 0) data.userData = this.userData;\n      if (this.parameters !== void 0) {\n        const parameters = this.parameters;\n        for (const key in parameters) {\n          if (parameters[key] !== void 0) data[key] = parameters[key];\n        }\n        return data;\n      }\n      data.data = { attributes: {} };\n      const index = this.index;\n      if (index !== null) {\n        data.data.index = {\n          type: index.array.constructor.name,\n          array: Array.prototype.slice.call(index.array)\n        };\n      }\n      const attributes = this.attributes;\n      for (const key in attributes) {\n        const attribute = attributes[key];\n        data.data.attributes[key] = attribute.toJSON(data.data);\n      }\n      const morphAttributes = {};\n      let hasMorphAttributes = false;\n      for (const key in this.morphAttributes) {\n        const attributeArray = this.morphAttributes[key];\n        const array = [];\n        for (let i2 = 0, il = attributeArray.length; i2 < il; i2++) {\n          const attribute = attributeArray[i2];\n          array.push(attribute.toJSON(data.data));\n        }\n        if (array.length > 0) {\n          morphAttributes[key] = array;\n          hasMorphAttributes = true;\n        }\n      }\n      if (hasMorphAttributes) {\n        data.data.morphAttributes = morphAttributes;\n        data.data.morphTargetsRelative = this.morphTargetsRelative;\n      }\n      const groups = this.groups;\n      if (groups.length > 0) {\n        data.data.groups = JSON.parse(JSON.stringify(groups));\n      }\n      const boundingSphere = this.boundingSphere;\n      if (boundingSphere !== null) {\n        data.data.boundingSphere = {\n          center: boundingSphere.center.toArray(),\n          radius: boundingSphere.radius\n        };\n      }\n      return data;\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n    copy(source) {\n      this.index = null;\n      this.attributes = {};\n      this.morphAttributes = {};\n      this.groups = [];\n      this.boundingBox = null;\n      this.boundingSphere = null;\n      const data = {};\n      this.name = source.name;\n      const index = source.index;\n      if (index !== null) {\n        this.setIndex(index.clone(data));\n      }\n      const attributes = source.attributes;\n      for (const name in attributes) {\n        const attribute = attributes[name];\n        this.setAttribute(name, attribute.clone(data));\n      }\n      const morphAttributes = source.morphAttributes;\n      for (const name in morphAttributes) {\n        const array = [];\n        const morphAttribute = morphAttributes[name];\n        for (let i2 = 0, l = morphAttribute.length; i2 < l; i2++) {\n          array.push(morphAttribute[i2].clone(data));\n        }\n        this.morphAttributes[name] = array;\n      }\n      this.morphTargetsRelative = source.morphTargetsRelative;\n      const groups = source.groups;\n      for (let i2 = 0, l = groups.length; i2 < l; i2++) {\n        const group = groups[i2];\n        this.addGroup(group.start, group.count, group.materialIndex);\n      }\n      const boundingBox = source.boundingBox;\n      if (boundingBox !== null) {\n        this.boundingBox = boundingBox.clone();\n      }\n      const boundingSphere = source.boundingSphere;\n      if (boundingSphere !== null) {\n        this.boundingSphere = boundingSphere.clone();\n      }\n      this.drawRange.start = source.drawRange.start;\n      this.drawRange.count = source.drawRange.count;\n      this.userData = source.userData;\n      return this;\n    }\n    dispose() {\n      this.dispatchEvent({ type: \"dispose\" });\n    }\n  }\n  const _inverseMatrix$3 = /* @__PURE__ */ new Matrix4();\n  const _ray$3 = /* @__PURE__ */ new Ray();\n  const _sphere$6 = /* @__PURE__ */ new Sphere();\n  const _sphereHitAt = /* @__PURE__ */ new Vector3();\n  const _vA$1 = /* @__PURE__ */ new Vector3();\n  const _vB$1 = /* @__PURE__ */ new Vector3();\n  const _vC$1 = /* @__PURE__ */ new Vector3();\n  const _tempA = /* @__PURE__ */ new Vector3();\n  const _morphA = /* @__PURE__ */ new Vector3();\n  const _intersectionPoint = /* @__PURE__ */ new Vector3();\n  const _intersectionPointWorld = /* @__PURE__ */ new Vector3();\n  class Mesh extends Object3D {\n    constructor(geometry = new BufferGeometry(), material = new MeshBasicMaterial()) {\n      super();\n      this.isMesh = true;\n      this.type = \"Mesh\";\n      this.geometry = geometry;\n      this.material = material;\n      this.updateMorphTargets();\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      if (source.morphTargetInfluences !== void 0) {\n        this.morphTargetInfluences = source.morphTargetInfluences.slice();\n      }\n      if (source.morphTargetDictionary !== void 0) {\n        this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);\n      }\n      this.material = Array.isArray(source.material) ? source.material.slice() : source.material;\n      this.geometry = source.geometry;\n      return this;\n    }\n    updateMorphTargets() {\n      const geometry = this.geometry;\n      const morphAttributes = geometry.morphAttributes;\n      const keys = Object.keys(morphAttributes);\n      if (keys.length > 0) {\n        const morphAttribute = morphAttributes[keys[0]];\n        if (morphAttribute !== void 0) {\n          this.morphTargetInfluences = [];\n          this.morphTargetDictionary = {};\n          for (let m = 0, ml = morphAttribute.length; m < ml; m++) {\n            const name = morphAttribute[m].name || String(m);\n            this.morphTargetInfluences.push(0);\n            this.morphTargetDictionary[name] = m;\n          }\n        }\n      }\n    }\n    getVertexPosition(index, target) {\n      const geometry = this.geometry;\n      const position = geometry.attributes.position;\n      const morphPosition = geometry.morphAttributes.position;\n      const morphTargetsRelative = geometry.morphTargetsRelative;\n      target.fromBufferAttribute(position, index);\n      const morphInfluences = this.morphTargetInfluences;\n      if (morphPosition && morphInfluences) {\n        _morphA.set(0, 0, 0);\n        for (let i2 = 0, il = morphPosition.length; i2 < il; i2++) {\n          const influence = morphInfluences[i2];\n          const morphAttribute = morphPosition[i2];\n          if (influence === 0) continue;\n          _tempA.fromBufferAttribute(morphAttribute, index);\n          if (morphTargetsRelative) {\n            _morphA.addScaledVector(_tempA, influence);\n          } else {\n            _morphA.addScaledVector(_tempA.sub(target), influence);\n          }\n        }\n        target.add(_morphA);\n      }\n      return target;\n    }\n    raycast(raycaster, intersects) {\n      const geometry = this.geometry;\n      const material = this.material;\n      const matrixWorld = this.matrixWorld;\n      if (material === void 0) return;\n      if (geometry.boundingSphere === null) geometry.computeBoundingSphere();\n      _sphere$6.copy(geometry.boundingSphere);\n      _sphere$6.applyMatrix4(matrixWorld);\n      _ray$3.copy(raycaster.ray).recast(raycaster.near);\n      if (_sphere$6.containsPoint(_ray$3.origin) === false) {\n        if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;\n        if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;\n      }\n      _inverseMatrix$3.copy(matrixWorld).invert();\n      _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);\n      if (geometry.boundingBox !== null) {\n        if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;\n      }\n      this._computeIntersections(raycaster, intersects, _ray$3);\n    }\n    _computeIntersections(raycaster, intersects, rayLocalSpace) {\n      let intersection;\n      const geometry = this.geometry;\n      const material = this.material;\n      const index = geometry.index;\n      const position = geometry.attributes.position;\n      const uv = geometry.attributes.uv;\n      const uv1 = geometry.attributes.uv1;\n      const normal = geometry.attributes.normal;\n      const groups = geometry.groups;\n      const drawRange = geometry.drawRange;\n      if (index !== null) {\n        if (Array.isArray(material)) {\n          for (let i2 = 0, il = groups.length; i2 < il; i2++) {\n            const group = groups[i2];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = index.getX(j);\n              const b = index.getX(j + 1);\n              const c = index.getX(j + 2);\n              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3);\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(index.count, drawRange.start + drawRange.count);\n          for (let i2 = start, il = end; i2 < il; i2 += 3) {\n            const a = index.getX(i2);\n            const b = index.getX(i2 + 1);\n            const c = index.getX(i2 + 2);\n            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i2 / 3);\n              intersects.push(intersection);\n            }\n          }\n        }\n      } else if (position !== void 0) {\n        if (Array.isArray(material)) {\n          for (let i2 = 0, il = groups.length; i2 < il; i2++) {\n            const group = groups[i2];\n            const groupMaterial = material[group.materialIndex];\n            const start = Math.max(group.start, drawRange.start);\n            const end = Math.min(position.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));\n            for (let j = start, jl = end; j < jl; j += 3) {\n              const a = j;\n              const b = j + 1;\n              const c = j + 2;\n              intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n              if (intersection) {\n                intersection.faceIndex = Math.floor(j / 3);\n                intersection.face.materialIndex = group.materialIndex;\n                intersects.push(intersection);\n              }\n            }\n          }\n        } else {\n          const start = Math.max(0, drawRange.start);\n          const end = Math.min(position.count, drawRange.start + drawRange.count);\n          for (let i2 = start, il = end; i2 < il; i2 += 3) {\n            const a = i2;\n            const b = i2 + 1;\n            const c = i2 + 2;\n            intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);\n            if (intersection) {\n              intersection.faceIndex = Math.floor(i2 / 3);\n              intersects.push(intersection);\n            }\n          }\n        }\n      }\n    }\n  }\n  function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {\n    let intersect;\n    if (material.side === BackSide) {\n      intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n    } else {\n      intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);\n    }\n    if (intersect === null) return null;\n    _intersectionPointWorld.copy(point);\n    _intersectionPointWorld.applyMatrix4(object.matrixWorld);\n    const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);\n    if (distance < raycaster.near || distance > raycaster.far) return null;\n    return {\n      distance,\n      point: _intersectionPointWorld.clone(),\n      object\n    };\n  }\n  function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {\n    object.getVertexPosition(a, _vA$1);\n    object.getVertexPosition(b, _vB$1);\n    object.getVertexPosition(c, _vC$1);\n    const intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);\n    if (intersection) {\n      const barycoord = new Vector3();\n      Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);\n      if (uv) {\n        intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2());\n      }\n      if (uv1) {\n        intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());\n      }\n      if (normal) {\n        intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3());\n        if (intersection.normal.dot(ray.direction) > 0) {\n          intersection.normal.multiplyScalar(-1);\n        }\n      }\n      const face = {\n        a,\n        b,\n        c,\n        normal: new Vector3(),\n        materialIndex: 0\n      };\n      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);\n      intersection.face = face;\n      intersection.barycoord = barycoord;\n    }\n    return intersection;\n  }\n  function cloneUniforms(src) {\n    const dst = {};\n    for (const u in src) {\n      dst[u] = {};\n      for (const p in src[u]) {\n        const property = src[u][p];\n        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {\n          if (property.isRenderTargetTexture) {\n            console.warn(\"UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().\");\n            dst[u][p] = null;\n          } else {\n            dst[u][p] = property.clone();\n          }\n        } else if (Array.isArray(property)) {\n          dst[u][p] = property.slice();\n        } else {\n          dst[u][p] = property;\n        }\n      }\n    }\n    return dst;\n  }\n  function cloneUniformsGroups(src) {\n    const dst = [];\n    for (let u = 0; u < src.length; u++) {\n      dst.push(src[u].clone());\n    }\n    return dst;\n  }\n  var default_vertex = \"void main() {\\\\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\\\\n}\";\n  var default_fragment = \"void main() {\\\\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\\\\n}\";\n  class ShaderMaterial extends Material {\n    constructor(parameters) {\n      super();\n      this.isShaderMaterial = true;\n      this.type = \"ShaderMaterial\";\n      this.defines = {};\n      this.uniforms = {};\n      this.uniformsGroups = [];\n      this.vertexShader = default_vertex;\n      this.fragmentShader = default_fragment;\n      this.linewidth = 1;\n      this.wireframe = false;\n      this.wireframeLinewidth = 1;\n      this.fog = false;\n      this.lights = false;\n      this.clipping = false;\n      this.forceSinglePass = true;\n      this.extensions = {\n        clipCullDistance: false,\n        // set to use vertex shader clipping\n        multiDraw: false\n        // set to use vertex shader multi_draw / enable gl_DrawID\n      };\n      this.defaultAttributeValues = {\n        \"color\": [1, 1, 1],\n        \"uv\": [0, 0],\n        \"uv1\": [0, 0]\n      };\n      this.index0AttributeName = void 0;\n      this.uniformsNeedUpdate = false;\n      this.glslVersion = null;\n      if (parameters !== void 0) {\n        this.setValues(parameters);\n      }\n    }\n    copy(source) {\n      super.copy(source);\n      this.fragmentShader = source.fragmentShader;\n      this.vertexShader = source.vertexShader;\n      this.uniforms = cloneUniforms(source.uniforms);\n      this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);\n      this.defines = Object.assign({}, source.defines);\n      this.wireframe = source.wireframe;\n      this.wireframeLinewidth = source.wireframeLinewidth;\n      this.fog = source.fog;\n      this.lights = source.lights;\n      this.clipping = source.clipping;\n      this.extensions = Object.assign({}, source.extensions);\n      this.glslVersion = source.glslVersion;\n      return this;\n    }\n    toJSON(meta) {\n      const data = super.toJSON(meta);\n      data.glslVersion = this.glslVersion;\n      data.uniforms = {};\n      for (const name in this.uniforms) {\n        const uniform = this.uniforms[name];\n        const value = uniform.value;\n        if (value && value.isTexture) {\n          data.uniforms[name] = {\n            type: \"t\",\n            value: value.toJSON(meta).uuid\n          };\n        } else if (value && value.isColor) {\n          data.uniforms[name] = {\n            type: \"c\",\n            value: value.getHex()\n          };\n        } else if (value && value.isVector2) {\n          data.uniforms[name] = {\n            type: \"v2\",\n            value: value.toArray()\n          };\n        } else if (value && value.isVector3) {\n          data.uniforms[name] = {\n            type: \"v3\",\n            value: value.toArray()\n          };\n        } else if (value && value.isVector4) {\n          data.uniforms[name] = {\n            type: \"v4\",\n            value: value.toArray()\n          };\n        } else if (value && value.isMatrix3) {\n          data.uniforms[name] = {\n            type: \"m3\",\n            value: value.toArray()\n          };\n        } else if (value && value.isMatrix4) {\n          data.uniforms[name] = {\n            type: \"m4\",\n            value: value.toArray()\n          };\n        } else {\n          data.uniforms[name] = {\n            value\n          };\n        }\n      }\n      if (Object.keys(this.defines).length > 0) data.defines = this.defines;\n      data.vertexShader = this.vertexShader;\n      data.fragmentShader = this.fragmentShader;\n      data.lights = this.lights;\n      data.clipping = this.clipping;\n      const extensions = {};\n      for (const key in this.extensions) {\n        if (this.extensions[key] === true) extensions[key] = true;\n      }\n      if (Object.keys(extensions).length > 0) data.extensions = extensions;\n      return data;\n    }\n  }\n  class Camera extends Object3D {\n    constructor() {\n      super();\n      this.isCamera = true;\n      this.type = \"Camera\";\n      this.matrixWorldInverse = new Matrix4();\n      this.projectionMatrix = new Matrix4();\n      this.projectionMatrixInverse = new Matrix4();\n      this.coordinateSystem = WebGLCoordinateSystem;\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      this.matrixWorldInverse.copy(source.matrixWorldInverse);\n      this.projectionMatrix.copy(source.projectionMatrix);\n      this.projectionMatrixInverse.copy(source.projectionMatrixInverse);\n      this.coordinateSystem = source.coordinateSystem;\n      return this;\n    }\n    getWorldDirection(target) {\n      return super.getWorldDirection(target).negate();\n    }\n    updateMatrixWorld(force) {\n      super.updateMatrixWorld(force);\n      this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n    updateWorldMatrix(updateParents, updateChildren) {\n      super.updateWorldMatrix(updateParents, updateChildren);\n      this.matrixWorldInverse.copy(this.matrixWorld).invert();\n    }\n    clone() {\n      return new this.constructor().copy(this);\n    }\n  }\n  class Scene extends Object3D {\n    constructor() {\n      super();\n      this.isScene = true;\n      this.type = \"Scene\";\n      this.background = null;\n      this.environment = null;\n      this.fog = null;\n      this.backgroundBlurriness = 0;\n      this.backgroundIntensity = 1;\n      this.backgroundRotation = new Euler();\n      this.environmentIntensity = 1;\n      this.environmentRotation = new Euler();\n      this.overrideMaterial = null;\n      if (typeof __THREE_DEVTOOLS__ !== \"undefined\") {\n        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"observe\", { detail: this }));\n      }\n    }\n    copy(source, recursive) {\n      super.copy(source, recursive);\n      if (source.background !== null) this.background = source.background.clone();\n      if (source.environment !== null) this.environment = source.environment.clone();\n      if (source.fog !== null) this.fog = source.fog.clone();\n      this.backgroundBlurriness = source.backgroundBlurriness;\n      this.backgroundIntensity = source.backgroundIntensity;\n      this.backgroundRotation.copy(source.backgroundRotation);\n      this.environmentIntensity = source.environmentIntensity;\n      this.environmentRotation.copy(source.environmentRotation);\n      if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();\n      this.matrixAutoUpdate = source.matrixAutoUpdate;\n      return this;\n    }\n    toJSON(meta) {\n      const data = super.toJSON(meta);\n      if (this.fog !== null) data.object.fog = this.fog.toJSON();\n      if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;\n      if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;\n      data.object.backgroundRotation = this.backgroundRotation.toArray();\n      if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;\n      data.object.environmentRotation = this.environmentRotation.toArray();\n      return data;\n    }\n  }\n  class DataTexture extends Texture {\n    constructor(data = null, width = 1, height = 1, format, type, mapping, wrapS, wrapT, magFilter = NearestFilter, minFilter = NearestFilter, anisotropy, colorSpace) {\n      super(null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace);\n      this.isDataTexture = true;\n      this.image = { data, width, height };\n      this.generateMipmaps = false;\n      this.flipY = false;\n      this.unpackAlignment = 1;\n    }\n  }\n  class PlaneGeometry extends BufferGeometry {\n    constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {\n      super();\n      this.type = \"PlaneGeometry\";\n      this.parameters = {\n        width,\n        height,\n        widthSegments,\n        heightSegments\n      };\n      const width_half = width / 2;\n      const height_half = height / 2;\n      const gridX = Math.floor(widthSegments);\n      const gridY = Math.floor(heightSegments);\n      const gridX1 = gridX + 1;\n      const gridY1 = gridY + 1;\n      const segment_width = width / gridX;\n      const segment_height = height / gridY;\n      const indices = [];\n      const vertices = [];\n      const normals = [];\n      const uvs = [];\n      for (let iy = 0; iy < gridY1; iy++) {\n        const y = iy * segment_height - height_half;\n        for (let ix = 0; ix < gridX1; ix++) {\n          const x2 = ix * segment_width - width_half;\n          vertices.push(x2, -y, 0);\n          normals.push(0, 0, 1);\n          uvs.push(ix / gridX);\n          uvs.push(1 - iy / gridY);\n        }\n      }\n      for (let iy = 0; iy < gridY; iy++) {\n        for (let ix = 0; ix < gridX; ix++) {\n          const a = ix + gridX1 * iy;\n          const b = ix + gridX1 * (iy + 1);\n          const c = ix + 1 + gridX1 * (iy + 1);\n          const d = ix + 1 + gridX1 * iy;\n          indices.push(a, b, d);\n          indices.push(b, c, d);\n        }\n      }\n      this.setIndex(indices);\n      this.setAttribute(\"position\", new Float32BufferAttribute(vertices, 3));\n      this.setAttribute(\"normal\", new Float32BufferAttribute(normals, 3));\n      this.setAttribute(\"uv\", new Float32BufferAttribute(uvs, 2));\n    }\n    copy(source) {\n      super.copy(source);\n      this.parameters = Object.assign({}, source.parameters);\n      return this;\n    }\n    static fromJSON(data) {\n      return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);\n    }\n  }\n  class RawShaderMaterial extends ShaderMaterial {\n    constructor(parameters) {\n      super(parameters);\n      this.isRawShaderMaterial = true;\n      this.type = \"RawShaderMaterial\";\n    }\n  }\n  class Matrix2 {\n    constructor(n11, n12, n21, n22) {\n      Matrix2.prototype.isMatrix2 = true;\n      this.elements = [\n        1,\n        0,\n        0,\n        1\n      ];\n      if (n11 !== void 0) {\n        this.set(n11, n12, n21, n22);\n      }\n    }\n    identity() {\n      this.set(\n        1,\n        0,\n        0,\n        1\n      );\n      return this;\n    }\n    fromArray(array, offset = 0) {\n      for (let i2 = 0; i2 < 4; i2++) {\n        this.elements[i2] = array[i2 + offset];\n      }\n      return this;\n    }\n    set(n11, n12, n21, n22) {\n      const te = this.elements;\n      te[0] = n11;\n      te[2] = n12;\n      te[1] = n21;\n      te[3] = n22;\n      return this;\n    }\n  }\n  if (typeof __THREE_DEVTOOLS__ !== \"undefined\") {\n    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent(\"register\", { detail: {\n      revision: REVISION\n    } }));\n  }\n  if (typeof window !== \"undefined\") {\n    if (window.__THREE__) {\n      console.warn(\"WARNING: Multiple instances of Three.js being imported.\");\n    } else {\n      window.__THREE__ = REVISION;\n    }\n  }\n  const LN_SCALE_MIN = -9;\n  const LN_SCALE_MAX = 9;\n  const LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254;\n  const SCALE_MIN = Math.exp(LN_SCALE_MIN);\n  const SPLAT_TEX_WIDTH_BITS = 11;\n  const SPLAT_TEX_HEIGHT_BITS = 11;\n  const SPLAT_TEX_WIDTH = 1 << SPLAT_TEX_WIDTH_BITS;\n  const SPLAT_TEX_HEIGHT = 1 << SPLAT_TEX_HEIGHT_BITS;\n  const SPLAT_TEX_MIN_HEIGHT = 1;\n  const WASM_SPLAT_SORT = true;\n  function isIntType(type) {\n    return type === \"int\" || type === \"ivec2\" || type === \"ivec3\" || type === \"ivec4\";\n  }\n  function isUintType(type) {\n    return type === \"uint\" || type === \"uvec2\" || type === \"uvec3\" || type === \"uvec4\";\n  }\n  function isFloatType(type) {\n    return type === \"float\" || type === \"vec2\" || type === \"vec3\" || type === \"vec4\";\n  }\n  function isMatFloatType(type) {\n    return type === \"mat2\" || type === \"mat2x2\" || type === \"mat2x3\" || type === \"mat2x4\" || type === \"mat3\" || type === \"mat3x2\" || type === \"mat3x3\" || type === \"mat3x4\" || type === \"mat4\" || type === \"mat4x2\" || type === \"mat4x3\" || type === \"mat4x4\";\n  }\n  function isAllFloatType(type) {\n    return isFloatType(type) || isMatFloatType(type);\n  }\n  function isMat2(type) {\n    return type === \"mat2\" || type === \"mat2x2\";\n  }\n  function isMat3(type) {\n    return type === \"mat3\" || type === \"mat3x3\";\n  }\n  function isMat4(type) {\n    return type === \"mat4\" || type === \"mat4x4\";\n  }\n  function numberAsInt(value) {\n    return Math.trunc(value).toString();\n  }\n  function numberAsUint(value) {\n    const v = Math.max(0, Math.trunc(value));\n    return \\`\\${v.toString()}u\\`;\n  }\n  function numberAsFloat(value) {\n    return value === Number.POSITIVE_INFINITY ? \"INFINITY\" : value === Number.NEGATIVE_INFINITY ? \"-INFINITY\" : Number.isInteger(value) ? value.toFixed(1) : value.toString();\n  }\n  function valType(val) {\n    if (val instanceof DynoValue) {\n      return val.type;\n    }\n    const value = val.dynoOut();\n    return value.type;\n  }\n  class DynoValue {\n    constructor(type) {\n      this.__isDynoValue = true;\n      this.type = type;\n    }\n  }\n  class DynoOutput extends DynoValue {\n    constructor(dyno2, key) {\n      super(dyno2.outTypes[key]);\n      this.dyno = dyno2;\n      this.key = key;\n    }\n  }\n  class DynoLiteral extends DynoValue {\n    constructor(type, literal) {\n      super(type);\n      this.literal = literal;\n    }\n    getLiteral() {\n      return this.literal;\n    }\n  }\n  class DynoConst extends DynoLiteral {\n    constructor(type, value) {\n      super(type, \"\");\n      this.value = value;\n    }\n    getLiteral() {\n      const { type, value } = this;\n      switch (type) {\n        case \"bool\":\n          return value ? \"true\" : \"false\";\n        case \"uint\":\n          return numberAsUint(value);\n        case \"int\":\n          return numberAsInt(value);\n        case \"float\":\n          return numberAsFloat(value);\n        case \"bvec2\": {\n          const v = value;\n          return \\`bvec2(\\${v[0]}, \\${v[1]})\\`;\n        }\n        case \"uvec2\": {\n          if (value instanceof Vector2) {\n            return \\`uvec2(\\${numberAsUint(value.x)}, \\${numberAsUint(value.y)})\\`;\n          }\n          const v = value;\n          return \\`uvec2(\\${numberAsUint(v[0])}, \\${numberAsUint(v[1])})\\`;\n        }\n        case \"ivec2\": {\n          if (value instanceof Vector2) {\n            return \\`ivec2(\\${numberAsInt(value.x)}, \\${numberAsInt(value.y)})\\`;\n          }\n          const v = value;\n          return \\`ivec2(\\${numberAsInt(v[0])}, \\${numberAsInt(v[1])})\\`;\n        }\n        case \"vec2\": {\n          if (value instanceof Vector2) {\n            return \\`vec2(\\${numberAsFloat(value.x)}, \\${numberAsFloat(value.y)})\\`;\n          }\n          const v = value;\n          return \\`vec2(\\${numberAsFloat(v[0])}, \\${numberAsFloat(v[1])})\\`;\n        }\n        case \"bvec3\": {\n          const v = value;\n          return \\`bvec3(\\${v[0]}, \\${v[1]}, \\${v[2]})\\`;\n        }\n        case \"uvec3\": {\n          if (value instanceof Vector3) {\n            return \\`uvec3(\\${numberAsUint(value.x)}, \\${numberAsUint(value.y)}, \\${numberAsUint(value.z)})\\`;\n          }\n          const v = value;\n          return \\`uvec3(\\${numberAsUint(v[0])}, \\${numberAsUint(v[1])}, \\${numberAsUint(v[2])})\\`;\n        }\n        case \"ivec3\": {\n          if (value instanceof Vector3) {\n            return \\`ivec3(\\${numberAsInt(value.x)}, \\${numberAsInt(value.y)}, \\${numberAsInt(value.z)})\\`;\n          }\n          const v = value;\n          return \\`ivec3(\\${numberAsInt(v[0])}, \\${numberAsInt(v[1])}, \\${numberAsInt(v[2])})\\`;\n        }\n        case \"vec3\": {\n          if (value instanceof Vector3) {\n            return \\`vec3(\\${numberAsFloat(value.x)}, \\${numberAsFloat(value.y)}, \\${numberAsFloat(value.z)})\\`;\n          }\n          const v = value;\n          return \\`vec3(\\${numberAsFloat(v[0])}, \\${numberAsFloat(v[1])}, \\${numberAsFloat(v[2])})\\`;\n        }\n        case \"bvec4\": {\n          const v = value;\n          return \\`bvec4(\\${v[0]}, \\${v[1]}, \\${v[2]}, \\${v[3]})\\`;\n        }\n        case \"uvec4\": {\n          if (value instanceof Vector4) {\n            return \\`uvec4(\\${numberAsUint(value.x)}, \\${numberAsUint(value.y)}, \\${numberAsUint(value.z)}, \\${numberAsUint(value.w)})\\`;\n          }\n          const v = value;\n          return \\`uvec4(\\${numberAsUint(v[0])}, \\${numberAsUint(v[1])}, \\${numberAsUint(v[2])}, \\${numberAsUint(v[3])})\\`;\n        }\n        case \"ivec4\": {\n          if (value instanceof Vector4) {\n            return \\`ivec4(\\${numberAsInt(value.x)}, \\${numberAsInt(value.y)}, \\${numberAsInt(value.z)}, \\${numberAsInt(value.w)})\\`;\n          }\n          const v = value;\n          return \\`ivec4(\\${numberAsInt(v[0])}, \\${numberAsInt(v[1])}, \\${numberAsInt(v[2])}, \\${numberAsInt(v[3])})\\`;\n        }\n        case \"vec4\": {\n          if (value instanceof Vector4) {\n            return \\`vec4(\\${numberAsFloat(value.x)}, \\${numberAsFloat(value.y)}, \\${numberAsFloat(value.z)}, \\${numberAsFloat(value.w)})\\`;\n          }\n          if (value instanceof Quaternion) {\n            return \\`vec4(\\${numberAsFloat(value.x)}, \\${numberAsFloat(value.y)}, \\${numberAsFloat(value.z)}, \\${numberAsFloat(value.w)})\\`;\n          }\n          const v = value;\n          return \\`vec4(\\${numberAsFloat(v[0])}, \\${numberAsFloat(v[1])}, \\${numberAsFloat(v[2])}, \\${numberAsFloat(v[3])})\\`;\n        }\n        case \"mat2\":\n        case \"mat2x2\": {\n          const m = value;\n          const e = m instanceof Matrix2 ? m.elements : value;\n          const arg = new Array(4).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        case \"mat2x3\": {\n          const e = value;\n          const arg = new Array(6).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        case \"mat2x4\": {\n          const e = value;\n          const arg = new Array(8).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        case \"mat3\":\n        case \"mat3x3\": {\n          const m = value;\n          const e = m instanceof Matrix3 ? m.elements : value;\n          const arg = new Array(9).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        case \"mat3x2\": {\n          const e = value;\n          const arg = new Array(6).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        case \"mat3x4\": {\n          const e = value;\n          const arg = new Array(12).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        case \"mat4\":\n        case \"mat4x4\": {\n          const m = value;\n          const e = m instanceof Matrix4 ? m.elements : value;\n          const arg = new Array(16).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        case \"mat4x2\": {\n          const e = value;\n          const arg = new Array(8).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        case \"mat4x3\": {\n          const e = value;\n          const arg = new Array(12).fill(0).map((_, i2) => numberAsFloat(e[i2]));\n          return \\`\\${type}(\\${arg.join(\", \")})\\`;\n        }\n        default:\n          throw new Error(\\`Type not implemented: \\${String(type)}\\`);\n      }\n    }\n  }\n  function dynoConst(type, value) {\n    return new DynoConst(type, value);\n  }\n  const DEFAULT_INDENT = \"    \";\n  class Compilation {\n    constructor({ indent } = {}) {\n      this.globals = /* @__PURE__ */ new Set();\n      this.statements = [];\n      this.uniforms = {};\n      this.declares = /* @__PURE__ */ new Set();\n      this.updaters = [];\n      this.sequence = 0;\n      this.indent = DEFAULT_INDENT;\n      this.indent = indent ?? DEFAULT_INDENT;\n    }\n    nextSequence() {\n      return this.sequence++;\n    }\n  }\n  class Dyno {\n    constructor({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      statements,\n      generate\n    }) {\n      this.inTypes = inTypes ?? {};\n      this.outTypes = outTypes ?? {};\n      this.inputs = inputs ?? {};\n      this.update = update;\n      this.globals = globals;\n      this.statements = statements;\n      this.generate = generate ?? (({ inputs: inputs2, outputs, compile }) => {\n        var _a2, _b2;\n        return {\n          globals: (_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs: inputs2, outputs, compile }),\n          statements: (_b2 = this.statements) == null ? void 0 : _b2.call(this, { inputs: inputs2, outputs, compile })\n        };\n      });\n    }\n    get outputs() {\n      const outputs = {};\n      for (const key in this.outTypes) {\n        outputs[key] = new DynoOutput(this, key);\n      }\n      return outputs;\n    }\n    apply(inputs) {\n      Object.assign(this.inputs, inputs);\n      return this.outputs;\n    }\n    compile({\n      inputs,\n      outputs,\n      compile\n    }) {\n      const result = [\n        \\`// \\${this.constructor.name}(\\${Object.values(inputs).join(\", \")}) => (\\${Object.values(outputs).join(\", \")})\\`\n      ];\n      const declares = [];\n      for (const key in outputs) {\n        const name = outputs[key];\n        if (name && !compile.declares.has(name)) {\n          compile.declares.add(name);\n          declares.push(key);\n        }\n      }\n      const { globals, statements, uniforms } = this.generate({\n        inputs,\n        outputs,\n        compile\n      });\n      for (const global of globals ?? []) {\n        compile.globals.add(global);\n      }\n      for (const key in uniforms) {\n        compile.uniforms[key] = uniforms[key];\n      }\n      if (this.update) {\n        compile.updaters.push(this.update);\n      }\n      for (const key of declares) {\n        const name = outputs[key];\n        if (name) {\n          if (!compile.uniforms[name]) {\n            result.push(\\`\\${dynoDeclare(name, this.outTypes[key])};\\`);\n          }\n        }\n      }\n      if (statements == null ? void 0 : statements.length) {\n        result.push(\"{\");\n        result.push(...statements.map((line) => compile.indent + line));\n        result.push(\"}\");\n      }\n      return result;\n    }\n  }\n  class DynoBlock extends Dyno {\n    constructor({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      construct\n    }) {\n      super({\n        inTypes,\n        outTypes,\n        inputs,\n        update,\n        globals,\n        generate: (args) => this.generateBlock(args)\n      });\n      this.construct = construct;\n    }\n    generateBlock({\n      inputs,\n      outputs,\n      compile\n    }) {\n      var _a2, _b2;\n      const blockInputs = {};\n      const blockOutputs = {};\n      for (const key in inputs) {\n        if (inputs[key] != null) {\n          blockInputs[key] = new DynoLiteral(this.inTypes[key], inputs[key]);\n        }\n      }\n      for (const key in outputs) {\n        if (outputs[key] != null) {\n          blockOutputs[key] = new DynoValue(this.outTypes[key]);\n        }\n      }\n      const options = { roots: [] };\n      const returned = this.construct(blockInputs, blockOutputs, options);\n      for (const global of ((_a2 = this.globals) == null ? void 0 : _a2.call(this, { inputs, outputs, compile })) ?? []) {\n        compile.globals.add(global);\n      }\n      const ordering = [];\n      const nodeOuts = /* @__PURE__ */ new Map();\n      function visit(node, outKey, outName) {\n        let outs = nodeOuts.get(node);\n        if (!outs) {\n          outs = {\n            sequence: compile.nextSequence(),\n            outNames: /* @__PURE__ */ new Map(),\n            newOuts: /* @__PURE__ */ new Set()\n          };\n          nodeOuts.set(node, outs);\n          for (const key in node.inputs) {\n            let input = node.inputs[key];\n            while (input) {\n              if (input instanceof DynoValue) {\n                if (input instanceof DynoOutput) {\n                  visit(input.dyno, input.key);\n                }\n                break;\n              }\n              input = input.dynoOut();\n            }\n          }\n          ordering.push(node);\n        }\n        if (outKey) {\n          if (!outName) {\n            outs.newOuts.add(outKey);\n          }\n          outs.outNames.set(outKey, outName ?? \\`\\${outKey}_\\${outs.sequence}\\`);\n        }\n      }\n      for (const root of options.roots) {\n        visit(root);\n      }\n      for (const key in blockOutputs) {\n        let value = (returned == null ? void 0 : returned[key]) ?? blockOutputs[key];\n        while (value) {\n          if (value instanceof DynoValue) {\n            if (value instanceof DynoOutput) {\n              visit(value.dyno, value.key, outputs[key]);\n            }\n            break;\n          }\n          value = value.dynoOut();\n        }\n        blockOutputs[key] = value;\n      }\n      const steps = [];\n      for (const dyno2 of ordering) {\n        const inputs2 = {};\n        const outputs2 = {};\n        for (const key in dyno2.inputs) {\n          let value = dyno2.inputs[key];\n          while (value) {\n            if (value instanceof DynoValue) {\n              if (value instanceof DynoLiteral) {\n                inputs2[key] = value.getLiteral();\n              } else if (value instanceof DynoOutput) {\n                const source = (_b2 = nodeOuts.get(value.dyno)) == null ? void 0 : _b2.outNames.get(value.key);\n                if (!source) {\n                  throw new Error(\n                    \\`Source not found for \\${value.dyno.constructor.name}.\\${value.key}\\`\n                  );\n                }\n                inputs2[key] = source;\n              }\n              break;\n            }\n            value = value.dynoOut();\n          }\n        }\n        const outs = nodeOuts.get(dyno2) ?? { outNames: /* @__PURE__ */ new Map() };\n        for (const [key, name] of outs.outNames.entries()) {\n          outputs2[key] = name;\n        }\n        const newSteps = dyno2.compile({ inputs: inputs2, outputs: outputs2, compile });\n        steps.push(newSteps);\n      }\n      const literalOutputs = [];\n      for (const key in outputs) {\n        if (blockOutputs[key] instanceof DynoLiteral) {\n          literalOutputs.push(\n            \\`\\${outputs[key]} = \\${blockOutputs[key].getLiteral()};\\`\n          );\n        }\n      }\n      if (literalOutputs.length > 0) {\n        steps.push(literalOutputs);\n      }\n      const statements = steps.flatMap((step, index) => {\n        return index === 0 ? step : [\"\", ...step];\n      });\n      return { statements };\n    }\n  }\n  function dynoBlock(inTypes, outTypes, construct, { update, globals } = {}) {\n    return new DynoBlock({ inTypes, outTypes, construct, update, globals });\n  }\n  function dyno({\n    inTypes,\n    outTypes,\n    inputs,\n    update,\n    globals,\n    statements,\n    generate\n  }) {\n    return new Dyno({\n      inTypes,\n      outTypes,\n      inputs,\n      update,\n      globals,\n      statements,\n      generate\n    });\n  }\n  function dynoDeclare(name, type, count) {\n    const typeStr = typeof type === \"string\" ? type : type.type;\n    if (!typeStr) {\n      throw new Error(\\`Invalid DynoType: \\${String(type)}\\`);\n    }\n    return \\`\\${typeStr} \\${name}\\${count != null ? \\`[\\${count}]\\` : \"\"}\\`;\n  }\n  function unindentLines(s) {\n    var _a2;\n    let seenNonEmpty = false;\n    const lines = s.split(\"\\\\n\").map((line) => {\n      const trimmedLine = line.trimEnd();\n      if (seenNonEmpty) {\n        return trimmedLine;\n      }\n      if (trimmedLine.length > 0) {\n        seenNonEmpty = true;\n        return trimmedLine;\n      }\n      return null;\n    }).filter((line) => line != null);\n    while (lines.length > 0 && lines[lines.length - 1].length === 0) {\n      lines.pop();\n    }\n    if (lines.length === 0) {\n      return [];\n    }\n    const indent = (_a2 = lines[0].match(/^\\\\s*/)) == null ? void 0 : _a2[0];\n    if (!indent) {\n      return lines;\n    }\n    const regex = new RegExp(\\`^\\${indent}\\`);\n    return lines.map((line) => line.replace(regex, \"\"));\n  }\n  function unindent(s) {\n    return unindentLines(s).join(\"\\\\n\");\n  }\n  class UnaryOp extends Dyno {\n    constructor({\n      a,\n      outKey,\n      outTypeFunc\n    }) {\n      const inTypes = { a: valType(a) };\n      const outType = outTypeFunc(valType(a));\n      const outTypes = { [outKey]: outType };\n      super({ inTypes, outTypes, inputs: { a } });\n      this.outKey = outKey;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  class BinaryOp extends Dyno {\n    constructor({\n      a,\n      b,\n      outKey,\n      outTypeFunc\n    }) {\n      const inTypes = { a: valType(a), b: valType(b) };\n      const outType = outTypeFunc(valType(a), valType(b));\n      const outTypes = { [outKey]: outType };\n      super({ inTypes, outTypes, inputs: { a, b } });\n      this.outKey = outKey;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  const f32buffer = new Float32Array(1);\n  const u32buffer = new Uint32Array(f32buffer.buffer);\n  function toHalf(f) {\n    f32buffer[0] = f;\n    const bits2 = u32buffer[0];\n    const sign = bits2 >> 31 & 1;\n    const exp = bits2 >> 23 & 255;\n    const frac = bits2 & 8388607;\n    const halfSign = sign << 15;\n    if (exp === 255) {\n      if (frac !== 0) {\n        return halfSign | 32767;\n      }\n      return halfSign | 31744;\n    }\n    const newExp = exp - 127 + 15;\n    if (newExp >= 31) {\n      return halfSign | 31744;\n    }\n    if (newExp <= 0) {\n      if (newExp < -10) {\n        return halfSign;\n      }\n      const subFrac = (frac | 8388608) >> 1 - newExp + 13;\n      return halfSign | subFrac;\n    }\n    const halfFrac = frac >> 13;\n    return halfSign | newExp << 10 | halfFrac;\n  }\n  function fromHalf(h) {\n    const sign = h >> 15 & 1;\n    const exp = h >> 10 & 31;\n    const frac = h & 1023;\n    let f32bits;\n    if (exp === 0) {\n      if (frac === 0) {\n        f32bits = sign << 31;\n      } else {\n        let mant = frac;\n        let e = -14;\n        while ((mant & 1024) === 0) {\n          mant <<= 1;\n          e--;\n        }\n        mant &= 1023;\n        const newExp = e + 127;\n        const newFrac = mant << 13;\n        f32bits = sign << 31 | newExp << 23 | newFrac;\n      }\n    } else if (exp === 31) {\n      if (frac === 0) {\n        f32bits = sign << 31 | 2139095040;\n      } else {\n        f32bits = sign << 31 | 2143289344;\n      }\n    } else {\n      const newExp = exp - 15 + 127;\n      const newFrac = frac << 13;\n      f32bits = sign << 31 | newExp << 23 | newFrac;\n    }\n    u32buffer[0] = f32bits;\n    return f32buffer[0];\n  }\n  function floatToUint8(v) {\n    return Math.max(0, Math.min(255, Math.round(v * 255)));\n  }\n  function getArrayBuffers(ctx) {\n    const buffers = [];\n    const seen = /* @__PURE__ */ new Set();\n    function traverse(obj) {\n      if (obj && typeof obj === \"object\" && !seen.has(obj)) {\n        seen.add(obj);\n        if (obj instanceof ArrayBuffer) {\n          buffers.push(obj);\n        } else if (ArrayBuffer.isView(obj)) {\n          buffers.push(obj.buffer);\n        } else if (Array.isArray(obj)) {\n          obj.forEach(traverse);\n        } else {\n          Object.values(obj).forEach(traverse);\n        }\n      }\n    }\n    traverse(ctx);\n    return buffers;\n  }\n  function setPackedSplat(packedSplats, index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) {\n    const uR = floatToUint8(r);\n    const uG = floatToUint8(g);\n    const uB = floatToUint8(b);\n    const uA = floatToUint8(opacity);\n    const uQuat = encodeQuatOctXy88R8(\n      new Quaternion(quatX, quatY, quatZ, quatW)\n    );\n    const uQuatX = uQuat & 255;\n    const uQuatY = uQuat >>> 8 & 255;\n    const uQuatZ = uQuat >>> 16 & 255;\n    const uScaleX = scaleX === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleX) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleY = scaleY === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleY) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleZ = scaleZ === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleZ) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uCenterX = toHalf(x2);\n    const uCenterY = toHalf(y);\n    const uCenterZ = toHalf(z);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | uA << 24;\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n    packedSplats[i4 + 2] = uCenterZ | uQuatX << 16 | uQuatY << 24;\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | uQuatZ << 24;\n  }\n  function setPackedSplatCenter(packedSplats, index, x2, y, z) {\n    const uCenterX = toHalf(x2);\n    const uCenterY = toHalf(y);\n    const uCenterZ = toHalf(z);\n    const i4 = index * 4;\n    packedSplats[i4 + 1] = uCenterX | uCenterY << 16;\n    packedSplats[i4 + 2] = uCenterZ | packedSplats[i4 + 2] & 4294901760;\n  }\n  function setPackedSplatScales(packedSplats, index, scaleX, scaleY, scaleZ) {\n    const uScaleX = scaleX === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleX) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleY = scaleY === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleY) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const uScaleZ = scaleZ === 0 ? 0 : Math.min(\n      255,\n      Math.max(\n        0,\n        Math.round((Math.log(scaleZ) - LN_SCALE_MIN) / LN_RESCALE) + 1\n      )\n    );\n    const i4 = index * 4;\n    packedSplats[i4 + 3] = uScaleX | uScaleY << 8 | uScaleZ << 16 | packedSplats[i4 + 3] & 4278190080;\n  }\n  function setPackedSplatQuat(packedSplats, index, quatX, quatY, quatZ, quatW) {\n    const uQuat = encodeQuatOctXy88R8(\n      new Quaternion(quatX, quatY, quatZ, quatW)\n    );\n    const uQuatX = uQuat & 255;\n    const uQuatY = uQuat >>> 8 & 255;\n    const uQuatZ = uQuat >>> 16 & 255;\n    const i4 = index * 4;\n    packedSplats[i4 + 2] = packedSplats[i4 + 2] & 65535 | uQuatX << 16 | uQuatY << 24;\n    packedSplats[i4 + 3] = packedSplats[i4 + 3] & 16777215 | uQuatZ << 24;\n  }\n  function setPackedSplatRgb(packedSplats, index, r, g, b) {\n    const uR = floatToUint8(r);\n    const uG = floatToUint8(g);\n    const uB = floatToUint8(b);\n    const i4 = index * 4;\n    packedSplats[i4] = uR | uG << 8 | uB << 16 | packedSplats[i4] & 4278190080;\n  }\n  function setPackedSplatOpacity(packedSplats, index, opacity) {\n    const uA = floatToUint8(opacity);\n    const i4 = index * 4;\n    packedSplats[i4] = packedSplats[i4] & 16777215 | uA << 24;\n  }\n  const packedCenter = new Vector3();\n  const packedScales = new Vector3();\n  const packedQuaternion = new Quaternion();\n  const packedColor = new Color();\n  const packedFields = {\n    center: packedCenter,\n    scales: packedScales,\n    quaternion: packedQuaternion,\n    color: packedColor,\n    opacity: 0\n  };\n  function unpackSplat(packedSplats, index) {\n    const result = packedFields;\n    const i4 = index * 4;\n    const word0 = packedSplats[i4];\n    const word1 = packedSplats[i4 + 1];\n    const word2 = packedSplats[i4 + 2];\n    const word3 = packedSplats[i4 + 3];\n    result.color.set(\n      (word0 & 255) / 255,\n      (word0 >>> 8 & 255) / 255,\n      (word0 >>> 16 & 255) / 255\n    );\n    result.opacity = (word0 >>> 24 & 255) / 255;\n    result.center.set(\n      fromHalf(word1 & 65535),\n      fromHalf(word1 >>> 16 & 65535),\n      fromHalf(word2 & 65535)\n    );\n    const uScalesX = word3 & 255;\n    result.scales.x = uScalesX === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesX - 1) * LN_RESCALE);\n    const uScalesY = word3 >>> 8 & 255;\n    result.scales.y = uScalesY === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesY - 1) * LN_RESCALE);\n    const uScalesZ = word3 >>> 16 & 255;\n    result.scales.z = uScalesZ === 0 ? 0 : Math.exp(LN_SCALE_MIN + (uScalesZ - 1) * LN_RESCALE);\n    const uQuat = word2 >>> 16 & 65535 | word3 >>> 8 & 16711680;\n    decodeQuatOctXy88R8(uQuat, result.quaternion);\n    return result;\n  }\n  function getTextureSize(numSplats) {\n    const width = SPLAT_TEX_WIDTH;\n    const height = Math.max(\n      SPLAT_TEX_MIN_HEIGHT,\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n    );\n    const depth = Math.ceil(numSplats / (width * height));\n    const maxSplats = width * height * depth;\n    return { width, height, depth, maxSplats };\n  }\n  function computeMaxSplats(numSplats) {\n    const width = SPLAT_TEX_WIDTH;\n    const height = Math.max(\n      SPLAT_TEX_MIN_HEIGHT,\n      Math.min(SPLAT_TEX_HEIGHT, Math.ceil(numSplats / width))\n    );\n    const depth = Math.ceil(numSplats / (width * height));\n    return width * height * depth;\n  }\n  const IDENT_VERTEX_SHADER = unindent(\\`\n  precision highp float;\n\n  in vec3 position;\n\n  void main() {\n    gl_Position = vec4(position.xy, 0.0, 1.0);\n  }\n\\`);\n  function encodeQuatOctXy88R8(q) {\n    const qnorm = q.clone().normalize();\n    if (qnorm.w < 0) {\n      qnorm.set(-qnorm.x, -qnorm.y, -qnorm.z, -qnorm.w);\n    }\n    const theta = 2 * Math.acos(qnorm.w);\n    const xyz_norm = Math.sqrt(\n      qnorm.x * qnorm.x + qnorm.y * qnorm.y + qnorm.z * qnorm.z\n    );\n    const axis = xyz_norm < 1e-6 ? new Vector3(1, 0, 0) : new Vector3(qnorm.x, qnorm.y, qnorm.z).divideScalar(xyz_norm);\n    const sum = Math.abs(axis.x) + Math.abs(axis.y) + Math.abs(axis.z);\n    let p_x = axis.x / sum;\n    let p_y = axis.y / sum;\n    if (axis.z < 0) {\n      const tmp = p_x;\n      p_x = (1 - Math.abs(p_y)) * (p_x >= 0 ? 1 : -1);\n      p_y = (1 - Math.abs(tmp)) * (p_y >= 0 ? 1 : -1);\n    }\n    const u_f = p_x * 0.5 + 0.5;\n    const v_f = p_y * 0.5 + 0.5;\n    const quantU = Math.round(u_f * 255);\n    const quantV = Math.round(v_f * 255);\n    const angleInt = Math.round(theta * (255 / Math.PI));\n    return angleInt << 16 | quantV << 8 | quantU;\n  }\n  function decodeQuatOctXy88R8(encoded, out) {\n    const quantU = encoded & 255;\n    const quantV = encoded >>> 8 & 255;\n    const angleInt = encoded >>> 16 & 255;\n    const u_f = quantU / 255;\n    const v_f = quantV / 255;\n    let f_x = (u_f - 0.5) * 2;\n    let f_y = (v_f - 0.5) * 2;\n    const f_z = 1 - (Math.abs(f_x) + Math.abs(f_y));\n    const t = Math.max(-f_z, 0);\n    f_x += f_x >= 0 ? -t : t;\n    f_y += f_y >= 0 ? -t : t;\n    const axis = new Vector3(f_x, f_y, f_z).normalize();\n    const theta = angleInt / 255 * Math.PI;\n    const halfTheta = theta * 0.5;\n    const s = Math.sin(halfTheta);\n    const w = Math.cos(halfTheta);\n    out.set(axis.x * s, axis.y * s, axis.z * s, w);\n    return out;\n  }\n  function packSint8Bytes(b0, b1, b2, b3) {\n    const clampedB0 = Math.max(-127, Math.min(127, b0 * 127));\n    const clampedB1 = Math.max(-127, Math.min(127, b1 * 127));\n    const clampedB2 = Math.max(-127, Math.min(127, b2 * 127));\n    const clampedB3 = Math.max(-127, Math.min(127, b3 * 127));\n    return clampedB0 & 255 | (clampedB1 & 255) << 8 | (clampedB2 & 255) << 16 | (clampedB3 & 255) << 24;\n  }\n  function encodeSh1Rgb(sh1Array, index, sh1Rgb) {\n    const base = index * 2;\n    for (let i2 = 0; i2 < 9; ++i2) {\n      const value = Math.max(-63, Math.min(63, sh1Rgb[i2] * 63)) & 127;\n      const bitStart = i2 * 7;\n      const bitEnd = bitStart + 7;\n      const wordStart = Math.floor(bitStart / 32);\n      const bitOffset = bitStart - wordStart * 32;\n      const firstWord = value << bitOffset & 4294967295;\n      sh1Array[base + wordStart] |= firstWord;\n      if (bitEnd > wordStart * 32 + 32) {\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\n        sh1Array[base + wordStart + 1] |= secondWord;\n      }\n    }\n  }\n  function encodeSh2Rgb(sh2Array, index, sh2Rgb) {\n    sh2Array[index * 4 + 0] = packSint8Bytes(\n      sh2Rgb[0],\n      sh2Rgb[1],\n      sh2Rgb[2],\n      sh2Rgb[3]\n    );\n    sh2Array[index * 4 + 1] = packSint8Bytes(\n      sh2Rgb[4],\n      sh2Rgb[5],\n      sh2Rgb[6],\n      sh2Rgb[7]\n    );\n    sh2Array[index * 4 + 2] = packSint8Bytes(\n      sh2Rgb[8],\n      sh2Rgb[9],\n      sh2Rgb[10],\n      sh2Rgb[11]\n    );\n    sh2Array[index * 4 + 3] = packSint8Bytes(\n      sh2Rgb[12],\n      sh2Rgb[13],\n      sh2Rgb[14],\n      0\n    );\n  }\n  function encodeSh3Rgb(sh3Array, index, sh3Rgb) {\n    const base = index * 4;\n    for (let i2 = 0; i2 < 21; ++i2) {\n      const value = Math.max(-31, Math.min(31, sh3Rgb[i2] * 31)) & 63;\n      const bitStart = i2 * 6;\n      const bitEnd = bitStart + 6;\n      const wordStart = Math.floor(bitStart / 32);\n      const bitOffset = bitStart - wordStart * 32;\n      const firstWord = value << bitOffset & 4294967295;\n      sh3Array[base + wordStart] |= firstWord;\n      if (bitEnd > wordStart * 32 + 32) {\n        const secondWord = value >>> 32 - bitOffset & 4294967295;\n        sh3Array[base + wordStart + 1] |= secondWord;\n      }\n    }\n  }\n  function decompressPartialGzip(fileBytes, numBytes) {\n    const chunks = [];\n    let totalBytes = 0;\n    let result = null;\n    const gunzip = new Gunzip((data, final) => {\n      chunks.push(data);\n      totalBytes += data.length;\n      if (final || totalBytes >= numBytes) {\n        const allBytes = new Uint8Array(totalBytes);\n        let offset2 = 0;\n        for (const chunk of chunks) {\n          allBytes.set(chunk, offset2);\n          offset2 += chunk.length;\n        }\n        result = allBytes.slice(0, numBytes);\n      }\n    });\n    const CHUNK_SIZE = 1024;\n    let offset = 0;\n    while (result == null && offset < fileBytes.length) {\n      const chunk = fileBytes.slice(offset, offset + CHUNK_SIZE);\n      gunzip.push(chunk, false);\n      offset += CHUNK_SIZE;\n    }\n    if (result == null) {\n      gunzip.push(new Uint8Array(), true);\n      if (result == null) {\n        throw new Error(\"Failed to decompress partial gzip\");\n      }\n    }\n    return result;\n  }\n  class GunzipReader {\n    constructor({\n      fileBytes,\n      chunkBytes = 64 * 1024\n    }) {\n      this.fileBytes = fileBytes;\n      this.chunkBytes = chunkBytes;\n      this.offset = 0;\n      this.chunks = [];\n      this.totalBytes = 0;\n      this.gunzip = new Gunzip((chunk, _final) => {\n        this.chunks.push(chunk);\n        this.totalBytes += chunk.length;\n      });\n    }\n    read(numBytes) {\n      while (this.totalBytes < numBytes && this.offset < this.fileBytes.length) {\n        const end = Math.min(\n          this.offset + this.chunkBytes,\n          this.fileBytes.length\n        );\n        this.gunzip.push(this.fileBytes.subarray(this.offset, end), false);\n        this.offset = end;\n      }\n      if (this.totalBytes < numBytes && this.offset >= this.fileBytes.length) {\n        this.gunzip.push(new Uint8Array(0), true);\n      }\n      if (this.totalBytes < numBytes) {\n        throw new Error(\n          \\`Unexpected EOF: needed \\${numBytes}, got \\${this.totalBytes}\\`\n        );\n      }\n      const allBytes = new Uint8Array(this.totalBytes);\n      let outOffset = 0;\n      for (const chunk of this.chunks) {\n        allBytes.set(chunk, outOffset);\n        outOffset += chunk.length;\n      }\n      const result = allBytes.subarray(0, numBytes);\n      this.chunks = [allBytes.subarray(numBytes)];\n      this.totalBytes -= numBytes;\n      return result;\n    }\n  }\n  function decodeAntiSplat(fileBytes, initNumSplats, splatCallback) {\n    const numSplats = Math.floor(fileBytes.length / 32);\n    if (numSplats * 32 !== fileBytes.length) {\n      throw new Error(\"Invalid .splat file size\");\n    }\n    initNumSplats(numSplats);\n    const f32 = new Float32Array(fileBytes.buffer);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const i322 = i2 * 32;\n      const i8 = i2 * 8;\n      const x2 = f32[i8 + 0];\n      const y = f32[i8 + 1];\n      const z = f32[i8 + 2];\n      const scaleX = f32[i8 + 3];\n      const scaleY = f32[i8 + 4];\n      const scaleZ = f32[i8 + 5];\n      const r = fileBytes[i322 + 24] / 255;\n      const g = fileBytes[i322 + 25] / 255;\n      const b = fileBytes[i322 + 26] / 255;\n      const opacity = fileBytes[i322 + 27] / 255;\n      const quatW = (fileBytes[i322 + 28] - 128) / 128;\n      const quatX = (fileBytes[i322 + 29] - 128) / 128;\n      const quatY = (fileBytes[i322 + 30] - 128) / 128;\n      const quatZ = (fileBytes[i322 + 31] - 128) / 128;\n      splatCallback(\n        i2,\n        x2,\n        y,\n        z,\n        scaleX,\n        scaleY,\n        scaleZ,\n        quatX,\n        quatY,\n        quatZ,\n        quatW,\n        opacity,\n        r,\n        g,\n        b\n      );\n    }\n  }\n  function unpackAntiSplat(fileBytes) {\n    let numSplats = 0;\n    let maxSplats = 0;\n    let packedArray = new Uint32Array(0);\n    decodeAntiSplat(\n      fileBytes,\n      (cbNumSplats) => {\n        numSplats = cbNumSplats;\n        maxSplats = computeMaxSplats(numSplats);\n        packedArray = new Uint32Array(maxSplats * 4);\n      },\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n        setPackedSplat(\n          packedArray,\n          index,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n      }\n    );\n    return { packedArray, numSplats };\n  }\n  const KSPLAT_COMPRESSION = {\n    0: {\n      bytesPerCenter: 12,\n      bytesPerScale: 12,\n      bytesPerRotation: 16,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 4,\n      scaleOffsetBytes: 12,\n      rotationOffsetBytes: 24,\n      colorOffsetBytes: 40,\n      sphericalHarmonicsOffsetBytes: 44,\n      scaleRange: 1\n    },\n    1: {\n      bytesPerCenter: 6,\n      bytesPerScale: 6,\n      bytesPerRotation: 8,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 2,\n      scaleOffsetBytes: 6,\n      rotationOffsetBytes: 12,\n      colorOffsetBytes: 20,\n      sphericalHarmonicsOffsetBytes: 24,\n      scaleRange: 32767\n    },\n    2: {\n      bytesPerCenter: 6,\n      bytesPerScale: 6,\n      bytesPerRotation: 8,\n      bytesPerColor: 4,\n      bytesPerSphericalHarmonicsComponent: 1,\n      scaleOffsetBytes: 6,\n      rotationOffsetBytes: 12,\n      colorOffsetBytes: 20,\n      sphericalHarmonicsOffsetBytes: 24,\n      scaleRange: 32767\n    }\n  };\n  const KSPLAT_SH_DEGREE_TO_COMPONENTS = {\n    0: 0,\n    1: 9,\n    2: 24,\n    3: 45\n  };\n  function decodeKsplat(fileBytes, initNumSplats, splatCallback, shCallback) {\n    var _a2;\n    const HEADER_BYTES = 4096;\n    const SECTION_BYTES = 1024;\n    let headerOffset = 0;\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n    headerOffset += HEADER_BYTES;\n    const versionMajor = header.getUint8(0);\n    const versionMinor = header.getUint8(1);\n    if (versionMajor !== 0 || versionMinor < 1) {\n      throw new Error(\n        \\`Unsupported .ksplat version: \\${versionMajor}.\\${versionMinor}\\`\n      );\n    }\n    const maxSectionCount = header.getUint32(4, true);\n    header.getUint32(16, true);\n    const compressionLevel = header.getUint16(20, true);\n    if (compressionLevel < 0 || compressionLevel > 2) {\n      throw new Error(\\`Invalid .ksplat compression level: \\${compressionLevel}\\`);\n    }\n    header.getFloat32(36, true) || -1.5;\n    header.getFloat32(40, true) || 1.5;\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n    for (let section = 0; section < maxSectionCount; ++section) {\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n      headerOffset += SECTION_BYTES;\n      const sectionSplatCount = section2.getUint32(0, true);\n      const sectionMaxSplatCount = section2.getUint32(4, true);\n      const bucketSize = section2.getUint32(8, true);\n      const bucketCount = section2.getUint32(12, true);\n      const bucketBlockSize = section2.getFloat32(16, true);\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n      const {\n        bytesPerCenter,\n        bytesPerScale,\n        bytesPerRotation,\n        bytesPerColor,\n        bytesPerSphericalHarmonicsComponent,\n        scaleOffsetBytes,\n        rotationOffsetBytes,\n        colorOffsetBytes,\n        sphericalHarmonicsOffsetBytes\n      } = KSPLAT_COMPRESSION[compressionLevel];\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\n      const data = new DataView(\n        fileBytes.buffer,\n        dataBase,\n        splatDataStorageSizeBytes\n      );\n      const bucketArray = new Float32Array(\n        fileBytes.buffer,\n        bucketsBase,\n        bucketCount * 3\n      );\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\n        const splatOffset = i2 * bytesPerSplat;\n        const bucketIndex = Math.floor(i2 / bucketSize);\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n        );\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n        );\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n        );\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n        );\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n        splatCallback(\n          i2,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n        if (sphericalHarmonicsDegree >= 1 && sh1) {\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\n        }\n      }\n      sectionBase += storageSizeBytes;\n    }\n  }\n  function unpackKsplat(fileBytes) {\n    var _a2;\n    const HEADER_BYTES = 4096;\n    const SECTION_BYTES = 1024;\n    let headerOffset = 0;\n    const header = new DataView(fileBytes.buffer, headerOffset, HEADER_BYTES);\n    headerOffset += HEADER_BYTES;\n    const versionMajor = header.getUint8(0);\n    const versionMinor = header.getUint8(1);\n    if (versionMajor !== 0 || versionMinor < 1) {\n      throw new Error(\n        \\`Unsupported .ksplat version: \\${versionMajor}.\\${versionMinor}\\`\n      );\n    }\n    const maxSectionCount = header.getUint32(4, true);\n    const splatCount = header.getUint32(16, true);\n    const compressionLevel = header.getUint16(20, true);\n    if (compressionLevel < 0 || compressionLevel > 2) {\n      throw new Error(\\`Invalid .ksplat compression level: \\${compressionLevel}\\`);\n    }\n    const minSphericalHarmonicsCoeff = header.getFloat32(36, true) || -1.5;\n    const maxSphericalHarmonicsCoeff = header.getFloat32(40, true) || 1.5;\n    const numSplats = splatCount;\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    let sectionBase = HEADER_BYTES + maxSectionCount * SECTION_BYTES;\n    for (let section = 0; section < maxSectionCount; ++section) {\n      let getSh = function(splatOffset, component) {\n        if (compressionLevel === 0) {\n          return data.getFloat32(\n            splatOffset + sphericalHarmonicsOffsetBytes + component * 4,\n            true\n          );\n        }\n        if (compressionLevel === 1) {\n          return fromHalf(\n            data.getUint16(\n              splatOffset + sphericalHarmonicsOffsetBytes + component * 2,\n              true\n            )\n          );\n        }\n        const t = data.getUint8(splatOffset + sphericalHarmonicsOffsetBytes + component) / 255;\n        return minSphericalHarmonicsCoeff + t * (maxSphericalHarmonicsCoeff - minSphericalHarmonicsCoeff);\n      };\n      const section2 = new DataView(fileBytes.buffer, headerOffset, SECTION_BYTES);\n      headerOffset += SECTION_BYTES;\n      const sectionSplatCount = section2.getUint32(0, true);\n      const sectionMaxSplatCount = section2.getUint32(4, true);\n      const bucketSize = section2.getUint32(8, true);\n      const bucketCount = section2.getUint32(12, true);\n      const bucketBlockSize = section2.getFloat32(16, true);\n      const bucketStorageSizeBytes = section2.getUint16(20, true);\n      const compressionScaleRange = (section2.getUint32(24, true) || ((_a2 = KSPLAT_COMPRESSION[compressionLevel]) == null ? void 0 : _a2.scaleRange)) ?? 1;\n      const partiallyFilledBucketCount = section2.getUint32(36, true);\n      const bucketsMetaDataSizeBytes = partiallyFilledBucketCount * 4;\n      const bucketsStorageSizeBytes = bucketStorageSizeBytes * bucketCount + bucketsMetaDataSizeBytes;\n      const sphericalHarmonicsDegree = section2.getUint16(40, true);\n      const shComponents = KSPLAT_SH_DEGREE_TO_COMPONENTS[sphericalHarmonicsDegree];\n      const {\n        bytesPerCenter,\n        bytesPerScale,\n        bytesPerRotation,\n        bytesPerColor,\n        bytesPerSphericalHarmonicsComponent,\n        scaleOffsetBytes,\n        rotationOffsetBytes,\n        colorOffsetBytes,\n        sphericalHarmonicsOffsetBytes\n      } = KSPLAT_COMPRESSION[compressionLevel];\n      const bytesPerSplat = bytesPerCenter + bytesPerScale + bytesPerRotation + bytesPerColor + shComponents * bytesPerSphericalHarmonicsComponent;\n      const splatDataStorageSizeBytes = bytesPerSplat * sectionMaxSplatCount;\n      const storageSizeBytes = splatDataStorageSizeBytes + bucketsStorageSizeBytes;\n      const sh1Index = [0, 3, 6, 1, 4, 7, 2, 5, 8];\n      const sh2Index = [\n        9,\n        14,\n        19,\n        10,\n        15,\n        20,\n        11,\n        16,\n        21,\n        12,\n        17,\n        22,\n        13,\n        18,\n        23\n      ];\n      const sh3Index = [\n        24,\n        31,\n        38,\n        25,\n        32,\n        39,\n        26,\n        33,\n        40,\n        27,\n        34,\n        41,\n        28,\n        35,\n        42,\n        29,\n        36,\n        43,\n        30,\n        37,\n        44\n      ];\n      const sh1 = sphericalHarmonicsDegree >= 1 ? new Float32Array(3 * 3) : void 0;\n      const sh2 = sphericalHarmonicsDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n      const sh3 = sphericalHarmonicsDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n      const compressionScaleFactor = bucketBlockSize / 2 / compressionScaleRange;\n      const bucketsBase = sectionBase + bucketsMetaDataSizeBytes;\n      const dataBase = sectionBase + bucketsStorageSizeBytes;\n      const data = new DataView(\n        fileBytes.buffer,\n        dataBase,\n        splatDataStorageSizeBytes\n      );\n      const bucketArray = new Float32Array(\n        fileBytes.buffer,\n        bucketsBase,\n        bucketCount * 3\n      );\n      for (let i2 = 0; i2 < sectionSplatCount; ++i2) {\n        const splatOffset = i2 * bytesPerSplat;\n        const bucketIndex = Math.floor(i2 / bucketSize);\n        const x2 = compressionLevel === 0 ? data.getFloat32(splatOffset + 0, true) : (data.getUint16(splatOffset + 0, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 0];\n        const y = compressionLevel === 0 ? data.getFloat32(splatOffset + 4, true) : (data.getUint16(splatOffset + 2, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 1];\n        const z = compressionLevel === 0 ? data.getFloat32(splatOffset + 8, true) : (data.getUint16(splatOffset + 4, true) - compressionScaleRange) * compressionScaleFactor + bucketArray[3 * bucketIndex + 2];\n        const scaleX = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 0, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 0, true));\n        const scaleY = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 4, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 2, true));\n        const scaleZ = compressionLevel === 0 ? data.getFloat32(splatOffset + scaleOffsetBytes + 8, true) : fromHalf(data.getUint16(splatOffset + scaleOffsetBytes + 4, true));\n        const quatW = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 0, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 0, true)\n        );\n        const quatX = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 4, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 2, true)\n        );\n        const quatY = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 8, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 4, true)\n        );\n        const quatZ = compressionLevel === 0 ? data.getFloat32(splatOffset + rotationOffsetBytes + 12, true) : fromHalf(\n          data.getUint16(splatOffset + rotationOffsetBytes + 6, true)\n        );\n        const r = data.getUint8(splatOffset + colorOffsetBytes + 0) / 255;\n        const g = data.getUint8(splatOffset + colorOffsetBytes + 1) / 255;\n        const b = data.getUint8(splatOffset + colorOffsetBytes + 2) / 255;\n        const opacity = data.getUint8(splatOffset + colorOffsetBytes + 3) / 255;\n        setPackedSplat(\n          packedArray,\n          i2,\n          x2,\n          y,\n          z,\n          scaleX,\n          scaleY,\n          scaleZ,\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n        if (sphericalHarmonicsDegree >= 1) {\n          if (sh1) {\n            if (!extra.sh1) {\n              extra.sh1 = new Uint32Array(numSplats * 2);\n            }\n            for (const [i22, key] of sh1Index.entries()) {\n              sh1[i22] = getSh(splatOffset, key);\n            }\n            encodeSh1Rgb(extra.sh1, i2, sh1);\n          }\n          if (sh2) {\n            if (!extra.sh2) {\n              extra.sh2 = new Uint32Array(numSplats * 4);\n            }\n            for (const [i22, key] of sh2Index.entries()) {\n              sh2[i22] = getSh(splatOffset, key);\n            }\n            encodeSh2Rgb(extra.sh2, i2, sh2);\n          }\n          if (sh3) {\n            if (!extra.sh3) {\n              extra.sh3 = new Uint32Array(numSplats * 4);\n            }\n            for (const [i22, key] of sh3Index.entries()) {\n              sh3[i22] = getSh(splatOffset, key);\n            }\n            encodeSh3Rgb(extra.sh3, i2, sh3);\n          }\n        }\n      }\n      sectionBase += storageSizeBytes;\n    }\n    return { packedArray, numSplats, extra };\n  }\n  const _PlyReader = class _PlyReader {\n    // Create a PlyReader from a Uint8Array/ArrayBuffer, no parsing done yet\n    constructor({ fileBytes }) {\n      this.header = \"\";\n      this.littleEndian = true;\n      this.elements = {};\n      this.comments = [];\n      this.data = null;\n      this.numSplats = 0;\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n    }\n    // Identify and parse the PLY text header (assumed to be <64KB in size).\n    // this.elements will contain all the elements in the file, typically\n    // \"vertex\" contains the Gsplat data.\n    async parseHeader() {\n      const bufferStream = new ReadableStream({\n        start: (controller) => {\n          controller.enqueue(this.fileBytes.slice(0, 65536));\n          controller.close();\n        }\n      });\n      const decoder = bufferStream.pipeThrough(new TextDecoderStream()).getReader();\n      this.header = \"\";\n      const headerTerminator = \"end_header\\\\n\";\n      while (true) {\n        const { value, done } = await decoder.read();\n        if (done) {\n          throw new Error(\"Failed to read header\");\n        }\n        this.header += value;\n        const endHeader = this.header.indexOf(headerTerminator);\n        if (endHeader >= 0) {\n          this.header = this.header.slice(0, endHeader + headerTerminator.length);\n          break;\n        }\n      }\n      const headerLen = new TextEncoder().encode(this.header).length;\n      this.data = new DataView(this.fileBytes.buffer, headerLen);\n      this.elements = {};\n      let curElement = null;\n      this.comments = [];\n      this.header.trim().split(\"\\\\n\").forEach((line, lineIndex) => {\n        const trimmedLine = line.trim();\n        if (lineIndex === 0) {\n          if (trimmedLine !== \"ply\") {\n            throw new Error(\"Invalid PLY header\");\n          }\n          return;\n        }\n        if (trimmedLine.length === 0) {\n          return;\n        }\n        const fields = trimmedLine.split(\" \");\n        switch (fields[0]) {\n          case \"format\":\n            if (fields[1] === \"binary_little_endian\") {\n              this.littleEndian = true;\n            } else if (fields[1] === \"binary_big_endian\") {\n              this.littleEndian = false;\n            } else {\n              throw new Error(\\`Unsupported PLY format: \\${fields[1]}\\`);\n            }\n            if (fields[2] !== \"1.0\") {\n              throw new Error(\\`Unsupported PLY version: \\${fields[2]}\\`);\n            }\n            break;\n          case \"end_header\":\n            break;\n          case \"comment\":\n            this.comments.push(trimmedLine.slice(\"comment \".length));\n            break;\n          case \"element\": {\n            const name = fields[1];\n            curElement = {\n              name,\n              count: Number.parseInt(fields[2]),\n              properties: {}\n            };\n            this.elements[name] = curElement;\n            break;\n          }\n          case \"property\":\n            if (curElement == null) {\n              throw new Error(\"Property must be inside an element\");\n            }\n            if (fields[1] === \"list\") {\n              curElement.properties[fields[4]] = {\n                isList: true,\n                type: fields[3],\n                countType: fields[2]\n              };\n            } else {\n              curElement.properties[fields[2]] = {\n                isList: false,\n                type: fields[1]\n              };\n            }\n            break;\n        }\n      });\n      if (this.elements.vertex) {\n        this.numSplats = this.elements.vertex.count;\n      }\n    }\n    parseData(elementCallback) {\n      let offset = 0;\n      const data = this.data;\n      if (data == null) {\n        throw new Error(\"No data to parse\");\n      }\n      for (const elementName in this.elements) {\n        const element = this.elements[elementName];\n        const { count, properties } = element;\n        const item = {};\n        const parsers = [];\n        for (const [propertyName, property] of Object.entries(properties)) {\n          if (!property.isList) {\n            item[propertyName] = 0;\n            parsers.push(() => {\n              item[propertyName] = PARSE_FIELD[property.type](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.type];\n            });\n          } else {\n            item[propertyName] = [];\n            parsers.push(() => {\n              const list = item[propertyName];\n              list.length = PARSE_FIELD[property.countType](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.countType];\n              for (let i2 = 0; i2 < list.length; i2++) {\n                list[i2] = PARSE_FIELD[property.type](\n                  data,\n                  offset,\n                  this.littleEndian\n                );\n                offset += FIELD_BYTES[property.type];\n              }\n            });\n          }\n        }\n        const callback = elementCallback(element) ?? (() => {\n        });\n        for (let index = 0; index < count; index++) {\n          for (const parser of parsers) {\n            parser();\n          }\n          callback(index, item);\n        }\n      }\n    }\n    // Parse all the Gsplat data in the PLY file in go, invoking the given\n    // callbacks for each Gsplat.\n    parseSplats(splatCallback, shCallback) {\n      if (this.elements.vertex == null) {\n        throw new Error(\"No vertex element found\");\n      }\n      let isSuperSplat = false;\n      const ssChunks = [];\n      let numSh = 0;\n      let sh1Props = [];\n      let sh2Props = [];\n      let sh3Props = [];\n      let sh1 = void 0;\n      let sh2 = void 0;\n      let sh3 = void 0;\n      function prepareSh() {\n        const num_f_rest = NUM_SH_TO_NUM_F_REST[numSh];\n        sh1Props = new Array(3).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => \\`f_rest_\\${k + d * num_f_rest / 3}\\`)\n        );\n        sh2Props = new Array(5).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => \\`f_rest_\\${3 + k + d * num_f_rest / 3}\\`)\n        );\n        sh3Props = new Array(7).fill(null).flatMap(\n          (_, k) => [0, 1, 2].map((_2, d) => \\`f_rest_\\${8 + k + d * num_f_rest / 3}\\`)\n        );\n        sh1 = numSh >= 1 ? new Float32Array(3 * 3) : void 0;\n        sh2 = numSh >= 2 ? new Float32Array(5 * 3) : void 0;\n        sh3 = numSh >= 3 ? new Float32Array(7 * 3) : void 0;\n      }\n      function ssShCallback(index, item) {\n        if (!sh1) {\n          throw new Error(\"Missing sh1\");\n        }\n        for (const [i2, key] of sh1Props.entries()) {\n          sh1[i2] = item[key] * 8 / 255 - 4;\n        }\n        if (sh2) {\n          for (const [i2, key] of sh2Props.entries()) {\n            sh2[i2] = item[key] * 8 / 255 - 4;\n          }\n        }\n        if (sh3) {\n          for (const [i2, key] of sh3Props.entries()) {\n            sh3[i2] = item[key] * 8 / 255 - 4;\n          }\n        }\n        shCallback == null ? void 0 : shCallback(index, sh1, sh2, sh3);\n      }\n      function initSuperSplat(element) {\n        const {\n          min_x,\n          min_y,\n          min_z,\n          max_x,\n          max_y,\n          max_z,\n          min_scale_x,\n          min_scale_y,\n          min_scale_z,\n          max_scale_x,\n          max_scale_y,\n          max_scale_z,\n          min_r,\n          min_g,\n          min_b,\n          max_r,\n          max_g,\n          max_b\n        } = element.properties;\n        if (!min_x || !min_y || !min_z || !max_x || !max_y || !max_z || !min_scale_x || !min_scale_y || !min_scale_z || !max_scale_x || !max_scale_y || !max_scale_z || !min_r || !min_g || !min_b || !max_r || !max_g || !max_b) {\n          throw new Error(\"Missing PLY chunk properties\");\n        }\n        isSuperSplat = true;\n        return (index, item) => {\n          const {\n            min_x: min_x2,\n            min_y: min_y2,\n            min_z: min_z2,\n            max_x: max_x2,\n            max_y: max_y2,\n            max_z: max_z2,\n            min_scale_x: min_scale_x2,\n            min_scale_y: min_scale_y2,\n            min_scale_z: min_scale_z2,\n            max_scale_x: max_scale_x2,\n            max_scale_y: max_scale_y2,\n            max_scale_z: max_scale_z2,\n            min_r: min_r2,\n            min_g: min_g2,\n            min_b: min_b2,\n            max_r: max_r2,\n            max_g: max_g2,\n            max_b: max_b2\n          } = item;\n          ssChunks.push({\n            min_x: min_x2,\n            min_y: min_y2,\n            min_z: min_z2,\n            max_x: max_x2,\n            max_y: max_y2,\n            max_z: max_z2,\n            min_scale_x: min_scale_x2,\n            min_scale_y: min_scale_y2,\n            min_scale_z: min_scale_z2,\n            max_scale_x: max_scale_x2,\n            max_scale_y: max_scale_y2,\n            max_scale_z: max_scale_z2,\n            min_r: min_r2,\n            min_g: min_g2,\n            min_b: min_b2,\n            max_r: max_r2,\n            max_g: max_g2,\n            max_b: max_b2\n          });\n        };\n      }\n      function decodeSuperSplat(element) {\n        if (shCallback && element.name === \"sh\") {\n          numSh = getNumSh(element.properties);\n          prepareSh();\n          return ssShCallback;\n        }\n        if (element.name !== \"vertex\") {\n          return null;\n        }\n        const { packed_position, packed_rotation, packed_scale, packed_color } = element.properties;\n        if (!packed_position || !packed_rotation || !packed_scale || !packed_color) {\n          throw new Error(\n            \"Missing PLY properties: packed_position, packed_rotation, packed_scale, packed_color\"\n          );\n        }\n        const SQRT2 = Math.sqrt(2);\n        return (index, item) => {\n          const chunk = ssChunks[index >>> 8];\n          if (chunk == null) {\n            throw new Error(\"Missing PLY chunk\");\n          }\n          const {\n            min_x,\n            min_y,\n            min_z,\n            max_x,\n            max_y,\n            max_z,\n            min_scale_x,\n            min_scale_y,\n            min_scale_z,\n            max_scale_x,\n            max_scale_y,\n            max_scale_z,\n            min_r,\n            min_g,\n            min_b,\n            max_r,\n            max_g,\n            max_b\n          } = chunk;\n          const { packed_position: packed_position2, packed_rotation: packed_rotation2, packed_scale: packed_scale2, packed_color: packed_color2 } = item;\n          const x2 = (packed_position2 >>> 21 & 2047) / 2047 * (max_x - min_x) + min_x;\n          const y = (packed_position2 >>> 11 & 1023) / 1023 * (max_y - min_y) + min_y;\n          const z = (packed_position2 & 2047) / 2047 * (max_z - min_z) + min_z;\n          const r0 = ((packed_rotation2 >>> 20 & 1023) / 1023 - 0.5) * SQRT2;\n          const r1 = ((packed_rotation2 >>> 10 & 1023) / 1023 - 0.5) * SQRT2;\n          const r2 = ((packed_rotation2 & 1023) / 1023 - 0.5) * SQRT2;\n          const rr = Math.sqrt(Math.max(0, 1 - r0 * r0 - r1 * r1 - r2 * r2));\n          const rOrder = packed_rotation2 >>> 30;\n          const quatX = rOrder === 0 ? r0 : rOrder === 1 ? rr : r1;\n          const quatY = rOrder <= 1 ? r1 : rOrder === 2 ? rr : r2;\n          const quatZ = rOrder <= 2 ? r2 : rr;\n          const quatW = rOrder === 0 ? rr : r0;\n          const scaleX = Math.exp(\n            (packed_scale2 >>> 21 & 2047) / 2047 * (max_scale_x - min_scale_x) + min_scale_x\n          );\n          const scaleY = Math.exp(\n            (packed_scale2 >>> 11 & 1023) / 1023 * (max_scale_y - min_scale_y) + min_scale_y\n          );\n          const scaleZ = Math.exp(\n            (packed_scale2 & 2047) / 2047 * (max_scale_z - min_scale_z) + min_scale_z\n          );\n          const r = (packed_color2 >>> 24 & 255) / 255 * (max_r - min_r) + min_r;\n          const g = (packed_color2 >>> 16 & 255) / 255 * (max_g - min_g) + min_g;\n          const b = (packed_color2 >>> 8 & 255) / 255 * (max_b - min_b) + min_b;\n          const opacity = (packed_color2 & 255) / 255;\n          splatCallback(\n            index,\n            x2,\n            y,\n            z,\n            scaleX,\n            scaleY,\n            scaleZ,\n            quatX,\n            quatY,\n            quatZ,\n            quatW,\n            opacity,\n            r,\n            g,\n            b\n          );\n        };\n      }\n      const elementCallback = (element) => {\n        if (element.name === \"chunk\") {\n          return initSuperSplat(element);\n        }\n        if (isSuperSplat) {\n          return decodeSuperSplat(element);\n        }\n        if (element.name !== \"vertex\") {\n          return null;\n        }\n        const {\n          x: x2,\n          y,\n          z,\n          scale_0,\n          scale_1,\n          scale_2,\n          rot_0,\n          rot_1,\n          rot_2,\n          rot_3,\n          opacity,\n          f_dc_0,\n          f_dc_1,\n          f_dc_2,\n          red,\n          green,\n          blue,\n          alpha\n        } = element.properties;\n        if (!x2 || !y || !z) {\n          throw new Error(\"Missing PLY properties: x, y, z\");\n        }\n        const hasScales = scale_0 && scale_1 && scale_2;\n        const hasRots = rot_0 && rot_1 && rot_2 && rot_3;\n        const alphaDiv = alpha != null ? FIELD_SCALE[alpha.type] : 1;\n        const redDiv = red != null ? FIELD_SCALE[red.type] : 1;\n        const greenDiv = green != null ? FIELD_SCALE[green.type] : 1;\n        const blueDiv = blue != null ? FIELD_SCALE[blue.type] : 1;\n        numSh = getNumSh(element.properties);\n        prepareSh();\n        return (index, item) => {\n          const scaleX = hasScales ? Math.exp(item.scale_0) : _PlyReader.defaultPointScale;\n          const scaleY = hasScales ? Math.exp(item.scale_1) : _PlyReader.defaultPointScale;\n          const scaleZ = hasScales ? Math.exp(item.scale_2) : _PlyReader.defaultPointScale;\n          const quatX = hasRots ? item.rot_1 : 0;\n          const quatY = hasRots ? item.rot_2 : 0;\n          const quatZ = hasRots ? item.rot_3 : 0;\n          const quatW = hasRots ? item.rot_0 : 1;\n          const op = opacity != null ? 1 / (1 + Math.exp(-item.opacity)) : alpha != null ? item.alpha / alphaDiv : 1;\n          const r = f_dc_0 != null ? item.f_dc_0 * SH_C0$1 + 0.5 : red != null ? item.red / redDiv : 1;\n          const g = f_dc_1 != null ? item.f_dc_1 * SH_C0$1 + 0.5 : green != null ? item.green / greenDiv : 1;\n          const b = f_dc_2 != null ? item.f_dc_2 * SH_C0$1 + 0.5 : blue != null ? item.blue / blueDiv : 1;\n          splatCallback(\n            index,\n            item.x,\n            item.y,\n            item.z,\n            scaleX,\n            scaleY,\n            scaleZ,\n            quatX,\n            quatY,\n            quatZ,\n            quatW,\n            op,\n            r,\n            g,\n            b\n          );\n          if (shCallback && sh1) {\n            if (sh1) {\n              for (const [i2, key] of sh1Props.entries()) {\n                sh1[i2] = item[key];\n              }\n            }\n            if (sh2) {\n              for (const [i2, key] of sh2Props.entries()) {\n                sh2[i2] = item[key];\n              }\n            }\n            if (sh3) {\n              for (const [i2, key] of sh3Props.entries()) {\n                sh3[i2] = item[key];\n              }\n            }\n            shCallback(index, sh1, sh2, sh3);\n          }\n        };\n      };\n      this.parseData(elementCallback);\n    }\n    // Inject RGBA values into original PLY file, which can be used to modify\n    // the color/opacity of the Gsplats and write out the modified PLY file.\n    injectRgba(rgba) {\n      let offset = 0;\n      const data = this.data;\n      if (data == null) {\n        throw new Error(\"No parsed data\");\n      }\n      if (rgba.length !== this.numSplats * 4) {\n        throw new Error(\"Invalid RGBA array length\");\n      }\n      for (const elementName in this.elements) {\n        const element = this.elements[elementName];\n        const { count, properties } = element;\n        const parsers = [];\n        let rgbaOffset = 0;\n        const isVertex = elementName === \"vertex\";\n        if (isVertex) {\n          for (const name of [\"opacity\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"]) {\n            if (!properties[name] || properties[name].type !== \"float\") {\n              throw new Error(\\`Can't injectRgba due to property: \\${name}\\`);\n            }\n          }\n        }\n        for (const [propertyName, property] of Object.entries(properties)) {\n          if (!property.isList) {\n            if (isVertex) {\n              if (propertyName === \"f_dc_0\" || propertyName === \"f_dc_1\" || propertyName === \"f_dc_2\") {\n                const component = Number.parseInt(\n                  propertyName.slice(\"f_dc_\".length)\n                );\n                parsers.push(() => {\n                  const value = (rgba[rgbaOffset + component] / 255 - 0.5) / SH_C0$1;\n                  SET_FIELD[property.type](\n                    data,\n                    offset,\n                    this.littleEndian,\n                    value\n                  );\n                });\n              } else if (propertyName === \"opacity\") {\n                parsers.push(() => {\n                  const value = Math.max(\n                    -100,\n                    Math.min(\n                      100,\n                      -Math.log(1 / (rgba[rgbaOffset + 3] / 255) - 1)\n                    )\n                  );\n                  SET_FIELD[property.type](\n                    data,\n                    offset,\n                    this.littleEndian,\n                    value\n                  );\n                });\n              }\n            }\n            parsers.push(() => {\n              offset += FIELD_BYTES[property.type];\n            });\n          } else {\n            parsers.push(() => {\n              const length = PARSE_FIELD[property.countType](\n                data,\n                offset,\n                this.littleEndian\n              );\n              offset += FIELD_BYTES[property.countType];\n              offset += length * FIELD_BYTES[property.type];\n            });\n          }\n        }\n        for (let index = 0; index < count; index++) {\n          for (const parser of parsers) {\n            parser();\n          }\n          if (isVertex) {\n            rgbaOffset += 4;\n          }\n        }\n      }\n    }\n  };\n  _PlyReader.defaultPointScale = 1e-3;\n  let PlyReader = _PlyReader;\n  const SH_C0$1 = 0.28209479177387814;\n  const PARSE_FIELD = {\n    char: (data, offset, littleEndian) => {\n      return data.getInt8(offset);\n    },\n    uchar: (data, offset, littleEndian) => {\n      return data.getUint8(offset);\n    },\n    short: (data, offset, littleEndian) => {\n      return data.getInt16(offset, littleEndian);\n    },\n    ushort: (data, offset, littleEndian) => {\n      return data.getUint16(offset, littleEndian);\n    },\n    int: (data, offset, littleEndian) => {\n      return data.getInt32(offset, littleEndian);\n    },\n    uint: (data, offset, littleEndian) => {\n      return data.getUint32(offset, littleEndian);\n    },\n    float: (data, offset, littleEndian) => {\n      return data.getFloat32(offset, littleEndian);\n    },\n    double: (data, offset, littleEndian) => {\n      return data.getFloat64(offset, littleEndian);\n    }\n  };\n  const SET_FIELD = {\n    char: (data, offset, littleEndian, value) => {\n      data.setInt8(offset, value);\n    },\n    uchar: (data, offset, littleEndian, value) => {\n      data.setUint8(offset, value);\n    },\n    short: (data, offset, littleEndian, value) => {\n      data.setInt16(offset, value, littleEndian);\n    },\n    ushort: (data, offset, littleEndian, value) => {\n      data.setUint16(offset, value, littleEndian);\n    },\n    int: (data, offset, littleEndian, value) => {\n      data.setInt32(offset, value, littleEndian);\n    },\n    uint: (data, offset, littleEndian, value) => {\n      data.setUint32(offset, value, littleEndian);\n    },\n    float: (data, offset, littleEndian, value) => {\n      data.setFloat32(offset, value, littleEndian);\n    },\n    double: (data, offset, littleEndian, value) => {\n      data.setFloat64(offset, value, littleEndian);\n    }\n  };\n  const FIELD_BYTES = {\n    char: 1,\n    uchar: 1,\n    short: 2,\n    ushort: 2,\n    int: 4,\n    uint: 4,\n    float: 4,\n    double: 8\n  };\n  const FIELD_SCALE = {\n    char: 127,\n    uchar: 255,\n    short: 32767,\n    ushort: 65535,\n    int: 2147483647,\n    uint: 4294967295,\n    float: 1,\n    double: 1\n  };\n  const NUM_F_REST_TO_NUM_SH = {\n    0: 0,\n    9: 1,\n    24: 2,\n    45: 3\n  };\n  const NUM_SH_TO_NUM_F_REST = {\n    0: 0,\n    1: 9,\n    2: 24,\n    3: 45\n  };\n  function getNumSh(properties) {\n    let num_f_rest = 0;\n    while (properties[\\`f_rest_\\${num_f_rest}\\`]) {\n      num_f_rest += 1;\n    }\n    const numSh = NUM_F_REST_TO_NUM_SH[num_f_rest];\n    if (numSh == null) {\n      throw new Error(\\`Unsupported number of SH coefficients: \\${num_f_rest}\\`);\n    }\n    return numSh;\n  }\n  const Gsplat = { type: \"Gsplat\" };\n  const TPackedSplats = { type: \"PackedSplats\" };\n  const readPackedSplat = (packedSplats, index) => new ReadPackedSplat({ packedSplats, index });\n  const readPackedSplatRange = (packedSplats, index, base, count) => new ReadPackedSplatRange({ packedSplats, index, base, count });\n  const splitGsplat = (gsplat) => new SplitGsplat({ gsplat });\n  const combineGsplat = ({\n    gsplat,\n    flags,\n    index,\n    center,\n    scales,\n    quaternion,\n    rgba,\n    rgb,\n    opacity,\n    x: x2,\n    y,\n    z,\n    r,\n    g,\n    b\n  }) => {\n    return new CombineGsplat({\n      gsplat,\n      flags,\n      index,\n      center,\n      scales,\n      quaternion,\n      rgba,\n      rgb,\n      opacity,\n      x: x2,\n      y,\n      z,\n      r,\n      g,\n      b\n    });\n  };\n  const transformGsplat = (gsplat, {\n    scale,\n    rotate,\n    translate,\n    recolor\n  }) => {\n    return new TransformGsplat({ gsplat, scale, rotate, translate, recolor });\n  };\n  const defineGsplat = unindent(\\`\n  struct Gsplat {\n    vec3 center;\n    uint flags;\n    vec3 scales;\n    int index;\n    vec4 quaternion;\n    vec4 rgba;\n  };\n  const uint GSPLAT_FLAG_ACTIVE = 1u << 0u;\n\n  bool isGsplatActive(uint flags) {\n    return (flags & GSPLAT_FLAG_ACTIVE) != 0u;\n  }\n\\`);\n  const definePackedSplats = unindent(\\`\n  struct PackedSplats {\n    usampler2DArray texture;\n    int numSplats;\n  };\n\\`);\n  const defineReadPackedSplat = unindent(\\`\n  bool readPackedSplat(usampler2DArray texture, int numSplats, int index, out Gsplat gsplat) {\n    if ((index >= 0) && (index < numSplats)) {\n      uvec4 packed = texelFetch(texture, splatTexCoord(index), 0);\n      unpackSplat(packed, gsplat.center, gsplat.scales, gsplat.quaternion, gsplat.rgba);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\\`);\n  class ReadPackedSplat extends Dyno {\n    constructor({\n      packedSplats,\n      index\n    }) {\n      super({\n        inTypes: { packedSplats: TPackedSplats, index: \"int\" },\n        outTypes: { gsplat: Gsplat },\n        inputs: { packedSplats, index },\n        globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat } = outputs;\n          if (!gsplat) {\n            return [];\n          }\n          const { packedSplats: packedSplats2, index: index2 } = inputs;\n          let statements;\n          if (packedSplats2 && index2) {\n            statements = unindentLines(\\`\n            if (readPackedSplat(\\${packedSplats2}.texture, \\${packedSplats2}.numSplats, \\${index2}, \\${gsplat})) {\n              bool zeroSize = all(equal(\\${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n              \\${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n            } else {\n              \\${gsplat}.flags = 0u;\n            }\n          \\`);\n          } else {\n            statements = [\\`\\${gsplat}.flags = 0u;\\`];\n          }\n          statements.push(\\`\\${gsplat}.index = \\${index2 ?? \"0\"};\\`);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, \"gsplat\");\n    }\n  }\n  class ReadPackedSplatRange extends Dyno {\n    constructor({\n      packedSplats,\n      index,\n      base,\n      count\n    }) {\n      super({\n        inTypes: {\n          packedSplats: TPackedSplats,\n          index: \"int\",\n          base: \"int\",\n          count: \"int\"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: { packedSplats, index, base, count },\n        globals: () => [defineGsplat, definePackedSplats, defineReadPackedSplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat } = outputs;\n          if (!gsplat) {\n            return [];\n          }\n          const { packedSplats: packedSplats2, index: index2, base: base2, count: count2 } = inputs;\n          let statements;\n          if (packedSplats2 && index2 && base2 && count2) {\n            statements = unindentLines(\\`\n            \\${gsplat}.flags = 0u;\n            if ((\\${index2} >= \\${base2}) && (\\${index2} < (\\${base2} + \\${count2}))) {\n              if (readPackedSplat(\\${packedSplats2}.texture, \\${packedSplats2}.numSplats, \\${index2}, \\${gsplat})) {\n                bool zeroSize = all(equal(\\${gsplat}.scales, vec3(0.0, 0.0, 0.0)));\n                \\${gsplat}.flags = zeroSize ? 0u : GSPLAT_FLAG_ACTIVE;\n              }\n            }\n          \\`);\n          } else {\n            statements = [\\`\\${gsplat}.flags = 0u;\\`];\n          }\n          statements.push(\\`\\${gsplat}.index = \\${index2 ?? \"0\"};\\`);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, \"gsplat\");\n    }\n  }\n  class SplitGsplat extends Dyno {\n    constructor({ gsplat }) {\n      super({\n        inTypes: { gsplat: Gsplat },\n        outTypes: {\n          flags: \"uint\",\n          active: \"bool\",\n          index: \"int\",\n          center: \"vec3\",\n          scales: \"vec3\",\n          quaternion: \"vec4\",\n          rgba: \"vec4\",\n          rgb: \"vec3\",\n          opacity: \"float\",\n          x: \"float\",\n          y: \"float\",\n          z: \"float\",\n          r: \"float\",\n          g: \"float\",\n          b: \"float\"\n        },\n        inputs: { gsplat },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat: gsplat2 } = inputs;\n          const {\n            flags,\n            active,\n            index,\n            center,\n            scales,\n            quaternion,\n            rgba,\n            rgb,\n            opacity,\n            x: x2,\n            y,\n            z,\n            r,\n            g,\n            b\n          } = outputs;\n          return [\n            !flags ? null : \\`\\${flags} = \\${gsplat2 ? \\`\\${gsplat2}.flags\\` : \"0u\"};\\`,\n            !active ? null : \\`\\${active} = isGsplatActive(\\${gsplat2 ? \\`\\${gsplat2}.flags\\` : \"0u\"});\\`,\n            !index ? null : \\`\\${index} = \\${gsplat2 ? \\`\\${gsplat2}.index\\` : \"0\"};\\`,\n            !center ? null : \\`\\${center} = \\${gsplat2 ? \\`\\${gsplat2}.center\\` : \"vec3(0.0, 0.0, 0.0)\"};\\`,\n            !scales ? null : \\`\\${scales} = \\${gsplat2 ? \\`\\${gsplat2}.scales\\` : \"vec3(0.0, 0.0, 0.0)\"};\\`,\n            !quaternion ? null : \\`\\${quaternion} = \\${gsplat2 ? \\`\\${gsplat2}.quaternion\\` : \"vec4(0.0, 0.0, 0.0, 1.0)\"};\\`,\n            !rgba ? null : \\`\\${rgba} = \\${gsplat2 ? \\`\\${gsplat2}.rgba\\` : \"vec4(0.0, 0.0, 0.0, 0.0)\"};\\`,\n            !rgb ? null : \\`\\${rgb} = \\${gsplat2 ? \\`\\${gsplat2}.rgba.rgb\\` : \"vec3(0.0, 0.0, 0.0)\"};\\`,\n            !opacity ? null : \\`\\${opacity} = \\${gsplat2 ? \\`\\${gsplat2}.rgba.a\\` : \"0.0\"};\\`,\n            !x2 ? null : \\`\\${x2} = \\${gsplat2 ? \\`\\${gsplat2}.center.x\\` : \"0.0\"};\\`,\n            !y ? null : \\`\\${y} = \\${gsplat2 ? \\`\\${gsplat2}.center.y\\` : \"0.0\"};\\`,\n            !z ? null : \\`\\${z} = \\${gsplat2 ? \\`\\${gsplat2}.center.z\\` : \"0.0\"};\\`,\n            !r ? null : \\`\\${r} = \\${gsplat2 ? \\`\\${gsplat2}.rgba.r\\` : \"0.0\"};\\`,\n            !g ? null : \\`\\${g} = \\${gsplat2 ? \\`\\${gsplat2}.rgba.g\\` : \"0.0\"};\\`,\n            !b ? null : \\`\\${b} = \\${gsplat2 ? \\`\\${gsplat2}.rgba.b\\` : \"0.0\"};\\`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  class CombineGsplat extends Dyno {\n    constructor({\n      gsplat,\n      flags,\n      index,\n      center,\n      scales,\n      quaternion,\n      rgba,\n      rgb,\n      opacity,\n      x: x2,\n      y,\n      z,\n      r,\n      g,\n      b\n    }) {\n      super({\n        inTypes: {\n          gsplat: Gsplat,\n          flags: \"uint\",\n          index: \"int\",\n          center: \"vec3\",\n          scales: \"vec3\",\n          quaternion: \"vec4\",\n          rgba: \"vec4\",\n          rgb: \"vec3\",\n          opacity: \"float\",\n          x: \"float\",\n          y: \"float\",\n          z: \"float\",\n          r: \"float\",\n          g: \"float\",\n          b: \"float\"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: {\n          gsplat,\n          flags,\n          index,\n          center,\n          scales,\n          quaternion,\n          rgba,\n          rgb,\n          opacity,\n          x: x2,\n          y,\n          z,\n          r,\n          g,\n          b\n        },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { gsplat: outGsplat } = outputs;\n          if (!outGsplat) {\n            return [];\n          }\n          const {\n            gsplat: gsplat2,\n            flags: flags2,\n            index: index2,\n            center: center2,\n            scales: scales2,\n            quaternion: quaternion2,\n            rgba: rgba2,\n            rgb: rgb2,\n            opacity: opacity2,\n            x: x22,\n            y: y2,\n            z: z2,\n            r: r2,\n            g: g2,\n            b: b2\n          } = inputs;\n          return [\n            \\`\\${outGsplat}.flags = \\${flags2 ?? (gsplat2 ? \\`\\${gsplat2}.flags\\` : \"0u\")};\\`,\n            \\`\\${outGsplat}.index = \\${index2 ?? (gsplat2 ? \\`\\${gsplat2}.index\\` : \"0\")};\\`,\n            \\`\\${outGsplat}.center = \\${center2 ?? (gsplat2 ? \\`\\${gsplat2}.center\\` : \"vec3(0.0, 0.0, 0.0)\")};\\`,\n            \\`\\${outGsplat}.scales = \\${scales2 ?? (gsplat2 ? \\`\\${gsplat2}.scales\\` : \"vec3(0.0, 0.0, 0.0)\")};\\`,\n            \\`\\${outGsplat}.quaternion = \\${quaternion2 ?? (gsplat2 ? \\`\\${gsplat2}.quaternion\\` : \"vec4(0.0, 0.0, 0.0, 1.0)\")};\\`,\n            \\`\\${outGsplat}.rgba = \\${rgba2 ?? (gsplat2 ? \\`\\${gsplat2}.rgba\\` : \"vec4(0.0, 0.0, 0.0, 0.0)\")};\\`,\n            !rgb2 ? null : \\`\\${outGsplat}.rgba.rgb = \\${rgb2};\\`,\n            !opacity2 ? null : \\`\\${outGsplat}.rgba.a = \\${opacity2};\\`,\n            !x22 ? null : \\`\\${outGsplat}.center.x = \\${x22};\\`,\n            !y2 ? null : \\`\\${outGsplat}.center.y = \\${y2};\\`,\n            !z2 ? null : \\`\\${outGsplat}.center.z = \\${z2};\\`,\n            !r2 ? null : \\`\\${outGsplat}.rgba.r = \\${r2};\\`,\n            !g2 ? null : \\`\\${outGsplat}.rgba.g = \\${g2};\\`,\n            !b2 ? null : \\`\\${outGsplat}.rgba.b = \\${b2};\\`\n          ].filter(Boolean);\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, \"gsplat\");\n    }\n  }\n  unindent(\\`\n  vec3 gsplatNormal(vec3 scales, vec4 quaternion) {\n    float minScale = min(scales.x, min(scales.y, scales.z));\n    vec3 normal;\n    if (scales.z == minScale) {\n      normal = vec3(0.0, 0.0, 1.0);\n    } else if (scales.y == minScale) {\n      normal = vec3(0.0, 1.0, 0.0);\n    } else {\n      normal = vec3(1.0, 0.0, 0.0);\n    }\n    return quatVec(quaternion, normal);\n  }\n\\`);\n  class TransformGsplat extends Dyno {\n    constructor({\n      gsplat,\n      scale,\n      rotate,\n      translate,\n      recolor\n    }) {\n      super({\n        inTypes: {\n          gsplat: Gsplat,\n          scale: \"float\",\n          rotate: \"vec4\",\n          translate: \"vec3\",\n          recolor: \"vec4\"\n        },\n        outTypes: { gsplat: Gsplat },\n        inputs: { gsplat, scale, rotate, translate, recolor },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs, compile }) => {\n          const { gsplat: gsplat2 } = outputs;\n          if (!gsplat2 || !inputs.gsplat) {\n            return [];\n          }\n          const { scale: scale2, rotate: rotate2, translate: translate2, recolor: recolor2 } = inputs;\n          const indent = compile.indent;\n          const statements = [\n            \\`\\${gsplat2} = \\${inputs.gsplat};\\`,\n            \\`if (isGsplatActive(\\${gsplat2}.flags)) {\\`,\n            scale2 ? \\`\\${indent}\\${gsplat2}.center *= \\${scale2};\\` : null,\n            rotate2 ? \\`\\${indent}\\${gsplat2}.center = quatVec(\\${rotate2}, \\${gsplat2}.center);\\` : null,\n            translate2 ? \\`\\${indent}\\${gsplat2}.center += \\${translate2};\\` : null,\n            scale2 ? \\`\\${indent}\\${gsplat2}.scales *= \\${scale2};\\` : null,\n            rotate2 ? \\`\\${indent}\\${gsplat2}.quaternion = quatQuat(\\${rotate2}, \\${gsplat2}.quaternion);\\` : null,\n            recolor2 ? \\`\\${indent}\\${gsplat2}.rgba *= \\${recolor2};\\` : null,\n            \"}\"\n          ].filter(Boolean);\n          return statements;\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, \"gsplat\");\n    }\n  }\n  const outputPackedSplat = (gsplat) => new OutputPackedSplat({ gsplat });\n  class OutputPackedSplat extends Dyno {\n    constructor({ gsplat }) {\n      super({\n        inTypes: { gsplat: Gsplat },\n        inputs: { gsplat },\n        globals: () => [defineGsplat],\n        statements: ({ inputs, outputs }) => {\n          const { output } = outputs;\n          if (!output) {\n            return [];\n          }\n          const { gsplat: gsplat2 } = inputs;\n          if (gsplat2) {\n            return unindentLines(\\`\n            if (isGsplatActive(\\${gsplat2}.flags)) {\n              \\${output} = packSplat(\\${gsplat2}.center, \\${gsplat2}.scales, \\${gsplat2}.quaternion, \\${gsplat2}.rgba);\n            } else {\n              \\${output} = uvec4(0u, 0u, 0u, 0u);\n            }\n          \\`);\n          }\n          return [\\`\\${output} = uvec4(0u, 0u, 0u, 0u);\\`];\n        }\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, \"output\");\n    }\n  }\n  class OutputRgba8 extends Dyno {\n    constructor({ rgba8 }) {\n      super({\n        inTypes: { rgba8: \"vec4\" },\n        inputs: { rgba8 },\n        statements: ({ inputs, outputs }) => [\n          \\`target = \\${inputs.rgba8 ?? \"vec4(0.0, 0.0, 0.0, 0.0)\"};\\`\n        ]\n      });\n    }\n    dynoOut() {\n      return new DynoOutput(this, \"rgba8\");\n    }\n  }\n  class DynoUniform extends Dyno {\n    constructor({\n      key,\n      type,\n      count,\n      value,\n      update,\n      globals\n    }) {\n      key = key ?? \"value\";\n      super({\n        outTypes: { [key]: type },\n        update: () => {\n          if (update) {\n            const value2 = update(this.value);\n            if (value2 !== void 0) {\n              this.value = value2;\n            }\n          }\n          this.uniform.value = this.value;\n        },\n        generate: ({ inputs, outputs }) => {\n          const allGlobals = (globals == null ? void 0 : globals({ inputs, outputs })) ?? [];\n          const uniforms = {};\n          const name = outputs[key];\n          if (name) {\n            allGlobals.push(\\`uniform \\${dynoDeclare(name, type, count)};\\`);\n            uniforms[name] = this.uniform;\n          }\n          return { globals: allGlobals, uniforms };\n        }\n      });\n      this.type = type;\n      this.count = count;\n      this.value = value;\n      this.uniform = { value };\n      this.outKey = key;\n    }\n    dynoOut() {\n      return new DynoOutput(this, this.outKey);\n    }\n  }\n  class DynoInt extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: \"int\", value, update });\n    }\n  }\n  class DynoFloat extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: \"float\", value, update });\n    }\n  }\n  class DynoVec3 extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: \"vec3\", value, update });\n    }\n  }\n  class DynoVec4 extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: \"vec4\", value, update });\n    }\n  }\n  class DynoUsampler2DArray extends DynoUniform {\n    constructor({\n      key,\n      value,\n      update\n    }) {\n      super({ key, type: \"usampler2DArray\", value, update });\n    }\n  }\n  class DynoProgram {\n    constructor({\n      graph,\n      inputs,\n      outputs,\n      template\n    }) {\n      this.graph = graph;\n      this.template = template;\n      this.inputs = inputs ?? {};\n      this.outputs = outputs ?? {};\n      const compile = new Compilation({ indent: this.template.indent });\n      for (const key in this.outputs) {\n        if (this.outputs[key]) {\n          compile.declares.add(this.outputs[key]);\n        }\n      }\n      const statements = graph.compile({\n        inputs: this.inputs,\n        outputs: this.outputs,\n        compile\n      });\n      this.shader = template.generate({ globals: compile.globals, statements });\n      this.uniforms = compile.uniforms;\n      this.updaters = compile.updaters;\n    }\n    prepareMaterial() {\n      return getMaterial(this);\n    }\n    update() {\n      for (const updater of this.updaters) {\n        updater();\n      }\n    }\n  }\n  class DynoProgramTemplate {\n    constructor(template) {\n      const globals = template.match(/^([ \\\\t]*)\\\\{\\\\{\\\\s*GLOBALS\\\\s*\\\\}\\\\}/m);\n      const statements = template.match(/^([ \\\\t]*)\\\\{\\\\{\\\\s*STATEMENTS\\\\s*\\\\}\\\\}/m);\n      if (!globals || !statements) {\n        throw new Error(\n          \"Template must contain {{ GLOBALS }} and {{ STATEMENTS }}\"\n        );\n      }\n      this.before = template.substring(0, globals.index);\n      this.between = template.substring(\n        globals.index + globals[0].length,\n        statements.index\n      );\n      this.after = template.substring(\n        statements.index + statements[0].length\n      );\n      this.indent = statements[1];\n    }\n    generate({\n      globals,\n      statements\n    }) {\n      return this.before + Array.from(globals).join(\"\\\\n\\\\n\") + this.between + statements.map((s) => this.indent + s).join(\"\\\\n\") + this.after;\n    }\n  }\n  const programMaterial = /* @__PURE__ */ new Map();\n  function getMaterial(program) {\n    let material = programMaterial.get(program);\n    if (material) {\n      return material;\n    }\n    material = new RawShaderMaterial({\n      glslVersion: GLSL3,\n      vertexShader: IDENT_VERTEX_SHADER,\n      fragmentShader: program.shader,\n      uniforms: program.uniforms\n    });\n    programMaterial.set(program, material);\n    return material;\n  }\n  function addOutputType(a, b, operation = \"add\") {\n    const error = () => {\n      throw new Error(\\`Invalid \\${operation} types: \\${a}, \\${b}\\`);\n    };\n    if (a === b) return a;\n    if (a === \"int\") {\n      if (isIntType(b)) return b;\n      error();\n    }\n    if (b === \"int\") {\n      if (isIntType(a)) return a;\n      error();\n    }\n    if (a === \"uint\") {\n      if (isUintType(b)) return b;\n      error();\n    }\n    if (b === \"uint\") {\n      if (isUintType(a)) return a;\n      error();\n    }\n    if (a === \"float\") {\n      if (isAllFloatType(b)) return b;\n      error();\n    }\n    if (b === \"float\") {\n      if (isAllFloatType(a)) return a;\n      error();\n    }\n    throw new Error(\\`Invalid \\${operation} types: \\${a}, \\${b}\\`);\n  }\n  function subOutputType(a, b) {\n    return addOutputType(a, b, \"sub\");\n  }\n  function mulOutputType(a, b) {\n    const error = () => {\n      throw new Error(\\`Invalid mul types: \\${a}, \\${b}\\`);\n    };\n    const result = (value) => value;\n    if (a === \"int\") {\n      if (isIntType(b)) return result(b);\n      error();\n    }\n    if (b === \"int\") {\n      if (isIntType(a)) return result(a);\n      error();\n    }\n    if (a === \"uint\") {\n      if (isUintType(b)) return result(b);\n      error();\n    }\n    if (b === \"uint\") {\n      if (isUintType(a)) return result(a);\n      error();\n    }\n    if (a === \"float\") {\n      if (isAllFloatType(b)) return result(b);\n      error();\n    }\n    if (b === \"float\") {\n      if (isAllFloatType(a)) return result(a);\n      error();\n    }\n    if (isIntType(a) || isUintType(a) || isIntType(b) || isUintType(b)) {\n      if (a === b) return result(a);\n      error();\n    }\n    if (a === \"vec2\") {\n      if (b === \"vec2\" || isMat2(b)) return result(\"vec2\");\n      if (b === \"mat3x2\") return result(\"vec3\");\n      if (b === \"mat4x2\") return result(\"vec4\");\n      error();\n    }\n    if (a === \"vec3\") {\n      if (b === \"mat2x3\") return result(\"vec2\");\n      if (b === \"vec3\" || isMat3(b)) return result(\"vec3\");\n      if (b === \"mat4x3\") return result(\"vec4\");\n      error();\n    }\n    if (a === \"vec4\") {\n      if (b === \"mat2x4\") return result(\"vec2\");\n      if (b === \"mat3x4\") return result(\"vec3\");\n      if (b === \"vec4\" || isMat4(b)) return result(\"vec4\");\n      error();\n    }\n    if (b === \"vec2\") {\n      if (isMat2(a)) return result(\"vec2\");\n      if (a === \"mat2x3\") return result(\"vec3\");\n      if (a === \"mat2x4\") return result(\"vec4\");\n      error();\n    }\n    if (b === \"vec3\") {\n      if (a === \"mat3x2\") return result(\"vec2\");\n      if (isMat3(a)) return result(\"vec3\");\n      if (a === \"mat3x4\") return result(\"vec4\");\n      error();\n    }\n    if (b === \"vec4\") {\n      if (a === \"mat4x2\") return result(\"vec2\");\n      if (a === \"mat4x3\") return result(\"vec3\");\n      if (isMat4(a)) return result(\"vec4\");\n      error();\n    }\n    if (isMat2(a)) {\n      if (isMat2(b)) return result(\"mat2\");\n      if (b === \"mat3x2\") return result(\"mat3x2\");\n      if (b === \"mat4x2\") return result(\"mat4x2\");\n      error();\n    }\n    if (a === \"mat2x3\") {\n      if (isMat2(b)) return result(\"mat2x3\");\n      if (b === \"mat3x2\") return result(\"mat3\");\n      if (b === \"mat4x2\") return result(\"mat4x3\");\n      error();\n    }\n    if (a === \"mat2x4\") {\n      if (isMat2(b)) return result(\"mat2x4\");\n      if (b === \"mat3x2\") return result(\"mat3x4\");\n      if (b === \"mat4x2\") return result(\"mat4\");\n      error();\n    }\n    if (a === \"mat3x2\") {\n      if (b === \"mat2x3\") return result(\"mat2\");\n      if (isMat3(b)) return result(\"mat3x2\");\n      if (b === \"mat4x3\") return result(\"mat4x2\");\n      error();\n    }\n    if (isMat3(a)) {\n      if (b === \"mat2x3\") return result(\"mat2x3\");\n      if (isMat3(b)) return result(\"mat3\");\n      if (b === \"mat4x3\") return result(\"mat4x3\");\n      error();\n    }\n    if (a === \"mat3x4\") {\n      if (b === \"mat2x3\") return result(\"mat2x4\");\n      if (isMat3(b)) return result(\"mat3x4\");\n      if (b === \"mat4x3\") return result(\"mat4\");\n      error();\n    }\n    if (a === \"mat4x2\") {\n      if (b === \"mat2x4\") return result(\"mat2\");\n      if (b === \"mat3x4\") return result(\"mat3x2\");\n      if (isMat4(b)) return result(\"mat4x2\");\n      error();\n    }\n    if (a === \"mat4x3\") {\n      if (b === \"mat2x4\") return result(\"mat2x3\");\n      if (b === \"mat3x4\") return result(\"mat3\");\n      if (isMat4(b)) return result(\"mat4x3\");\n      error();\n    }\n    if (isMat4(a)) {\n      if (b === \"mat2x4\") return result(\"mat2x4\");\n      if (b === \"mat3x4\") return result(\"mat3x4\");\n      if (isMat4(b)) return result(\"mat4\");\n      error();\n    }\n    throw new Error(\\`Invalid mul types: \\${a}, \\${b}\\`);\n  }\n  const add = (a, b) => new Add({ a, b });\n  const sub = (a, b) => new Sub({ a, b });\n  const mul = (a, b) => new Mul({ a, b });\n  class Add extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: \"sum\", outTypeFunc: addOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [\\`\\${outputs.sum} = \\${inputs.a} + \\${inputs.b};\\`];\n      };\n    }\n  }\n  class Sub extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: \"difference\", outTypeFunc: subOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [\\`\\${outputs.difference} = \\${inputs.a} - \\${inputs.b};\\`];\n      };\n    }\n  }\n  class Mul extends BinaryOp {\n    constructor({ a, b }) {\n      super({ a, b, outKey: \"product\", outTypeFunc: mulOutputType });\n      this.statements = ({ inputs, outputs }) => {\n        return [\\`\\${outputs.product} = \\${inputs.a} * \\${inputs.b};\\`];\n      };\n    }\n  }\n  const normalize = (a) => new Normalize({ a });\n  const extendVec = (a, b) => new ExtendVec({ a, b });\n  class Normalize extends UnaryOp {\n    constructor({ a }) {\n      super({ a, outTypeFunc: (aType) => aType, outKey: \"normalize\" });\n      this.statements = ({ inputs, outputs }) => [\n        \\`\\${outputs.normalize} = normalize(\\${inputs.a});\\`\n      ];\n    }\n  }\n  function extendVecOutputType(type) {\n    if (type === \"float\") return \"vec2\";\n    if (type === \"vec2\") return \"vec3\";\n    if (type === \"vec3\") return \"vec4\";\n    throw new Error(\"Invalid type\");\n  }\n  class ExtendVec extends BinaryOp {\n    constructor({ a, b }) {\n      const type = valType(a);\n      const outType = extendVecOutputType(type);\n      super({ a, b, outKey: \"extend\", outTypeFunc: () => outType });\n      this.statements = ({ inputs, outputs }) => [\n        \\`\\${outputs.extend} = \\${outType}(\\${inputs.a}, \\${inputs.b});\\`\n      ];\n    }\n  }\n  const transformPos = (position, {\n    scale,\n    scales,\n    rotate,\n    translate\n  }) => {\n    return new TransformPosition({ position, scale, scales, rotate, translate }).outputs.position;\n  };\n  const transformDir = (dir, {\n    scale,\n    scales,\n    rotate\n  }) => {\n    return new TransformDir({ dir, scale, scales, rotate }).outputs.dir;\n  };\n  class TransformPosition extends Dyno {\n    constructor({\n      position,\n      scale,\n      scales,\n      rotate,\n      translate\n    }) {\n      super({\n        inTypes: {\n          position: \"vec3\",\n          scale: \"float\",\n          scales: \"vec3\",\n          rotate: \"vec4\",\n          translate: \"vec3\"\n        },\n        outTypes: { position: \"vec3\" },\n        inputs: { position, scale, scales, rotate, translate },\n        statements: ({ inputs, outputs }) => {\n          const { position: position2 } = outputs;\n          if (!position2) {\n            return [];\n          }\n          const { scale: scale2, scales: scales2, rotate: rotate2, translate: translate2 } = inputs;\n          return [\n            \\`\\${position2} = \\${inputs.position ?? \"vec3(0.0, 0.0, 0.0)\"};\\`,\n            !scale2 ? null : \\`\\${position2} *= \\${scale2};\\`,\n            !scales2 ? null : \\`\\${position2} *= \\${scales2};\\`,\n            !rotate2 ? null : \\`\\${position2} = quatVec(\\${rotate2}, \\${position2});\\`,\n            !translate2 ? null : \\`\\${position2} += \\${translate2};\\`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  class TransformDir extends Dyno {\n    constructor({\n      dir,\n      scale,\n      scales,\n      rotate\n    }) {\n      super({\n        inTypes: { dir: \"vec3\", scale: \"float\", scales: \"vec3\", rotate: \"vec4\" },\n        outTypes: { dir: \"vec3\" },\n        inputs: { dir, scale, scales, rotate },\n        statements: ({ inputs, outputs }) => {\n          const { dir: dir2 } = outputs;\n          if (!dir2) {\n            return [];\n          }\n          const { scale: scale2, scales: scales2, rotate: rotate2 } = inputs;\n          return [\n            \\`\\${dir2} = \\${inputs.dir ?? \"vec3(0.0, 0.0, 0.0)\"};\\`,\n            !scale2 ? null : \\`\\${dir2} *= \\${scale2};\\`,\n            !scales2 ? null : \\`\\${dir2} *= \\${scales2};\\`,\n            !rotate2 ? null : \\`\\${dir2} = quatVec(\\${rotate2}, \\${dir2});\\`\n          ].filter(Boolean);\n        }\n      });\n    }\n  }\n  var computeUvec4_default = \"precision highp float;\\\\nprecision highp int;\\\\nprecision highp sampler2D;\\\\nprecision highp usampler2D;\\\\nprecision highp isampler2D;\\\\nprecision highp sampler2DArray;\\\\nprecision highp usampler2DArray;\\\\nprecision highp isampler2DArray;\\\\nprecision highp sampler3D;\\\\nprecision highp usampler3D;\\\\nprecision highp isampler3D;\\\\n\\\\n#include <splatDefines>\\\\n\\\\nuniform uint targetLayer;\\\\nuniform int targetBase;\\\\nuniform int targetCount;\\\\n\\\\nout uvec4 target;\\\\n\\\\n{{ GLOBALS }}\\\\n\\\\nvoid produceSplat(int index) {\\\\n    {{ STATEMENTS }}\\\\n}\\\\n\\\\nvoid main() {\\\\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\\\\n    int index = targetIndex - targetBase;\\\\n\\\\n    if ((index >= 0) && (index < targetCount)) {\\\\n        produceSplat(index);\\\\n    } else {\\\\n        target = uvec4(0u, 0u, 0u, 0u);\\\\n    }\\\\n}\";\n  const _PackedSplats = class _PackedSplats {\n    constructor(options = {}) {\n      this.maxSplats = 0;\n      this.numSplats = 0;\n      this.packedArray = null;\n      this.isInitialized = false;\n      this.target = null;\n      this.source = null;\n      this.needsUpdate = true;\n      this.extra = {};\n      this.dyno = new DynoPackedSplats({ packedSplats: this });\n      this.initialized = Promise.resolve(this);\n      this.reinitialize(options);\n    }\n    reinitialize(options) {\n      this.isInitialized = false;\n      if (options.url || options.fileBytes || options.construct) {\n        this.initialized = this.asyncInitialize(options).then(() => {\n          this.isInitialized = true;\n          return this;\n        });\n      } else {\n        this.initialize(options);\n        this.isInitialized = true;\n        this.initialized = Promise.resolve(this);\n      }\n    }\n    initialize(options) {\n      if (options.packedArray) {\n        this.packedArray = options.packedArray;\n        this.maxSplats = Math.floor(this.packedArray.length / 4);\n        this.maxSplats = Math.floor(this.maxSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        this.numSplats = Math.min(\n          this.maxSplats,\n          options.numSplats ?? Number.POSITIVE_INFINITY\n        );\n      } else {\n        this.maxSplats = options.maxSplats ?? 0;\n        this.numSplats = 0;\n      }\n      this.extra = options.extra ?? {};\n    }\n    async asyncInitialize(options) {\n      let { url, fileBytes, construct } = options;\n      if (url) {\n        fileBytes = await fetch(url).then(async (response) => {\n          if (!response.ok) {\n            throw new Error(\n              \\`\\${response.status} \"\\${response.statusText}\" fetching URL: \\${url}\\`\n            );\n          }\n          const arrayBuffer = await response.arrayBuffer();\n          return arrayBuffer;\n        });\n      }\n      if (fileBytes) {\n        const unpacked = await unpackSplats({\n          input: fileBytes,\n          fileType: options.fileType,\n          pathOrUrl: options.fileName ?? url\n        });\n        this.initialize(unpacked);\n      }\n      if (construct) {\n        const maybePromise = construct(this);\n        if (maybePromise instanceof Promise) {\n          await maybePromise;\n        }\n      }\n    }\n    // Call this when you are finished with the PackedSplats and want to free\n    // any buffers it holds.\n    dispose() {\n      if (this.target) {\n        this.target.dispose();\n        this.target = null;\n      }\n      if (this.source) {\n        this.source.dispose();\n        this.source = null;\n      }\n    }\n    // Ensures that this.packedArray can fit numSplats Gsplats. If it's too small,\n    // resize exponentially and copy over the original data.\n    //\n    // Typically you don't need to call this, because calling this.setSplat(index, ...)\n    // and this.pushSplat(...) will automatically call ensureSplats() so we have\n    // enough splats.\n    ensureSplats(numSplats) {\n      const targetSize = numSplats <= this.maxSplats ? this.maxSplats : (\n        // Grow exponentially to avoid frequent reallocations\n        Math.max(numSplats, 2 * this.maxSplats)\n      );\n      const currentSize = !this.packedArray ? 0 : this.packedArray.length / 4;\n      if (!this.packedArray || targetSize > currentSize) {\n        this.maxSplats = getTextureSize(targetSize).maxSplats;\n        const newArray = new Uint32Array(this.maxSplats * 4);\n        if (this.packedArray) {\n          newArray.set(this.packedArray);\n        }\n        this.packedArray = newArray;\n      }\n      return this.packedArray;\n    }\n    // Ensure the extra array for the given level is large enough to hold numSplats\n    ensureSplatsSh(level, numSplats) {\n      let wordsPerSplat;\n      let key;\n      if (level === 0) {\n        return this.ensureSplats(numSplats);\n      }\n      if (level === 1) {\n        wordsPerSplat = 2;\n        key = \"sh1\";\n      } else if (level === 2) {\n        wordsPerSplat = 4;\n        key = \"sh2\";\n      } else if (level === 3) {\n        wordsPerSplat = 4;\n        key = \"sh3\";\n      } else {\n        throw new Error(\\`Invalid level: \\${level}\\`);\n      }\n      let maxSplats = !this.extra[key] ? 0 : this.extra[key].length / wordsPerSplat;\n      const targetSize = numSplats <= maxSplats ? maxSplats : Math.max(numSplats, 2 * maxSplats);\n      if (!this.extra[key] || targetSize > maxSplats) {\n        maxSplats = getTextureSize(targetSize).maxSplats;\n        const newArray = new Uint32Array(maxSplats * wordsPerSplat);\n        if (this.extra[key]) {\n          newArray.set(this.extra[key]);\n        }\n        this.extra[key] = newArray;\n      }\n      return this.extra[key];\n    }\n    // Unpack the 16-byte Gsplat data at index into the Three.js components\n    // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n    // opacity: number 0..1, color: THREE.Color 0..1.\n    getSplat(index) {\n      if (!this.packedArray || index >= this.numSplats) {\n        throw new Error(\"Invalid index\");\n      }\n      return unpackSplat(this.packedArray, index);\n    }\n    // Set all PackedSplat components at index with the provided Gsplat attributes\n    // (can be the same objects returned by getSplat). Ensures there is capacity\n    // for at least index+1 Gsplats.\n    setSplat(index, center, scales, quaternion, opacity, color) {\n      const packedSplats = this.ensureSplats(index + 1);\n      setPackedSplat(\n        packedSplats,\n        index,\n        center.x,\n        center.y,\n        center.z,\n        scales.x,\n        scales.y,\n        scales.z,\n        quaternion.x,\n        quaternion.y,\n        quaternion.z,\n        quaternion.w,\n        opacity,\n        color.r,\n        color.g,\n        color.b\n      );\n      this.numSplats = Math.max(this.numSplats, index + 1);\n    }\n    // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on\n    // construction where you just want to iterate and create a collection of Gsplats.\n    pushSplat(center, scales, quaternion, opacity, color) {\n      const packedSplats = this.ensureSplats(this.numSplats + 1);\n      setPackedSplat(\n        packedSplats,\n        this.numSplats,\n        center.x,\n        center.y,\n        center.z,\n        scales.x,\n        scales.y,\n        scales.z,\n        quaternion.x,\n        quaternion.y,\n        quaternion.z,\n        quaternion.w,\n        opacity,\n        color.r,\n        color.g,\n        color.b\n      );\n      ++this.numSplats;\n    }\n    // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat\n    // and invoke the callback function with the Gsplat attributes.\n    forEachSplat(callback) {\n      if (!this.packedArray || !this.numSplats) {\n        return;\n      }\n      for (let i2 = 0; i2 < this.numSplats; ++i2) {\n        const unpacked = unpackSplat(this.packedArray, i2);\n        callback(\n          i2,\n          unpacked.center,\n          unpacked.scales,\n          unpacked.quaternion,\n          unpacked.opacity,\n          unpacked.color\n        );\n      }\n    }\n    // Ensures our PackedSplats.target render target has enough space to generate\n    // maxSplats total Gsplats, and reallocate if not large enough.\n    ensureGenerate(maxSplats) {\n      if (this.target && (maxSplats ?? 1) <= this.maxSplats) {\n        return false;\n      }\n      this.dispose();\n      const textureSize = getTextureSize(maxSplats ?? 1);\n      const { width, height, depth } = textureSize;\n      this.maxSplats = textureSize.maxSplats;\n      this.target = new WebGLArrayRenderTarget(width, height, depth, {\n        depthBuffer: false,\n        stencilBuffer: false,\n        generateMipmaps: false,\n        magFilter: NearestFilter,\n        minFilter: NearestFilter\n      });\n      this.target.texture.format = RGBAIntegerFormat;\n      this.target.texture.type = UnsignedIntType;\n      this.target.texture.internalFormat = \"RGBA32UI\";\n      return true;\n    }\n    // Given an array of splatCounts (.numSplats for each\n    // SplatGenerator/SplatMesh in the scene), compute a\n    // \"mapping layout\" in the composite array of generated outputs.\n    generateMapping(splatCounts) {\n      let maxSplats = 0;\n      const mapping = splatCounts.map((numSplats) => {\n        const base = maxSplats;\n        const rounded = Math.ceil(numSplats / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        maxSplats += rounded;\n        return { base, count: numSplats };\n      });\n      return { maxSplats, mapping };\n    }\n    // Returns a THREE.DataArrayTexture representing the PackedSplats content as\n    // a Uint32x4 data array texture (2048 x 2048 x depth in size)\n    getTexture() {\n      if (this.target) {\n        return this.target.texture;\n      }\n      if (this.source || this.packedArray) {\n        const source = this.maybeUpdateSource();\n        return source;\n      }\n      return _PackedSplats.getEmpty();\n    }\n    // Check if source texture needs to be created/updated\n    maybeUpdateSource() {\n      if (!this.packedArray) {\n        throw new Error(\"No packed splats\");\n      }\n      if (this.needsUpdate || !this.source) {\n        this.needsUpdate = false;\n        if (this.source) {\n          const { width, height, depth } = this.source.image;\n          if (this.maxSplats !== width * height * depth) {\n            this.source.dispose();\n            this.source = null;\n          }\n        }\n        if (!this.source) {\n          const { width, height, depth } = getTextureSize(this.maxSplats);\n          this.source = new DataArrayTexture(\n            this.packedArray,\n            width,\n            height,\n            depth\n          );\n          this.source.format = RGBAIntegerFormat;\n          this.source.type = UnsignedIntType;\n          this.source.internalFormat = \"RGBA32UI\";\n          this.source.needsUpdate = true;\n        } else if (this.packedArray.buffer !== this.source.image.data.buffer) {\n          this.source.image.data = new Uint8Array(this.packedArray.buffer);\n        }\n        this.source.needsUpdate = true;\n      }\n      return this.source;\n    }\n    // Can be used where you need an uninitialized THREE.DataArrayTexture like\n    // a uniform you will update with the result of this.getTexture() later.\n    static getEmpty() {\n      if (!_PackedSplats.emptySource) {\n        const { width, height, depth, maxSplats } = getTextureSize(1);\n        const emptyArray = new Uint32Array(maxSplats * 4);\n        _PackedSplats.emptySource = new DataArrayTexture(\n          emptyArray,\n          width,\n          height,\n          depth\n        );\n        _PackedSplats.emptySource.format = RGBAIntegerFormat;\n        _PackedSplats.emptySource.type = UnsignedIntType;\n        _PackedSplats.emptySource.internalFormat = \"RGBA32UI\";\n        _PackedSplats.emptySource.needsUpdate = true;\n      }\n      return _PackedSplats.emptySource;\n    }\n    // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,\n    // generating it if necessary and caching the result.\n    prepareProgramMaterial(generator) {\n      let program = _PackedSplats.generatorProgram.get(generator);\n      if (!program) {\n        const graph = dynoBlock(\n          { index: \"int\" },\n          { output: \"uvec4\" },\n          ({ index }) => {\n            generator.inputs.index = index;\n            const gsplat = generator.outputs.gsplat;\n            const output = outputPackedSplat(gsplat);\n            return { output };\n          }\n        );\n        if (!_PackedSplats.programTemplate) {\n          _PackedSplats.programTemplate = new DynoProgramTemplate(\n            computeUvec4_default\n          );\n        }\n        program = new DynoProgram({\n          graph,\n          inputs: { index: \"index\" },\n          outputs: { output: \"target\" },\n          template: _PackedSplats.programTemplate\n        });\n        Object.assign(program.uniforms, {\n          targetLayer: { value: 0 },\n          targetBase: { value: 0 },\n          targetCount: { value: 0 }\n        });\n        _PackedSplats.generatorProgram.set(generator, program);\n      }\n      const material = program.prepareMaterial();\n      _PackedSplats.mesh.material = material;\n      return { program, material };\n    }\n    saveRenderState(renderer) {\n      return {\n        xrPresenting: renderer.xr.isPresenting,\n        autoClear: renderer.autoClear,\n        scissorTest: renderer.getScissorTest(),\n        pixelRatio: renderer.getPixelRatio()\n      };\n    }\n    resetRenderState(renderer, state) {\n      renderer.setRenderTarget(null);\n      renderer.setPixelRatio(state.pixelRatio);\n      renderer.xr.isPresenting = state.xrPresenting;\n      renderer.autoClear = state.autoClear;\n      renderer.setScissorTest(state.scissorTest);\n    }\n    // Executes a dyno program specified by generator which is any DynoBlock that\n    // maps { index: \"int\" } to { gsplat: Gsplat }. This is called in\n    // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for\n    // SplatGenerator instances whose version is newer than what was generated\n    // for it last time.\n    generate({\n      generator,\n      base,\n      count,\n      renderer\n    }) {\n      if (!this.target) {\n        throw new Error(\"Target must be initialized with ensureSplats\");\n      }\n      if (base + count > this.maxSplats) {\n        throw new Error(\"Base + count exceeds maxSplats\");\n      }\n      const { program, material } = this.prepareProgramMaterial(generator);\n      program.update();\n      const renderState = this.saveRenderState(renderer);\n      const nextBase = Math.ceil((base + count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      material.uniforms.targetBase.value = base;\n      material.uniforms.targetCount.value = count;\n      while (base < nextBase) {\n        const layer = Math.floor(base / layerSize);\n        material.uniforms.targetLayer.value = layer;\n        const layerBase = layer * layerSize;\n        const layerYStart = Math.floor((base - layerBase) / SPLAT_TEX_WIDTH);\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((nextBase - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        renderer.setPixelRatio(1);\n        renderer.setRenderTarget(this.target, layer);\n        renderer.xr.isPresenting = false;\n        renderer.autoClear = false;\n        renderer.setScissorTest(true);\n        renderer.setScissor(\n          0,\n          layerYStart,\n          SPLAT_TEX_WIDTH,\n          layerYEnd - layerYStart\n        );\n        renderer.render(_PackedSplats.scene, _PackedSplats.camera);\n        base += SPLAT_TEX_WIDTH * (layerYEnd - layerYStart);\n      }\n      this.resetRenderState(renderer, renderState);\n      return { nextBase };\n    }\n  };\n  _PackedSplats.emptySource = null;\n  _PackedSplats.programTemplate = null;\n  _PackedSplats.generatorProgram = /* @__PURE__ */ new Map();\n  _PackedSplats.geometry = new PlaneGeometry(2, 2);\n  _PackedSplats.mesh = new Mesh(\n    _PackedSplats.geometry,\n    new RawShaderMaterial({ visible: false })\n  );\n  _PackedSplats.scene = new Scene().add(_PackedSplats.mesh);\n  _PackedSplats.camera = new Camera();\n  let PackedSplats = _PackedSplats;\n  class DynoPackedSplats extends DynoUniform {\n    constructor({ packedSplats } = {}) {\n      super({\n        key: \"packedSplats\",\n        type: TPackedSplats,\n        globals: () => [definePackedSplats],\n        value: {\n          texture: PackedSplats.getEmpty(),\n          numSplats: 0\n        },\n        update: (value) => {\n          var _a2, _b2;\n          value.texture = ((_a2 = this.packedSplats) == null ? void 0 : _a2.getTexture()) ?? PackedSplats.getEmpty();\n          value.numSplats = ((_b2 = this.packedSplats) == null ? void 0 : _b2.numSplats) ?? 0;\n          return value;\n        }\n      });\n      this.packedSplats = packedSplats;\n    }\n  }\n  var computeVec4_default = \"precision highp float;\\\\nprecision highp int;\\\\nprecision highp sampler2D;\\\\nprecision highp usampler2D;\\\\nprecision highp isampler2D;\\\\nprecision highp sampler2DArray;\\\\nprecision highp usampler2DArray;\\\\nprecision highp isampler2DArray;\\\\nprecision highp sampler3D;\\\\nprecision highp usampler3D;\\\\nprecision highp isampler3D;\\\\n\\\\n#include <splatDefines>\\\\n\\\\nuniform uint targetLayer;\\\\nuniform int targetBase;\\\\nuniform int targetCount;\\\\n\\\\nout vec4 target;\\\\n\\\\n{{ GLOBALS }}\\\\n\\\\nvoid computeReadback(int index) {\\\\n    {{ STATEMENTS }}\\\\n}\\\\n\\\\nvoid main() {\\\\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\\\\n    int index = targetIndex - targetBase;\\\\n\\\\n    if ((index >= 0) && (index < targetCount)) {\\\\n        computeReadback(index);\\\\n    } else {\\\\n        target = vec4(0.0, 0.0, 0.0, 0.0);\\\\n    }\\\\n}\";\n  const _Readback = class _Readback {\n    constructor({ renderer } = {}) {\n      this.renderer = renderer;\n      this.capacity = 0;\n      this.count = 0;\n    }\n    dispose() {\n      if (this.target) {\n        this.target.dispose();\n        this.target = void 0;\n      }\n    }\n    // Ensure we have a buffer large enough for the readback of count indices.\n    // Pass in previous bufer of the desired type.\n    ensureBuffer(count, buffer) {\n      const roundedCount = Math.ceil(Math.max(1, count) / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      const bytes = roundedCount * 4;\n      if (buffer.byteLength >= bytes) {\n        return buffer;\n      }\n      const newBuffer = new ArrayBuffer(bytes);\n      if (buffer instanceof ArrayBuffer) {\n        return newBuffer;\n      }\n      const ctor = buffer.constructor;\n      return new ctor(newBuffer);\n    }\n    // Ensure our render target is large enough for the readback of capacity indices.\n    ensureCapacity(capacity) {\n      const { width, height, depth, maxSplats } = getTextureSize(capacity);\n      if (!this.target || maxSplats > this.capacity) {\n        this.dispose();\n        this.capacity = maxSplats;\n        this.target = new WebGLArrayRenderTarget(width, height, depth, {\n          depthBuffer: false,\n          stencilBuffer: false,\n          generateMipmaps: false,\n          magFilter: NearestFilter,\n          minFilter: NearestFilter\n        });\n        this.target.texture.format = RGBAFormat;\n        this.target.texture.type = UnsignedByteType;\n        this.target.texture.internalFormat = \"RGBA8\";\n      }\n    }\n    // Get a program and THREE.RawShaderMaterial for a given Rgba8Readback,\n    // generating it if necessary and caching the result.\n    prepareProgramMaterial(reader) {\n      let program = _Readback.readbackProgram.get(reader);\n      if (!program) {\n        const graph = dynoBlock(\n          { index: \"int\" },\n          { rgba8: \"vec4\" },\n          ({ index }) => {\n            reader.inputs.index = index;\n            const rgba8 = new OutputRgba8({ rgba8: reader.outputs.rgba8 });\n            return { rgba8 };\n          }\n        );\n        if (!_Readback.programTemplate) {\n          _Readback.programTemplate = new DynoProgramTemplate(computeVec4_default);\n        }\n        program = new DynoProgram({\n          graph,\n          inputs: { index: \"index\" },\n          outputs: { rgba8: \"target\" },\n          template: _Readback.programTemplate\n        });\n        Object.assign(program.uniforms, {\n          targetLayer: { value: 0 },\n          targetBase: { value: 0 },\n          targetCount: { value: 0 }\n        });\n        _Readback.readbackProgram.set(reader, program);\n      }\n      const material = program.prepareMaterial();\n      _Readback.mesh.material = material;\n      return { program, material };\n    }\n    saveRenderState(renderer) {\n      return {\n        xrPresenting: renderer.xr.isPresenting,\n        autoClear: renderer.autoClear,\n        scissorTest: renderer.getScissorTest(),\n        pixelRatio: renderer.getPixelRatio()\n      };\n    }\n    resetRenderState(renderer, state) {\n      renderer.setRenderTarget(null);\n      renderer.setPixelRatio(state.pixelRatio);\n      renderer.xr.isPresenting = state.xrPresenting;\n      renderer.autoClear = state.autoClear;\n      renderer.setScissorTest(state.scissorTest);\n    }\n    process({\n      count,\n      material\n    }) {\n      const renderer = this.renderer;\n      if (!renderer) {\n        throw new Error(\"No renderer\");\n      }\n      if (!this.target) {\n        throw new Error(\"No target\");\n      }\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      material.uniforms.targetBase.value = 0;\n      material.uniforms.targetCount.value = count;\n      let baseIndex = 0;\n      while (baseIndex < count) {\n        const layer = Math.floor(baseIndex / layerSize);\n        const layerBase = layer * layerSize;\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((count - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        material.uniforms.targetLayer.value = layer;\n        renderer.setPixelRatio(1);\n        renderer.setRenderTarget(this.target, layer);\n        renderer.xr.isPresenting = false;\n        renderer.autoClear = false;\n        renderer.setScissorTest(true);\n        renderer.setScissor(0, 0, SPLAT_TEX_WIDTH, layerYEnd);\n        renderer.render(_Readback.scene, _Readback.camera);\n        baseIndex += SPLAT_TEX_WIDTH * layerYEnd;\n      }\n      this.count = count;\n    }\n    async read({\n      readback\n    }) {\n      const renderer = this.renderer;\n      if (!renderer) {\n        throw new Error(\"No renderer\");\n      }\n      if (!this.target) {\n        throw new Error(\"No target\");\n      }\n      const roundedCount = Math.ceil(this.count / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n      if (readback.byteLength < roundedCount * 4) {\n        throw new Error(\n          \\`Readback buffer too small: \\${readback.byteLength} < \\${roundedCount * 4}\\`\n        );\n      }\n      const readbackUint8 = new Uint8Array(\n        readback instanceof ArrayBuffer ? readback : readback.buffer\n      );\n      const layerSize = SPLAT_TEX_WIDTH * SPLAT_TEX_HEIGHT;\n      let baseIndex = 0;\n      const promises = [];\n      while (baseIndex < this.count) {\n        const layer = Math.floor(baseIndex / layerSize);\n        const layerBase = layer * layerSize;\n        const layerYEnd = Math.min(\n          SPLAT_TEX_HEIGHT,\n          Math.ceil((this.count - layerBase) / SPLAT_TEX_WIDTH)\n        );\n        renderer.setPixelRatio(1);\n        renderer.setRenderTarget(this.target, layer);\n        const readbackSize = SPLAT_TEX_WIDTH * layerYEnd * 4;\n        const subReadback = readbackUint8.subarray(\n          layerBase * 4,\n          layerBase * 4 + readbackSize\n        );\n        const promise = renderer == null ? void 0 : renderer.readRenderTargetPixelsAsync(\n          this.target,\n          0,\n          0,\n          SPLAT_TEX_WIDTH,\n          layerYEnd,\n          subReadback\n        );\n        promises.push(promise);\n        baseIndex += SPLAT_TEX_WIDTH * layerYEnd;\n      }\n      return Promise.all(promises).then(() => readback);\n    }\n    // Perform render operation to run the Rgba8Readback program\n    // but don't perform the readback yet.\n    render({\n      reader,\n      count,\n      renderer\n    }) {\n      this.renderer = renderer || this.renderer;\n      if (!this.renderer) {\n        throw new Error(\"No renderer\");\n      }\n      this.ensureCapacity(count);\n      const { program, material } = this.prepareProgramMaterial(reader);\n      program.update();\n      const renderState = this.saveRenderState(this.renderer);\n      this.process({ count, material });\n      this.resetRenderState(this.renderer, renderState);\n    }\n    // Perform a readback of the render target, returning a buffer of the\n    // given type.\n    async readback({\n      readback\n    }) {\n      if (!this.renderer) {\n        throw new Error(\"No renderer\");\n      }\n      const renderState = this.saveRenderState(this.renderer);\n      const promise = this.read({ readback });\n      this.resetRenderState(this.renderer, renderState);\n      return promise;\n    }\n    // Perform a render and readback operation for the given Rgba8Readback,\n    // and readback buffer (call ensureBuffer first).\n    async renderReadback({\n      reader,\n      count,\n      renderer,\n      readback\n    }) {\n      this.renderer = renderer || this.renderer;\n      if (!this.renderer) {\n        throw new Error(\"No renderer\");\n      }\n      this.ensureCapacity(count);\n      const { program, material } = this.prepareProgramMaterial(reader);\n      program.update();\n      const renderState = this.saveRenderState(this.renderer);\n      this.process({ count, material });\n      const promise = this.read({ readback });\n      this.resetRenderState(this.renderer, renderState);\n      return promise;\n    }\n    getTexture() {\n      var _a2;\n      return (_a2 = this.target) == null ? void 0 : _a2.texture;\n    }\n  };\n  _Readback.programTemplate = null;\n  _Readback.readbackProgram = /* @__PURE__ */ new Map();\n  _Readback.geometry = new PlaneGeometry(2, 2);\n  _Readback.mesh = new Mesh(\n    _Readback.geometry,\n    new RawShaderMaterial({ visible: false })\n  );\n  _Readback.scene = new Scene().add(_Readback.mesh);\n  _Readback.camera = new Camera();\n  let Readback = _Readback;\n  const _RgbaArray = class _RgbaArray {\n    constructor(options = {}) {\n      this.capacity = 0;\n      this.count = 0;\n      this.array = null;\n      this.readback = null;\n      this.source = null;\n      this.needsUpdate = true;\n      this.dyno = new DynoUniform({\n        key: \"rgbaArray\",\n        type: TRgbaArray,\n        globals: () => [defineRgbaArray],\n        value: {\n          texture: _RgbaArray.getEmpty(),\n          count: 0\n        },\n        update: (value) => {\n          var _a2;\n          value.texture = ((_a2 = this.readback) == null ? void 0 : _a2.getTexture()) ?? this.source ?? _RgbaArray.getEmpty();\n          value.count = this.count;\n          return value;\n        }\n      });\n      if (options.array) {\n        this.array = options.array;\n        this.capacity = Math.floor(this.array.length / 4);\n        this.capacity = Math.floor(this.capacity / SPLAT_TEX_WIDTH) * SPLAT_TEX_WIDTH;\n        this.count = Math.min(\n          this.capacity,\n          options.count ?? Number.POSITIVE_INFINITY\n        );\n      } else {\n        this.capacity = options.capacity ?? 0;\n        this.count = 0;\n      }\n    }\n    // Free up resources\n    dispose() {\n      if (this.readback) {\n        this.readback.dispose();\n        this.readback = null;\n      }\n      if (this.source) {\n        this.source.dispose();\n        this.source = null;\n      }\n    }\n    // Ensure that our array is large enough to hold capacity RGBA8 values.\n    ensureCapacity(capacity) {\n      var _a2;\n      if (!this.array || capacity > (((_a2 = this.array) == null ? void 0 : _a2.length) ?? 0) / 4) {\n        this.capacity = getTextureSize(capacity).maxSplats;\n        const newArray = new Uint8Array(this.capacity * 4);\n        if (this.array) {\n          newArray.set(this.array);\n        }\n        this.array = newArray;\n      }\n      return this.array;\n    }\n    // Get the THREE.DataArrayTexture from either the readback or the source.\n    getTexture() {\n      var _a2;\n      let texture = (_a2 = this.readback) == null ? void 0 : _a2.getTexture();\n      if (this.source || this.array) {\n        texture = this.maybeUpdateSource();\n      }\n      return texture ?? _RgbaArray.getEmpty();\n    }\n    // Create or get a THREE.DataArrayTexture from the data array.\n    maybeUpdateSource() {\n      if (!this.array) {\n        throw new Error(\"No array\");\n      }\n      if (this.needsUpdate || !this.source) {\n        this.needsUpdate = false;\n        if (this.source) {\n          const { width, height, depth } = this.source.image;\n          if (this.capacity !== width * height * depth) {\n            this.source.dispose();\n            this.source = null;\n          }\n        }\n        if (!this.source) {\n          const { width, height, depth } = getTextureSize(this.capacity);\n          this.source = new DataArrayTexture(\n            this.array,\n            width,\n            height,\n            depth\n          );\n          this.source.format = RGBAFormat;\n          this.source.type = UnsignedByteType;\n          this.source.internalFormat = \"RGBA8\";\n          this.source.needsUpdate = true;\n        } else if (this.array.buffer !== this.source.image.data.buffer) {\n          this.source.image.data = new Uint8Array(this.array.buffer);\n        }\n        this.source.needsUpdate = true;\n      }\n      return this.source;\n    }\n    // Generate the RGBA8 values from a Rgba8Readback dyno program.\n    render({\n      reader,\n      count,\n      renderer\n    }) {\n      if (!this.readback) {\n        this.readback = new Readback({ renderer });\n      }\n      this.readback.render({ reader, count, renderer });\n      this.capacity = this.readback.capacity;\n      this.count = this.readback.count;\n    }\n    // Extract the RGBA8 values from a PackedSplats collection.\n    fromPackedSplats({\n      packedSplats,\n      base,\n      count,\n      renderer\n    }) {\n      const { dynoSplats, dynoBase, dynoCount, reader } = _RgbaArray.makeDynos();\n      dynoSplats.packedSplats = packedSplats;\n      dynoBase.value = base;\n      dynoCount.value = count;\n      this.render({ reader, count, renderer });\n      return this;\n    }\n    // Read back the RGBA8 values from the readback buffer.\n    async read() {\n      if (!this.readback) {\n        throw new Error(\"No readback\");\n      }\n      if (!this.array || this.array.length < this.count * 4) {\n        this.array = new Uint8Array(this.capacity * 4);\n      }\n      const result = await this.readback.readback({ readback: this.array });\n      return result.subarray(0, this.count * 4);\n    }\n    // Can be used where you need an uninitialized THREE.DataArrayTexture like\n    // a uniform you will update with the result of this.getTexture() later.\n    static getEmpty() {\n      if (!_RgbaArray.emptySource) {\n        const emptyArray = new Uint8Array(1 * 4);\n        _RgbaArray.emptySource = new DataArrayTexture(emptyArray, 1, 1, 1);\n        _RgbaArray.emptySource.format = RGBAFormat;\n        _RgbaArray.emptySource.type = UnsignedByteType;\n        _RgbaArray.emptySource.internalFormat = \"RGBA8\";\n        _RgbaArray.emptySource.needsUpdate = true;\n      }\n      return _RgbaArray.emptySource;\n    }\n    // Create a dyno program that can extract RGBA8 values from a PackedSplats\n    static makeDynos() {\n      if (!_RgbaArray.dynos) {\n        const dynoSplats = new DynoPackedSplats();\n        const dynoBase = new DynoInt({ value: 0 });\n        const dynoCount = new DynoInt({ value: 0 });\n        const reader = dynoBlock(\n          { index: \"int\" },\n          { rgba8: \"vec4\" },\n          ({ index }) => {\n            if (!index) {\n              throw new Error(\"index is undefined\");\n            }\n            index = add(index, dynoBase);\n            const gsplat = readPackedSplatRange(\n              dynoSplats,\n              index,\n              dynoBase,\n              dynoCount\n            );\n            return { rgba8: splitGsplat(gsplat).outputs.rgba };\n          }\n        );\n        _RgbaArray.dynos = { dynoSplats, dynoBase, dynoCount, reader };\n      }\n      return _RgbaArray.dynos;\n    }\n  };\n  _RgbaArray.emptySource = null;\n  _RgbaArray.dynos = null;\n  let RgbaArray = _RgbaArray;\n  const TRgbaArray = { type: \"RgbaArray\" };\n  const defineRgbaArray = unindent(\\`\n  struct RgbaArray {\n    sampler2DArray texture;\n    int count;\n  };\n\\`);\n  function readRgbaArray(rgba, index) {\n    const dyno2 = new Dyno({\n      inTypes: { rgba: TRgbaArray, index: \"int\" },\n      outTypes: { rgba: \"vec4\" },\n      inputs: { rgba, index },\n      globals: () => [defineRgbaArray],\n      statements: ({ inputs, outputs }) => unindentLines(\\`\n        if ((index >= 0) && (index < \\${inputs.rgba}.count)) {\n          \\${outputs.rgba} = texelFetch(\\${inputs.rgba}.texture, splatTexCoord(index), 0);\n        } else {\n          \\${outputs.rgba} = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n      \\`)\n    });\n    return dyno2.outputs.rgba;\n  }\n  function sdfTypeToNumber(type) {\n    switch (type) {\n      case \"all\":\n        return 0;\n      case \"plane\":\n        return 1;\n      case \"sphere\":\n        return 2;\n      case \"box\":\n        return 3;\n      case \"ellipsoid\":\n        return 4;\n      case \"cylinder\":\n        return 5;\n      case \"capsule\":\n        return 6;\n      case \"infinite_cone\":\n        return 7;\n      default:\n        throw new Error(\\`Unknown SDF type: \\${type}\\`);\n    }\n  }\n  function rgbaBlendModeToNumber(mode) {\n    switch (mode) {\n      case \"multiply\":\n        return 0;\n      case \"set_rgb\":\n        return 1;\n      case \"add_rgba\":\n        return 2;\n      default:\n        throw new Error(\\`Unknown blend mode: \\${mode}\\`);\n    }\n  }\n  class SplatEditSdf extends Object3D {\n    constructor(options = {}) {\n      super();\n      const { type, invert, opacity, color, displace, radius } = options;\n      this.type = type ?? \"sphere\";\n      this.invert = invert ?? false;\n      this.opacity = opacity ?? 1;\n      this.color = color ?? new Color(1, 1, 1);\n      this.displace = displace ?? new Vector3(0, 0, 0);\n      this.radius = radius ?? 0;\n    }\n  }\n  const _SplatEdit = class _SplatEdit extends Object3D {\n    constructor(options = {}) {\n      const {\n        name,\n        rgbaBlendMode = \"multiply\",\n        sdfSmooth = 0,\n        softEdge = 0,\n        invert = false,\n        sdfs = null\n      } = options;\n      super();\n      this.rgbaBlendMode = rgbaBlendMode;\n      this.sdfSmooth = sdfSmooth;\n      this.softEdge = softEdge;\n      this.invert = invert;\n      this.sdfs = sdfs;\n      this.ordering = _SplatEdit.nextOrdering++;\n      this.name = name ?? \\`Edit \\${this.ordering}\\`;\n    }\n    addSdf(sdf) {\n      if (this.sdfs == null) {\n        this.sdfs = [];\n      }\n      this.sdfs.push(sdf);\n    }\n    removeSdf(sdf) {\n      if (this.sdfs == null) {\n        return;\n      }\n      this.sdfs = this.sdfs.filter((s) => s !== sdf);\n    }\n  };\n  _SplatEdit.nextOrdering = 1;\n  let SplatEdit = _SplatEdit;\n  class SplatEdits {\n    constructor({ maxSdfs, maxEdits }) {\n      this.maxSdfs = Math.max(16, maxSdfs ?? 0);\n      this.numSdfs = 0;\n      this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\n      this.sdfFloatData = new Float32Array(this.sdfData.buffer);\n      this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);\n      this.dynoSdfArray = new DynoUniform({\n        key: \"sdfArray\",\n        type: SdfArray,\n        globals: () => [defineSdfArray],\n        value: {\n          numSdfs: 0,\n          sdfTexture: this.sdfTexture\n        },\n        update: (uniform) => {\n          uniform.numSdfs = this.numSdfs;\n          uniform.sdfTexture = this.sdfTexture;\n          return uniform;\n        }\n      });\n      this.maxEdits = Math.max(16, maxEdits ?? 0);\n      this.numEdits = 0;\n      this.editData = new Uint32Array(this.maxEdits * 4);\n      this.editFloatData = new Float32Array(this.editData.buffer);\n      this.dynoNumEdits = new DynoInt({ value: 0 });\n      this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n    }\n    newSdfTexture(data, maxSdfs) {\n      const texture = new DataTexture(\n        data,\n        8,\n        maxSdfs,\n        RGBAIntegerFormat,\n        UnsignedIntType\n      );\n      texture.internalFormat = \"RGBA32UI\";\n      texture.needsUpdate = true;\n      return texture;\n    }\n    newEdits(data, maxEdits) {\n      return new DynoUniform({\n        key: \"edits\",\n        type: \"uvec4\",\n        count: maxEdits,\n        globals: () => [defineEdit],\n        value: data\n      });\n    }\n    // Ensure our SDF texture and edits uniform array have enough capacity.\n    // Reallocate if not.\n    ensureCapacity({\n      maxSdfs,\n      maxEdits\n    }) {\n      let dynoUpdated = false;\n      if (maxSdfs > this.sdfTexture.image.height) {\n        this.sdfTexture.dispose();\n        this.maxSdfs = Math.max(this.maxSdfs * 2, maxSdfs);\n        this.sdfData = new Uint32Array(this.maxSdfs * 8 * 4);\n        this.sdfFloatData = new Float32Array(this.sdfData.buffer);\n        this.sdfTexture = this.newSdfTexture(this.sdfData, this.maxSdfs);\n      }\n      if (maxEdits > (this.dynoEdits.count ?? 0)) {\n        this.maxEdits = Math.max(this.maxEdits * 2, maxEdits);\n        this.editData = new Uint32Array(this.maxEdits * 4);\n        this.editFloatData = new Float32Array(this.editData.buffer);\n        this.dynoEdits = this.newEdits(this.editData, this.maxEdits);\n        dynoUpdated = true;\n      }\n      return dynoUpdated;\n    }\n    updateEditData(offset, value) {\n      const updated = this.editData[offset] !== value;\n      this.editData[offset] = value;\n      return updated;\n    }\n    updateEditFloatData(offset, value) {\n      tempFloat32[0] = value;\n      const updated = this.editFloatData[offset] !== tempFloat32[0];\n      if (updated) {\n        this.editFloatData[offset] = tempFloat32[0];\n      }\n      return updated;\n    }\n    encodeEdit(editIndex, {\n      sdfFirst,\n      sdfCount,\n      invert,\n      rgbaBlendMode,\n      softEdge,\n      sdfSmooth\n    }) {\n      const base = editIndex * 4;\n      let updated = false;\n      updated = this.updateEditData(base + 0, rgbaBlendMode | (invert ? 1 << 8 : 0)) || updated;\n      updated = this.updateEditData(base + 1, sdfFirst | sdfCount << 16) || updated;\n      updated = this.updateEditFloatData(base + 2, softEdge) || updated;\n      updated = this.updateEditFloatData(base + 3, sdfSmooth) || updated;\n      return updated;\n    }\n    updateSdfData(offset, value) {\n      const updated = this.sdfData[offset] !== value;\n      this.sdfData[offset] = value;\n      return updated;\n    }\n    updateSdfFloatData(offset, value) {\n      tempFloat32[0] = value;\n      const updated = this.sdfFloatData[offset] !== tempFloat32[0];\n      if (updated) {\n        this.sdfFloatData[offset] = tempFloat32[0];\n      }\n      return updated;\n    }\n    encodeSdf(sdfIndex, {\n      sdfType,\n      invert,\n      center,\n      quaternion,\n      scale,\n      sizes\n    }, values) {\n      const base = sdfIndex * (8 * 4);\n      const flags = sdfType | (invert ? 1 << 8 : 0);\n      let updated = false;\n      updated = this.updateSdfFloatData(base + 0, (center == null ? void 0 : center.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 1, (center == null ? void 0 : center.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 2, (center == null ? void 0 : center.z) ?? 0) || updated;\n      updated = this.updateSdfData(base + 3, flags) || updated;\n      updated = this.updateSdfFloatData(base + 4, (quaternion == null ? void 0 : quaternion.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 5, (quaternion == null ? void 0 : quaternion.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 6, (quaternion == null ? void 0 : quaternion.z) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 7, (quaternion == null ? void 0 : quaternion.w) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 8, (scale == null ? void 0 : scale.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 9, (scale == null ? void 0 : scale.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 10, (scale == null ? void 0 : scale.z) ?? 0) || updated;\n      updated = this.updateSdfData(base + 11, 0) || updated;\n      updated = this.updateSdfFloatData(base + 12, (sizes == null ? void 0 : sizes.x) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 13, (sizes == null ? void 0 : sizes.y) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 14, (sizes == null ? void 0 : sizes.z) ?? 0) || updated;\n      updated = this.updateSdfFloatData(base + 15, (sizes == null ? void 0 : sizes.w) ?? 0) || updated;\n      const nValues = Math.min(4, values.length);\n      for (let i2 = 0; i2 < nValues; ++i2) {\n        const vBase = base + 16 + i2 * 4;\n        updated = this.updateSdfFloatData(vBase + 0, values[i2].x) || updated;\n        updated = this.updateSdfFloatData(vBase + 1, values[i2].y) || updated;\n        updated = this.updateSdfFloatData(vBase + 2, values[i2].z) || updated;\n        updated = this.updateSdfFloatData(vBase + 3, values[i2].w) || updated;\n      }\n      return updated;\n    }\n    // Update the SDFs and edits from an array of SplatEdits and their\n    // associated SplatEditSdfs, updating it for the dyno shader program.\n    update(edits) {\n      const sdfCount = edits.reduce((total, { sdfs }) => total + sdfs.length, 0);\n      const dynoUpdated = this.ensureCapacity({\n        maxEdits: edits.length,\n        maxSdfs: sdfCount\n      });\n      const values = [new Vector4(), new Vector4()];\n      const center = new Vector3();\n      const quaternion = new Quaternion();\n      const scale = new Vector3();\n      const sizes = new Vector4();\n      let sdfIndex = 0;\n      let updated = dynoUpdated;\n      if (edits.length !== this.dynoNumEdits.value) {\n        this.dynoNumEdits.value = edits.length;\n        this.numEdits = edits.length;\n        updated = true;\n      }\n      for (const [editIndex, { edit, sdfs }] of edits.entries()) {\n        updated = this.encodeEdit(editIndex, {\n          sdfFirst: sdfIndex,\n          sdfCount: sdfs.length,\n          invert: edit.invert,\n          rgbaBlendMode: rgbaBlendModeToNumber(edit.rgbaBlendMode),\n          softEdge: edit.softEdge,\n          sdfSmooth: edit.sdfSmooth\n        }) || updated;\n        let sdfUpdated = false;\n        for (const sdf of sdfs) {\n          sizes.set(sdf.scale.x, sdf.scale.y, sdf.scale.z, sdf.radius);\n          sdf.scale.setScalar(1);\n          sdf.updateMatrixWorld();\n          const worldToSdf = sdf.matrixWorld.clone().invert();\n          worldToSdf.decompose(center, quaternion, scale);\n          sdf.scale.set(sizes.x, sizes.y, sizes.z);\n          sdf.updateMatrixWorld();\n          values[0].set(sdf.color.r, sdf.color.g, sdf.color.b, sdf.opacity);\n          values[1].set(sdf.displace.x, sdf.displace.y, sdf.displace.z, 1);\n          sdfUpdated = this.encodeSdf(\n            sdfIndex,\n            {\n              sdfType: sdfTypeToNumber(sdf.type),\n              invert: sdf.invert,\n              center,\n              quaternion,\n              scale,\n              sizes\n            },\n            values\n          ) || sdfUpdated;\n          sdfIndex += 1;\n        }\n        this.numSdfs = sdfIndex;\n        if (sdfUpdated) {\n          this.sdfTexture.needsUpdate = true;\n        }\n        updated || (updated = sdfUpdated);\n      }\n      return { updated, dynoUpdated };\n    }\n    // Modify a Gsplat in a dyno shader program using the current edits and SDFs.\n    modify(gsplat) {\n      return applyGsplatRgbaDisplaceEdits(\n        gsplat,\n        this.dynoSdfArray,\n        this.dynoNumEdits,\n        this.dynoEdits\n      );\n    }\n  }\n  const SdfArray = { type: \"SdfArray\" };\n  const defineSdfArray = unindent(\\`\n  struct SdfArray {\n    int numSdfs;\n    usampler2D sdfTexture;\n  };\n\n  void unpackSdfArray(\n    usampler2D sdfTexture, int sdfIndex, out uint flags,\n    out vec3 center, out vec4 quaternion, out vec3 scale, out vec4 sizes,\n    int numValues, out vec4 values[4]\n  ) {\n    uvec4 temp = texelFetch(sdfTexture, ivec2(0, sdfIndex), 0);\n    flags = temp.w;\n    center = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(1, sdfIndex), 0);\n    quaternion = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    temp = texelFetch(sdfTexture, ivec2(2, sdfIndex), 0);\n    scale = vec3(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z));\n\n    temp = texelFetch(sdfTexture, ivec2(3, sdfIndex), 0);\n    sizes = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n\n    for (int i = 0; i < numValues; ++i) {\n      temp = texelFetch(sdfTexture, ivec2(4 + i, sdfIndex), 0);\n      values[i] = vec4(uintBitsToFloat(temp.x), uintBitsToFloat(temp.y), uintBitsToFloat(temp.z), uintBitsToFloat(temp.w));\n    }\n  }\n\n  const uint SDF_FLAG_TYPE = 0xFFu;\n  const uint SDF_FLAG_INVERT = 1u << 8u;\n\n  const uint SDF_TYPE_ALL = 0u;\n  const uint SDF_TYPE_PLANE = 1u;\n  const uint SDF_TYPE_SPHERE = 2u;\n  const uint SDF_TYPE_BOX = 3u;\n  const uint SDF_TYPE_ELLIPSOID = 4u;\n  const uint SDF_TYPE_CYLINDER = 5u;\n  const uint SDF_TYPE_CAPSULE = 6u;\n  const uint SDF_TYPE_INFINITE_CONE = 7u;\n\n  float evaluateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 outValues[4]\n  ) {\n    float distanceAccum = (smoothK == 0.0) ? 1.0 / 0.0 : 0.0;\n    float maxExp = -1.0 / 0.0;\n    for (int i = 0; i < numValues; ++i) {\n        outValues[i] = vec4(0.0);\n    }\n\n    uint flags;\n    vec3 center, scale;\n    vec4 quaternion, sizes;\n    vec4 values[4];\n\n    int sdfLast = min(sdfFirst + sdfCount, numSdfs);\n    for (int index = sdfFirst; index < sdfLast; ++index) {\n      unpackSdfArray(sdfTexture, index, flags, center, quaternion, scale, sizes, numValues, values);\n      uint sdfType = flags & SDF_FLAG_TYPE;\n      vec3 sdfPos = quatVec(quaternion, pos * scale) + center;\n\n      float distance;\n      switch (sdfType) {\n        case SDF_TYPE_ALL:\n          distance = -1.0 / 0.0;\n          break;\n        case SDF_TYPE_PLANE: {\n          distance = sdfPos.z;\n          break;\n        }\n        case SDF_TYPE_SPHERE: {\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_BOX: {\n          vec3 q = abs(sdfPos) - sizes.xyz + sizes.w;\n          distance = length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_ELLIPSOID: {\n          vec3 sizes = sizes.xyz;\n          float k0 = length(sdfPos / sizes);\n          float k1 = length(sdfPos / dot(sizes, sizes));\n          distance = k0 * (k0 - 1.0) / k1;\n          break;\n        }\n        case SDF_TYPE_CYLINDER: {\n          vec2 d = abs(vec2(length(sdfPos.xz), sdfPos.y)) - sizes.wy;\n          distance = min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n          break;\n        }\n        case SDF_TYPE_CAPSULE: {\n          sdfPos.y -= clamp(sdfPos.y, -0.5 * sizes.y, 0.5 * sizes.y);\n          distance = length(sdfPos) - sizes.w;\n          break;\n        }\n        case SDF_TYPE_INFINITE_CONE: {\n          float angle = 0.25 * PI * sizes.w;\n          vec2 c = vec2(sin(angle), cos(angle));\n          vec2 q = vec2(length(sdfPos.xy), -sdfPos.z);\n          float d = length(q - c * max(dot(q, c), 0.0));\n          distance = d * (((q.x * c.y - q.y * c.x) < 0.0) ? -1.0 : 1.0);\n          break;\n        }\n      }\n\n      if ((flags & SDF_FLAG_INVERT) != 0u) {\n        distance = -distance;\n      }\n\n      if (smoothK == 0.0) {\n        if (distance < distanceAccum) {\n          distanceAccum = distance;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] = values[i];\n          }\n        }\n      } else {\n        float scaledDistance = -distance / smoothK;\n        if (scaledDistance > maxExp) {\n          float scale = exp(maxExp - scaledDistance);\n          distanceAccum *= scale;\n          for (int i = 0; i < numValues; ++i) {\n            outValues[i] *= scale;\n          }\n          maxExp = scaledDistance;\n        }\n\n        float weight = exp(scaledDistance - maxExp);\n        distanceAccum += weight;\n        for (int i = 0; i < numValues; ++i) {\n          outValues[i] += weight * values[i];\n        }\n      }\n    }\n\n    if (smoothK == 0.0) {\n      return distanceAccum;\n    } else {\n      // Very distant SDFs may result in 0 accumulation\n      if (distanceAccum == 0.0) {\n        return 1.0 / 0.0;\n      }\n      for (int i = 0; i < numValues; ++i) {\n        outValues[i] /= distanceAccum;\n      }\n      return (-log(distanceAccum) - maxExp) * smoothK;\n    }\n  }\n\n  float modulateSdfArray(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, vec3 pos,\n    float smoothK, int numValues, out vec4 values[4],\n    float softEdge, bool invert\n  ) {\n    float distance = evaluateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, numValues, values);\n    if (invert) {\n      distance = -distance;\n    }\n\n    return (softEdge == 0.0) ? ((distance < 0.0) ? 1.0 : 0.0)\n      : clamp(-distance / softEdge + 0.5, 0.0, 1.0);\n  }\n\\`);\n  const defineEdit = unindent(\\`\n  const uint EDIT_FLAG_BLEND = 0xFFu;\n  const uint EDIT_BLEND_MULTIPLY = 0u;\n  const uint EDIT_BLEND_SET_RGB = 1u;\n  const uint EDIT_BLEND_ADD_RGBA = 2u;\n  const uint EDIT_FLAG_INVERT = 0x100u;\n\n  void decodeEdit(\n    uvec4 packedEdit, out int sdfFirst, out int sdfCount,\n    out bool invert, out uint rgbaBlendMode, out float softEdge, out float sdfSmooth\n  ) {\n    rgbaBlendMode = packedEdit.x & EDIT_FLAG_BLEND;\n    invert = (packedEdit.x & EDIT_FLAG_INVERT) != 0u;\n\n    sdfFirst = int(packedEdit.y & 0xFFFFu);\n    sdfCount = int(packedEdit.y >> 16u);\n\n    softEdge = uintBitsToFloat(packedEdit.z);\n    sdfSmooth = uintBitsToFloat(packedEdit.w);\n  }\n\n  void applyRgbaDisplaceEdit(\n    usampler2D sdfTexture, int numSdfs, int sdfFirst, int sdfCount, inout vec3 pos,\n    float smoothK, float softEdge, bool invert, uint rgbaBlendMode, inout vec4 rgba\n  ) {\n    vec4 values[4];\n    float modulate = modulateSdfArray(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, smoothK, 2, values, softEdge, invert);\n    // On Android, moving values[0] is necessary to work around a compiler bug.\n    vec4 sdfRgba = values[0];\n    vec4 sdfDisplaceScale = values[1];\n\n    vec4 target;\n    switch (rgbaBlendMode) {\n      case EDIT_BLEND_MULTIPLY:\n        target = rgba * sdfRgba;\n        break;\n      case EDIT_BLEND_SET_RGB:\n        target = vec4(sdfRgba.rgb, rgba.a * sdfRgba.a);\n        break;\n      case EDIT_BLEND_ADD_RGBA:\n        target = rgba + sdfRgba;\n        break;\n      default:\n        // Debug output if blend mode not set\n        target = vec4(fract(pos), 1.0);\n    }\n    rgba = mix(rgba, target, modulate);\n    pos += sdfDisplaceScale.xyz * modulate;\n  }\n\n  void applyPackedRgbaDisplaceEdit(uvec4 packedEdit, usampler2D sdfTexture, int numSdfs, inout vec3 pos, inout vec4 rgba) {\n    int sdfFirst, sdfCount;\n    bool invert;\n    uint rgbaBlendMode;\n    float softEdge, sdfSmooth;\n    decodeEdit(packedEdit, sdfFirst, sdfCount, invert, rgbaBlendMode, softEdge, sdfSmooth);\n    applyRgbaDisplaceEdit(sdfTexture, numSdfs, sdfFirst, sdfCount, pos, sdfSmooth, softEdge, invert, rgbaBlendMode, rgba);\n  }\n\\`);\n  function applyGsplatRgbaDisplaceEdits(gsplat, sdfArray, numEdits, rgbaDisplaceEdits) {\n    const dyno2 = new Dyno({\n      inTypes: {\n        gsplat: Gsplat,\n        sdfArray: SdfArray,\n        numEdits: \"int\",\n        rgbaDisplaceEdits: \"uvec4\"\n      },\n      outTypes: { gsplat: Gsplat },\n      globals: () => [defineSdfArray, defineEdit],\n      inputs: { gsplat, sdfArray, numEdits, rgbaDisplaceEdits },\n      statements: ({ inputs, outputs }) => {\n        const { sdfArray: sdfArray2, numEdits: numEdits2, rgbaDisplaceEdits: rgbaDisplaceEdits2 } = inputs;\n        const { gsplat: gsplat2 } = outputs;\n        return unindentLines(\\`\n        \\${gsplat2} = \\${inputs.gsplat};\n        if (isGsplatActive(\\${gsplat2}.flags)) {\n          for (int editIndex = 0; editIndex < \\${numEdits2}; ++editIndex) {\n            applyPackedRgbaDisplaceEdit(\n              \\${rgbaDisplaceEdits2}[editIndex], \\${sdfArray2}.sdfTexture, \\${sdfArray2}.numSdfs,\n              \\${gsplat2}.center, \\${gsplat2}.rgba\n            );\n          }\n        }\n      \\`);\n      }\n    });\n    return dyno2.outputs.gsplat;\n  }\n  const tempFloat32 = new Float32Array(1);\n  class SplatTransformer {\n    // Create the dyno uniforms that parameterize the transform, setting them\n    // to initial values that are different from any valid transform.\n    constructor() {\n      this.scale = new DynoFloat({ value: Number.NEGATIVE_INFINITY });\n      this.rotate = new DynoVec4({\n        value: new Quaternion(\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY\n        )\n      });\n      this.translate = new DynoVec3({\n        value: new Vector3(\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY,\n          Number.POSITIVE_INFINITY\n        )\n      });\n    }\n    // Apply the transform to a Vec3 position in a dyno program.\n    apply(position) {\n      return transformPos(position, {\n        scale: this.scale,\n        rotate: this.rotate,\n        translate: this.translate\n      });\n    }\n    applyDir(dir) {\n      return transformDir(dir, {\n        rotate: this.rotate\n      });\n    }\n    // Apply the transform to a Gsplat in a dyno program.\n    applyGsplat(gsplat) {\n      return transformGsplat(gsplat, {\n        scale: this.scale,\n        rotate: this.rotate,\n        translate: this.translate\n      });\n    }\n    // Update the uniforms to match the given transform matrix.\n    updateFromMatrix(transform) {\n      const scale = new Vector3();\n      const quaternion = new Quaternion();\n      const position = new Vector3();\n      transform.decompose(position, quaternion, scale);\n      const newScale = (scale.x + scale.y + scale.z) / 3;\n      let updated = false;\n      if (newScale !== this.scale.value) {\n        this.scale.value = newScale;\n        updated = true;\n      }\n      if (!position.equals(this.translate.value)) {\n        this.translate.value.copy(position);\n        updated = true;\n      }\n      if (!quaternion.equals(this.rotate.value)) {\n        this.rotate.value.copy(quaternion);\n        updated = true;\n      }\n      return updated;\n    }\n    // Update this transform to match the object's to-world transform.\n    update(object) {\n      object.updateMatrixWorld();\n      return this.updateFromMatrix(object.matrixWorld);\n    }\n  }\n  class SplatGenerator extends Object3D {\n    constructor({\n      numSplats,\n      generator,\n      construct,\n      update\n    }) {\n      super();\n      this.numSplats = numSplats ?? 0;\n      this.generator = generator;\n      this.frameUpdate = update;\n      this.version = 0;\n      if (construct) {\n        const constructed = construct(this);\n        Object.assign(this, constructed);\n      }\n    }\n    updateVersion() {\n      this.version += 1;\n    }\n    set needsUpdate(value) {\n      if (value) {\n        this.updateVersion();\n      }\n    }\n  }\n  const _SplatMesh = class _SplatMesh extends SplatGenerator {\n    constructor(options = {}) {\n      const transform = new SplatTransformer();\n      const viewToWorld = new SplatTransformer();\n      const worldToView = new SplatTransformer();\n      const viewToObject = new SplatTransformer();\n      const recolor = new DynoVec4({\n        value: new Vector4(\n          Number.NEGATIVE_INFINITY,\n          Number.NEGATIVE_INFINITY,\n          Number.NEGATIVE_INFINITY,\n          Number.NEGATIVE_INFINITY\n        )\n      });\n      const time = new DynoFloat({ value: 0 });\n      const deltaTime = new DynoFloat({ value: 0 });\n      const context = {\n        transform,\n        viewToWorld,\n        worldToView,\n        viewToObject,\n        recolor,\n        time,\n        deltaTime\n      };\n      super({\n        update: ({ time: time2, deltaTime: deltaTime2, viewToWorld: viewToWorld2, globalEdits }) => this.update({ time: time2, deltaTime: deltaTime2, viewToWorld: viewToWorld2, globalEdits })\n      });\n      this.isInitialized = false;\n      this.recolor = new Color(1, 1, 1);\n      this.opacity = 1;\n      this.enableViewToObject = false;\n      this.enableViewToWorld = false;\n      this.enableWorldToView = false;\n      this.skinning = null;\n      this.edits = null;\n      this.rgbaDisplaceEdits = null;\n      this.splatRgba = null;\n      this.maxSh = 3;\n      this.packedSplats = options.packedSplats ?? new PackedSplats();\n      this.numSplats = this.packedSplats.numSplats;\n      this.editable = options.editable ?? true;\n      this.onFrame = options.onFrame;\n      this.context = context;\n      this.objectModifier = options.objectModifier;\n      this.worldModifier = options.worldModifier;\n      this.updateGenerator();\n      if (options.url || options.fileBytes || options.constructSplats || options.packedSplats && !options.packedSplats.isInitialized) {\n        this.initialized = this.asyncInitialize(options).then(async () => {\n          this.updateGenerator();\n          this.isInitialized = true;\n          if (options.onLoad) {\n            const maybePromise = options.onLoad(this);\n            if (maybePromise instanceof Promise) {\n              await maybePromise;\n            }\n          }\n          return this;\n        });\n      } else {\n        this.isInitialized = true;\n        this.initialized = Promise.resolve(this);\n        if (options.onLoad) {\n          const maybePromise = options.onLoad(this);\n          if (maybePromise instanceof Promise) {\n            this.initialized = maybePromise.then(() => this);\n          }\n        }\n      }\n    }\n    async asyncInitialize(options) {\n      const { url, fileBytes, fileType, fileName, maxSplats, constructSplats } = options;\n      if (url || fileBytes || constructSplats) {\n        const packedSplatsOptions = {\n          url,\n          fileBytes,\n          fileType,\n          fileName,\n          maxSplats,\n          construct: constructSplats\n        };\n        this.packedSplats.reinitialize(packedSplatsOptions);\n      }\n      if (this.packedSplats) {\n        await this.packedSplats.initialized;\n        this.numSplats = this.packedSplats.numSplats;\n        this.updateGenerator();\n      }\n    }\n    static async staticInitialize() {\n      await __wbg_init();\n      _SplatMesh.isStaticInitialized = true;\n    }\n    // Creates a new Gsplat with the provided parameters (all values in \"float\" space,\n    // i.e. 0-1 for opacity and color) and adds it to the end of the packedSplats,\n    // increasing numSplats by 1. If necessary, reallocates the buffer with an exponential\n    // doubling strategy to fit the new data, so it's fairly efficient to just\n    // pushSplat(...) each Gsplat you want to create in a loop.\n    pushSplat(center, scales, quaternion, opacity, color) {\n      this.packedSplats.pushSplat(center, scales, quaternion, opacity, color);\n    }\n    // This method iterates over all Gsplats in this instance's packedSplats,\n    // invoking the provided callback with index: number in 0..=(this.numSplats-1) and\n    // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n    // opacity: number (0..1), and color: THREE.Color (rgb values in 0..1).\n    // Note that the objects passed in as center etc. are the same for every callback\n    // invocation: these objects are reused for efficiency. Changing these values has\n    // no effect as they are decoded/unpacked copies of the underlying data. To update\n    // the packedSplats, call .packedSplats.setSplat(index, center, scales,\n    // quaternion, opacity, color).\n    forEachSplat(callback) {\n      this.packedSplats.forEachSplat(callback);\n    }\n    // Call this when you are finished with the SplatMesh and want to free\n    // any buffers it holds (via packedSplats).\n    dispose() {\n      this.packedSplats.dispose();\n    }\n    constructGenerator(context) {\n      const { transform, viewToObject, recolor } = context;\n      const generator = dynoBlock(\n        { index: \"int\" },\n        { gsplat: Gsplat },\n        ({ index }) => {\n          if (!index) {\n            throw new Error(\"index is undefined\");\n          }\n          let gsplat = readPackedSplat(this.packedSplats.dyno, index);\n          if (this.maxSh >= 1) {\n            const { sh1Texture, sh2Texture, sh3Texture } = this.ensureShTextures();\n            if (sh1Texture) {\n              const viewCenterInObject = viewToObject.translate;\n              const { center } = splitGsplat(gsplat).outputs;\n              const viewDir = normalize(sub(center, viewCenterInObject));\n              let rgb = evaluateSH1(gsplat, sh1Texture, viewDir);\n              if (this.maxSh >= 2 && sh2Texture) {\n                rgb = add(rgb, evaluateSH2(gsplat, sh2Texture, viewDir));\n              }\n              if (this.maxSh >= 3 && sh3Texture) {\n                rgb = add(rgb, evaluateSH3(gsplat, sh3Texture, viewDir));\n              }\n              let { rgba } = splitGsplat(gsplat).outputs;\n              rgba = add(rgba, extendVec(rgb, dynoConst(\"float\", 0)));\n              gsplat = combineGsplat({ gsplat, rgba });\n            }\n          }\n          if (this.splatRgba) {\n            const rgba = readRgbaArray(this.splatRgba.dyno, index);\n            gsplat = combineGsplat({ gsplat, rgba });\n          }\n          if (this.skinning) {\n            gsplat = this.skinning.modify(gsplat);\n          }\n          if (this.objectModifier) {\n            gsplat = this.objectModifier.apply({ gsplat }).gsplat;\n          }\n          gsplat = transform.applyGsplat(gsplat);\n          const recolorRgba = mul(recolor, splitGsplat(gsplat).outputs.rgba);\n          gsplat = combineGsplat({ gsplat, rgba: recolorRgba });\n          if (this.rgbaDisplaceEdits) {\n            gsplat = this.rgbaDisplaceEdits.modify(gsplat);\n          }\n          if (this.worldModifier) {\n            gsplat = this.worldModifier.apply({ gsplat }).gsplat;\n          }\n          return { gsplat };\n        }\n      );\n      this.generator = generator;\n    }\n    // Call this whenever something changes in the Gsplat processing pipeline,\n    // for example changing maxSh or updating objectModifier or worldModifier.\n    // Compiled generators are cached for efficiency and re-use when the same\n    // pipeline structure emerges after successive changes.\n    updateGenerator() {\n      this.constructGenerator(this.context);\n    }\n    // This is called automatically by SparkRenderer and you should not have to\n    // call it. It updates parameters for the generated pipeline and calls\n    // updateGenerator() if the pipeline needs to change.\n    update({\n      time,\n      viewToWorld,\n      deltaTime,\n      globalEdits\n    }) {\n      var _a2;\n      this.numSplats = this.packedSplats.numSplats;\n      this.context.time.value = time;\n      this.context.deltaTime.value = deltaTime;\n      _SplatMesh.dynoTime.value = time;\n      const { transform, viewToObject, recolor } = this.context;\n      let updated = transform.update(this);\n      if (this.context.viewToWorld.updateFromMatrix(viewToWorld) && this.enableViewToWorld) {\n        updated = true;\n      }\n      const worldToView = viewToWorld.clone().invert();\n      if (this.context.worldToView.updateFromMatrix(worldToView) && this.enableWorldToView) {\n        updated = true;\n      }\n      const objectToWorld = new Matrix4().compose(\n        transform.translate.value,\n        transform.rotate.value,\n        new Vector3().setScalar(transform.scale.value)\n      );\n      const worldToObject = objectToWorld.invert();\n      const viewToObjectMatrix = worldToObject.multiply(viewToWorld);\n      if (viewToObject.updateFromMatrix(viewToObjectMatrix) && (this.enableViewToObject || this.packedSplats.extra.sh1)) {\n        updated = true;\n      }\n      const newRecolor = new Vector4(\n        this.recolor.r,\n        this.recolor.g,\n        this.recolor.b,\n        this.opacity\n      );\n      if (!newRecolor.equals(recolor.value)) {\n        recolor.value.copy(newRecolor);\n        updated = true;\n      }\n      const edits = this.editable ? (this.edits ?? []).concat(globalEdits) : [];\n      if (this.editable && !this.edits) {\n        this.traverseVisible((node) => {\n          if (node instanceof SplatEdit) {\n            edits.push(node);\n          }\n        });\n      }\n      edits.sort((a, b) => a.ordering - b.ordering);\n      const editsSdfs = edits.map((edit) => {\n        if (edit.sdfs != null) {\n          return { edit, sdfs: edit.sdfs };\n        }\n        const sdfs = [];\n        edit.traverseVisible((node) => {\n          if (node instanceof SplatEditSdf) {\n            sdfs.push(node);\n          }\n        });\n        return { edit, sdfs };\n      });\n      if (editsSdfs.length > 0 && !this.rgbaDisplaceEdits) {\n        const edits2 = editsSdfs.length;\n        const sdfs = editsSdfs.reduce(\n          (total, edit) => total + edit.sdfs.length,\n          0\n        );\n        this.rgbaDisplaceEdits = new SplatEdits({\n          maxEdits: edits2,\n          maxSdfs: sdfs\n        });\n        this.updateGenerator();\n      }\n      if (this.rgbaDisplaceEdits) {\n        const editResult = this.rgbaDisplaceEdits.update(editsSdfs);\n        updated || (updated = editResult.updated);\n        if (editResult.dynoUpdated) {\n          this.updateGenerator();\n        }\n      }\n      if (updated) {\n        this.updateVersion();\n      }\n      (_a2 = this.onFrame) == null ? void 0 : _a2.call(this, { mesh: this, time, deltaTime });\n    }\n    // This method conforms to the standard THREE.Raycaster API, performing object-ray\n    // intersections using this method to populate the provided intersects[] array\n    // with each intersection point.\n    raycast(raycaster, intersects) {\n      if (!this.packedSplats.packedArray || !this.packedSplats.numSplats) {\n        return;\n      }\n      const { near, far, ray } = raycaster;\n      const worldToMesh = this.matrixWorld.clone().invert();\n      const worldToMeshRot = new Matrix3().setFromMatrix4(worldToMesh);\n      const origin = ray.origin.clone().applyMatrix4(worldToMesh);\n      const direction = ray.direction.clone().applyMatrix3(worldToMeshRot);\n      const scales = new Vector3();\n      worldToMesh.decompose(new Vector3(), new Quaternion(), scales);\n      (scales.x * scales.y * scales.z) ** (1 / 3);\n      const RAYCAST_ELLIPSOID = true;\n      const distances = raycast_splats(\n        origin.x,\n        origin.y,\n        origin.z,\n        direction.x,\n        direction.y,\n        direction.z,\n        near,\n        far,\n        this.packedSplats.numSplats,\n        this.packedSplats.packedArray,\n        RAYCAST_ELLIPSOID\n      );\n      for (const distance of distances) {\n        const point = ray.direction.clone().multiplyScalar(distance).add(ray.origin);\n        intersects.push({\n          distance,\n          point,\n          object: this\n        });\n      }\n    }\n    ensureShTextures() {\n      if (!this.packedSplats.extra.sh1) {\n        return {};\n      }\n      let sh1Texture = this.packedSplats.extra.sh1Texture;\n      if (!sh1Texture) {\n        let sh1 = this.packedSplats.extra.sh1;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh1.length / 2\n        );\n        if (sh1.length < maxSplats * 2) {\n          const newSh1 = new Uint32Array(maxSplats * 2);\n          newSh1.set(sh1);\n          this.packedSplats.extra.sh1 = newSh1;\n          sh1 = newSh1;\n        }\n        const texture = new DataArrayTexture(sh1, width, height, depth);\n        texture.format = RGIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = \"RG32UI\";\n        texture.needsUpdate = true;\n        sh1Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: \"sh1\"\n        });\n        this.packedSplats.extra.sh1Texture = sh1Texture;\n      }\n      if (!this.packedSplats.extra.sh2) {\n        return { sh1Texture };\n      }\n      let sh2Texture = this.packedSplats.extra.sh2Texture;\n      if (!sh2Texture) {\n        let sh2 = this.packedSplats.extra.sh2;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh2.length / 4\n        );\n        if (sh2.length < maxSplats * 4) {\n          const newSh2 = new Uint32Array(maxSplats * 4);\n          newSh2.set(sh2);\n          this.packedSplats.extra.sh2 = newSh2;\n          sh2 = newSh2;\n        }\n        const texture = new DataArrayTexture(sh2, width, height, depth);\n        texture.format = RGBAIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = \"RGBA32UI\";\n        texture.needsUpdate = true;\n        sh2Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: \"sh2\"\n        });\n        this.packedSplats.extra.sh2Texture = sh2Texture;\n      }\n      if (!this.packedSplats.extra.sh3) {\n        return { sh1Texture, sh2Texture };\n      }\n      let sh3Texture = this.packedSplats.extra.sh3Texture;\n      if (!sh3Texture) {\n        let sh3 = this.packedSplats.extra.sh3;\n        const { width, height, depth, maxSplats } = getTextureSize(\n          sh3.length / 4\n        );\n        if (sh3.length < maxSplats * 4) {\n          const newSh3 = new Uint32Array(maxSplats * 4);\n          newSh3.set(sh3);\n          this.packedSplats.extra.sh3 = newSh3;\n          sh3 = newSh3;\n        }\n        const texture = new DataArrayTexture(sh3, width, height, depth);\n        texture.format = RGBAIntegerFormat;\n        texture.type = UnsignedIntType;\n        texture.internalFormat = \"RGBA32UI\";\n        texture.needsUpdate = true;\n        sh3Texture = new DynoUsampler2DArray({\n          value: texture,\n          key: \"sh3\"\n        });\n        this.packedSplats.extra.sh3Texture = sh3Texture;\n      }\n      return { sh1Texture, sh2Texture, sh3Texture };\n    }\n  };\n  _SplatMesh.staticInitialized = _SplatMesh.staticInitialize();\n  _SplatMesh.isStaticInitialized = false;\n  _SplatMesh.dynoTime = new DynoFloat({ value: 0 });\n  let SplatMesh = _SplatMesh;\n  const defineEvaluateSH1 = unindent(\\`\n  vec3 evaluateSH1(Gsplat gsplat, usampler2DArray sh1, vec3 viewDir) {\n    // Extract sint7 values packed into 2 x uint32\n    uvec2 packed = texelFetch(sh1, splatTexCoord(gsplat.index), 0).rg;\n    vec3 sh1_0 = vec3(ivec3(\n      int(packed.x << 25u) >> 25,\n      int(packed.x << 18u) >> 25,\n      int(packed.x << 11u) >> 25\n    )) / 63.0;\n    vec3 sh1_1 = vec3(ivec3(\n      int(packed.x << 4u) >> 25,\n      int((packed.x >> 3u) | (packed.y << 29u)) >> 25,\n      int(packed.y << 22u) >> 25\n    )) / 63.0;\n    vec3 sh1_2 = vec3(ivec3(\n      int(packed.y << 15u) >> 25,\n      int(packed.y << 8u) >> 25,\n      int(packed.y << 1u) >> 25\n    )) / 63.0;\n\n    return sh1_0 * (-0.4886025 * viewDir.y)\n      + sh1_1 * (0.4886025 * viewDir.z)\n      + sh1_2 * (-0.4886025 * viewDir.x);\n  }\n\\`);\n  const defineEvaluateSH2 = unindent(\\`\n  vec3 evaluateSH2(Gsplat gsplat, usampler2DArray sh2, vec3 viewDir) {\n    // Extract sint8 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh2, splatTexCoord(gsplat.index), 0);\n    vec3 sh2_0 = vec3(ivec3(\n      int(packed.x << 24u) >> 24,\n      int(packed.x << 16u) >> 24,\n      int(packed.x << 8u) >> 24\n    )) / 127.0;\n    vec3 sh2_1 = vec3(ivec3(\n      int(packed.x) >> 24,\n      int(packed.y << 24u) >> 24,\n      int(packed.y << 16u) >> 24\n    )) / 127.0;\n    vec3 sh2_2 = vec3(ivec3(\n      int(packed.y << 8u) >> 24,\n      int(packed.y) >> 24,\n      int(packed.z << 24u) >> 24\n    )) / 127.0;\n    vec3 sh2_3 = vec3(ivec3(\n      int(packed.z << 16u) >> 24,\n      int(packed.z << 8u) >> 24,\n      int(packed.z) >> 24\n    )) / 127.0;\n    vec3 sh2_4 = vec3(ivec3(\n      int(packed.w << 24u) >> 24,\n      int(packed.w << 16u) >> 24,\n      int(packed.w << 8u) >> 24\n    )) / 127.0;\n\n    return sh2_0 * (1.0925484 * viewDir.x * viewDir.y)\n      + sh2_1 * (1.0925484 * viewDir.y * viewDir.z)\n      + sh2_2 * (0.3153915 * (2.0 * viewDir.z * viewDir.z - viewDir.x * viewDir.x - viewDir.y * viewDir.y))\n      + sh2_3 * (1.0925484 * viewDir.x * viewDir.z)\n      + sh2_4 * (0.5462742 * (viewDir.x * viewDir.x - viewDir.y * viewDir.y));\n  }\n\\`);\n  const defineEvaluateSH3 = unindent(\\`\n  vec3 evaluateSH3(Gsplat gsplat, usampler2DArray sh3, vec3 viewDir) {\n    // Extract sint6 values packed into 4 x uint32\n    uvec4 packed = texelFetch(sh3, splatTexCoord(gsplat.index), 0);\n    vec3 sh3_0 = vec3(ivec3(\n      int(packed.x << 26u) >> 26,\n      int(packed.x << 20u) >> 26,\n      int(packed.x << 14u) >> 26\n    )) / 31.0;\n    vec3 sh3_1 = vec3(ivec3(\n      int(packed.x << 8u) >> 26,\n      int(packed.x << 2u) >> 26,\n      int((packed.x >> 4u) | (packed.y << 28u)) >> 26\n    )) / 31.0;\n    vec3 sh3_2 = vec3(ivec3(\n      int(packed.y << 22u) >> 26,\n      int(packed.y << 16u) >> 26,\n      int(packed.y << 10u) >> 26\n    )) / 31.0;\n    vec3 sh3_3 = vec3(ivec3(\n      int(packed.y << 4u) >> 26,\n      int((packed.y >> 2u) | (packed.z << 30u)) >> 26,\n      int(packed.z << 24u) >> 26\n    )) / 31.0;\n    vec3 sh3_4 = vec3(ivec3(\n      int(packed.z << 18u) >> 26,\n      int(packed.z << 12u) >> 26,\n      int(packed.z << 6u) >> 26\n    )) / 31.0;\n    vec3 sh3_5 = vec3(ivec3(\n      int(packed.z) >> 26,\n      int(packed.w << 26u) >> 26,\n      int(packed.w << 20u) >> 26\n    )) / 31.0;\n    vec3 sh3_6 = vec3(ivec3(\n      int(packed.w << 14u) >> 26,\n      int(packed.w << 8u) >> 26,\n      int(packed.w << 2u) >> 26\n    )) / 31.0;\n\n    float xx = viewDir.x * viewDir.x;\n    float yy = viewDir.y * viewDir.y;\n    float zz = viewDir.z * viewDir.z;\n    float xy = viewDir.x * viewDir.y;\n    float yz = viewDir.y * viewDir.z;\n    float zx = viewDir.z * viewDir.x;\n\n    return sh3_0 * (-0.5900436 * viewDir.y * (3.0 * xx - yy))\n      + sh3_1 * (2.8906114 * xy * viewDir.z) +\n      + sh3_2 * (-0.4570458 * viewDir.y * (4.0 * zz - xx - yy))\n      + sh3_3 * (0.3731763 * viewDir.z * (2.0 * zz - 3.0 * xx - 3.0 * yy))\n      + sh3_4 * (-0.4570458 * viewDir.x * (4.0 * zz - xx - yy))\n      + sh3_5 * (1.4453057 * viewDir.z * (xx - yy))\n      + sh3_6 * (-0.5900436 * viewDir.x * (xx - 3.0 * yy));\n  }\n\\`);\n  function evaluateSH1(gsplat, sh1, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh1: \"usampler2DArray\", viewDir: \"vec3\" },\n      outTypes: { rgb: \"vec3\" },\n      inputs: { gsplat, sh1, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH1],\n      statements: ({ inputs, outputs }) => {\n        const statements = unindentLines(\\`\n        if (isGsplatActive(\\${inputs.gsplat}.flags)) {\n          \\${outputs.rgb} = evaluateSH1(\\${inputs.gsplat}, \\${inputs.sh1}, \\${inputs.viewDir});\n        } else {\n          \\${outputs.rgb} = vec3(0.0);\n        }\n      \\`);\n        return statements;\n      }\n    }).outputs.rgb;\n  }\n  function evaluateSH2(gsplat, sh2, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh2: \"usampler2DArray\", viewDir: \"vec3\" },\n      outTypes: { rgb: \"vec3\" },\n      inputs: { gsplat, sh2, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH2],\n      statements: ({ inputs, outputs }) => unindentLines(\\`\n        if (isGsplatActive(\\${inputs.gsplat}.flags)) {\n          \\${outputs.rgb} = evaluateSH2(\\${inputs.gsplat}, \\${inputs.sh2}, \\${inputs.viewDir});\n        } else {\n          \\${outputs.rgb} = vec3(0.0);\n        }\n      \\`)\n    }).outputs.rgb;\n  }\n  function evaluateSH3(gsplat, sh3, viewDir) {\n    return dyno({\n      inTypes: { gsplat: Gsplat, sh3: \"usampler2DArray\", viewDir: \"vec3\" },\n      outTypes: { rgb: \"vec3\" },\n      inputs: { gsplat, sh3, viewDir },\n      globals: () => [defineGsplat, defineEvaluateSH3],\n      statements: ({ inputs, outputs }) => unindentLines(\\`\n        if (isGsplatActive(\\${inputs.gsplat}.flags)) {\n          \\${outputs.rgb} = evaluateSH3(\\${inputs.gsplat}, \\${inputs.sh3}, \\${inputs.viewDir});\n        } else {\n          \\${outputs.rgb} = vec3(0.0);\n        }\n      \\`)\n    }).outputs.rgb;\n  }\n  function WorkerWrapper(options) {\n    return new Worker(\n      self.location.href,\n      {\n        name: options == null ? void 0 : options.name\n      }\n    );\n  }\n  class SplatWorker {\n    constructor() {\n      this.messages = {};\n      this.messageIdNext = 0;\n      this.worker = new WorkerWrapper();\n      this.worker.onmessage = (event) => this.onMessage(event);\n    }\n    makeMessageId() {\n      return ++this.messageIdNext;\n    }\n    makeMessagePromiseId() {\n      const id = this.makeMessageId();\n      const promise = new Promise((resolve, reject) => {\n        this.messages[id] = { resolve, reject };\n      });\n      return { id, promise };\n    }\n    onMessage(event) {\n      const { id, result, error } = event.data;\n      const handler = this.messages[id];\n      if (handler) {\n        delete this.messages[id];\n        if (error) {\n          handler.reject(error);\n        } else {\n          handler.resolve(result);\n        }\n      }\n    }\n    // Invoke an RPC on the worker with the given name and arguments.\n    // The normal usage of a worker is to run one activity at a time,\n    // but this function allows for concurrent calls, tagging each request\n    // with a unique message Id and awaiting a response to that same Id.\n    // The method will automatically transfer any ArrayBuffers in the\n    // arguments to the worker. If you'd like to transfer a copy of a\n    // buffer then you must clone it before passing to this function.\n    async call(name, args) {\n      const { id, promise } = this.makeMessagePromiseId();\n      this.worker.postMessage(\n        { name, args, id },\n        { transfer: getArrayBuffers(args) }\n      );\n      return promise;\n    }\n  }\n  let maxWorkers = 4;\n  let numWorkers = 0;\n  const freeWorkers = [];\n  const workerQueue = [];\n  async function allocWorker() {\n    const worker = freeWorkers.shift();\n    if (worker) {\n      return worker;\n    }\n    if (numWorkers < maxWorkers) {\n      const worker2 = new SplatWorker();\n      numWorkers += 1;\n      return worker2;\n    }\n    return new Promise((resolve) => {\n      workerQueue.push(resolve);\n    });\n  }\n  function freeWorker(worker) {\n    if (numWorkers > maxWorkers) {\n      numWorkers -= 1;\n      return;\n    }\n    const waiter = workerQueue.shift();\n    if (waiter) {\n      waiter(worker);\n      return;\n    }\n    freeWorkers.push(worker);\n  }\n  async function withWorker(callback) {\n    const worker = await allocWorker();\n    try {\n      return await callback(worker);\n    } finally {\n      freeWorker(worker);\n    }\n  }\n  var SplatFileType = /* @__PURE__ */ ((SplatFileType2) => {\n    SplatFileType2[\"PLY\"] = \"ply\";\n    SplatFileType2[\"SPZ\"] = \"spz\";\n    SplatFileType2[\"SPLAT\"] = \"splat\";\n    SplatFileType2[\"KSPLAT\"] = \"ksplat\";\n    return SplatFileType2;\n  })(SplatFileType || {});\n  function getSplatFileType(fileBytes) {\n    const view = new DataView(fileBytes.buffer);\n    if ((view.getUint32(0, true) & 16777215) === 7957616) {\n      return \"ply\";\n    }\n    if ((view.getUint32(0, true) & 16777215) === 559903) {\n      const header = decompressPartialGzip(fileBytes, 4);\n      const gView = new DataView(header.buffer);\n      if (gView.getUint32(0, true) === 1347635022) {\n        return \"spz\";\n      }\n      return void 0;\n    }\n    return void 0;\n  }\n  function getFileExtension(pathOrUrl) {\n    const noTrailing = pathOrUrl.split(/[?#]/, 1)[0];\n    const lastSlash = Math.max(\n      noTrailing.lastIndexOf(\"/\"),\n      noTrailing.lastIndexOf(\"\\\\\\\\\")\n    );\n    const filename = noTrailing.slice(lastSlash + 1);\n    const lastDot = filename.lastIndexOf(\".\");\n    if (lastDot <= 0 || lastDot === filename.length - 1) {\n      return \"\";\n    }\n    return filename.slice(lastDot + 1).toLowerCase();\n  }\n  function getSplatFileTypeFromPath(pathOrUrl) {\n    const extension = getFileExtension(pathOrUrl);\n    if (extension === \"ply\") {\n      return \"ply\";\n    }\n    if (extension === \"spz\") {\n      return \"spz\";\n    }\n    if (extension === \"splat\") {\n      return \"splat\";\n    }\n    if (extension === \"ksplat\") {\n      return \"ksplat\";\n    }\n    return void 0;\n  }\n  async function unpackSplats({\n    input,\n    fileType,\n    pathOrUrl\n  }) {\n    const fileBytes = input instanceof ArrayBuffer ? new Uint8Array(input) : input;\n    let splatFileType = fileType;\n    if (!fileType) {\n      splatFileType = getSplatFileType(fileBytes);\n      if (!splatFileType && pathOrUrl) {\n        splatFileType = getSplatFileTypeFromPath(pathOrUrl);\n      }\n    }\n    switch (splatFileType) {\n      case \"ply\": {\n        const ply = new PlyReader({ fileBytes });\n        await ply.parseHeader();\n        const numSplats = ply.numSplats;\n        const maxSplats = getTextureSize(numSplats).maxSplats;\n        const args = { fileBytes, packedArray: new Uint32Array(maxSplats * 4) };\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats: numSplats2, extra } = await worker.call(\n            \"unpackPly\",\n            args\n          );\n          return { packedArray, numSplats: numSplats2, extra };\n        });\n      }\n      case \"spz\": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats, extra } = await worker.call(\n            \"decodeSpz\",\n            {\n              fileBytes\n            }\n          );\n          return { packedArray, numSplats, extra };\n        });\n      }\n      case \"splat\": {\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats } = await worker.call(\n            \"decodeAntiSplat\",\n            {\n              fileBytes\n            }\n          );\n          return { packedArray, numSplats };\n        });\n      }\n      case \"ksplat\":\n        return await withWorker(async (worker) => {\n          const { packedArray, numSplats, extra } = await worker.call(\n            \"decodeKsplat\",\n            { fileBytes }\n          );\n          return { packedArray, numSplats, extra };\n        });\n      default: {\n        throw new Error(\\`Unknown splat file type: \\${splatFileType}\\`);\n      }\n    }\n  }\n  class SplatData {\n    constructor({ maxSplats = 1 } = {}) {\n      this.numSplats = 0;\n      this.maxSplats = getTextureSize(maxSplats).maxSplats;\n      this.centers = new Float32Array(this.maxSplats * 3);\n      this.scales = new Float32Array(this.maxSplats * 3);\n      this.quaternions = new Float32Array(this.maxSplats * 4);\n      this.opacities = new Float32Array(this.maxSplats);\n      this.colors = new Float32Array(this.maxSplats * 3);\n    }\n    pushSplat() {\n      const index = this.numSplats;\n      this.ensureIndex(index);\n      this.numSplats += 1;\n      return index;\n    }\n    unpushSplat(index) {\n      if (index === this.numSplats - 1) {\n        this.numSplats -= 1;\n      } else {\n        throw new Error(\"Cannot unpush splat from non-last position\");\n      }\n    }\n    ensureCapacity(numSplats) {\n      if (numSplats > this.maxSplats) {\n        const targetSplats = Math.max(numSplats, this.maxSplats * 2);\n        const newCenters = new Float32Array(targetSplats * 3);\n        const newScales = new Float32Array(targetSplats * 3);\n        const newQuaternions = new Float32Array(targetSplats * 4);\n        const newOpacities = new Float32Array(targetSplats);\n        const newColors = new Float32Array(targetSplats * 3);\n        newCenters.set(this.centers);\n        newScales.set(this.scales);\n        newQuaternions.set(this.quaternions);\n        newOpacities.set(this.opacities);\n        newColors.set(this.colors);\n        this.centers = newCenters;\n        this.scales = newScales;\n        this.quaternions = newQuaternions;\n        this.opacities = newOpacities;\n        this.colors = newColors;\n        if (this.sh1) {\n          const newSh1 = new Float32Array(targetSplats * 9);\n          newSh1.set(this.sh1);\n          this.sh1 = newSh1;\n        }\n        if (this.sh2) {\n          const newSh2 = new Float32Array(targetSplats * 15);\n          newSh2.set(this.sh2);\n          this.sh2 = newSh2;\n        }\n        if (this.sh3) {\n          const newSh3 = new Float32Array(targetSplats * 21);\n          newSh3.set(this.sh3);\n          this.sh3 = newSh3;\n        }\n        this.maxSplats = targetSplats;\n      }\n    }\n    ensureIndex(index) {\n      this.ensureCapacity(index + 1);\n    }\n    setCenter(index, x2, y, z) {\n      this.centers[index * 3] = x2;\n      this.centers[index * 3 + 1] = y;\n      this.centers[index * 3 + 2] = z;\n    }\n    setScale(index, scaleX, scaleY, scaleZ) {\n      this.scales[index * 3] = scaleX;\n      this.scales[index * 3 + 1] = scaleY;\n      this.scales[index * 3 + 2] = scaleZ;\n    }\n    setQuaternion(index, x2, y, z, w) {\n      this.quaternions[index * 4] = x2;\n      this.quaternions[index * 4 + 1] = y;\n      this.quaternions[index * 4 + 2] = z;\n      this.quaternions[index * 4 + 3] = w;\n    }\n    setOpacity(index, opacity) {\n      this.opacities[index] = opacity;\n    }\n    setColor(index, r, g, b) {\n      this.colors[index * 3] = r;\n      this.colors[index * 3 + 1] = g;\n      this.colors[index * 3 + 2] = b;\n    }\n    setSh1(index, sh1) {\n      if (!this.sh1) {\n        this.sh1 = new Float32Array(this.maxSplats * 9);\n      }\n      for (let j = 0; j < 9; ++j) {\n        this.sh1[index * 9 + j] = sh1[j];\n      }\n    }\n    setSh2(index, sh2) {\n      if (!this.sh2) {\n        this.sh2 = new Float32Array(this.maxSplats * 15);\n      }\n      for (let j = 0; j < 15; ++j) {\n        this.sh2[index * 15 + j] = sh2[j];\n      }\n    }\n    setSh3(index, sh3) {\n      if (!this.sh3) {\n        this.sh3 = new Float32Array(this.maxSplats * 21);\n      }\n      for (let j = 0; j < 21; ++j) {\n        this.sh3[index * 21 + j] = sh3[j];\n      }\n    }\n  }\n  class SpzReader {\n    constructor({ fileBytes }) {\n      this.fileBytes = fileBytes instanceof ArrayBuffer ? new Uint8Array(fileBytes) : fileBytes;\n      this.reader = new GunzipReader({ fileBytes: this.fileBytes });\n      const header = new DataView(this.reader.read(16).buffer);\n      if (header.getUint32(0, true) !== 1347635022) {\n        throw new Error(\"Invalid SPZ file\");\n      }\n      this.version = header.getUint32(4, true);\n      if (this.version < 1 || this.version > 2) {\n        throw new Error(\\`Unsupported SPZ version: \\${this.version}\\`);\n      }\n      this.numSplats = header.getUint32(8, true);\n      this.shDegree = header.getUint8(12);\n      this.fractionalBits = header.getUint8(13);\n      this.flags = header.getUint8(14);\n      this.flagAntiAlias = (this.flags & 1) !== 0;\n      this.reserved = header.getUint8(15);\n      this.parsed = false;\n    }\n    parseSplats(centerCallback, alphaCallback, rgbCallback, scalesCallback, quatCallback, shCallback) {\n      if (this.parsed) {\n        throw new Error(\"SPZ file already parsed\");\n      }\n      this.parsed = true;\n      if (this.version === 1) {\n        const centerBytes = this.reader.read(this.numSplats * 3 * 2);\n        const centerUint16 = new Uint16Array(centerBytes.buffer);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const x2 = fromHalf(centerUint16[i3]);\n          const y = fromHalf(centerUint16[i3 + 1]);\n          const z = fromHalf(centerUint16[i3 + 2]);\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\n        }\n      } else if (this.version === 2) {\n        const fixed = 1 << this.fractionalBits;\n        const centerBytes = this.reader.read(this.numSplats * 3 * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i9 = i2 * 9;\n          const x2 = ((centerBytes[i9 + 2] << 24 | centerBytes[i9 + 1] << 16 | centerBytes[i9] << 8) >> 8) / fixed;\n          const y = ((centerBytes[i9 + 5] << 24 | centerBytes[i9 + 4] << 16 | centerBytes[i9 + 3] << 8) >> 8) / fixed;\n          const z = ((centerBytes[i9 + 8] << 24 | centerBytes[i9 + 7] << 16 | centerBytes[i9 + 6] << 8) >> 8) / fixed;\n          centerCallback == null ? void 0 : centerCallback(i2, x2, y, z);\n        }\n      } else {\n        throw new Error(\"Unreachable\");\n      }\n      {\n        const bytes = this.reader.read(this.numSplats);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          alphaCallback == null ? void 0 : alphaCallback(i2, bytes[i2] / 255);\n        }\n      }\n      {\n        const rgbBytes = this.reader.read(this.numSplats * 3);\n        const scale = SH_C0 / 0.15;\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const r = (rgbBytes[i3] / 255 - 0.5) * scale + 0.5;\n          const g = (rgbBytes[i3 + 1] / 255 - 0.5) * scale + 0.5;\n          const b = (rgbBytes[i3 + 2] / 255 - 0.5) * scale + 0.5;\n          rgbCallback == null ? void 0 : rgbCallback(i2, r, g, b);\n        }\n      }\n      {\n        const scalesBytes = this.reader.read(this.numSplats * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const scaleX = Math.exp(scalesBytes[i3] / 16 - 10);\n          const scaleY = Math.exp(scalesBytes[i3 + 1] / 16 - 10);\n          const scaleZ = Math.exp(scalesBytes[i3 + 2] / 16 - 10);\n          scalesCallback == null ? void 0 : scalesCallback(i2, scaleX, scaleY, scaleZ);\n        }\n      }\n      {\n        const quatBytes = this.reader.read(this.numSplats * 3);\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          const i3 = i2 * 3;\n          const quatX = quatBytes[i3] / 127.5 - 1;\n          const quatY = quatBytes[i3 + 1] / 127.5 - 1;\n          const quatZ = quatBytes[i3 + 2] / 127.5 - 1;\n          const quatW = Math.sqrt(\n            Math.max(0, 1 - quatX * quatX - quatY * quatY - quatZ * quatZ)\n          );\n          quatCallback == null ? void 0 : quatCallback(i2, quatX, quatY, quatZ, quatW);\n        }\n      }\n      if (shCallback && this.shDegree >= 1) {\n        const sh1 = new Float32Array(3 * 3);\n        const sh2 = this.shDegree >= 2 ? new Float32Array(5 * 3) : void 0;\n        const sh3 = this.shDegree >= 3 ? new Float32Array(7 * 3) : void 0;\n        const shBytes = this.reader.read(\n          this.numSplats * SH_DEGREE_TO_VECS[this.shDegree] * 3\n        );\n        let offset = 0;\n        for (let i2 = 0; i2 < this.numSplats; i2++) {\n          for (let j = 0; j < 9; ++j) {\n            sh1[j] = (shBytes[offset + j] - 128) / 128;\n          }\n          offset += 9;\n          if (sh2) {\n            for (let j = 0; j < 15; ++j) {\n              sh2[j] = (shBytes[offset + j] - 128) / 128;\n            }\n            offset += 15;\n          }\n          if (sh3) {\n            for (let j = 0; j < 21; ++j) {\n              sh3[j] = (shBytes[offset + j] - 128) / 128;\n            }\n            offset += 21;\n          }\n          shCallback == null ? void 0 : shCallback(i2, sh1, sh2, sh3);\n        }\n      }\n    }\n  }\n  const SH_DEGREE_TO_VECS = { 1: 3, 2: 8, 3: 15 };\n  const SH_C0 = 0.28209479177387814;\n  const SPZ_MAGIC = 1347635022;\n  const SPZ_VERSION = 2;\n  const FLAG_ANTIALIASED = 1;\n  class SpzWriter {\n    constructor({\n      numSplats,\n      shDegree,\n      fractionalBits = 12,\n      flagAntiAlias = true\n    }) {\n      this.clippedCount = 0;\n      const splatSize = 9 + 1 + 3 + 3 + 3 + (shDegree >= 1 ? 9 : 0) + (shDegree >= 2 ? 15 : 0) + (shDegree >= 3 ? 21 : 0);\n      const bufferSize = 16 + numSplats * splatSize;\n      this.buffer = new ArrayBuffer(bufferSize);\n      this.view = new DataView(this.buffer);\n      this.view.setUint32(0, SPZ_MAGIC, true);\n      this.view.setUint32(4, SPZ_VERSION, true);\n      this.view.setUint32(8, numSplats, true);\n      this.view.setUint8(12, shDegree);\n      this.view.setUint8(13, fractionalBits);\n      this.view.setUint8(14, flagAntiAlias ? FLAG_ANTIALIASED : 0);\n      this.view.setUint8(15, 0);\n      this.numSplats = numSplats;\n      this.shDegree = shDegree;\n      this.fractionalBits = fractionalBits;\n      this.fraction = 1 << fractionalBits;\n      this.flagAntiAlias = flagAntiAlias;\n    }\n    setCenter(index, x2, y, z) {\n      const xRounded = Math.round(x2 * this.fraction);\n      const xInt = Math.max(-8388607, Math.min(8388607, xRounded));\n      const yRounded = Math.round(y * this.fraction);\n      const yInt = Math.max(-8388607, Math.min(8388607, yRounded));\n      const zRounded = Math.round(z * this.fraction);\n      const zInt = Math.max(-8388607, Math.min(8388607, zRounded));\n      const clipped = xRounded !== xInt || yRounded !== yInt || zRounded !== zInt;\n      if (clipped) {\n        this.clippedCount += 1;\n      }\n      const i9 = index * 9;\n      const base = 16 + i9;\n      this.view.setUint8(base, xInt & 255);\n      this.view.setUint8(base + 1, xInt >> 8 & 255);\n      this.view.setUint8(base + 2, xInt >> 16 & 255);\n      this.view.setUint8(base + 3, yInt & 255);\n      this.view.setUint8(base + 4, yInt >> 8 & 255);\n      this.view.setUint8(base + 5, yInt >> 16 & 255);\n      this.view.setUint8(base + 6, zInt & 255);\n      this.view.setUint8(base + 7, zInt >> 8 & 255);\n      this.view.setUint8(base + 8, zInt >> 16 & 255);\n    }\n    setAlpha(index, alpha) {\n      const base = 16 + this.numSplats * 9 + index;\n      this.view.setUint8(\n        base,\n        Math.max(0, Math.min(255, Math.round(alpha * 255)))\n      );\n    }\n    static scaleRgb(r) {\n      const v = ((r - 0.5) / (SH_C0 / 0.15) + 0.5) * 255;\n      return Math.max(0, Math.min(255, Math.round(v)));\n    }\n    setRgb(index, r, g, b) {\n      const base = 16 + this.numSplats * 10 + index * 3;\n      this.view.setUint8(base, SpzWriter.scaleRgb(r));\n      this.view.setUint8(base + 1, SpzWriter.scaleRgb(g));\n      this.view.setUint8(base + 2, SpzWriter.scaleRgb(b));\n    }\n    setScale(index, scaleX, scaleY, scaleZ) {\n      const base = 16 + this.numSplats * 13 + index * 3;\n      this.view.setUint8(\n        base,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleX) + 10) * 16)))\n      );\n      this.view.setUint8(\n        base + 1,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleY) + 10) * 16)))\n      );\n      this.view.setUint8(\n        base + 2,\n        Math.max(0, Math.min(255, Math.round((Math.log(scaleZ) + 10) * 16)))\n      );\n    }\n    setQuat(index, quatX, quatY, quatZ, quatW) {\n      const base = 16 + this.numSplats * 16 + index * 3;\n      const quatNeg = quatW < 0;\n      this.view.setUint8(\n        base,\n        Math.max(\n          0,\n          Math.min(255, Math.round(((quatNeg ? -quatX : quatX) + 1) * 127.5))\n        )\n      );\n      this.view.setUint8(\n        base + 1,\n        Math.max(\n          0,\n          Math.min(255, Math.round(((quatNeg ? -quatY : quatY) + 1) * 127.5))\n        )\n      );\n      this.view.setUint8(\n        base + 2,\n        Math.max(\n          0,\n          Math.min(255, Math.round(((quatNeg ? -quatZ : quatZ) + 1) * 127.5))\n        )\n      );\n    }\n    static quantizeSh(sh, bits2) {\n      const value = Math.round(sh * 128) + 128;\n      const bucketSize = 1 << 8 - bits2;\n      const quantized = Math.floor((value + bucketSize / 2) / bucketSize) * bucketSize;\n      return Math.max(0, Math.min(255, quantized));\n    }\n    setSh(index, sh1, sh2, sh3) {\n      const shVecs = SH_DEGREE_TO_VECS[this.shDegree] || 0;\n      const base1 = 16 + this.numSplats * 19 + index * shVecs * 3;\n      for (let j = 0; j < 9; ++j) {\n        this.view.setUint8(base1 + j, SpzWriter.quantizeSh(sh1[j], 5));\n      }\n      if (sh2) {\n        const base2 = base1 + 9;\n        for (let j = 0; j < 15; ++j) {\n          this.view.setUint8(base2 + j, SpzWriter.quantizeSh(sh2[j], 4));\n        }\n        if (sh3) {\n          const base3 = base2 + 15;\n          for (let j = 0; j < 21; ++j) {\n            this.view.setUint8(base3 + j, SpzWriter.quantizeSh(sh3[j], 4));\n          }\n        }\n      }\n    }\n    async finalize() {\n      const input = new Uint8Array(this.buffer);\n      const stream = new ReadableStream({\n        async start(controller) {\n          controller.enqueue(input);\n          controller.close();\n        }\n      });\n      const compressed = stream.pipeThrough(new CompressionStream(\"gzip\"));\n      const response = new Response(compressed);\n      const buffer = await response.arrayBuffer();\n      console.log(\n        \"Compressed\",\n        input.length,\n        \"bytes to\",\n        buffer.byteLength,\n        \"bytes\"\n      );\n      return new Uint8Array(buffer);\n    }\n  }\n  async function transcodeSpz(input) {\n    var _a2, _b2, _c;\n    const splats = new SplatData();\n    const {\n      inputs,\n      clipXyz,\n      maxSh,\n      fractionalBits = 12,\n      opacityThreshold\n    } = input;\n    for (const input2 of inputs) {\n      let transformPos2 = function(pos) {\n        pos.multiplyScalar(scale);\n        pos.applyQuaternion(quaternion);\n        pos.add(translate);\n        return pos;\n      }, transformScales = function(scales) {\n        scales.multiplyScalar(scale);\n        return scales;\n      }, transformQuaternion = function(quat) {\n        quat.premultiply(quaternion);\n        return quat;\n      }, withinClip = function(p) {\n        return !clip || clip.containsPoint(p);\n      }, withinOpacity = function(opacity) {\n        return opacityThreshold !== void 0 ? opacity >= opacityThreshold : true;\n      };\n      const scale = ((_a2 = input2.transform) == null ? void 0 : _a2.scale) ?? 1;\n      const quaternion = new Quaternion().fromArray(\n        ((_b2 = input2.transform) == null ? void 0 : _b2.quaternion) ?? [0, 0, 0, 1]\n      );\n      const translate = new Vector3().fromArray(\n        ((_c = input2.transform) == null ? void 0 : _c.translate) ?? [0, 0, 0]\n      );\n      const clip = clipXyz ? new Box3(\n        new Vector3().fromArray(clipXyz.min),\n        new Vector3().fromArray(clipXyz.max)\n      ) : void 0;\n      let fileType = input2.fileType;\n      if (!fileType) {\n        fileType = getSplatFileType(input2.fileBytes);\n        if (!fileType && input2.pathOrUrl) {\n          fileType = getSplatFileTypeFromPath(input2.pathOrUrl);\n        }\n      }\n      switch (fileType) {\n        case SplatFileType.PLY: {\n          const ply = new PlyReader({ fileBytes: input2.fileBytes });\n          await ply.parseHeader();\n          let lastIndex = null;\n          ply.parseSplats(\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                lastIndex = splats.pushSplat();\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  lastIndex,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(lastIndex, opacity);\n                splats.setColor(lastIndex, r, g, b);\n              } else {\n                lastIndex = null;\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (sh1 && lastIndex !== null) {\n                splats.setSh1(lastIndex, sh1);\n              }\n              if (sh2 && lastIndex !== null) {\n                splats.setSh2(lastIndex, sh2);\n              }\n              if (sh3 && lastIndex !== null) {\n                splats.setSh3(lastIndex, sh3);\n              }\n            }\n          );\n          break;\n        }\n        case SplatFileType.SPZ: {\n          const spz2 = new SpzReader({ fileBytes: input2.fileBytes });\n          const mapping = new Int32Array(spz2.numSplats);\n          mapping.fill(-1);\n          const centers = new Float32Array(spz2.numSplats * 3);\n          const center = new Vector3();\n          spz2.parseSplats(\n            (index, x2, y, z) => {\n              const center2 = transformPos2(new Vector3(x2, y, z));\n              centers[index * 3] = center2.x;\n              centers[index * 3 + 1] = center2.y;\n              centers[index * 3 + 2] = center2.z;\n            },\n            (index, alpha) => {\n              center.fromArray(centers, index * 3);\n              if (withinClip(center) && withinOpacity(alpha)) {\n                mapping[index] = splats.pushSplat();\n                splats.setCenter(mapping[index], center.x, center.y, center.z);\n                splats.setOpacity(mapping[index], alpha);\n              }\n            },\n            (index, r, g, b) => {\n              if (mapping[index] >= 0) {\n                splats.setColor(mapping[index], r, g, b);\n              }\n            },\n            (index, scaleX, scaleY, scaleZ) => {\n              if (mapping[index] >= 0) {\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(mapping[index], scales.x, scales.y, scales.z);\n              }\n            },\n            (index, quatX, quatY, quatZ, quatW) => {\n              if (mapping[index] >= 0) {\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  mapping[index],\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (mapping[index] >= 0) {\n                splats.setSh1(mapping[index], sh1);\n                if (sh2) {\n                  splats.setSh2(mapping[index], sh2);\n                }\n                if (sh3) {\n                  splats.setSh3(mapping[index], sh3);\n                }\n              }\n            }\n          );\n          break;\n        }\n        case SplatFileType.SPLAT:\n          decodeAntiSplat(\n            input2.fileBytes,\n            (numSplats) => {\n            },\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                const index2 = splats.pushSplat();\n                splats.setCenter(index2, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(index2, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  index2,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(index2, opacity);\n                splats.setColor(index2, r, g, b);\n              }\n            }\n          );\n          break;\n        case SplatFileType.KSPLAT: {\n          let lastIndex = null;\n          decodeKsplat(\n            input2.fileBytes,\n            (numSplats) => {\n            },\n            (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n              const center = transformPos2(new Vector3(x2, y, z));\n              if (withinClip(center) && withinOpacity(opacity)) {\n                lastIndex = splats.pushSplat();\n                splats.setCenter(lastIndex, center.x, center.y, center.z);\n                const scales = transformScales(\n                  new Vector3(scaleX, scaleY, scaleZ)\n                );\n                splats.setScale(lastIndex, scales.x, scales.y, scales.z);\n                const quaternion2 = transformQuaternion(\n                  new Quaternion(quatX, quatY, quatZ, quatW)\n                );\n                splats.setQuaternion(\n                  lastIndex,\n                  quaternion2.x,\n                  quaternion2.y,\n                  quaternion2.z,\n                  quaternion2.w\n                );\n                splats.setOpacity(lastIndex, opacity);\n                splats.setColor(lastIndex, r, g, b);\n              } else {\n                lastIndex = null;\n              }\n            },\n            (index, sh1, sh2, sh3) => {\n              if (lastIndex !== null) {\n                splats.setSh1(lastIndex, sh1);\n                if (sh2) {\n                  splats.setSh2(lastIndex, sh2);\n                }\n                if (sh3) {\n                  splats.setSh3(lastIndex, sh3);\n                }\n              }\n            }\n          );\n          break;\n        }\n        default:\n          throw new Error(\\`transcodeSpz not implemented for \\${fileType}\\`);\n      }\n    }\n    const shDegree = Math.min(\n      maxSh ?? 3,\n      splats.sh3 ? 3 : splats.sh2 ? 2 : splats.sh1 ? 1 : 0\n    );\n    const spz = new SpzWriter({\n      numSplats: splats.numSplats,\n      shDegree,\n      fractionalBits,\n      flagAntiAlias: true\n    });\n    for (let i2 = 0; i2 < splats.numSplats; ++i2) {\n      const i3 = i2 * 3;\n      const i4 = i2 * 4;\n      spz.setCenter(\n        i2,\n        splats.centers[i3],\n        splats.centers[i3 + 1],\n        splats.centers[i3 + 2]\n      );\n      spz.setScale(\n        i2,\n        splats.scales[i3],\n        splats.scales[i3 + 1],\n        splats.scales[i3 + 2]\n      );\n      spz.setQuat(\n        i2,\n        splats.quaternions[i4],\n        splats.quaternions[i4 + 1],\n        splats.quaternions[i4 + 2],\n        splats.quaternions[i4 + 3]\n      );\n      spz.setAlpha(i2, splats.opacities[i2]);\n      spz.setRgb(\n        i2,\n        splats.colors[i3],\n        splats.colors[i3 + 1],\n        splats.colors[i3 + 2]\n      );\n      if (splats.sh1 && shDegree >= 1) {\n        spz.setSh(\n          i2,\n          splats.sh1.slice(i2 * 9, (i2 + 1) * 9),\n          shDegree >= 2 && splats.sh2 ? splats.sh2.slice(i2 * 15, (i2 + 1) * 15) : void 0,\n          shDegree >= 3 && splats.sh3 ? splats.sh3.slice(i2 * 21, (i2 + 1) * 21) : void 0\n        );\n      }\n    }\n    const spzBytes = await spz.finalize();\n    return { fileBytes: spzBytes, clippedCount: spz.clippedCount };\n  }\n  async function onMessage(event) {\n    const { name, args, id } = event.data;\n    let result = void 0;\n    let error = void 0;\n    try {\n      switch (name) {\n        case \"unpackPly\": {\n          const { packedArray, fileBytes } = args;\n          const decoded = await unpackPly({ packedArray, fileBytes });\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case \"decodeSpz\": {\n          const { fileBytes } = args;\n          const decoded = unpackSpz(fileBytes);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case \"decodeAntiSplat\": {\n          const { fileBytes } = args;\n          const decoded = unpackAntiSplat(fileBytes);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray\n          };\n          break;\n        }\n        case \"decodeKsplat\": {\n          const { fileBytes } = args;\n          const decoded = unpackKsplat(fileBytes);\n          result = {\n            id,\n            numSplats: decoded.numSplats,\n            packedArray: decoded.packedArray,\n            extra: decoded.extra\n          };\n          break;\n        }\n        case \"sortSplats\": {\n          const { maxSplats, totalSplats, readback, ordering } = args;\n          result = {\n            id,\n            readback,\n            ...sortSplats({ totalSplats, readback, ordering })\n          };\n          break;\n        }\n        case \"sortDoubleSplats\": {\n          const { numSplats, readback, ordering } = args;\n          result = {\n            id,\n            readback,\n            ordering\n          };\n          if (WASM_SPLAT_SORT) {\n            result = {\n              id,\n              readback,\n              ordering,\n              activeSplats: sort_splats(numSplats, readback, ordering)\n            };\n          }\n          break;\n        }\n        case \"transcodeSpz\": {\n          const input = args;\n          const spzBytes = await transcodeSpz(input);\n          result = {\n            id,\n            fileBytes: spzBytes,\n            input\n          };\n          break;\n        }\n        default: {\n          throw new Error(\\`Unknown name: \\${name}\\`);\n        }\n      }\n    } catch (e) {\n      error = e;\n    }\n    self.postMessage(\n      { id, result, error },\n      { transfer: getArrayBuffers(result) }\n    );\n  }\n  async function unpackPly({\n    packedArray,\n    fileBytes\n  }) {\n    const ply = new PlyReader({ fileBytes });\n    await ply.parseHeader();\n    const numSplats = ply.numSplats;\n    const extra = {};\n    const ZERO_CUTOFF = Math.exp(-20);\n    ply.parseSplats(\n      (index, x2, y, z, scaleX, scaleY, scaleZ, quatX, quatY, quatZ, quatW, opacity, r, g, b) => {\n        setPackedSplat(\n          packedArray,\n          index,\n          x2,\n          y,\n          z,\n          scaleX < ZERO_CUTOFF ? 0 : Math.max(SCALE_MIN, scaleX),\n          scaleY < ZERO_CUTOFF ? 0 : Math.max(SCALE_MIN, scaleY),\n          scaleZ < ZERO_CUTOFF ? 0 : Math.max(SCALE_MIN, scaleZ),\n          quatX,\n          quatY,\n          quatZ,\n          quatW,\n          opacity,\n          r,\n          g,\n          b\n        );\n      },\n      (index, sh1, sh2, sh3) => {\n        if (sh1) {\n          if (!extra.sh1) {\n            extra.sh1 = new Uint32Array(numSplats * 2);\n          }\n          encodeSh1Rgb(extra.sh1, index, sh1);\n        }\n        if (sh2) {\n          if (!extra.sh2) {\n            extra.sh2 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh2Rgb(extra.sh2, index, sh2);\n        }\n        if (sh3) {\n          if (!extra.sh3) {\n            extra.sh3 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh3Rgb(extra.sh3, index, sh3);\n        }\n      }\n    );\n    return { packedArray, numSplats, extra };\n  }\n  function unpackSpz(fileBytes) {\n    const spz = new SpzReader({ fileBytes });\n    const numSplats = spz.numSplats;\n    const maxSplats = computeMaxSplats(numSplats);\n    const packedArray = new Uint32Array(maxSplats * 4);\n    const extra = {};\n    spz.parseSplats(\n      (index, x2, y, z) => {\n        setPackedSplatCenter(packedArray, index, x2, y, z);\n      },\n      (index, alpha) => {\n        setPackedSplatOpacity(packedArray, index, alpha);\n      },\n      (index, r, g, b) => {\n        setPackedSplatRgb(packedArray, index, r, g, b);\n      },\n      (index, scaleX, scaleY, scaleZ) => {\n        setPackedSplatScales(packedArray, index, scaleX, scaleY, scaleZ);\n      },\n      (index, quatX, quatY, quatZ, quatW) => {\n        setPackedSplatQuat(packedArray, index, quatX, quatY, quatZ, quatW);\n      },\n      (index, sh1, sh2, sh3) => {\n        if (sh1) {\n          if (!extra.sh1) {\n            extra.sh1 = new Uint32Array(numSplats * 2);\n          }\n          encodeSh1Rgb(extra.sh1, index, sh1);\n        }\n        if (sh2) {\n          if (!extra.sh2) {\n            extra.sh2 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh2Rgb(extra.sh2, index, sh2);\n        }\n        if (sh3) {\n          if (!extra.sh3) {\n            extra.sh3 = new Uint32Array(numSplats * 4);\n          }\n          encodeSh3Rgb(extra.sh3, index, sh3);\n        }\n      }\n    );\n    return { packedArray, numSplats, extra };\n  }\n  const DEPTH_INFINITY = 31744;\n  const DEPTH_SIZE = DEPTH_INFINITY + 1;\n  let depthArray = null;\n  function sortSplats({\n    totalSplats,\n    readback,\n    ordering\n  }) {\n    if (!depthArray) {\n      depthArray = new Uint32Array(DEPTH_SIZE);\n    }\n    depthArray.fill(0);\n    const readbackUint32 = readback.map((layer) => new Uint32Array(layer.buffer));\n    const layerSize = readbackUint32[0].length;\n    const numLayers = Math.ceil(totalSplats / layerSize);\n    let layerBase = 0;\n    for (let layer = 0; layer < numLayers; ++layer) {\n      const readbackLayer = readbackUint32[layer];\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\n        const pri = readbackLayer[i2] & 32767;\n        if (pri < DEPTH_INFINITY) {\n          depthArray[pri] += 1;\n        }\n      }\n      layerBase += layerSplats;\n    }\n    let activeSplats = 0;\n    for (let j = 0; j < DEPTH_SIZE; ++j) {\n      const nextIndex = activeSplats + depthArray[j];\n      depthArray[j] = activeSplats;\n      activeSplats = nextIndex;\n    }\n    layerBase = 0;\n    for (let layer = 0; layer < numLayers; ++layer) {\n      const readbackLayer = readbackUint32[layer];\n      const layerSplats = Math.min(readbackLayer.length, totalSplats - layerBase);\n      for (let i2 = 0; i2 < layerSplats; ++i2) {\n        const pri = readbackLayer[i2] & 32767;\n        if (pri < DEPTH_INFINITY) {\n          ordering[depthArray[pri]] = layerBase + i2;\n          depthArray[pri] += 1;\n        }\n      }\n      layerBase += layerSplats;\n    }\n    if (depthArray[DEPTH_SIZE - 1] !== activeSplats) {\n      throw new Error(\n        \\`Expected \\${activeSplats} active splats but got \\${depthArray[DEPTH_SIZE - 1]}\\`\n      );\n    }\n    return { activeSplats, ordering };\n  }\n  function sortDoubleSplats({\n    numSplats,\n    readback,\n    ordering\n  }) {\n    if (!depthArray) {\n      depthArray = new Uint32Array(DEPTH_SIZE);\n    }\n    depthArray.fill(0);\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const pri = readback[i2];\n      if (pri < DEPTH_INFINITY) {\n        depthArray[pri] += 1;\n      }\n    }\n    let activeSplats = 0;\n    for (let j = DEPTH_INFINITY - 1; j >= 0; --j) {\n      const nextIndex = activeSplats + depthArray[j];\n      depthArray[j] = activeSplats;\n      activeSplats = nextIndex;\n    }\n    for (let i2 = 0; i2 < numSplats; ++i2) {\n      const pri = readback[i2];\n      if (pri < DEPTH_INFINITY) {\n        ordering[depthArray[pri]] = i2;\n        depthArray[pri] += 1;\n      }\n    }\n    if (depthArray[0] !== activeSplats) {\n      throw new Error(\n        \\`Expected \\${activeSplats} active splats but got \\${depthArray[0]}\\`\n      );\n    }\n    return { activeSplats, ordering };\n  }\n  const messageBuffer = [];\n  function bufferMessage(event) {\n    messageBuffer.push(event);\n  }\n  async function initialize() {\n    self.addEventListener(\"message\", bufferMessage);\n    await __wbg_init();\n    self.removeEventListener(\"message\", bufferMessage);\n    self.addEventListener(\"message\", onMessage);\n    for (const event of messageBuffer) {\n      onMessage(event);\n    }\n    messageBuffer.length = 0;\n  }\n  initialize().catch(console.error);\n})();\n//# sourceMappingURL=worker-Do1mGyaZ.js.map\n`, Vt = typeof self < \"u\" && self.Blob && new Blob([be], { type: \"text/javascript;charset=utf-8\" });\nfunction Yi(s) {\n  let A;\n  try {\n    if (A = Vt && (self.URL || self.webkitURL).createObjectURL(Vt), !A) throw \"\";\n    const t = new Worker(A, {\n      name: s == null ? void 0 : s.name\n    });\n    return t.addEventListener(\"error\", () => {\n      (self.URL || self.webkitURL).revokeObjectURL(A);\n    }), t;\n  } catch {\n    return new Worker(\n      \"data:text/javascript;charset=utf-8,\" + encodeURIComponent(be),\n      {\n        name: s == null ? void 0 : s.name\n      }\n    );\n  } finally {\n    A && (self.URL || self.webkitURL).revokeObjectURL(A);\n  }\n}\nclass Ti {\n  constructor() {\n    this.messages = {}, this.messageIdNext = 0, this.worker = new Yi(), this.worker.onmessage = (A) => this.onMessage(A);\n  }\n  makeMessageId() {\n    return ++this.messageIdNext;\n  }\n  makeMessagePromiseId() {\n    const A = this.makeMessageId(), t = new Promise((e, i) => {\n      this.messages[A] = { resolve: e, reject: i };\n    });\n    return { id: A, promise: t };\n  }\n  onMessage(A) {\n    const { id: t, result: e, error: i } = A.data, a = this.messages[t];\n    a && (delete this.messages[t], i ? a.reject(i) : a.resolve(e));\n  }\n  // Invoke an RPC on the worker with the given name and arguments.\n  // The normal usage of a worker is to run one activity at a time,\n  // but this function allows for concurrent calls, tagging each request\n  // with a unique message Id and awaiting a response to that same Id.\n  // The method will automatically transfer any ArrayBuffers in the\n  // arguments to the worker. If you'd like to transfer a copy of a\n  // buffer then you must clone it before passing to this function.\n  async call(A, t) {\n    const { id: e, promise: i } = this.makeMessagePromiseId();\n    return this.worker.postMessage(\n      { name: A, args: t, id: e },\n      { transfer: _s(t) }\n    ), i;\n  }\n}\nlet ke = 4, Bt = 0;\nconst Me = [], Fe = [];\nasync function Ji() {\n  const s = Me.shift();\n  if (s)\n    return s;\n  if (Bt < ke) {\n    const A = new Ti();\n    return Bt += 1, A;\n  }\n  return new Promise((A) => {\n    Fe.push(A);\n  });\n}\nfunction Hi(s) {\n  if (Bt > ke) {\n    Bt -= 1;\n    return;\n  }\n  const A = Fe.shift();\n  if (A) {\n    A(s);\n    return;\n  }\n  Me.push(s);\n}\nasync function qA(s) {\n  const A = await Ji();\n  try {\n    return await s(A);\n  } finally {\n    Hi(A);\n  }\n}\nfunction qi(s) {\n  const A = new DataView(s.buffer);\n  if ((A.getUint32(0, !0) & 16777215) === 7957616)\n    return \"ply\";\n  if ((A.getUint32(0, !0) & 16777215) === 559903) {\n    const t = Xs(s, 4);\n    return new DataView(t.buffer).getUint32(0, !0) === 1347635022 ? \"spz\" : void 0;\n  }\n}\nfunction zi(s) {\n  const A = s.split(/[?#]/, 1)[0], t = Math.max(\n    A.lastIndexOf(\"/\"),\n    A.lastIndexOf(\"\\\\\")\n  ), e = A.slice(t + 1), i = e.lastIndexOf(\".\");\n  return i <= 0 || i === e.length - 1 ? \"\" : e.slice(i + 1).toLowerCase();\n}\nfunction Ki(s) {\n  const A = zi(s);\n  if (A === \"ply\")\n    return \"ply\";\n  if (A === \"spz\")\n    return \"spz\";\n  if (A === \"splat\")\n    return \"splat\";\n  if (A === \"ksplat\")\n    return \"ksplat\";\n}\nasync function Pi({\n  input: s,\n  fileType: A,\n  pathOrUrl: t\n}) {\n  const e = s instanceof ArrayBuffer ? new Uint8Array(s) : s;\n  let i = A;\n  switch (A || (i = qi(e), !i && t && (i = Ki(t))), i) {\n    case \"ply\": {\n      const a = new Ui({ fileBytes: e });\n      await a.parseHeader();\n      const r = a.numSplats, n = $(r).maxSplats, I = { fileBytes: e, packedArray: new Uint32Array(n * 4) };\n      return await qA(async (o) => {\n        const { packedArray: Q, numSplats: g, extra: c } = await o.call(\n          \"unpackPly\",\n          I\n        );\n        return { packedArray: Q, numSplats: g, extra: c };\n      });\n    }\n    case \"spz\":\n      return await qA(async (a) => {\n        const { packedArray: r, numSplats: n, extra: I } = await a.call(\n          \"decodeSpz\",\n          {\n            fileBytes: e\n          }\n        );\n        return { packedArray: r, numSplats: n, extra: I };\n      });\n    case \"splat\":\n      return await qA(async (a) => {\n        const { packedArray: r, numSplats: n } = await a.call(\n          \"decodeAntiSplat\",\n          {\n            fileBytes: e\n          }\n        );\n        return { packedArray: r, numSplats: n };\n      });\n    case \"ksplat\":\n      return await qA(async (a) => {\n        const { packedArray: r, numSplats: n, extra: I } = await a.call(\n          \"decodeKsplat\",\n          { fileBytes: e }\n        );\n        return { packedArray: r, numSplats: n, extra: I };\n      });\n    default:\n      throw new Error(`Unknown splat file type: ${i}`);\n  }\n}\nvar Oi = `precision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp usampler2D;\nprecision highp isampler2D;\nprecision highp sampler2DArray;\nprecision highp usampler2DArray;\nprecision highp isampler2DArray;\nprecision highp sampler3D;\nprecision highp usampler3D;\nprecision highp isampler3D;\n\n#include <splatDefines>\n\nuniform uint targetLayer;\nuniform int targetBase;\nuniform int targetCount;\n\nout uvec4 target;\n\n{{ GLOBALS }}\n\nvoid produceSplat(int index) {\n    {{ STATEMENTS }}\n}\n\nvoid main() {\n    int targetIndex = int(targetLayer << SPLAT_TEX_LAYER_BITS) + int(uint(gl_FragCoord.y) << SPLAT_TEX_WIDTH_BITS) + int(gl_FragCoord.x);\n    int index = targetIndex - targetBase;\n\n    if ((index >= 0) && (index < targetCount)) {\n        produceSplat(index);\n    } else {\n        target = uvec4(0u, 0u, 0u, 0u);\n    }\n}`;\nconst IA = class L {\n  constructor(A = {}) {\n    this.maxSplats = 0, this.numSplats = 0, this.packedArray = null, this.isInitialized = !1, this.target = null, this.source = null, this.needsUpdate = !0, this.extra = {}, this.dyno = new Lt({ packedSplats: this }), this.initialized = Promise.resolve(this), this.reinitialize(A);\n  }\n  reinitialize(A) {\n    this.isInitialized = !1, A.url || A.fileBytes || A.construct ? this.initialized = this.asyncInitialize(A).then(() => (this.isInitialized = !0, this)) : (this.initialize(A), this.isInitialized = !0, this.initialized = Promise.resolve(this));\n  }\n  initialize(A) {\n    A.packedArray ? (this.packedArray = A.packedArray, this.maxSplats = Math.floor(this.packedArray.length / 4), this.maxSplats = Math.floor(this.maxSplats / x) * x, this.numSplats = Math.min(\n      this.maxSplats,\n      A.numSplats ?? Number.POSITIVE_INFINITY\n    )) : (this.maxSplats = A.maxSplats ?? 0, this.numSplats = 0), this.extra = A.extra ?? {};\n  }\n  async asyncInitialize(A) {\n    let { url: t, fileBytes: e, construct: i } = A;\n    if (t && (e = await fetch(t).then(async (a) => {\n      if (!a.ok)\n        throw new Error(\n          `${a.status} \"${a.statusText}\" fetching URL: ${t}`\n        );\n      return await a.arrayBuffer();\n    })), e) {\n      const a = await Pi({\n        input: e,\n        fileType: A.fileType,\n        pathOrUrl: A.fileName ?? t\n      });\n      this.initialize(a);\n    }\n    if (i) {\n      const a = i(this);\n      a instanceof Promise && await a;\n    }\n  }\n  // Call this when you are finished with the PackedSplats and want to free\n  // any buffers it holds.\n  dispose() {\n    this.target && (this.target.dispose(), this.target = null), this.source && (this.source.dispose(), this.source = null);\n  }\n  // Ensures that this.packedArray can fit numSplats Gsplats. If it's too small,\n  // resize exponentially and copy over the original data.\n  //\n  // Typically you don't need to call this, because calling this.setSplat(index, ...)\n  // and this.pushSplat(...) will automatically call ensureSplats() so we have\n  // enough splats.\n  ensureSplats(A) {\n    const t = A <= this.maxSplats ? this.maxSplats : (\n      // Grow exponentially to avoid frequent reallocations\n      Math.max(A, 2 * this.maxSplats)\n    ), e = this.packedArray ? this.packedArray.length / 4 : 0;\n    if (!this.packedArray || t > e) {\n      this.maxSplats = $(t).maxSplats;\n      const i = new Uint32Array(this.maxSplats * 4);\n      this.packedArray && i.set(this.packedArray), this.packedArray = i;\n    }\n    return this.packedArray;\n  }\n  // Ensure the extra array for the given level is large enough to hold numSplats\n  ensureSplatsSh(A, t) {\n    let e, i;\n    if (A === 0)\n      return this.ensureSplats(t);\n    if (A === 1)\n      e = 2, i = \"sh1\";\n    else if (A === 2)\n      e = 4, i = \"sh2\";\n    else if (A === 3)\n      e = 4, i = \"sh3\";\n    else\n      throw new Error(`Invalid level: ${A}`);\n    let a = this.extra[i] ? this.extra[i].length / e : 0;\n    const r = t <= a ? a : Math.max(t, 2 * a);\n    if (!this.extra[i] || r > a) {\n      a = $(r).maxSplats;\n      const n = new Uint32Array(a * e);\n      this.extra[i] && n.set(this.extra[i]), this.extra[i] = n;\n    }\n    return this.extra[i];\n  }\n  // Unpack the 16-byte Gsplat data at index into the Three.js components\n  // center: THREE.Vector3, scales: THREE.Vector3, quaternion: THREE.Quaternion,\n  // opacity: number 0..1, color: THREE.Color 0..1.\n  getSplat(A) {\n    if (!this.packedArray || A >= this.numSplats)\n      throw new Error(\"Invalid index\");\n    return zt(this.packedArray, A);\n  }\n  // Set all PackedSplat components at index with the provided Gsplat attributes\n  // (can be the same objects returned by getSplat). Ensures there is capacity\n  // for at least index+1 Gsplats.\n  setSplat(A, t, e, i, a, r) {\n    const n = this.ensureSplats(A + 1);\n    qt(\n      n,\n      A,\n      t.x,\n      t.y,\n      t.z,\n      e.x,\n      e.y,\n      e.z,\n      i.x,\n      i.y,\n      i.z,\n      i.w,\n      a,\n      r.r,\n      r.g,\n      r.b\n    ), this.numSplats = Math.max(this.numSplats, A + 1);\n  }\n  // Effectively calls this.setSplat(this.numSplats++, center, ...), useful on\n  // construction where you just want to iterate and create a collection of Gsplats.\n  pushSplat(A, t, e, i, a) {\n    const r = this.ensureSplats(this.numSplats + 1);\n    qt(\n      r,\n      this.numSplats,\n      A.x,\n      A.y,\n      A.z,\n      t.x,\n      t.y,\n      t.z,\n      e.x,\n      e.y,\n      e.z,\n      e.w,\n      i,\n      a.r,\n      a.g,\n      a.b\n    ), ++this.numSplats;\n  }\n  // Iterate over Gsplats index 0..=(this.numSplats-1), unpack each Gsplat\n  // and invoke the callback function with the Gsplat attributes.\n  forEachSplat(A) {\n    if (!(!this.packedArray || !this.numSplats))\n      for (let t = 0; t < this.numSplats; ++t) {\n        const e = zt(this.packedArray, t);\n        A(\n          t,\n          e.center,\n          e.scales,\n          e.quaternion,\n          e.opacity,\n          e.color\n        );\n      }\n  }\n  // Ensures our PackedSplats.target render target has enough space to generate\n  // maxSplats total Gsplats, and reallocate if not large enough.\n  ensureGenerate(A) {\n    if (this.target && (A ?? 1) <= this.maxSplats)\n      return !1;\n    this.dispose();\n    const t = $(A ?? 1), { width: e, height: i, depth: a } = t;\n    return this.maxSplats = t.maxSplats, this.target = new B.WebGLArrayRenderTarget(e, i, a, {\n      depthBuffer: !1,\n      stencilBuffer: !1,\n      generateMipmaps: !1,\n      magFilter: B.NearestFilter,\n      minFilter: B.NearestFilter\n    }), this.target.texture.format = B.RGBAIntegerFormat, this.target.texture.type = B.UnsignedIntType, this.target.texture.internalFormat = \"RGBA32UI\", !0;\n  }\n  // Given an array of splatCounts (.numSplats for each\n  // SplatGenerator/SplatMesh in the scene), compute a\n  // \"mapping layout\" in the composite array of generated outputs.\n  generateMapping(A) {\n    let t = 0;\n    const e = A.map((i) => {\n      const a = t, r = Math.ceil(i / x) * x;\n      return t += r, { base: a, count: i };\n    });\n    return { maxSplats: t, mapping: e };\n  }\n  // Returns a THREE.DataArrayTexture representing the PackedSplats content as\n  // a Uint32x4 data array texture (2048 x 2048 x depth in size)\n  getTexture() {\n    return this.target ? this.target.texture : this.source || this.packedArray ? this.maybeUpdateSource() : L.getEmpty();\n  }\n  // Check if source texture needs to be created/updated\n  maybeUpdateSource() {\n    if (!this.packedArray)\n      throw new Error(\"No packed splats\");\n    if (this.needsUpdate || !this.source) {\n      if (this.needsUpdate = !1, this.source) {\n        const { width: A, height: t, depth: e } = this.source.image;\n        this.maxSplats !== A * t * e && (this.source.dispose(), this.source = null);\n      }\n      if (this.source)\n        this.packedArray.buffer !== this.source.image.data.buffer && (this.source.image.data = new Uint8Array(this.packedArray.buffer));\n      else {\n        const { width: A, height: t, depth: e } = $(this.maxSplats);\n        this.source = new B.DataArrayTexture(\n          this.packedArray,\n          A,\n          t,\n          e\n        ), this.source.format = B.RGBAIntegerFormat, this.source.type = B.UnsignedIntType, this.source.internalFormat = \"RGBA32UI\", this.source.needsUpdate = !0;\n      }\n      this.source.needsUpdate = !0;\n    }\n    return this.source;\n  }\n  // Can be used where you need an uninitialized THREE.DataArrayTexture like\n  // a uniform you will update with the result of this.getTexture() later.\n  static getEmpty() {\n    if (!L.emptySource) {\n      const { width: A, height: t, depth: e, maxSplats: i } = $(1), a = new Uint32Array(i * 4);\n      L.emptySource = new B.DataArrayTexture(\n        a,\n        A,\n        t,\n        e\n      ), L.emptySource.format = B.RGBAIntegerFormat, L.emptySource.type = B.UnsignedIntType, L.emptySource.internalFormat = \"RGBA32UI\", L.emptySource.needsUpdate = !0;\n    }\n    return L.emptySource;\n  }\n  // Get a program and THREE.RawShaderMaterial for a given GsplatGenerator,\n  // generating it if necessary and caching the result.\n  prepareProgramMaterial(A) {\n    let t = L.generatorProgram.get(A);\n    if (!t) {\n      const i = SA(\n        { index: \"int\" },\n        { output: \"uvec4\" },\n        ({ index: a }) => {\n          A.inputs.index = a;\n          const r = A.outputs.gsplat;\n          return { output: ys(r) };\n        }\n      );\n      L.programTemplate || (L.programTemplate = new Ce(\n        Oi\n      )), t = new ce({\n        graph: i,\n        inputs: { index: \"index\" },\n        outputs: { output: \"target\" },\n        template: L.programTemplate\n      }), Object.assign(t.uniforms, {\n        targetLayer: { value: 0 },\n        targetBase: { value: 0 },\n        targetCount: { value: 0 }\n      }), L.generatorProgram.set(A, t);\n    }\n    const e = t.prepareMaterial();\n    return L.mesh.material = e, { program: t, material: e };\n  }\n  saveRenderState(A) {\n    return {\n      xrPresenting: A.xr.isPresenting,\n      autoClear: A.autoClear,\n      scissorTest: A.getScissorTest(),\n      pixelRatio: A.getPixelRatio()\n    };\n  }\n  resetRenderState(A, t) {\n    A.setRenderTarget(null), A.setPixelRatio(t.pixelRatio), A.xr.isPresenting = t.xrPresenting, A.autoClear = t.autoClear, A.setScissorTest(t.scissorTest);\n  }\n  // Executes a dyno program specified by generator which is any DynoBlock that\n  // maps { index: \"int\" } to { gsplat: Gsplat }. This is called in\n  // SparkRenderer.updateInternal() to re-generate Gsplats in the scene for\n  // SplatGenerator instances whose version is newer than what was generated\n  // for it last time.\n  generate({\n    generator: A,\n    base: t,\n    count: e,\n    renderer: i\n  }) {\n    if (!this.target)\n      throw new Error(\"Target must be initialized with ensureSplats\");\n    if (t + e > this.maxSplats)\n      throw new Error(\"Base + count exceeds maxSplats\");\n    const { program: a, material: r } = this.prepareProgramMaterial(A);\n    a.update();\n    const n = this.saveRenderState(i), I = Math.ceil((t + e) / x) * x, o = x * kA;\n    for (r.uniforms.targetBase.value = t, r.uniforms.targetCount.value = e; t < I; ) {\n      const Q = Math.floor(t / o);\n      r.uniforms.targetLayer.value = Q;\n      const g = Q * o, c = Math.floor((t - g) / x), E = Math.min(\n        kA,\n        Math.ceil((I - g) / x)\n      );\n      i.setPixelRatio(1), i.setRenderTarget(this.target, Q), i.xr.isPresenting = !1, i.autoClear = !1, i.setScissorTest(!0), i.setScissor(\n        0,\n        c,\n        x,\n        E - c\n      ), i.render(L.scene, L.camera), t += x * (E - c);\n    }\n    return this.resetRenderState(i, n), { nextBase: I };\n  }\n};\nIA.emptySource = null;\nIA.programTemplate = null;\nIA.generatorProgram = /* @__PURE__ */ new Map();\nIA.geometry = new B.PlaneGeometry(2, 2);\nIA.mesh = new B.Mesh(\n  IA.geometry,\n  new B.RawShaderMaterial({ visible: !1 })\n);\nIA.scene = new B.Scene().add(IA.mesh);\nIA.camera = new B.Camera();\nlet TA = IA;\nclass Lt extends oA {\n  constructor({ packedSplats: A } = {}) {\n    super({\n      key: \"packedSplats\",\n      type: Ct,\n      globals: () => [Rt],\n      value: {\n        texture: TA.getEmpty(),\n        numSplats: 0\n      },\n      update: (t) => {\n        var e, i;\n        return t.texture = ((e = this.packedSplats) == null ? void 0 : e.getTexture()) ?? TA.getEmpty(), t.numSplats = ((i = this.packedSplats) == null ? void 0 : i.numSplats) ?? 0, t;\n      }\n    }), this.packedSplats = A;\n  }\n}\nclass bt extends B.InstancedBufferGeometry {\n  constructor(A, t) {\n    super(), this.ordering = A, this.setAttribute(\"position\", new B.BufferAttribute(Vi, 3)), this.setIndex(new B.BufferAttribute(ji, 1)), this._maxInstanceCount = A.length, this.instanceCount = t, this.attribute = new B.InstancedBufferAttribute(A, 1, !1, 1), this.attribute.setUsage(B.DynamicDrawUsage), this.setAttribute(\"splatIndex\", this.attribute);\n  }\n  update(A, t) {\n    this.ordering = A, this.attribute.array = A, this.instanceCount = t, this.attribute.addUpdateRange(0, t), this.attribute.needsUpdate = !0;\n  }\n}\nconst Vi = new Float32Array([\n  -1,\n  -1,\n  0,\n  1,\n  -1,\n  0,\n  1,\n  1,\n  0,\n  -1,\n  1,\n  0\n]), ji = new Uint16Array([0, 1, 2, 0, 2, 3]), _t = class zA {\n  constructor(A) {\n    if (this.lastTime = null, this.encodeLinear = !1, this.superXY = 1, this.display = null, this.sorting = null, this.pending = null, this.sortingCheck = !1, this.readback = new Uint16Array(0), this.spark = A.spark, this.camera = A.camera, this.viewToWorld = A.viewToWorld ?? new B.Matrix4(), A.target) {\n      const { width: t, height: e, doubleBuffer: i } = A.target, a = Math.max(1, Math.min(4, A.target.superXY ?? 1));\n      if (this.superXY = a, t * a > 8192 || e * a > 8192)\n        throw new Error(\"Target size too large\");\n      this.target = new B.WebGLRenderTarget(\n        t * a,\n        e * a,\n        {\n          format: B.RGBAFormat,\n          type: B.UnsignedByteType,\n          colorSpace: B.SRGBColorSpace\n        }\n      ), i && (this.back = new B.WebGLRenderTarget(\n        t * a,\n        e * a,\n        {\n          format: B.RGBAFormat,\n          type: B.UnsignedByteType,\n          colorSpace: B.SRGBColorSpace\n        }\n      )), this.encodeLinear = !0;\n    }\n    this.onTextureUpdated = A.onTextureUpdated, this.sortRadial = A.sortRadial ?? !0, this.sortDistance = A.sortDistance, this.sortCoorient = A.sortCoorient, this.depthBias = A.depthBias, this.sort360 = A.sort360, this.orderingFreelist = new Ys({\n      allocate: (t) => new Uint32Array(t),\n      valid: (t, e) => t.length === e\n    }), this.autoUpdate = !1, this.setAutoUpdate(A.autoUpdate ?? !1);\n  }\n  // Call this when you are done with the SparkViewpoint and want to\n  // free up its resources (GPU targets, pixel buffers, etc.)\n  dispose() {\n    var A;\n    this.setAutoUpdate(!1), this.target && (this.target.dispose(), this.target = void 0), this.back && (this.back.dispose(), this.back = void 0), this.display && (this.spark.releaseAccumulator(this.display.accumulator), this.display.geometry.dispose(), this.display = null), (A = this.pending) != null && A.accumulator && (this.spark.releaseAccumulator(this.pending.accumulator), this.pending = null);\n  }\n  // Use this function to change whether this viewpoint will auto-update\n  // its sort order whenever the attached SparkRenderer updates the Gsplats.\n  // Turn this on or off depending on whether you expect to do renders from\n  // this viewpoint most frames.\n  setAutoUpdate(A) {\n    !this.autoUpdate && A ? this.spark.autoViewpoints.push(this) : this.autoUpdate && !A && (this.spark.autoViewpoints = this.spark.autoViewpoints.filter(\n      (t) => t !== this\n    )), this.autoUpdate = A;\n  }\n  // See below async prepareRenderPixels() for explanation of parameters.\n  // Awaiting this method updates the Gsplats in the scene and performs a sort of the\n  // Gsplats from this viewpoint, preparing it for a subsequent this.renderTarget()\n  // call in the same tick.\n  async prepare({\n    scene: A,\n    camera: t,\n    viewToWorld: e,\n    update: i,\n    forceOrigin: a\n  }) {\n    var r;\n    for (e ? this.viewToWorld = e : (this.camera = t ?? this.camera, this.camera && (this.camera.updateMatrixWorld(), this.viewToWorld = this.camera.matrixWorld.clone())); i ?? !0; ) {\n      const I = a ? this.viewToWorld : void 0;\n      if (this.spark.updateInternal({ scene: A, originToWorld: I }))\n        break;\n      await new Promise((o) => setTimeout(o, 10));\n    }\n    const n = this.spark.active;\n    n !== ((r = this.display) == null ? void 0 : r.accumulator) && (this.spark.active.refCount += 1), await this.sortUpdate({ accumulator: n, viewToWorld: this.viewToWorld });\n  }\n  // Render out the viewpoint to the view target RGBA buffer.\n  // Swaps buffers if doubleBuffer: true was set.\n  // Calls onTextureUpdated(texture) with the resulting texture.\n  renderTarget({\n    scene: A,\n    camera: t\n  }) {\n    var e;\n    const i = this.back ?? this.target;\n    if (!i)\n      throw new Error(\"Must initialize SparkViewpoint with target\");\n    if (t = t ?? this.camera, !t)\n      throw new Error(\"Must provide camera\");\n    if (t instanceof B.PerspectiveCamera) {\n      const a = new B.PerspectiveCamera().copy(t, !1);\n      a.aspect = i.width / i.height, a.updateProjectionMatrix(), t = a;\n    }\n    this.viewToWorld = t.matrixWorld.clone();\n    try {\n      this.spark.renderer.setRenderTarget(i), this.spark.prepareViewpoint(this), this.spark.renderer.render(A, t);\n    } finally {\n      this.spark.prepareViewpoint(this.spark.defaultView), this.spark.renderer.setRenderTarget(null);\n    }\n    i !== this.target && ([this.target, this.back] = [this.back, this.target]), (e = this.onTextureUpdated) == null || e.call(this, i.texture);\n  }\n  // Read back the previously rendered target image as a Uint8Array of packed\n  // RGBA values (in that order). If superXY was set greater than 1 then\n  // downsampling is performed in the target pixel array with simple averaging\n  // to derive the returned pixel values. Subsequent calls to this.readTarget()\n  // will reuse the same buffers to minimize memory allocations.\n  async readTarget() {\n    if (!this.target)\n      throw new Error(\"Must initialize SparkViewpoint with target\");\n    const { width: A, height: t } = this.target, e = A * t * 4;\n    (!this.superPixels || this.superPixels.length < e) && (this.superPixels = new Uint8Array(e)), await this.spark.renderer.readRenderTargetPixelsAsync(\n      this.target,\n      0,\n      0,\n      A,\n      t,\n      this.superPixels\n    );\n    const { superXY: i } = this;\n    if (i === 1)\n      return this.superPixels;\n    const a = A / i, r = t / i, n = a * r * 4;\n    (!this.pixels || this.pixels.length < n) && (this.pixels = new Uint8Array(n));\n    const { superPixels: I, pixels: o } = this, Q = i * i;\n    for (let g = 0; g < r; g++) {\n      const c = g * a;\n      for (let E = 0; E < a; E++) {\n        const l = E * i;\n        let C = 0, u = 0, y = 0, d = 0;\n        for (let p = 0; p < i; p++) {\n          const f = (g * i + p) * this.target.width;\n          for (let D = 0; D < i; D++) {\n            const k = (f + l + D) * 4;\n            C += I[k], u += I[k + 1], y += I[k + 2], d += I[k + 3];\n          }\n        }\n        const h = (c + E) * 4;\n        o[h] = C / Q, o[h + 1] = u / Q, o[h + 2] = y / Q, o[h + 3] = d / Q;\n      }\n    }\n    return o;\n  }\n  // Render out a viewpoint as a Uint8Array of RGBA values for the provided scene\n  // and any camera/viewToWorld viewpoint overrides. By default update is true,\n  // which triggers its SparkRenderer to check and potentially update the Gsplats.\n  // Setting update to false disables this and sorts the Gsplats as they are.\n  // Setting forceOrigin (default: false) to true forces the view update to\n  // recalculate the splats with this view origin, potentially altering any\n  // view-dependent effects. If you expect view-dependent effects to play a role\n  // in the rendering quality, enable this.\n  //\n  // Underneath, prepareRenderPixels() simply calls await this.prepare(...),\n  // this.renderTarget(...), and finally returns the result this.readTarget(),\n  // a Promise to a Uint8Array with RGBA values for all the pixels (potentially\n  // downsampled if the superXY parameter was used). These steps can also be called\n  // manually, for example if you need to alter the scene before and after\n  // this.renderTarget(...) to hide UI elements from being rendered.\n  async prepareRenderPixels({\n    scene: A,\n    camera: t,\n    viewToWorld: e,\n    update: i,\n    forceOrigin: a\n  }) {\n    return await this.prepare({ scene: A, camera: t, viewToWorld: e, update: i, forceOrigin: a }), this.renderTarget({ scene: A, camera: t }), this.readTarget();\n  }\n  // This is called automatically by SparkRenderer, there is no need to call it!\n  // The method cannot be private because then SparkRenderer would\n  // not be able to call it.\n  autoPoll({ accumulator: A }) {\n    var t, e, i, a;\n    this.camera && (this.camera.updateMatrixWorld(), this.viewToWorld = this.camera.matrixWorld.clone());\n    let r = !1, n = !1;\n    if (!this.display)\n      r = !0;\n    else if (A) {\n      r = !0;\n      const { mappingVersion: o } = this.display.accumulator;\n      A.mappingVersion === o && (this.spark.releaseAccumulator(this.display.accumulator), this.display.accumulator = A, n = !0);\n    }\n    const I = ((t = this.sorting) == null ? void 0 : t.viewToWorld) ?? ((e = this.display) == null ? void 0 : e.viewToWorld);\n    I && !xt({\n      matrix1: this.viewToWorld,\n      matrix2: I,\n      // By default update sort each 1 cm\n      maxDistance: this.sortDistance ?? 0.01,\n      // By default for radial sort, update for intermittent movement so that\n      // we bring back splats culled by being behind the camera.\n      // For depth sort, small rotations can change sort order a lot, so\n      // update sort for even small rotations.\n      minCoorient: this.sortCoorient ?? this.sortRadial ? 0.99 : 0.999\n    }) && (r = !0), r && (A && (A.refCount += 1), A && (i = this.pending) != null && i.accumulator && this.pending.accumulator !== ((a = this.display) == null ? void 0 : a.accumulator) && this.spark.releaseAccumulator(this.pending.accumulator), this.pending = { accumulator: A, viewToWorld: this.viewToWorld, displayed: n }, this.driveSort());\n  }\n  async driveSort() {\n    for (var A; ; ) {\n      if (this.sorting || !this.pending)\n        return;\n      const { viewToWorld: t, displayed: e } = this.pending;\n      let i = this.pending.accumulator ?? ((A = this.display) == null ? void 0 : A.accumulator);\n      if (i || (i = this.spark.active, i.refCount += 1), this.pending = null, !i)\n        throw new Error(\"No accumulator to sort\");\n      this.sorting = { viewToWorld: t }, await this.sortUpdate({ accumulator: i, viewToWorld: t, displayed: e }), this.sorting = null;\n    }\n  }\n  async sortUpdate({\n    accumulator: A,\n    viewToWorld: t,\n    displayed: e = !1\n  }) {\n    if (this.sortingCheck)\n      throw new Error(\"Only one sort at a time\");\n    this.sortingCheck = !0, A = A ?? this.spark.active;\n    const { numSplats: i, maxSplats: a } = A.splats;\n    let r = 0, n = this.orderingFreelist.alloc(a);\n    if (i > 0) {\n      const {\n        reader: I,\n        doubleSortReader: o,\n        dynoSortRadial: Q,\n        dynoOrigin: g,\n        dynoDirection: c,\n        dynoDepthBias: E,\n        dynoSort360: l,\n        dynoSplats: C\n      } = zA.makeSorter(), u = Math.ceil(a / 2);\n      this.readback = I.ensureBuffer(u, this.readback);\n      const y = A.toWorld.clone().invert(), d = t.clone().premultiply(y);\n      Q.value = this.sort360 ? !0 : this.sortRadial, g.value.set(0, 0, 0).applyMatrix4(d), c.value.set(0, 0, -1).applyMatrix4(d).sub(g.value).normalize(), E.value = this.depthBias ?? 1, l.value = this.sort360 ?? !1, C.packedSplats = A.splats, await I.renderReadback({\n        renderer: this.spark.renderer,\n        reader: o,\n        count: Math.ceil(i / 2),\n        readback: this.readback\n      });\n      const h = await qA(async (p) => p.call(\"sortDoubleSplats\", {\n        numSplats: i,\n        readback: this.readback,\n        ordering: n\n      }));\n      this.readback = h.readback, n = h.ordering, r = h.activeSplats;\n    }\n    this.updateDisplay({\n      accumulator: A,\n      viewToWorld: t,\n      ordering: n,\n      activeSplats: r,\n      displayed: e\n    }), this.sortingCheck = !1;\n  }\n  updateDisplay({\n    accumulator: A,\n    viewToWorld: t,\n    ordering: e,\n    activeSplats: i,\n    displayed: a = !1\n  }) {\n    if (!this.display)\n      this.display = {\n        accumulator: A,\n        viewToWorld: t,\n        geometry: new bt(e, i)\n      };\n    else {\n      !a && A !== this.display.accumulator && (this.spark.releaseAccumulator(this.display.accumulator), this.display.accumulator = A), this.display.viewToWorld = t;\n      const r = this.display.geometry.ordering;\n      r.length === e.length ? this.display.geometry.update(e, i) : (this.display.geometry.dispose(), this.display.geometry = new bt(e, i)), this.orderingFreelist.free(r);\n    }\n    this.spark.viewpoint === this && this.spark.prepareViewpoint(this);\n  }\n  static makeSorter() {\n    if (!zA.dynos) {\n      const A = new Ht({ value: !0 }), t = new ot({ value: new B.Vector3() }), e = new ot({ value: new B.Vector3() }), i = new jA({ value: 1 }), a = new Ht({ value: !1 }), r = new Lt(), n = new he(), I = SA(\n        { index: \"int\" },\n        { rgba8: \"vec4\" },\n        ({ index: o }) => {\n          if (!o)\n            throw new Error(\"No index\");\n          const Q = {\n            sortRadial: A,\n            sortOrigin: t,\n            sortDirection: e,\n            sortDepthBias: i,\n            sort360: a\n          }, g = le(o, wt(\"int\", 2)), c = gt(r, g), E = Zt({ gsplat: c, ...Q }), l = gt(\n            r,\n            OA(g, wt(\"int\", 1))\n          ), C = Zt({ gsplat: l, ...Q }), u = Bi({\n            vectorType: \"vec2\",\n            x: E,\n            y: C\n          });\n          return { rgba8: ni(ri(u)) };\n        }\n      );\n      zA.dynos = {\n        dynoSortRadial: A,\n        dynoOrigin: t,\n        dynoDirection: e,\n        dynoDepthBias: i,\n        dynoSort360: a,\n        dynoSplats: r,\n        reader: n,\n        doubleSortReader: I\n      };\n    }\n    return zA.dynos;\n  }\n};\n_t.EMPTY_TEXTURE = new B.Texture();\n_t.dynos = null;\nlet jt = _t;\nconst Zi = O(`\n  float computeSort(Gsplat gsplat, bool sortRadial, vec3 sortOrigin, vec3 sortDirection, float sortDepthBias, bool sort360) {\n    if (!isGsplatActive(gsplat.flags)) {\n      return INFINITY;\n    }\n\n    vec3 center = gsplat.center - sortOrigin;\n    float biasedDepth = dot(center, sortDirection) + sortDepthBias;\n    if (!sort360 && (biasedDepth <= 0.0)) {\n      return INFINITY;\n    }\n\n    return sortRadial ? length(center) : biasedDepth;\n  }\n`);\nfunction Zt({\n  gsplat: s,\n  sortRadial: A,\n  sortOrigin: t,\n  sortDirection: e,\n  sortDepthBias: i,\n  sort360: a\n}) {\n  return Qt({\n    inTypes: {\n      gsplat: G,\n      sortRadial: \"bool\",\n      sortOrigin: \"vec3\",\n      sortDirection: \"vec3\",\n      sortDepthBias: \"float\",\n      sort360: \"bool\"\n    },\n    outTypes: { metric: \"float\" },\n    globals: () => [QA, Zi],\n    inputs: {\n      gsplat: s,\n      sortRadial: A,\n      sortOrigin: t,\n      sortDirection: e,\n      sortDepthBias: i,\n      sort360: a\n    },\n    statements: ({ inputs: r, outputs: n }) => {\n      const {\n        gsplat: I,\n        sortRadial: o,\n        sortOrigin: Q,\n        sortDirection: g,\n        sortDepthBias: c,\n        sort360: E\n      } = r;\n      return BA(`\n        ${n.metric} = computeSort(${I}, ${o}, ${Q}, ${g}, ${c}, ${E});\n      `);\n    }\n  }).outputs.metric;\n}\nclass ft {\n  constructor() {\n    this.splats = new TA(), this.toWorld = new B.Matrix4(), this.mapping = [], this.refCount = 0, this.splatsVersion = -1, this.mappingVersion = -1;\n  }\n  ensureGenerate(A) {\n    this.splats.ensureGenerate(A) && (this.mapping = []);\n  }\n  // Generate all Gsplats from an array of generators\n  generateSplats({\n    renderer: A,\n    modifier: t,\n    generators: e,\n    forceUpdate: i,\n    originToWorld: a\n  }) {\n    const r = this.mapping.reduce((o, Q) => (o.set(Q.node, Q), o), /* @__PURE__ */ new Map());\n    let n = 0, I = 0;\n    for (const { node: o, generator: Q, version: g, base: c, count: E } of e) {\n      const l = r.get(o);\n      if ((i || Q !== (l == null ? void 0 : l.generator) || g !== (l == null ? void 0 : l.version) || c !== (l == null ? void 0 : l.base) || E !== (l == null ? void 0 : l.count)) && Q && E > 0) {\n        const C = t.apply(Q);\n        try {\n          this.splats.generate({\n            generator: C,\n            base: c,\n            count: E,\n            renderer: A\n          });\n        } catch (u) {\n          o.generator = void 0, o.generatorError = u;\n        }\n        n += 1;\n      }\n      I = Math.max(I, c + E);\n    }\n    return this.splats.numSplats = I, this.toWorld = a, this.mapping = e, n !== 0;\n  }\n  // Check if this accumulator has exactly the same generator mapping as\n  // the previous one. If so, we can reuse the Gsplat sort order.\n  hasCorrespondence(A) {\n    return this.mapping.length !== A.mapping.length ? !1 : this.mapping.every(({ node: t, base: e, count: i }, a) => {\n      const {\n        node: r,\n        base: n,\n        count: I\n      } = A.mapping[a];\n      return t === r && e === n && i === I;\n    });\n  }\n}\nvar Wi = `const float LN_SCALE_MIN = -9.0;\nconst float LN_SCALE_MAX = 9.0;\nconst float LN_RESCALE = (LN_SCALE_MAX - LN_SCALE_MIN) / 254.0; \n\nconst uint SPLAT_TEX_WIDTH_BITS = 11u;\nconst uint SPLAT_TEX_HEIGHT_BITS = 11u;\nconst uint SPLAT_TEX_DEPTH_BITS = 11u;\nconst uint SPLAT_TEX_LAYER_BITS = SPLAT_TEX_WIDTH_BITS + SPLAT_TEX_HEIGHT_BITS;\n\nconst uint SPLAT_TEX_WIDTH = 1u << SPLAT_TEX_WIDTH_BITS;\nconst uint SPLAT_TEX_HEIGHT = 1u << SPLAT_TEX_HEIGHT_BITS;\nconst uint SPLAT_TEX_DEPTH = 1u << SPLAT_TEX_DEPTH_BITS;\n\nconst uint SPLAT_TEX_WIDTH_MASK = SPLAT_TEX_WIDTH - 1u;\nconst uint SPLAT_TEX_HEIGHT_MASK = SPLAT_TEX_HEIGHT - 1u;\nconst uint SPLAT_TEX_DEPTH_MASK = SPLAT_TEX_DEPTH - 1u;\n\nconst uint F16_INF = 0x7c00u;\nconst float PI = 3.1415926535897932384626433832795;\n\nconst float INFINITY = 1.0 / 0.0;\nconst float NEG_INFINITY = -INFINITY;\n\nconst float MAX_PIXEL_RADIUS = 512.0;\nconst float MIN_ALPHA = 0.5 * (1.0 / 255.0); \nconst float MAX_STDDEV = sqrt(8.0);\n\nfloat sqr(float x) {\n    return x * x;\n}\n\nfloat pow4(float x) {\n    float x2 = x * x;\n    return x2 * x2;\n}\n\nfloat pow8(float x) {\n    float x4 = pow4(x);\n    return x4 * x4;\n}\n\nvec3 srgbToLinear(vec3 rgb) {\n    return pow(rgb, vec3(2.2));\n}\n\nvec3 linearToSrgb(vec3 rgb) {\n    return pow(rgb, vec3(1.0 / 2.2));\n}\n\nuint encodeQuatOctXy88R8(vec4 q) {\n    \n    if (q.w < 0.0) {\n        q = -q;\n    }\n    \n    float theta = 2.0 * acos(q.w);\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    \n    vec3 axis = (abs(s) < 1e-6) ? vec3(1.0, 0.0, 0.0) : q.xyz / s;\n    \n    \n    \n    float sum = abs(axis.x) + abs(axis.y) + abs(axis.z);\n    vec2 p = vec2(axis.x, axis.y) / sum;\n    \n    if (axis.z < 0.0) {\n        float oldPx = p.x;\n        p.x = (1.0 - abs(p.y)) * (p.x >= 0.0 ? 1.0 : -1.0);\n        p.y = (1.0 - abs(oldPx)) * (p.y >= 0.0 ? 1.0 : -1.0);\n    }\n    \n    float u_f = p.x * 0.5 + 0.5;\n    float v_f = p.y * 0.5 + 0.5;\n    \n    uint quantU = uint(clamp(round(u_f * 255.0), 0.0, 255.0));\n    uint quantV = uint(clamp(round(v_f * 255.0), 0.0, 255.0));\n    \n    \n    \n    uint angleInt = uint(clamp(round((theta / 3.14159265359) * 255.0), 0.0, 255.0));\n    \n    \n    return (angleInt << 16u) | (quantV << 8u) | quantU;\n}\n\nvec4 decodeQuatOctXy88R8(uint encoded) {\n    \n    uint quantU = encoded & uint(0xFFu);               \n    uint quantV = (encoded >> 8u) & uint(0xFFu);         \n    uint angleInt = encoded >> 16u;                      \n\n    \n    float u_f = float(quantU) / 255.0;\n    float v_f = float(quantV) / 255.0;\n    vec2 f = vec2(u_f * 2.0 - 1.0, v_f * 2.0 - 1.0);\n\n    vec3 axis = vec3(f.xy, 1.0 - abs(f.x) - abs(f.y));\n    float t = max(-axis.z, 0.0);\n    axis.x += (axis.x >= 0.0) ? -t : t;\n    axis.y += (axis.y >= 0.0) ? -t : t;\n    axis = normalize(axis);\n    \n    \n    float theta = (float(angleInt) / 255.0) * 3.14159265359;\n    float halfTheta = theta * 0.5;\n    float s = sin(halfTheta);\n    float w = cos(halfTheta);\n    \n    return vec4(axis * s, w);\n}\n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\n    \n\nuvec4 packSplat(vec3 center, vec3 scales, vec4 quaternion, vec4 rgba) {\n    uvec4 uRgba = uvec4(round(clamp(rgba * 255.0, 0.0, 255.0)));\n\n    uint uQuat = encodeQuatOctXy88R8(quaternion);\n    \n    \n    uvec3 uQuat3 = uvec3(uQuat & 0xffu, (uQuat >> 8u) & 0xffu, (uQuat >> 16u) & 0xffu);\n\n    \n    uvec3 uScales = uvec3(\n        (scales.x == 0.0) ? 0u : uint(round(clamp((log(scales.x) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,\n        (scales.y == 0.0) ? 0u : uint(round(clamp((log(scales.y) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u,\n        (scales.z == 0.0) ? 0u : uint(round(clamp((log(scales.z) - LN_SCALE_MIN) / LN_RESCALE, 0.0, 254.0))) + 1u\n    );\n\n    \n    uint word0 = uRgba.r | (uRgba.g << 8u) | (uRgba.b << 16u) | (uRgba.a << 24u);\n    uint word1 = packHalf2x16(center.xy);\n    uint word2 = packHalf2x16(vec2(center.z, 0.0)) | (uQuat3.x << 16u) | (uQuat3.y << 24u);\n    uint word3 = uScales.x | (uScales.y << 8u) | (uScales.z << 16u) | (uQuat3.z << 24u);\n    return uvec4(word0, word1, word2, word3);\n}\n\nvoid unpackSplat(uvec4 packed, out vec3 center, out vec3 scales, out vec4 quaternion, out vec4 rgba) {\n    uint word0 = packed.x, word1 = packed.y, word2 = packed.z, word3 = packed.w;\n\n    uvec4 uRgba = uvec4(word0 & 0xffu, (word0 >> 8u) & 0xffu, (word0 >> 16u) & 0xffu, (word0 >> 24u) & 0xffu);\n    rgba = vec4(uRgba) / 255.0;\n\n    center = vec4(\n        unpackHalf2x16(word1),\n        unpackHalf2x16(word2 & 0xffffu)\n    ).xyz;\n\n    uvec3 uScales = uvec3(word3 & 0xffu, (word3 >> 8u) & 0xffu, (word3 >> 16u) & 0xffu);\n    scales = vec3(\n        (uScales.x == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.x - 1u) * LN_RESCALE),\n        (uScales.y == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.y - 1u) * LN_RESCALE),\n        (uScales.z == 0u) ? 0.0 : exp(LN_SCALE_MIN + float(uScales.z - 1u) * LN_RESCALE)\n    );\n\n    uint uQuat = ((word2 >> 16u) & 0xFFFFu) | ((word3 >> 8u) & 0xFF0000u);\n    quaternion = decodeQuatOctXy88R8(uQuat);\n    \n    \n}\n\nvec3 quatVec(vec4 q, vec3 v) {\n    \n    vec3 t = 2.0 * cross(q.xyz, v);\n    return v + q.w * t + cross(q.xyz, t);\n}\n\nvec4 quatQuat(vec4 q1, vec4 q2) {\n    return vec4(\n        q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,\n        q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,\n        q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w,\n        q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n    );\n}\n\nmat3 scaleQuaternionToMatrix(vec3 s, vec4 q) {\n    \n    return mat3(\n        s.x * (1.0 - 2.0 * (q.y * q.y + q.z * q.z)),\n        s.x * (2.0 * (q.x * q.y + q.w * q.z)),\n        s.x * (2.0 * (q.x * q.z - q.w * q.y)),\n        s.y * (2.0 * (q.x * q.y - q.w * q.z)),\n        s.y * (1.0 - 2.0 * (q.x * q.x + q.z * q.z)),\n        s.y * (2.0 * (q.y * q.z + q.w * q.x)),\n        s.z * (2.0 * (q.x * q.z + q.w * q.y)),\n        s.z * (2.0 * (q.y * q.z - q.w * q.x)),\n        s.z * (1.0 - 2.0 * (q.x * q.x + q.y * q.y))\n    );\n}\n\nvec4 slerp(vec4 q1, vec4 q2, float t) {\n    \n    float cosHalfTheta = dot(q1, q2);\n\n    \n    if (abs(cosHalfTheta) >= 0.999) {\n        return q1;\n    }\n    \n    \n    \n    if (cosHalfTheta < 0.0) {\n        q2 = -q2;\n        cosHalfTheta = -cosHalfTheta;\n    }\n\n    \n    float halfTheta = acos(cosHalfTheta);\n    float sinHalfTheta = sqrt(1.0 - cosHalfTheta * cosHalfTheta);\n\n    \n    float ratioA = sin((1.0 - t) * halfTheta) / sinHalfTheta;\n    float ratioB = sin(t * halfTheta) / sinHalfTheta;\n\n    \n    return q1 * ratioA + q2 * ratioB;\n}\n\nivec3 splatTexCoord(int index) {\n    uint x = uint(index) & SPLAT_TEX_WIDTH_MASK;\n    uint y = (uint(index) >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK;\n    uint z = uint(index) >> SPLAT_TEX_LAYER_BITS;\n    return ivec3(x, y, z);\n}`, Xi = `precision highp float;\nprecision highp int;\n\n#include <splatDefines>\n\nuniform bool encodeLinear;\nuniform float maxStdDev;\nuniform bool disableFalloff;\nuniform float falloff;\n\nout vec4 fragColor;\n\nin vec4 vRgba;\nin vec2 vSplatUv;\nin vec3 vNdc;\n\nvoid main() {\n    float z = dot(vSplatUv, vSplatUv);\n    if (z > (maxStdDev * maxStdDev)) {\n        discard;\n    }\n\n    float alpha = vRgba.a;\n    alpha *= mix(1.0, exp(-0.5 * z), falloff);\n    if (alpha < MIN_ALPHA) {\n        discard;\n    }\n\n    vec3 rgb = vRgba.rgb;\n    if (encodeLinear) {\n        rgb = srgbToLinear(rgb);\n    }\n    fragColor = vec4(rgb, alpha);\n}`, $i = `precision highp float;\nprecision highp int;\nprecision highp usampler2DArray;\n\n#include <splatDefines>\n\nattribute uint splatIndex;\n\nout vec4 vRgba;\nout vec2 vSplatUv;\nout vec3 vNdc;\n\nuniform vec2 renderSize;\nuniform uint numSplats;\nuniform vec4 renderToViewQuat;\nuniform vec3 renderToViewPos;\nuniform float maxStdDev;\nuniform float time;\nuniform float deltaTime;\nuniform bool debugFlag;\nuniform bool enable2DGS;\nuniform float blurAmount;\nuniform float preBlurAmount;\nuniform float clipXY;\n\nuniform usampler2DArray packedSplats;\n\nvoid main() {\n    \n    gl_Position = vec4(0.0, 0.0, 2.0, 1.0);\n\n    if (uint(gl_InstanceID) >= numSplats) {\n        return;\n    }\n    if (splatIndex == 0xffffffffu) {\n        \n        return;\n    }\n\n    ivec3 texCoord = ivec3(\n        splatIndex & SPLAT_TEX_WIDTH_MASK,\n        (splatIndex >> SPLAT_TEX_WIDTH_BITS) & SPLAT_TEX_HEIGHT_MASK,\n        splatIndex >> SPLAT_TEX_LAYER_BITS\n    );\n    uvec4 packed = texelFetch(packedSplats, texCoord, 0);\n\n    vec3 center, scales;\n    vec4 quaternion, rgba;\n    unpackSplat(packed, center, scales, quaternion, rgba);\n\n    if (rgba.a < MIN_ALPHA) {\n        return;\n    }\n    bvec3 zeroScales = equal(scales, vec3(0.0));\n    if (all(zeroScales)) {\n        return;\n    }\n\n    \n    vec3 viewCenter = quatVec(renderToViewQuat, center) + renderToViewPos;\n\n    \n    if (viewCenter.z >= 0.0) {\n        return;\n    }\n\n    \n    vec4 clipCenter = projectionMatrix * vec4(viewCenter, 1.0);\n\n    \n    if (abs(clipCenter.z) >= clipCenter.w) {\n        return;\n    }\n\n    \n    float clip = clipXY * clipCenter.w;\n    if (abs(clipCenter.x) > clip || abs(clipCenter.y) > clip) {\n        return;\n    }\n\n    \n    vec4 viewQuaternion = quatQuat(renderToViewQuat, quaternion);\n\n    if (enable2DGS && any(zeroScales)) {\n        vRgba = rgba;\n        vSplatUv = position.xy * maxStdDev;\n\n        vec3 offset;\n        if (zeroScales.z) {\n            offset = vec3(vSplatUv.xy * scales.xy, 0.0);\n        } else if (zeroScales.y) {\n            offset = vec3(vSplatUv.x * scales.x, 0.0, vSplatUv.y * scales.z);\n        } else {\n            offset = vec3(0.0, vSplatUv.xy * scales.yz);\n        }\n\n        vec3 viewPos = viewCenter + quatVec(viewQuaternion, offset);\n        gl_Position = projectionMatrix * vec4(viewPos, 1.0);\n        vNdc = gl_Position.xyz / gl_Position.w;\n        return;\n    }\n\n    \n    vec3 ndcCenter = clipCenter.xyz / clipCenter.w;\n\n    \n    mat3 RS = scaleQuaternionToMatrix(scales, viewQuaternion);\n    mat3 cov3D = RS * transpose(RS);\n\n    \n    vec2 focal = 0.5 * renderSize * vec2(projectionMatrix[0][0], projectionMatrix[1][1]);\n    float invZ = 1.0 / viewCenter.z;\n    vec2 J1 = focal * invZ;\n    vec2 J2 = -(J1 * viewCenter.xy) * invZ;\n    mat3 J = mat3(\n        J1.x, 0.0, J2.x,\n        0.0, J1.y, J2.y,\n        0.0, 0.0, 0.0\n    );\n\n    \n    \n    \n    \n    \n    \n    \n    mat3 cov2D = transpose(J) * cov3D * J;\n    float a = cov2D[0][0];\n    float d = cov2D[1][1];\n    float b = cov2D[0][1];\n\n    \n    a += preBlurAmount;\n    d += preBlurAmount;\n\n    \n    float detOrig = a * d - b * b;\n    a += blurAmount;\n    d += blurAmount;\n    float det = a * d - b * b;\n\n    \n    float blurAdjust = sqrt(max(0.0, detOrig / det));\n    rgba.a *= blurAdjust;\n    if (rgba.a < MIN_ALPHA) {\n        return;\n    }\n\n    \n    float eigenAvg = 0.5 * (a + d);\n    float eigenDelta = sqrt(max(0.0, eigenAvg * eigenAvg - det));\n    float eigen1 = eigenAvg + eigenDelta;\n    float eigen2 = eigenAvg - eigenDelta;\n\n    vec2 eigenVec1 = normalize(vec2((abs(b) < 0.001) ? 1.0 : b, eigen1 - a));\n    vec2 eigenVec2 = vec2(eigenVec1.y, -eigenVec1.x);\n\n    float scale1 = position.x * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen1));\n    float scale2 = position.y * min(MAX_PIXEL_RADIUS, maxStdDev * sqrt(eigen2));\n\n    \n    vec2 pixelOffset = eigenVec1 * scale1 + eigenVec2 * scale2;\n    vec2 ndcOffset = (2.0 / renderSize) * pixelOffset;\n    vec3 ndc = vec3(ndcCenter.xy + ndcOffset, ndcCenter.z);\n\n    vRgba = rgba;\n    vSplatUv = position.xy * maxStdDev;\n    vNdc = ndc;\n    gl_Position = vec4(ndc.xy * clipCenter.w, clipCenter.zw);\n}`;\nlet mt = null;\nfunction Aa() {\n  return mt || (B.ShaderChunk.splatDefines = Wi, mt = {\n    splatVertex: $i,\n    splatFragment: Xi\n  }), mt;\n}\nconst Wt = 5;\nlet kt = !1, Mt = !1, Ne;\nfunction ta(s) {\n  let A = !1;\n  return s instanceof It ? !0 : (s.traverse((t) => {\n    A = A || t instanceof It;\n  }), A);\n}\nconst Re = B.Scene.prototype.add;\nB.Scene.prototype.add = function(s) {\n  return kt = kt || ta(s), Mt = Mt || s instanceof ve, Re.call(this, s), this;\n};\nconst ea = B.Scene.prototype.onBeforeRender;\nB.Scene.prototype.onBeforeRender = function(s) {\n  if (kt) {\n    if (!Mt) {\n      const A = Ne || new ve({ renderer: s });\n      this.add(A);\n    }\n    B.Scene.prototype.onBeforeRender = ea, B.Scene.prototype.add = Re;\n  }\n};\nconst Yt = class Z extends B.Mesh {\n  constructor(A) {\n    const t = Z.makeUniforms(), e = Aa(), i = new B.ShaderMaterial({\n      glslVersion: B.GLSL3,\n      vertexShader: e.splatVertex,\n      fragmentShader: e.splatFragment,\n      uniforms: t,\n      transparent: !0,\n      blending: B.NormalBlending,\n      depthTest: !0,\n      depthWrite: !1,\n      side: B.DoubleSide\n    });\n    super(Xt, i), this.autoViewpoints = [], this.rotateToAccumulator = new vt({ value: new B.Quaternion() }), this.translateToAccumulator = new ot({ value: new B.Vector3() }), this.lastFrame = -1, this.lastUpdateTime = null, this.defaultCameras = [], this.pendingUpdate = null, this.envViewpoint = null, this.frustumCulled = !1, this.renderer = A.renderer, this.material = i, this.uniforms = t;\n    const a = SA(\n      { gsplat: G },\n      { gsplat: G },\n      ({ gsplat: r }) => {\n        if (!r)\n          throw new Error(\"gsplat not defined\");\n        return r = ee(r, {\n          rotate: this.rotateToAccumulator,\n          translate: this.translateToAccumulator\n        }), { gsplat: r };\n      }\n    );\n    this.modifier = new ki(a), this.autoUpdate = A.autoUpdate ?? !0, this.preUpdate = A.preUpdate ?? !1, this.originDistance = A.originDistance ?? 1, this.maxStdDev = A.maxStdDev ?? Math.sqrt(8), this.enable2DGS = A.enable2DGS ?? !0, this.preBlurAmount = A.preBlurAmount ?? 0, this.blurAmount = A.blurAmount ?? 0.3, this.falloff = A.falloff ?? 1, this.clipXY = A.clipXY ?? 1.4, this.active = new ft(), this.accumulatorCount = 1, this.freeAccumulators = [];\n    for (let r = 0; r < 1; ++r)\n      this.freeAccumulators.push(new ft()), this.accumulatorCount += 1;\n    this.defaultView = new jt({\n      ...A.view,\n      autoUpdate: !0,\n      spark: this\n    }), this.viewpoint = this.defaultView, this.prepareViewpoint(this.viewpoint), this.clock = A.clock ? Ks(A.clock) : new B.Clock(), Ne = this;\n  }\n  static makeUniforms() {\n    return {\n      // Size of render viewport in pixels\n      renderSize: { value: new B.Vector2() },\n      // Total number of Gsplats in packedSplats to render\n      numSplats: { value: 0 },\n      // SplatAccumulator to view transformation quaternion\n      renderToViewQuat: { value: new B.Quaternion() },\n      // SplatAccumulator to view transformation translation\n      renderToViewPos: { value: new B.Vector3() },\n      // Maximum distance (in stddevs) from Gsplat center to render\n      maxStdDev: { value: 1 },\n      // Enable interpreting 0-thickness Gsplats as 2DGS\n      enable2DGS: { value: !1 },\n      // Add to projected 2D splat covariance diagonal (thickens and brightens)\n      preBlurAmount: { value: 0 },\n      // Add to 2D splat covariance diagonal and adjust opacity (anti-aliasing)\n      blurAmount: { value: 0.3 },\n      // Modulate Gaussian kernal falloff. 0 means \"no falloff, flat shading\",\n      // 1 is normal e^-x^2 falloff.\n      falloff: { value: 1 },\n      // Clip Gsplats that are clipXY times beyond the +-1 frustum bounds\n      clipXY: { value: 1.4 },\n      // Gsplat collection to render\n      packedSplats: { type: \"t\", value: TA.getEmpty() },\n      // Time in seconds for time-based effects\n      time: { value: 0 },\n      // Delta time in seconds since last frame\n      deltaTime: { value: 0 },\n      // Whether to encode Gsplat with linear RGB (for environment mapping)\n      encodeLinear: { value: !1 },\n      // Debug flag that alternates each frame\n      debugFlag: { value: !1 }\n    };\n  }\n  canAllocAccumulator() {\n    return this.freeAccumulators.length > 0 || this.accumulatorCount < Wt;\n  }\n  maybeAllocAccumulator() {\n    let A = this.freeAccumulators.pop();\n    if (A === void 0) {\n      if (this.accumulatorCount >= Wt)\n        return null;\n      A = new ft(), this.accumulatorCount += 1;\n    }\n    return A.refCount = 1, A;\n  }\n  releaseAccumulator(A) {\n    A.refCount -= 1, A.refCount === 0 && this.freeAccumulators.push(A);\n  }\n  newViewpoint(A) {\n    return new jt({ ...A, spark: this });\n  }\n  onBeforeRender(A, t, e) {\n    var i, a;\n    const r = this.time ?? this.clock.getElapsedTime(), n = r - (this.viewpoint.lastTime ?? r);\n    this.viewpoint.lastTime = r;\n    const I = A.info.render.frame, o = I !== this.lastFrame;\n    this.lastFrame = I;\n    const Q = this.viewpoint;\n    if (Q === this.defaultView) {\n      if (o)\n        if (!A.xr.isPresenting)\n          this.defaultView.viewToWorld = e.matrixWorld.clone(), this.defaultCameras = [this.defaultView.viewToWorld];\n        else {\n          const E = A.xr.getCamera().cameras;\n          this.defaultCameras = [\n            E[0].matrixWorld,\n            E[1].matrixWorld\n          ], this.defaultView.viewToWorld = sa(this.defaultCameras) ?? new B.Matrix4();\n        }\n      this.autoUpdate && this.update({ scene: t, viewToWorld: this.defaultView.viewToWorld });\n    }\n    if (o && (this.uniforms.time.value = r, this.uniforms.deltaTime.value = n, this.uniforms.debugFlag.value = performance.now() / 1e3 % 2 < 1), Q.target)\n      this.uniforms.renderSize.value.set(\n        Q.target.width,\n        Q.target.height\n      );\n    else {\n      const E = A.getSize(this.uniforms.renderSize.value);\n      if (E.x === 1 && E.y === 1) {\n        const l = (i = A.xr.getSession()) == null ? void 0 : i.renderState.baseLayer;\n        l && (E.x = l.framebufferWidth, E.y = l.framebufferHeight);\n      }\n    }\n    this.uniforms.encodeLinear.value = Q.encodeLinear, this.uniforms.maxStdDev.value = this.maxStdDev, this.uniforms.enable2DGS.value = this.enable2DGS, this.uniforms.preBlurAmount.value = this.preBlurAmount, this.uniforms.blurAmount.value = this.blurAmount, this.uniforms.falloff.value = this.falloff, this.uniforms.clipXY.value = this.clipXY;\n    const g = ((a = Q.display) == null ? void 0 : a.accumulator.toWorld) ?? new B.Matrix4(), c = e.matrixWorld.clone().invert();\n    g.clone().premultiply(c).decompose(\n      this.uniforms.renderToViewPos.value,\n      this.uniforms.renderToViewQuat.value,\n      new B.Vector3()\n    );\n  }\n  // Update the uniforms for the given viewpoint.\n  // Note that the client expects to be able to call render() at any point\n  // to update the canvas, so we must switch the viewpoint back to\n  // defaultView when we're finished.\n  prepareViewpoint(A) {\n    if (this.viewpoint = A ?? this.viewpoint, this.viewpoint.display) {\n      const { accumulator: t, geometry: e } = this.viewpoint.display;\n      this.uniforms.numSplats.value = t.splats.numSplats, this.uniforms.packedSplats.value = t.splats.getTexture(), this.geometry = e;\n    } else\n      this.uniforms.numSplats.value = 0, this.uniforms.packedSplats.value = TA.getEmpty(), this.geometry = Xt;\n  }\n  // If spark.autoUpdate is false then you must manually call\n  // spark.update({ scene }) to have the scene Gsplats be re-generated.\n  update({\n    scene: A,\n    viewToWorld: t\n  }) {\n    const e = this.matrixWorld.clone();\n    this.preUpdate ? this.updateInternal({ scene: A, originToWorld: e, viewToWorld: t }) : (this.pendingUpdate = {\n      scene: A,\n      originToWorld: e\n    }, setTimeout(() => {\n      if (this.pendingUpdate) {\n        const { scene: i, originToWorld: a } = this.pendingUpdate;\n        this.pendingUpdate = null, this.updateInternal({ scene: i, originToWorld: a, viewToWorld: t });\n      }\n    }, 1));\n  }\n  updateInternal({\n    scene: A,\n    originToWorld: t,\n    viewToWorld: e\n  }) {\n    var i;\n    if (!this.canAllocAccumulator())\n      return !1;\n    t || (t = this.active.toWorld), e = e ?? t.clone();\n    const a = this.time ?? this.clock.getElapsedTime(), r = a - (this.lastUpdateTime ?? a);\n    this.lastUpdateTime = a;\n    const n = this.active.mapping.reduce((c, E) => (c.set(E.node, E), c), /* @__PURE__ */ new Map()), { generators: I, globalEdits: o } = this.compileScene(A);\n    for (const c of I)\n      (i = c.frameUpdate) == null || i.call(c, {\n        object: c,\n        time: a,\n        deltaTime: r,\n        viewToWorld: e,\n        globalEdits: o\n      });\n    for (const c of I) {\n      const E = n.get(c), l = c.generator ? c.numSplats : 0;\n      (c.generator !== (E == null ? void 0 : E.generator) || l !== (E == null ? void 0 : E.count)) && c.updateVersion();\n    }\n    const Q = !xt({\n      matrix1: t,\n      matrix2: this.active.toWorld,\n      maxDistance: this.originDistance\n    }) || I.length !== n.size || I.some((c) => {\n      var E;\n      return c.version !== ((E = n.get(c)) == null ? void 0 : E.version);\n    });\n    let g = null;\n    if (Q) {\n      if (g = this.maybeAllocAccumulator(), !g)\n        throw new Error(\"Unreachable\");\n      const c = !xt({\n        matrix1: t,\n        matrix2: this.active.toWorld,\n        maxDistance: 1e-5,\n        minCoorient: 0.99999\n      }), E = I.map((h, p) => {\n        const f = n.get(h);\n        return f ? (\n          // Sort by version deltas then by previous ordering in the mapping,\n          // attempting to keep unchanging generators near the front\n          // to improve our chances of avoiding a re-generation.\n          [h.version - f.version, f.base, h]\n        ) : [Number.POSITIVE_INFINITY, h.version, h];\n      }).sort((h, p) => h[0] !== p[0] ? h[0] - p[0] : h[1] - p[1]).map(([h, p, f]) => f), l = E.map((h) => h.numSplats), { maxSplats: C, mapping: u } = g.splats.generateMapping(l), y = E.map((h, p) => {\n        const { base: f, count: D } = u[p];\n        return {\n          node: h,\n          generator: h.generator,\n          version: h.version,\n          base: f,\n          count: D\n        };\n      });\n      t.clone().invert().decompose(\n        this.translateToAccumulator.value,\n        this.rotateToAccumulator.value,\n        new B.Vector3()\n      ), g.ensureGenerate(C), g.generateSplats({\n        renderer: this.renderer,\n        modifier: this.modifier,\n        generators: y,\n        forceUpdate: c,\n        originToWorld: t\n      }), g.splatsVersion = this.active.splatsVersion + 1;\n      const d = g.hasCorrespondence(this.active);\n      g.mappingVersion = this.active.mappingVersion + (d ? 0 : 1), this.releaseAccumulator(this.active), this.active = g, this.prepareViewpoint();\n    }\n    return setTimeout(() => {\n      for (const c of this.autoViewpoints)\n        c.autoPoll({ accumulator: g ?? void 0 });\n    }, 1), !0;\n  }\n  compileScene(A) {\n    const t = [];\n    A.traverse((i) => {\n      i instanceof xe && t.push(i);\n    });\n    const e = /* @__PURE__ */ new Set();\n    return A.traverseVisible((i) => {\n      if (i instanceof fe) {\n        let a = i.parent;\n        for (; a != null && !(a instanceof It); )\n          a = a.parent;\n        a == null && e.add(i);\n      }\n    }), { generators: t, globalEdits: Array.from(e) };\n  }\n  // Renders out the scene to an environment map that can be used for\n  // Image-based lighting or similar applications. First optionally updates Gsplats,\n  // sorts them with respect to the provided worldCenter, renders 6 cube faces,\n  // then pre-filters them using THREE.PMREMGenerator and returns a THREE.Texture\n  // that can assigned directly to a THREE.MeshStandardMaterial.envMap property.\n  async renderEnvMap({\n    renderer: A,\n    scene: t,\n    worldCenter: e,\n    size: i = 256,\n    near: a = 0.1,\n    far: r = 1e3,\n    hideObjects: n = [],\n    update: I = !1\n  }) {\n    var o, Q;\n    if (this.envViewpoint || (this.envViewpoint = this.newViewpoint({ sort360: !0 })), !Z.cubeRender || Z.cubeRender.target.width !== i || Z.cubeRender.near !== a || Z.cubeRender.far !== r) {\n      Z.cubeRender && Z.cubeRender.target.dispose();\n      const C = new B.WebGLCubeRenderTarget(i, {\n        format: B.RGBAFormat,\n        generateMipmaps: !0,\n        minFilter: B.LinearMipMapLinearFilter\n      }), u = new B.CubeCamera(a, r, C);\n      Z.cubeRender = { target: C, camera: u, near: a, far: r };\n    }\n    Z.pmrem || (Z.pmrem = new B.PMREMGenerator(A ?? this.renderer));\n    const g = new B.Matrix4().setPosition(e);\n    await ((o = this.envViewpoint) == null ? void 0 : o.prepare({ scene: t, viewToWorld: g, update: I }));\n    const { target: c, camera: E } = Z.cubeRender;\n    E.position.copy(e);\n    const l = /* @__PURE__ */ new Map();\n    for (const C of n)\n      l.set(C, C.visible), C.visible = !1;\n    this.prepareViewpoint(this.envViewpoint), E.update(A ?? this.renderer, t), this.prepareViewpoint(this.defaultView);\n    for (const [C, u] of l.entries())\n      C.visible = u;\n    return (Q = Z.pmrem) == null ? void 0 : Q.fromCubemap(c.texture).texture;\n  }\n  // Utility function to recursively set the envMap property for any\n  // THREE.MeshStandardMaterial within the subtree of root.\n  recurseSetEnvMap(A, t) {\n    A.traverse((e) => {\n      if (e instanceof B.Mesh)\n        if (Array.isArray(e.material))\n          for (const i of e.material)\n            i instanceof B.MeshStandardMaterial && (i.envMap = t);\n        else\n          e.material instanceof B.MeshStandardMaterial && (e.material.envMap = t);\n    });\n  }\n  // Utility function that helps extract the Gsplat RGBA values from a\n  // SplatGenerator, including the result of any real-time RGBA SDF edits applied\n  // to a SplatMesh. This effectively \"bakes\" any computed RGBA values, which can\n  // now be used as a pipeline input via SplatMesh.splatRgba to inject these\n  // baked values into the Gsplat data.\n  getRgba({\n    generator: A,\n    rgba: t\n  }) {\n    const e = this.active.mapping.find(({ node: i }) => i === A);\n    if (!e)\n      throw new Error(\"Generator not found\");\n    return t = t ?? new fi(), t.fromPackedSplats({\n      packedSplats: this.active.splats,\n      base: e.base,\n      count: e.count,\n      renderer: this.renderer\n    }), t;\n  }\n  // Utility function that builds on getRgba({ generator }) and additionally\n  // reads back the RGBA values to the CPU in a Uint8Array with packed RGBA\n  // in that byte order.\n  async readRgba({\n    generator: A,\n    rgba: t\n  }) {\n    return t = this.getRgba({ generator: A, rgba: t }), t.read();\n  }\n};\nYt.cubeRender = null;\nYt.pmrem = null;\nlet ve = Yt;\nconst Xt = new bt(new Uint32Array(1), 0);\nSA(\n  { packedSplats: Ct, index: \"int\" },\n  { gsplat: G },\n  ({ packedSplats: s, index: A }) => {\n    if (!s || !A)\n      throw new Error(\"Invalid input\");\n    return { gsplat: gt(s, A) };\n  }\n);\nfunction sa(s) {\n  if (s.length === 0)\n    return null;\n  const A = new B.Vector3(), t = new B.Quaternion(), e = new B.Vector3(), i = [], a = [];\n  for (const r of s)\n    r.decompose(A, t, e), i.push(A), a.push(t);\n  return new B.Matrix4().compose(\n    Os(i),\n    Vs(a),\n    new B.Vector3(1, 1, 1)\n  );\n}\nO(`\n  struct GsplatSkinning {\n    int numSplats;\n    int numBones;\n    usampler2DArray skinTexture;\n    sampler2D boneTexture;\n  };\n`);\nO(`\n  void applyGsplatSkinning(\n    int numSplats, int numBones,\n    usampler2DArray skinTexture, sampler2D boneTexture,\n    int splatIndex, inout vec3 center, inout vec4 quaternion\n  ) {\n    if ((splatIndex < 0) || (splatIndex >= numSplats)) {\n      return;\n    }\n\n    uvec4 skinData = texelFetch(skinTexture, splatTexCoord(splatIndex), 0);\n\n    float weights[4];\n    weights[0] = float(skinData.x & 0xffu) / 255.0;\n    weights[1] = float(skinData.y & 0xffu) / 255.0;\n    weights[2] = float(skinData.z & 0xffu) / 255.0;\n    weights[3] = float(skinData.w & 0xffu) / 255.0;\n\n    uint boneIndices[4];\n    boneIndices[0] = (skinData.x >> 8u) & 0xffu;\n    boneIndices[1] = (skinData.y >> 8u) & 0xffu;\n    boneIndices[2] = (skinData.z >> 8u) & 0xffu;\n    boneIndices[3] = (skinData.w >> 8u) & 0xffu;\n\n    vec4 quat = vec4(0.0);\n    vec4 dual = vec4(0.0);\n    for (int i = 0; i < 4; i++) {\n      if (weights[i] > 0.0) {\n        int boneIndex = int(boneIndices[i]);\n        vec4 boneQuat = vec4(0.0, 0.0, 0.0, 1.0);\n        vec4 boneDual = vec4(0.0);\n        if (boneIndex < numBones) {\n          boneQuat = texelFetch(boneTexture, ivec2(2, boneIndex), 0);\n          boneDual = texelFetch(boneTexture, ivec2(3, boneIndex), 0);\n        }\n\n        if ((i > 0) && (dot(quat, boneQuat) < 0.0)) {\n          // Flip sign if next blend is pointing in the opposite direction\n          boneQuat = -boneQuat;\n          boneDual = -boneDual;\n        }\n        quat += weights[i] * boneQuat;\n        dual += weights[i] * boneDual;\n      }\n    }\n\n    // Normalize dual quaternion\n    float norm = length(quat);\n    quat /= norm;\n    dual /= norm;\n    vec3 translate = vec3(\n      2.0 * (-dual.w * quat.x + dual.x * quat.w - dual.y * quat.z + dual.z * quat.y),\n      2.0 * (-dual.w * quat.y + dual.x * quat.z + dual.y * quat.w - dual.z * quat.x),\n      2.0 * (-dual.w * quat.z - dual.x * quat.y + dual.y * quat.x + dual.z * quat.w)\n    );\n\n    center = quatVec(quat, center) + translate;\n    quaternion = quatQuat(quat, quaternion);\n  }\n`);\nnew B.Box3(\n  new B.Vector3(-1, -1, -1),\n  new B.Vector3(1, 1, 1)\n), new B.Vector3(-1, -3, 1).normalize(), new B.Color(1, 1, 1), new B.Color(0.5, 0.5, 1), new B.Vector3(1, 1, 1);\nnew B.Box3(\n  new B.Vector3(-2, -1, -2),\n  new B.Vector3(2, 5, 2)\n), new B.Vector3(0, -1, 0), new B.Color(1, 1, 1), new B.Color(0.25, 0.25, 0.5), new B.Vector3(0.1, 1, 0.1);\nconst Ge = class Ft {\n  static createButton(A, t = {}) {\n    const e = navigator.xr;\n    if (!e)\n      return null;\n    const i = e, a = document.createElement(\"button\");\n    A.xr.enabled = !0, A.xr.setReferenceSpaceType(\"local\");\n    function r() {\n      let g = null;\n      async function c(C) {\n        console.log(\"onSessionStarted\"), C.addEventListener(\"end\", E), await A.xr.setSession(C), a.textContent = \"EXIT VR\", g = C;\n      }\n      function E() {\n        console.log(\"onSessionEnded\"), g == null || g.removeEventListener(\"end\", E), a.textContent = \"ENTER VR\", g = null;\n      }\n      a.style.display = \"\", a.style.cursor = \"pointer\", a.style.left = \"calc(50% - 100px)\", a.style.width = \"200px\", a.style.height = \"100px\", a.textContent = \"ENTER VR\";\n      const l = {\n        ...t,\n        optionalFeatures: [\n          // \"local-floor\",\n          // \"bounded-floor\",\n          // \"layers\",\n          ...t.optionalFeatures || []\n        ]\n      };\n      a.onmouseenter = () => {\n        a.style.opacity = \"1.0\";\n      }, a.onmouseleave = () => {\n        a.style.opacity = \"0.5\";\n      }, a.onclick = () => {\n        g === null ? (console.log(\"requesting session\"), i.requestSession(\"immersive-vr\", l).then(\n          c\n        )) : (console.log(\"ending session\"), g.end());\n      };\n    }\n    function n() {\n      a.style.display = \"none\", a.style.cursor = \"auto\", a.style.left = \"calc(50% - 75px)\", a.style.width = \"150px\", a.onmouseenter = null, a.onmouseleave = null, a.onclick = null;\n    }\n    function I() {\n      n(), a.textContent = \"VR NOT SUPPORTED\";\n    }\n    function o(g) {\n      n(), console.warn(\n        \"Exception when trying to call xr.isSessionSupported\",\n        g\n      ), a.textContent = \"VR NOT ALLOWED\";\n    }\n    function Q(g) {\n      g.style.position = \"absolute\", g.style.bottom = \"20px\", g.style.padding = \"12px 6px\", g.style.border = \"1px solid #fff\", g.style.borderRadius = \"4px\", g.style.background = \"rgba(0,0,0,0.1)\", g.style.color = \"#fff\", g.style.font = \"normal 13px sans-serif\", g.style.textAlign = \"center\", g.style.opacity = \"0.5\", g.style.outline = \"none\", g.style.zIndex = \"999\";\n    }\n    return a.id = \"VRButton\", a.style.display = \"none\", Q(a), i.isSessionSupported(\"immersive-vr\").then((g) => {\n      g ? r() : I(), g && Ft.xrSessionIsGranted && a.click();\n    }).catch(o), a;\n  }\n  static registerSessionGrantedListener() {\n    const A = navigator.xr;\n    if (!A)\n      return null;\n    const t = A;\n    /WebXRViewer\\//i.test(navigator.userAgent) || t.addEventListener(\"sessiongranted\", () => {\n      Ft.xrSessionIsGranted = !0;\n    });\n  }\n};\nGe.xrSessionIsGranted = !1;\nlet ia = Ge;\nia.registerSessionGrantedListener();\nvar Ue = /* @__PURE__ */ ((s) => (s.w = \"wrist\", s.t0 = \"thumb-metacarpal\", s.t1 = \"thumb-phalanx-proximal\", s.t2 = \"thumb-phalanx-distal\", s.t3 = \"thumb-tip\", s.i0 = \"index-finger-metacarpal\", s.i1 = \"index-finger-phalanx-proximal\", s.i2 = \"index-finger-phalanx-intermediate\", s.i3 = \"index-finger-phalanx-distal\", s.i4 = \"index-finger-tip\", s.m0 = \"middle-finger-metacarpal\", s.m1 = \"middle-finger-phalanx-proximal\", s.m2 = \"middle-finger-phalanx-intermediate\", s.m3 = \"middle-finger-phalanx-distal\", s.m4 = \"middle-finger-tip\", s.r0 = \"ring-finger-metacarpal\", s.r1 = \"ring-finger-phalanx-proximal\", s.r2 = \"ring-finger-phalanx-intermediate\", s.r3 = \"ring-finger-phalanx-distal\", s.r4 = \"ring-finger-tip\", s.p0 = \"pinky-finger-metacarpal\", s.p1 = \"pinky-finger-phalanx-proximal\", s.p2 = \"pinky-finger-phalanx-intermediate\", s.p3 = \"pinky-finger-phalanx-distal\", s.p4 = \"pinky-finger-tip\", s))(Ue || {});\nconst aa = Object.keys(Ue);\naa.length;\nnew B.Vector3(0, 0, -1), new B.Vector3(0, 0, 1), new B.Vector3(-1, 0, 0), new B.Vector3(1, 0, 0), new B.Vector3(0, 1, 0), new B.Vector3(0, -1, 0);\nnew B.Vector3(0, 0, -1), new B.Vector3(0, 0, 1), new B.Vector3(-1, 0, 0), new B.Vector3(1, 0, 0), new B.Vector3(0, 1, 0), new B.Vector3(0, -1, 0);\nnew B.Vector3(0, 0, 1), new B.Vector3(0, 0, -1);\nnew B.Vector3(0, -1, 0), new B.Vector3(0, 1, 0), new B.Vector3(-1, 0, 0), new B.Vector3(1, 0, 0);\nfunction oa({ _ref: s, _key: A, src: t, ...e }) {\n  const i = Ve(null), a = s || i, r = Ze(({ scene: o }) => o), [n, I] = je(null);\n  return Tt(() => {\n    if (!t) return;\n    const o = new It({ url: t });\n    I(o);\n  }, [t]), Tt(() => {\n    var o;\n    if (a.current && n)\n      return r.add(n), r.remove(n), (o = a.current) == null || o.add(n), () => {\n        var Q;\n        n && ((Q = a.current) == null || Q.remove(n), n == null || n.dispose());\n      };\n  }, [a.current, n]), /* @__PURE__ */ Oe(\"group\", { ref: a, ...e }, A);\n}\nexport {\n  oa as default\n};\n"],"names":["lA","$t","HA","We","Xe","$e","Q","As","ts","es","Ae","RA","ss","YA","is","as","kA","rs","ns","MA","FA","gs","os","VA","vA","GA","UA","Is","Bs","xA","NA","it","Qs","B.Vector2","B.Vector3","B.Vector4","B.Quaternion","B.Matrix2","B.Matrix3","B.Matrix4","wt","XA","Jt","cs","c","te","Cs","u","d","h","E","l","SA","Qt","BA","Nt","ct","Ct","gt","ls","Es","hs","at","us","Et","ds","ee","ps","QA","Rt","se","V","ys","fs","ms","oA","Ht","Dt","jA","ot","vt","lt","KA","ws","ie","ae","Ds","re","ne","ge","xs","Ss","bs","oe","DA","PA","WA","Ie","ks","Ms","ht","iA","ut","Be","rt","Fs","X","Ns","sA","dA","pA","W","AA","uA","aA","rA","j","tA","nA","gA","eA","CA","Rs","vs","dt","Gs","Us","Ls","Gt","Qe","pt","yt","$A","_s","Ys","qt","Zs","Ts","Js","Hs","qs","B.Color","zs","zt","Ws","$","Ks","B.Clock","Ps","Os","Vs","js","xt","Xs","ce","$s","Ce","Kt","B.RawShaderMaterial","B.GLSL3","Ee","Ai","ti","OA","si","ei","ii","le","ai","ri","gi","ni","oi","Ii","ci","Bi","li","Qi","Ei","Ci","hi","di","ui","pi","yi","hA","EA","B.WebGLArrayRenderTarget","B.NearestFilter","B.RGBAFormat","B.UnsignedByteType","B.PlaneGeometry","B.Mesh","B.Scene","B.Camera","he","Ut","ue","de","B.DataArrayTexture","Lt","fi","mi","wi","Di","xi","B.Object3D","pe","ye","fe","Si","me","we","B.DataTexture","B.RGBAIntegerFormat","B.UnsignedIntType","De","LA","bi","ki","At","xe","ZA","St","TA","Ri","vi","Gi","B.RGIntegerFormat","It","Mi","Fi","Ni","Se","nt","et","_A","_i","JA","yA","fA","mA","wA","Ot","bA","Le","_e","Ye","Te","Je","He","qe","ze","Ke","Pe","st","tt","Pt","Ui","Li","be","Vt","Yi","Ti","ke","Bt","Me","Fe","Ji","Hi","qA","qi","zi","Ki","Pi","Oi","IA","bt","B.InstancedBufferGeometry","B.BufferAttribute","Vi","ji","B.InstancedBufferAttribute","B.DynamicDrawUsage","_t","zA","B.WebGLRenderTarget","B.SRGBColorSpace","B.PerspectiveCamera","Zt","B.Texture","jt","Zi","ft","Wi","Xi","$i","mt","Aa","B.ShaderChunk","Wt","kt","Mt","Ne","ta","Re","ve","ea","Yt","Z","B.ShaderMaterial","B.NormalBlending","B.DoubleSide","Xt","sa","B.WebGLCubeRenderTarget","B.LinearMipMapLinearFilter","B.CubeCamera","B.PMREMGenerator","B.MeshStandardMaterial","B.Box3","Ge","Ft","ia","Ue","aa","oa","Ve","Ze","je","Tt","Oe"],"mappings":"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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A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AA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAkPLC,GAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAiCLC,GAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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","x_google_ignoreList":[0]}